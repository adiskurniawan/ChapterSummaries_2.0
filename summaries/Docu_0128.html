<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1766645593">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      // Delegate addEventListener/removeEventListener to visible button
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      // Delegate onclick assignments
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      // Delegate focus/blur
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
      // If legacy code used direct addEventListener earlier than this script, listeners would already exist
      // on alias element; attempt to re-dispatch those by cloning them to visible button is non-trivial.
      // This approach covers the common case where legacy scripts query the alias and bind after DOM ready.
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0128_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1 • script.table.js</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown (script.table.js)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown (script.table.js)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>File-level overview & intent (complete)</strong><br><strong>Purpose:</strong> Client-side module that enhances rendered HTML tables with accessible TOCs, per-row anchors, copy/export (plain/Markdown/CSV/JSON/XLSX/PDF), client-side search with Unicode-correct highlight, sortable columns with restore, collapse/expand controls, layout responsiveness, and safe integration points for host utilities (<code>window.tvUtils</code>, <code>window.tvConfig</code>, <code>window.XLSX</code>, <code>window.PTToc</code>).<br><strong>Design constraints:</strong> read-only caption handling (never create caption nodes), idempotent DOM operations, pervasive try/catch to avoid breaking host pages, prefer host-provided helpers, non-blocking UI, conservative fallbacks.<br><strong>Public surface:</strong> <code>window.PasteToTable.initRenderedContent</code>, <code>window.PTTable.buildTocs</code>, and stable global helpers (<code>toggleTable</code>, <code>copyTablePlain</code>, <code>copyTableMarkdown</code>, <code>searchTable</code>, <code>exportTableCSV</code>, <code>exportTableJSON</code>, <code>exportTableXLSX</code>, <code>exportTablePDF</code>, <code>exportAllBtnHandler</code>, <code>backToTop</code>). </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>safe(fn)</code></strong><br><strong>Purpose:</strong> Minimal wrapper to call <code>fn()</code> and swallow exceptions.<br><strong>Inputs:</strong> <code>fn</code> (callable).<br><strong>Output:</strong> <code>fn()</code> return or <code>undefined</code> on throw.<br><strong>Behavior & invariants:</strong> never throws.<br><strong>Tradeoffs:</strong> hides errors (no telemetry), used to avoid cascading failures. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>isString(x)</code></strong><br><strong>Purpose:</strong> Lightweight <code>typeof</code> string check.<br><strong>Inputs:</strong> <code>x</code>.<br><strong>Output:</strong> boolean.<br><strong>Invariants:</strong> returns <code>true</code> exactly when <code>typeof x === &quot;string&quot;</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>copyToClipboard(text)</code></strong><br><strong>Purpose:</strong> Promise-based clipboard writer; prefer <code>navigator.clipboard.writeText</code>, fallback to hidden <code>&lt;textarea&gt;</code> + <code>document.execCommand(&#x27;copy&#x27;)</code>.<br><strong>Inputs:</strong> <code>text</code> (coerced to string).<br><strong>Outputs:</strong> <code>Promise</code> resolved on success, rejected on failure.<br><strong>Edge cases:</strong> <code>execCommand</code> may return boolean; function cleans temporary DOM nodes and focuses safely.<br><strong>Security/perms:</strong> may fail in insecure contexts; always returns Promise.<br><strong>Delegation:</strong> honors <code>window.tvUtils?.copyToClipboard</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>downloadBlob(blob, filename)</code></strong><br><strong>Purpose:</strong> Trigger browser download via <code>URL.createObjectURL</code> and synthetic <code>&lt;a&gt;</code> click.<br><strong>Inputs:</strong> <code>Blob</code>, <code>filename</code>.<br><strong>Behavior:</strong> best-effort, schedules cleanup via <code>setTimeout</code>.<br><strong>Edge-cases:</strong> silent on errors; revokes object URL after short delay. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>showToast</code></strong><br><strong>Purpose:</strong> User feedback abstraction.<br><strong>Delegation:</strong> <code>window.tvUtils.showToast</code> → <code>window.showToast</code> → <code>console.log</code>.<br><strong>Inputs:</strong> message (and optional opts if provided by delegate).<br><strong>Behavior:</strong> non-blocking, best-effort display. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>debounce(fn, wait)</code></strong><br><strong>Purpose:</strong> Basic debounce with single timer.<br><strong>Inputs:</strong> <code>fn</code>, <code>wait</code> ms.<br><strong>Output:</strong> debounced function.<br><strong>Behavior:</strong> clears existing timer and schedules <code>fn</code> with latest args.<br><strong>Limitations:</strong> no cancel method, single timer per returned function. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>sanitizeText(s)</code></strong><br><strong>Purpose:</strong> Defensive string coercion + trim.<br><strong>Inputs:</strong> any.<br><strong>Output:</strong> trimmed string or <code>&#x27;&#x27;</code> on failure. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>getContentRoot()</code></strong><br><strong>Purpose:</strong> Canonical content root selector (<code>#content</code>, <code>#tables-viewer</code>, <code>document.body</code>).<br><strong>Outputs:</strong> DOM node fallback to <code>document.body</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>_findTocBarUl(tocBar)</code></strong><br><strong>Purpose:</strong> Find or create a <code>&lt;ul&gt;</code> inside a TOC bar.<br><strong>Inputs:</strong> <code>tocBar</code> element.<br><strong>Output:</strong> <code>&lt;ul&gt;</code> or <code>null</code>.<br><strong>Behavior:</strong> idempotent create-on-missing, returns <code>null</code> when <code>tocBar</code> falsy. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>buildSingleTableToc()</code></strong><br><strong>Purpose:</strong> When exactly one table exists, produce a per-row TOC in <code>#tocBar</code> to navigate directly to rows.<br><strong>Algorithm:</strong> locate single table via <code>.table-wrapper</code>/<code>.table-container</code>/fallback queries; select only body rows (skip THEAD); for each row ensure stable unique <code>id</code> (<code>tv-row-N</code>, unique-ify on collision) and <code>tabindex=&quot;-1&quot;</code>; build <code>&lt;li&gt;&lt;a&gt;</code> entries with label extracted from first 1–2 non-empty lines of <code>row.textContent</code> (fallback <code>Row N</code>); clear existing TOC children first; attach smooth scroll + focus handlers; update history hash.<br><strong>Complexity:</strong> O(rows).<br><strong>Invariants:</strong> Idempotent, no caption creation, only mutates <code>id</code> and <code>tabindex</code> on rows.<br><strong>Accessibility:</strong> <code>aria-label</code> on links. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>buildTocFromCaptions()</code></strong><br><strong>Purpose:</strong> Read server-rendered caption-like nodes (<code>.table-caption</code>, <code>.table-title</code>, <code>.table-heading</code>) and populate <code>#toc</code> and <code>#tocBar</code>.<br><strong>Algorithm:</strong> query caption-like nodes with textContent; for each ensure unique <code>id</code> (unique-ify on collision), use caption text as link label (fallback <code>Table N</code>), create <code>&lt;li&gt;&lt;a&gt;</code> entries, append to <code>#toc</code> and clone to <code>#tocBar</code> if both exist; clear lists if no captions.<br><strong>Edge-cases:</strong> avoids creating caption nodes, uses <code>textContent</code> only (safe).<br><strong>Complexity:</strong> O(captions). </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>buildTocs()</code></strong><br><strong>Purpose:</strong> Top-level TOC builder—prefer host <code>window.PTToc</code> integration, otherwise run local <code>buildSingleTableToc</code> and <code>buildTocFromCaptions</code> with delayed second attempts (setTimeout 300ms) to catch late-render.<br><strong>Behavior:</strong> feature-detect <code>PTToc.init/build</code> and fall back safely; idempotent. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>_ensureRowUidsAndSnapshot(table, tableIdx)</code></strong><br><strong>Purpose:</strong> Assign stable <code>data-tv-uid</code> per row and snapshot original ordering into <code>originalRowOrders[tableIdx]</code>.<br><strong>Algorithm:</strong> iterate <code>tbody.rows</code>, assign <code>data-tv-uid</code> if missing, push uids into <code>originalRowOrders[tableIdx]</code>.<br><strong>Invariants:</strong> ensures ability to restore original order. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>updateHeaderSortUI(tableIdx)</code></strong><br><strong>Purpose:</strong> Sync header UI <code>.sort-btn</code> classes and <code>aria-sort</code> based on <code>sortStates[tableIdx]</code>.<br><strong>Behavior:</strong> removes/sets <code>sort-state-*</code> classes and toggles inline SVG icons per state (0/1/2).<br><strong>Edge-cases:</strong> no-op if <code>tHead</code> missing.<br><strong>Complexity:</strong> O(columns). </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>sortTableByColumn(tableIdx, colIdx)</code></strong><br><strong>Purpose:</strong> Three-state sort per column: unsorted → ascending → descending → restore original order.<br><strong>Algorithm:</strong> read cell text, attempt numeric parse (<code>parseFloat</code> after removing commas/whitespace); if both numeric, sort numerically; else <code>localeCompare</code>; ascending/descending toggles; on restoring unsorted, reconstruct rows using <code>originalRowOrders</code> by <code>data-tv-uid</code>. Store <code>data-orig-html</code> for cells if missing. Reset other column states to 0. Append rows back into <code>tbody</code>.<br><strong>Complexity:</strong> O(n log n) for sort, O(n) for restore.<br><strong>Edge-cases:</strong> missing <code>tbody</code>, missing <code>originalRowOrders</code> gracefully handled.<br><strong>Accessibility:</strong> updates <code>aria-sort</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>headerSortButtonClicked(tableIdx, colIdx, btnEl)</code></strong><br><strong>Purpose:</strong> Event bridge to call <code>sortTableByColumn</code> and focus clicked button.<br><strong>Behavior:</strong> thin wrapper, exported to <code>window</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>toggleTable(btn)</code></strong><br><strong>Purpose:</strong> Collapse/expand single table wrapper by toggling <code>tbody.style.display</code> and updating <code>btn</code> text & <code>aria-expanded</code>.<br><strong>Behavior:</strong> sets global <code>toggleAllBtn</code> text depending on any expanded state; calls <code>updateRowCounts</code>.<br><strong>Edge-cases:</strong> safely handles missing wrapper or table. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>toggleAllTables()</code></strong><br><strong>Purpose:</strong> Toggle all <code>.table-wrapper</code> elements between collapsed and expanded states.<br><strong>Algorithm:</strong> determine if any is expanded; if any expanded collapse all (set <code>display=&#x27;none&#x27;</code>), else expand all; update per-wrapper toggle button text and <code>toggleAllBtn</code>.<br><strong>Complexity:</strong> O(#wrappers). </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>updateRowCounts()</code></strong><br><strong>Purpose:</strong> For each <code>.table-wrapper</code> update <code>.row-count</code> text to <code>Showing X</code> or <code>Showing V of T</code>.<br><strong>Algorithm:</strong> count <code>tbody.rows</code> and visible rows (<code>style.display !== &#x27;none&#x27;</code>).<br><strong>Edge-cases:</strong> missing <code>.row-count</code> is ignored. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>formatCellForMarkdown(cell)</code></strong><br><strong>Purpose:</strong> Sanitize cell text for Markdown table: escape <code>|</code> → <code>\|</code>, convert newlines to <code>&lt;br&gt;</code> and trim.<br><strong>Input/Output:</strong> returns sanitized string.<br><strong>Edge-cases:</strong> fallback to minimal replacement on error. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>tableToMarkdownLines(table, title)</code></strong><br><strong>Purpose:</strong> Render table DOM to Markdown lines array (header from first row).<br><strong>Algorithm:</strong> build header row, separator row of <code>---</code>, then body rows via <code>formatCellForMarkdown</code>. Prepend <code>**title**</code> block if provided.<br><strong>Edge-cases:</strong> empty table returns <code>[]</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>attachSourceSnapshotters()</code> (IIFE)</strong><br><strong>Purpose:</strong> Keep <code>window.__tv_last_source</code> and <code>window.__tv_last_source_ts</code> updated from <code>#paste</code> <code>input</code> events and when user clicks convert buttons.<br><strong>Behavior:</strong> adds <code>input</code> listener to <code>#paste</code> (if present) and delegated click listener to capture convert actions; idempotent and best-effort. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>findMarkdownTableBlocks(source)</code></strong><br><strong>Purpose:</strong> Detect contiguous pipe-table blocks in plaintext source.<br><strong>Algorithm:</strong> scan lines for <code>|</code> header + separator detection (regex for <code>-</code> row), collect start/end and lines.<br><strong>Outputs:</strong> array of blocks <code>{ start, end, lines }</code>.<br><strong>Edge-cases:</strong> heuristic may mis-detect <code>|</code> text; acceptable for source matching. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>splitSourceByBlankLines(source)</code></strong><br><strong>Purpose:</strong> Split source into blocks separated by blank lines.<br><strong>Outputs:</strong> trimmed non-empty blocks array. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>getPreferredSourceForTable(table)</code></strong><br><strong>Purpose:</strong> Heuristically map a DOM table to the most likely source block from <code>window.__tv_last_source</code>.<br><strong>Algorithm:</strong> 1) locate table index in <code>.table-container table</code> → attempt same-index block from <code>splitSourceByBlankLines</code>; 2) if wrapper title exists, search source lines for title occurrences and return block within 6 lines prior to block start; 3) parse pipe-block header cells and compare to DOM header cells by first-cell substring or equal column count; 4) if single block exists return it; 5) fallback to header-cell fuzzy matching across blocks.<br><strong>Outputs:</strong> string block or <code>null</code>.<br><strong>Edge-cases:</strong> returns <code>null</code> for missing <code>__tv_last_source</code>.<br><strong>Complexity:</strong> O(source length + block comparisons). </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>getWrapperTitle(wrapper)</code></strong><br><strong>Purpose:</strong> Read-only title extraction from wrapper via <code>.table-caption</code> / <code>.table-title</code> / heading tags / <code>aria-label</code> / <code>data-*</code> attributes (<code>data-table</code>, <code>data-table-id</code>).<br><strong>Outputs:</strong> trimmed string title or <code>&quot;&quot;</code>.<br><strong>Invariants:</strong> safe, non-mutating. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>getTableFromButton(btn)</code></strong><br><strong>Purpose:</strong> Resolve a table given a control button: prefer explicit <code>data-tv-table-index</code>, else nearest <code>.table-wrapper</code> or <code>.table-container</code> ancestor.<br><strong>Outputs:</strong> <code>HTMLTableElement</code> or <code>null</code>.<br><strong>Edge-cases:</strong> invalid index falls back to ancestor resolution. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>copyTablePlain(btn)</code></strong><br><strong>Purpose:</strong> Copy tab-delimited plain text of table (title + rows) to clipboard or fallback to <code>window.__tv_last_source</code>.<br><strong>Algorithm:</strong> build lines <code>title\n</code> + rows as <code>\t</code>-joined cell texts; use <code>tvUtils.showCopyModal</code> when available, otherwise <code>copyToClipboard</code> + <code>showToast</code>.<br><strong>Edge-cases:</strong> if table absent and <code>__tv_last_source</code> exists prefer copying source; show warning on failure. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>copyTableMarkdown(btn)</code></strong><br><strong>Purpose:</strong> Prefer original source block via <code>getPreferredSourceForTable</code>; otherwise synthesize Markdown with <code>tableToMarkdownLines</code>.<br><strong>Behavior:</strong> uses <code>tvUtils.showCopyModal</code> if available, otherwise <code>copyToClipboard</code>.<br><strong>Safety:</strong> uses <code>textContent</code> only when synthesizing. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>sanitizeFileName(name)</code></strong><br><strong>Purpose:</strong> Remove filesystem-forbidden characters <code>\/\\:*?&quot;&lt;&gt;|</code> and trim to 160 chars.<br><strong>Inputs:</strong> <code>name</code>.<br><strong>Outputs:</strong> safe filename base or <code>&#x27;table&#x27;</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>exportTableCSV(btn, { filename } = {})</code></strong><br><strong>Purpose:</strong> Export table to CSV with UTF-8 BOM.<br><strong>Algorithm:</strong> iterate rows, escape <code>&quot;</code> by doubling, quote fields containing <code>&quot;</code>/<code>,</code>/newline, join rows with <code>\r\n</code>. Build <code>filename</code> from wrapper title sanitized by <code>sanitizeFileName</code>. Use <code>downloadBlob(new Blob([&quot;\uFEFF&quot;, csv]))</code>.<br><strong>Edge-cases:</strong> warn on empty table; best-effort on errors. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>exportTableJSON(btn, { filename } = {})</code></strong><br><strong>Purpose:</strong> Export table as array-of-objects JSON.<br><strong>Algorithm:</strong> derive headers from <code>thead</code> first row or fallback <code>ColN</code>; iterate <code>tbody</code> rows to create objects keyed by header; <code>JSON.stringify(rows, null, 2)</code> and download.<br><strong>Edge-cases:</strong> header/body mismatch handled by <code>ColN</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>exportTableXLSX(btn, { filename } = {})</code></strong><br><strong>Purpose:</strong> Export table as .xlsx using SheetJS (<code>window.XLSX</code>) when available; fallback to TSV saved as <code>.xlsx</code> for compatibility.<br><strong>Algorithm:</strong> build AOAs from table rows, call <code>XLSX.utils.aoa_to_sheet</code> and <code>book_append_sheet</code>, attempt <code>XLSX.writeFile</code> or <code>XLSX.write</code> → Blob. If SheetJS absent, produce TSV blob and warn user that fallback is TSV.<br><strong>Edge-cases:</strong> warn on fallback and log exceptions; preserve data via TSV when library absent. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>exportTablePDF(btn, { filename } = {})</code></strong><br><strong>Purpose:</strong> Open print dialog in new window with HTML containing <code>table.outerHTML</code> and printed styling so user can print-to-PDF.<br><strong>Algorithm:</strong> build minimal HTML doc with inlined styles, <code>window.open()</code>, <code>w.document.write()</code>, <code>w.print()</code> after short timeout.<br><strong>Edge-cases:</strong> popup blockers or cross-origin restrictions may block; function warns user.<br><strong>Security note:</strong> uses <code>table.outerHTML</code>—if page contains untrusted HTML, it will be included in print; module assumes host sanitizes content upstream. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>clearHighlights(cell)</code></strong><br><strong>Purpose:</strong> Remove <code>&lt;mark&gt;</code> nodes or restore <code>data-orig-html</code> if present.<br><strong>Algorithm:</strong> if <code>data-orig-html</code> exists set <code>innerHTML</code> to that value, else find all <code>&lt;mark&gt;</code> and replace with text nodes preserving <code>.textContent</code>.<br><strong>Edge-cases:</strong> safe fallback if DOM mutated since highlight. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>normalizeForSearchLocal(s)</code></strong><br><strong>Purpose:</strong> Normalize input for search comparison: lowercase, NFD decomposition, strip combining diacritics, remove non-letter/number characters, collapse whitespace.<br><strong>Delegation:</strong> prefer <code>window.__tv_utils.normalizeForSearchLocal</code>.<br><strong>Fallback:</strong> robust regex with <code>\p{L}\p{N}</code> when engine supports Unicode properties; fallback to <code>\w</code> based replacement otherwise.<br><strong>Edge-cases:</strong> catches regex errors, returns lowercase fallback. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>buildNormalizedMapForCell(cell)</code></strong><br><strong>Purpose:</strong> Produce <code>{ normStr, map, nodes }</code> to enable Unicode-accurate mapping from normalized-character-index → (textNodeIndex, offsetInNode) for highlight slicing.<br><strong>Algorithm:</strong> TreeWalker collects text nodes, iterate codepoints (handle surrogate pairs correctly), NFD-decompose and remove combining marks, filter allowed characters to produce <code>normStr</code> while pushing mapping entries per output character.<br><strong>Correctness:</strong> handles surrogate pairs and diacritics; essential to avoid misaligned highlight ranges.<br><strong>Performance:</strong> linear in codepoints of cell; cost can be high for very long cells—used only when highlighting is enabled. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>highlightMatches(cell, filterNorm)</code></strong><br><strong>Purpose:</strong> Wrap matched normalized ranges in <code>&lt;mark&gt;</code> elements using mapping produced by <code>buildNormalizedMapForCell</code>.<br><strong>Algorithm:</strong> build normalized map, find all <code>indexOf</code> occurrences of <code>needle</code> in <code>normStr</code>, iterate matches in reverse order to avoid DOM mutation shifting indices, map normalized indices to node offsets, split text nodes with <code>splitText</code>, collect contiguous nodes and wrap them in created <code>&lt;mark&gt;</code> element.<br><strong>Edge-cases:</strong> matches spanning multiple text nodes handled by gathering sibling nodes between start and end; if mapping incomplete skip match safely.<br><strong>Safety:</strong> uses <code>createTextNode</code>, not raw <code>innerHTML</code>.<br><strong>Complexity:</strong> O(N + M) where N = normalized length, M = number of matches. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>searchTable()</code></strong><br><strong>Purpose:</strong> Debounced search runner: read search input (<code>#searchBox</code>/<code>#searchInput</code>/<code>#search</code>), normalize filter, iterate tables/rows to set <code>row.style.display</code> and apply highlights, then scroll to first match and call <code>updateRowCounts()</code>.<br><strong>Algorithm:</strong> per-row: <code>clearHighlights(cell)</code>, check <code>normalizeForSearchLocal(cell.textContent).includes(filterNorm)</code>, toggle row visibility, apply <code>highlightMatches</code> if <code>window.tvConfig.highlight</code> truthy. Try virtualizer refresh if available.<br><strong>Performance:</strong> potentially heavy for large tables; mitigated by debounce and optional highlight toggle. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>optimizeTableControls()</code></strong><br><strong>Purpose:</strong> Responsive layout adjustments for <code>.table-header-wrapper</code>: group copy/export buttons into <code>.copy-buttons</code>, reorder toggle button into header, and apply inline style adjustments for mobile vs desktop via <code>matchMedia(&quot;(max-width:600px)&quot;)</code>.<br><strong>Behavior:</strong> idempotent per-wrapper, creates <code>.copy-buttons</code> if missing, tweaks button sizing/padding for mobile.<br><strong>Edge-cases:</strong> respects existing inline styles where possible; best-effort DOM moves. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>_debouncedOptimize</code> & resize listener</strong><br><strong>Purpose:</strong> Debounce <code>optimizeTableControls</code> and attach to resize and matchMedia change events for responsive behavior.<br><strong>Behavior:</strong> use <code>window.matchMedia</code> change listener if available; fallback to <code>resize</code> event. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>initRenderedContent()</code></strong><br><strong>Purpose:</strong> Consolidated initialization: ensure <code>.table-container</code> wrappers exist, build TOCs, ensure <code>data-tv-uid</code> and <code>sortStates</code> per table, cache <code>data-orig-html</code> for all cells, update header UI, set toggle labels, create <code>backToTop</code> control if missing, wire search input with debounce, attach per-table handlers for action buttons (guarded by <code>data-tv-handler-attached</code> and <code>onclick</code> presence), call <code>optimizeTableControls</code>, update row counts, and scroll first table into view.<br><strong>Sequence & idempotence:</strong> ordered steps with many try/catch blocks and dataset guards to allow safe repeat calls.<br><strong>Failure model:</strong> partial initialization allowed; no thrown exceptions leak to host. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Global delegated click handlers</strong><br><strong>(1) Header-sort delegation — Purpose:</strong> intercept clicks on <code>.sort-btn</code>/<code>.th-with-sort</code>/<code>th[role=button]</code>, compute <code>tableIdx</code> and <code>colIdx</code>, call <code>headerSortButtonClicked</code>.<br><strong>(2) TOC anchor — Purpose:</strong> intercept clicks on <code>#tocBar a[href^=&#x27;#&#x27;]</code>, prevent default, resolve <code>id</code>, smooth-scroll target or wrapper, update history hash, focus target.<br><strong>Behavior:</strong> delegated handlers minimize per-element binding and are tolerant to DOM variance. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Back-to-top logic & <code>backToTop()</code></strong><br><strong>Purpose:</strong> Show/hide <code>#backToTop</code> on scroll > 200px and scroll-to-top with smooth behavior.<br><strong>Listeners:</strong> window <code>scroll</code> toggles <code>display</code> of button. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>exportAllBtnHandler()</code></strong><br><strong>Purpose:</strong> Export all tables into one multi-sheet XLSX if SheetJS available; otherwise fallback to concatenated Markdown saved as <code>all_tables.md</code>.<br><strong>Algorithm:</strong> iterate <code>.table-wrapper</code>, build AOAs per table, create workbook, append sheets, call <code>XLSX.writeFile</code>/<code>write</code> or fallback to combined Markdown and <code>downloadBlob</code>.<br><strong>Edge-cases:</strong> if no tables, warn; logs SheetJS exceptions; fallback path uses <code>downloadBlob</code>.<br><strong>Complexity:</strong> O(total cells across all tables). </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Boot & keyboard shortcuts</strong><br><strong>Purpose:</strong> On DOMContentLoaded or immediate if already loaded, call <code>initRenderedContent()</code> and attach <code>keydown</code> shortcut: <code>/</code> focuses search input (if not editing), <code>Escape</code> triggers <code>backToTop()</code>.<br><strong>Behavior:</strong> prevents default for <code>/</code> when appropriate; idempotent. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Global export of helpers (non-destructive)</strong><br><strong>Purpose:</strong> Expose functions to <code>window</code> without overwriting existing implementations: <code>window.toggleTable = window.toggleTable || toggleTable;</code> etc.<br><strong>Invariants:</strong> never replace host-provided implementations. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong><code>window.PasteToTable</code> & <code>window.PTTable</code> exports</strong><br><strong>Purpose:</strong> Provide <code>PasteToTable.initRenderedContent</code> and <code>PTTable.buildTocs</code> for external triggers.<br><strong>Invariants:</strong> preserved names for integration. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Resilience design & failure modes</strong><br><strong>Notes:</strong> Pervasive <code>try/catch</code> prevents exceptions from escaping; this ensures host-page stability at expense of silent failures.<br><strong>Idempotence:</strong> dataset flags prevent double-binding handlers.<br><strong>Delegation:</strong> to host features (<code>tvUtils</code>, <code>PTToc</code>, <code>XLSX</code>) preserves richer UX when available and falls back to robust simpler implementations when not. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Security & XSS considerations</strong><br><strong>Notes:</strong> All user-visible text used for copy/export is derived via <code>textContent</code>, <code>createTextNode</code>, or stable DOM APIs—safe against injection.<br><strong>Caveat:</strong> <code>innerHTML</code> is used only for SVG icons in header UI and for <code>table.outerHTML</code> when building a print window for PDF export. Printing/outerHTML includes whatever the page has; upstream sanitization is recommended for untrusted content. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Performance considerations</strong><br><strong>Notes:</strong> Most expensive operations: <code>buildNormalizedMapForCell</code> and <code>highlightMatches</code> (per-character Unicode normalization and map creation). Gate with <code>tvConfig.highlight</code> and use debounce for <code>searchTable</code> to limit runs.<br><strong>Sorting:</strong> O(n log n) per-column; restoring original order O(n).<br><strong>Init cost:</strong> <code>initRenderedContent()</code> performs several DOM scans but is designed to run once (idempotent). </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Observability & debugging guidance</strong><br><strong>Notes:</strong> Module suppresses many errors; during integration enable host-level debug hooks (e.g., a <code>TV_DEBUG</code> flag) or temporarily remove try/catch for instrumentation. Use <code>console.warn</code> points already present in a few catches. Consider adding lightweight telemetry via <code>tvUtils</code> for <code>searchExecuted</code>, <code>exportStarted</code>, and <code>highlightTimeout</code>. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Compatibility & graceful degradation</strong><br><strong>Notes:</strong> Uses feature detection for <code>navigator.clipboard</code>, <code>URL.createObjectURL</code>, <code>matchMedia</code>, <code>Element.closest</code>, <code>dataset</code>, <code>XLSX</code>. Fallbacks exist for older engines (e.g., <code>execCommand</code> for clipboard). Unicode-aware regex uses <code>\p{}</code> when available with a fallback to <code>\w</code> based replacement. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Testing checklist (actionable & prioritized)</strong><br><strong>Unit tests:</strong> <code>buildNormalizedMapForCell</code> character mapping (surrogates & diacritics), <code>formatCellForMarkdown</code> escaping (<code>|</code>, newlines), <code>sanitizeFileName</code> length and replacement, <code>getPreferredSourceForTable</code> heuristics across source variations.<br><strong>Integration tests:</strong> <code>buildTocs</code> with server captions vs none, <code>buildSingleTableToc</code> on single-table pages, <code>copyTableMarkdown</code> returns original source when available, <code>searchTable</code> + highlight toggle performance and correctness, <code>sortTableByColumn</code> ascending/descending/restore correctness with numeric and string columns.<br><strong>E2E & perf:</strong> large table stress (10k rows) to measure sort, search debounce, highlight CPU/memory; repeated <code>initRenderedContent()</code> calls to detect leaks; SheetJS path for <code>exportTableXLSX</code> and TSV fallback verification.<br><strong>Accessibility tests:</strong> <code>aria-sort</code> values, TOC anchor focus behavior, keyboard <code>/</code> focusing search, and <code>aria-label</code> on TOC links. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Recommended non-breaking improvements</strong><br><strong>Items:</strong> Add opt-in debug flag (e.g., <code>window.TV_DEBUG</code>) to surface caught exceptions for integration QA.<br><strong>Items:</strong> Add highlight budget (skip or limit <code>highlightMatches</code> for cells > N characters or only first K matches) to avoid long main-thread stalls on huge cells.<br><strong>Items:</strong> Use <code>MutationObserver</code> (configurable) to detect late-inserted captions/tables instead of relying only on <code>setTimeout</code> retries; keep polling fallback for legacy browsers.<br><strong>Items:</strong> Add abort/cancellation for long-running highlight/map operations (cooperative cancellation token) to support quick user interruptions.<br><strong>Items:</strong> Expose lightweight telemetry hooks via <code>tvUtils.emit</code> or <code>tvUtils.log</code> for <code>searchExecuted</code>, <code>exportStarted</code>, <code>exportFailed</code>, and <code>workerFallback</code> (if later introduced). </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Integration & release notes</strong><br><strong>Notes:</strong> Preserve public global names to avoid breaking host code. Changes to highlight mapping logic, tokenization (<code>normalizeForSearchLocal</code>), or UID snapshot semantics require careful migration testing.<br><strong>Build:</strong> When minifying, ensure exported <code>window.*</code> assignments remain intact (do not mangle global names).<br><strong>Invariant:</strong> Keep <code>read-only caption</code> invariant: module must never create caption nodes or overwrite server-provided caption content. </td></tr><tr><td data-label="Technical Breakdown (script.table.js)"> <strong>Final verification checklist (pre-merge)</strong><br><strong>Unit:</strong> <code>buildNormalizedMapForCell</code>, <code>highlightMatches</code>, <code>getPreferredSourceForTable</code>, CSV/JSON/XLSX export correctness.<br><strong>Integration:</strong> TOC building (server captions + single-table), search+highlight ergonomics, sort/restore flow, handler idempotence on repeated <code>initRenderedContent()</code> calls.<br><strong>Performance:</strong> highlight profiling on large cells, sort performance for large row counts, memory leaks after repeated init/teardown cycles.<br><strong>Accessibility QA:</strong> <code>aria-sort</code>, TOC focus behavior, keyboard <code>/</code> focus, screen reader verification for row anchors. </td></tr></tbody></table></div><div class="row-count">Rows: 58</div></div><div class="table-caption" id="Table2" data-table="Docu_0128_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2 • script.save.js</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (script.save.js)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (script.save.js)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (script.save.js)"> <strong>File-level overview & intent (complete)</strong><br><strong>Purpose:</strong> Client-side save helper that posts Markdown content to <code>/save-md</code>, enforces client-side size limits, prompts for filenames, updates a status UI, dispatches namespaced request/response events, and exposes a small programmatic API (<code>window.PTT_SAVE</code>).<br><strong>Design constraints:</strong> minimal DOM assumptions, non-blocking network flow, robust defensive coding (try/catch), non-invasive integration with host page (namespaced events, dataset guards), configurable client max-payload via <code>PTT_CONFIG</code> or meta tag, and best-effort UX fallbacks (hidden live region if <code>#status</code> missing). </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Global constants & identifiers</strong><br><code>DEFAULT_MAX_PASTE_SIZE = 1000000</code> — default upper bound in bytes (UTF-8).<br><code>SAVE_ENDPOINT = &#x27;/save-md&#x27;</code> — POST target.<br><code>STATUS_ID = &#x27;status&#x27;</code>, <code>SAVE_BTN_ID = &#x27;saveBtn&#x27;</code>, <code>PASTE_ID = &#x27;paste&#x27;</code>, <code>FALLBACK_AREA_ID = &#x27;page-area&#x27;</code> — DOM selectors used throughout.<br><strong>Event names:</strong> <code>EVENT_REQUEST_MD = &#x27;ptt:save-md-request&#x27;</code>, <code>EVENT_RESPONSE_MD = &#x27;ptt:save-md-response&#x27;</code> — namespaced to avoid collisions. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Logging & small utilities</strong><br><code>logDebug()</code> — wrappers to <code>console.debug</code> if available (best-effort).<br><code>safeTrim(s)</code> — returns <code>&#x27;&#x27;</code> for null/undefined; <code>String(s).trim()</code> inside try/catch; used to defensively coerce values.<br><code>readElementText(id)</code> — returns <code>value</code> for form controls or trimmed <code>textContent/innerText</code>; returns <code>null</code> when element missing or on error; used to read <code>#paste</code> or fallback areas.<br><code>getMeta(name)</code> — reads <code>&lt;meta name=&quot;...&quot;&gt;</code> content; defensive try/catch. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Client config introspection — <code>getClientMaxSize()</code></strong><br><strong>Purpose:</strong> Determine upload size limit in bytes.<br><strong>Order of precedence:</strong> 1) <code>window.PTT_CONFIG.MAX_PASTE_SIZE</code> if numeric; 2) meta tag <code>ptt-max-paste-size</code>; 3) <code>DEFAULT_MAX_PASTE_SIZE</code> fallback.<br><strong>Behavior:</strong> parseInt with validation, robust to missing/invalid values. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>UTF-8 payload sizing — <code>utf8BytesLength(str)</code></strong><br><strong>Purpose:</strong> Compute byte-length of string as UTF-8 for client-side limit enforcement.<br><strong>Algorithm:</strong> prefer <code>TextEncoder().encode(str).length</code>; fallback to <code>unescape(encodeURIComponent(str)).length</code> when <code>TextEncoder</code> absent.<br><strong>Edge-cases:</strong> ensures multi-byte characters counted correctly (surrogate pairs, diacritics). </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Filename helpers — <code>ensureMdSuffix(filename)</code> & <code>promptFilename(defaultName)</code></strong><br><code>ensureMdSuffix</code> — append <code>.md</code> if missing (case-insensitive).<br><code>promptFilename</code> — shows <code>window.prompt</code> with sanitized default, normalizes path separators to <code>-</code>, strips disallowed characters via regex, truncates to 200 chars, returns <code>null</code> for cancel; wraps in try/catch. <br><strong>Security:</strong> user-entered filename sanitized to avoid path traversal and illegal characters. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Status UI — <code>updateStatus(message, isError)</code></strong><br><strong>Purpose:</strong> Write human-readable status messages to <code>#status</code> or fallback hidden live region <code>#ptt-live-status</code> with <code>aria-live=&quot;polite&quot;</code>.<br><strong>Behavior:</strong> if <code>isError</code> sets <code>role=&quot;alert&quot;</code>; creates fallback live element placed off-screen if necessary; fails silently on DOM errors. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Event dispatch — <code>dispatchResponseEvent(detail)</code></strong><br><strong>Purpose:</strong> Emit <code>ptt:save-md-response</code> <code>CustomEvent</code> with saved/failed payload; <code>bubbles:true</code>, <code>cancelable:false</code>.<br><strong>Behavior:</strong> wrapped in try/catch and logs failures via <code>logDebug</code>. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Network layer — <code>postSaveMarkdown(markdown, filename, opts)</code></strong><br><strong>Purpose:</strong> POST JSON <code>{ markdown, filename }</code> to <code>SAVE_ENDPOINT</code> with <code>credentials</code> default <code>&#x27;same-origin&#x27;</code> and <code>cache: &#x27;no-store&#x27;</code>.<br><strong>Behavior:</strong> returns a Promise resolving to <code>{ status, ok, json }</code> where <code>json</code> is parsed if server returned JSON; fallback <code>json</code> object created on parse errors with <code>invalid_server_response</code> marker. <br><strong>Error handling:</strong> upstream <code>.catch</code> paths handle network exceptions; promise always resolves to structured object for caller to interpret. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>High-level save flow — <code>doSaveAction(opts)</code></strong><br><strong>Purpose:</strong> Main orchestrator that reads markdown, enforces size constraint, prompts/validates filename, updates status UI, invokes <code>postSaveMarkdown</code>, and dispatches response event.<br><strong>Inputs:</strong> <code>opts</code> may contain <code>markdown</code> and/or <code>filename</code>.<br><strong>Steps (detailed):</strong><br>1. Acquire markdown: <code>opts.markdown</code> → <code>#paste</code> → <code>#page-area</code> → <code>&#x27;&#x27;</code>. If empty, set error status, dispatch <code>{ok:false, error:&#x27;missing_markdown&#x27;}</code> and return resolved Promise.<br>2. Get <code>clientMax</code> from <code>getClientMaxSize()</code> and compute <code>payloadBytes</code> with <code>utf8BytesLength</code>. If <code>payloadBytes &gt; clientMax</code>, update status and dispatch <code>{ error:&#x27;payload_too_large&#x27; }</code>. Return resolved Promise.<br>3. Filename: prefer <code>opts.filename</code>; else compute <code>defaultName</code> from sanitized <code>document.title</code> then call <code>promptFilename</code>. If user cancels return canceled result with status update and dispatch event.<br>4. <code>updateStatus(&#x27;Saving…&#x27;)</code> and call <code>postSaveMarkdown</code>.<br>5. On success (<code>result.ok &amp;&amp; json.ok</code>), build friendly message including <code>json.filename</code> and <code>json.size</code>; if <code>json.url</code> append a clickable anchor into <code>#status</code>; dispatch success detail <code>{ ok:true, status:&#x27;saved&#x27;, id, filename, rel_path, url, size }</code>.<br>6. On server error, set status <code>&#x27;Save failed: ...&#x27;</code> and dispatch server error detail.<br>7. On network error, set status and dispatch <code>{ error:&#x27;network_error&#x27; }</code>.<br><strong>Return:</strong> always a Promise resolving to either success or structured error object. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Cancelable request event — <code>onSaveButtonClick(e)</code></strong><br><strong>Purpose:</strong> Click handler attached to save button that dispatches cancelable <code>ptt:save-md-request</code> so integrators can intercept and provide <code>event.detail</code> overrides or cancel the action.<br><strong>Behavior:</strong><br>- Create <code>CustomEvent(EVENT_REQUEST_MD, { detail: {}, bubbles: true, cancelable: true })</code> and <code>dispatchEvent</code> it. If <code>dispatchEvent</code> returns <code>false</code> treat as cancelled by handler and emit response event <code>{ cancelled_by_handler }</code>.<br>- Read <code>detail.markdown</code> and <code>detail.filename</code> if provided by page handlers; fall back to DOM reads.<br>- Call <code>doSaveAction</code> with collected inputs.<br><strong>Design notes:</strong> allows host page to short-circuit or enrich save payload (e.g., attach metadata) safely. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Event wiring & programmatic API — <code>attachHandlers()</code></strong><br><strong>Responsibilities:</strong><br>- Attach click handler to <code>#saveBtn</code> if present, guarding against core owning the button via <code>btn.dataset.__tv_save_attached</code> and preventing double-attachment via <code>btn.dataset.__ptt_save_md_attached</code>.<br>- Add window listener for <code>EVENT_REQUEST_MD</code> to accept programmatic saves (<code>ev.detail</code> can provide <code>markdown</code>/<code>filename</code>).<br>- Expose <code>window.PTT_SAVE</code> if missing with <code>{ save(opts), getClientMaxSize }</code>; if present, attach <code>saveMd</code> alias method.<br><strong>Idempotence & safety:</strong> uses dataset flags and try/catch so repeated calls or multiple scripts don't double-wire handlers. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>DOM ready helper — <code>ready(fn)</code></strong><br><strong>Purpose:</strong> Execute <code>fn</code> when DOM is interactive or complete, or on <code>DOMContentLoaded</code> otherwise. Uses <code>setTimeout(fn,0)</code> for immediate scheduling when ready. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Initialization</strong><br><strong>Flow:</strong> <code>ready()</code> calls <code>attachHandlers()</code> and logs initialization with <code>getClientMaxSize()</code>. Wrapped in try/catch to avoid crashing host. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Response event payload shapes (canonical)</strong><br><strong>Success:</strong> <code>{ ok:true, status:&#x27;saved&#x27;, id:String|null, filename:String, rel_path:String|null, url:String|null, size:Number }</code>.<br><strong>Client errors:</strong> <code>{ ok:false, error:&#x27;missing_markdown&#x27;|&#x27;payload_too_large&#x27;|&#x27;cancelled&#x27;, details, max? }</code>.<br><strong>Server/network errors:</strong> <code>{ ok:false, error:&#x27;server_error&#x27;|&#x27;network_error&#x27;, details }</code>. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Security & injection considerations</strong><br>- All client-sent data is JSON-encoded; <code>postSaveMarkdown</code> sets <code>Content-Type: application/json</code>.<br>- Filenames sanitized in <code>promptFilename</code> and <code>ensureMdSuffix</code> to avoid directory traversal and control characters.<br>- Status DOM insertion uses <code>textContent</code> except for intentionally creating an <code>&lt;a&gt;</code> element when server returns <code>json.url</code> (link created with <code>textContent</code> for filename and <code>rel=&quot;noopener noreferrer&quot;</code>).<br>- No raw <code>innerHTML</code> insertion from server responses; server <code>json.url</code> used as <code>href</code> — ensure server-provided URLs are trusted or validated server-side. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Failure modes & resilience</strong><br>- Network errors, JSON parse errors, and server non-JSON responses handled gracefully: <code>postSaveMarkdown</code> returns structured object; <code>doSaveAction</code> transforms into user-visible status and <code>dispatchResponseEvent</code> calls.<br>- User cancel flows return resolved Promises with <code>cancelled</code> error object; nothing throws to host. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Observability & debugging</strong><br>- Minimal logging via <code>logDebug</code>; many errors swallowed to avoid host disruption. For integration testing add temporary <code>console</code> instrumentation or modify <code>logDebug</code> to route to host telemetry.<br>- <code>ptt:save-md-request</code> and <code>ptt:save-md-response</code> events provide integration hooks for telemetry and programmatic workflows. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Performance considerations</strong><br>- Client-side cost small: UTF-8 length compute and JSON stringify for payload; <code>TextEncoder</code> used when available (native fast path).<br>- No large synchronous DOM operations; prompt and network ops are user-driven and asynchronous. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Compatibility & graceful degradation</strong><br>- Uses <code>fetch</code> API — modern browsers. If <code>fetch</code> not available integration will fail; consider polyfill if supporting legacy browsers.<br>- <code>TextEncoder</code> optional fallback via <code>encodeURIComponent</code> technique ensures accurate payload sizing where <code>TextEncoder</code> unsupported. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Testing checklist (actionable)</strong><br><strong>Unit tests:</strong> <code>getClientMaxSize()</code> (PTT_CONFIG, meta tag, fallback), <code>utf8BytesLength()</code> (multi-byte chars), <code>promptFilename()</code> sanitization and truncation, <code>ensureMdSuffix()</code> case variations, <code>readElementText()</code> for <code>&lt;textarea&gt;</code> vs content div.<br><strong>Integration tests:</strong> <code>onSaveButtonClick</code> cancelable event flow (host cancels), <code>attachHandlers</code> idempotence (dataset flags), programmatic window dispatch of <code>ptt:save-md-request</code> with overrides, <code>PTT_SAVE.save()</code> API call flow.<br><strong>Network tests:</strong> <code>postSaveMarkdown</code> handles JSON success, non-JSON body, and network rejection; server response containing <code>url</code> should render clickable anchor in status.<br><strong>E2E tests:</strong> full save cycle with real backend returning <code>{ok:true, filename, size, url}</code>; client limit enforcement by injecting large paste; user cancel via <code>prompt</code> simulated. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Recommended non-breaking improvements</strong><br>1. Add optional <code>fetch</code> polyfill or graceful fallback to <code>XMLHttpRequest</code> for legacy environments.<br>2. Expose <code>PTT_SAVE.onResponse</code> callback registration to receive programmatic callbacks in addition to DOM events.<br>3. Make <code>SAVE_ENDPOINT</code> configurable via <code>PTT_CONFIG.SAVE_ENDPOINT</code> and allow override by meta tag for flexible deployments.<br>4. Provide a non-blocking filename UI fallback instead of synchronous <code>prompt()</code> (e.g., show a small overlay) to improve UX and testability.<br>5. Add optional <code>TV_DEBUG</code> flag to surface caught exceptions to console for QA integrations. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Integration & release notes</strong><br>- Preserve namespaced events (<code>ptt:save-md-request</code>, <code>ptt:save-md-response</code>) and <code>window.PTT_SAVE</code> API to remain compatible with host integrations.<br>- When minifying, ensure exported global names and dataset flags are not renamed/mangled. </td></tr><tr><td data-label="Technical breakdown (script.save.js)"> <strong>Final verification & pre-merge checklist</strong><br>- Static review: verify all <code>try/catch</code> blocks and ensure no unreachable Promise paths.<br>- Runtime tests: simulate server JSON, server non-JSON, network failure, oversized payload, user-cancel, and hosted handler cancelation via <code>EVENT_REQUEST_MD</code> returning <code>false</code> from <code>dispatchEvent</code>.<br>- UX tests: status update visible in both <code>#status</code> and fallback live region; clickable <code>json.url</code> anchor target <code>_blank</code> works and <code>rel</code> attributes present.<br>- Security review: confirm server-validated <code>json.url</code> usage and recommend server-side URL validation before including in response. </td></tr></tbody></table></div><div class="row-count">Rows: 24</div></div><div class="table-caption" id="Table3" data-table="Docu_0128_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3 • script.toc.js</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (script.toc.js)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (script.toc.js)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>File-level overview & intent (complete)</strong><br><strong>Purpose:</strong> Centralized TOC + labels loader for PasteToTable. Normalizes label keys for robust matching; injects safe captions (marked <code>data-ptt-injected</code>) to avoid duplicates; warms and reloads label caches non-blockingly; installs safe fetch/XHR interceptors to trigger refreshes after group-load/convert actions; exposes API for manual label application and scheduled TOC refreshes while preserving existing public API (<code>PTToc.reloadLabels</code>, <code>PTToc.getLabels</code>, <code>PTToc.scheduleTocRefresh</code>, <code>PTToc.init</code>, <code>PTToc.build</code>, <code>PTToc.applyLabelsNow</code>).<br><strong>Design constraints:</strong> defensive coding (pervasive try/catch), idempotence (guards to avoid double-installation), non-blocking UI, conservative network timeouts, minimal DOM mutation (inject captions only when helpful), preserve backward compatibility with <code>window.__ptt_labels_injected</code> and event semantics. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Module guard & PTToc shape</strong><br><strong>Behavior:</strong> Prevent double-install by checking <code>window.__pt_toc_installed</code>. Exposes <code>PTToc</code> with internal state: <code>_debounceMs</code>, <code>_rebuildTimer</code>, <code>_mutationObserver</code>, <code>_delegatedAttached</code>, <code>_labels</code>, <code>_reloadPromise</code>, <code>_labels_helpers_installed</code>, <code>_scheduledRefreshFlag</code>, <code>_pendingAutoSelect</code>, <code>_lastAutoSelectAt</code>, <code>_fetchWrapped</code>, <code>_xhrWrapped</code>, plus <code>config</code> with defaults (<code>tocSelector</code>, <code>labelsPaths</code>, <code>deferLabelsReload</code>, <code>autoSelectTable1Enabled</code>, etc.).<br><strong>Invariant:</strong> only one PTToc instance per page. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>dbg()</code> / <code>warn()</code></strong><br><strong>Purpose:</strong> Lightweight debug wrappers; call <code>console.debug</code>/<code>console.warn</code> when <code>window.tvDebug</code> truthy. <br><strong>Behavior:</strong> best-effort; swallow exceptions. <br><strong>Use:</strong> debugging only; no runtime side-effects. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>tryCatch(fn, fallback)</code></strong><br><strong>Purpose:</strong> Small helper to run <code>fn()</code> and return <code>fallback</code> on throw. <br><strong>Inputs / Outputs:</strong> <code>fn</code> (callable), <code>fallback</code> (any). <br><strong>Behavior:</strong> reduces boilerplate; used rarely. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>sanitizeText(s)</code></strong><br><strong>Purpose:</strong> Defensive <code>String</code> coercion + <code>trim()</code>. <br><strong>Edge-cases:</strong> returns <code>&#x27;&#x27;</code> for null/undefined or on error. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>_normalize_heading_text(raw)</code></strong><br><strong>Purpose:</strong> Normalize heading content for stable id/name base: strip tags, convert <code>&lt;br/&gt;</code> to spaces, collapse whitespace and newlines. <br><strong>Inputs:</strong> raw string (may contain HTML). <br><strong>Output:</strong> single-line trimmed string (fallback to raw trimmed if processing fails). <br><strong>Invariant:</strong> safe to call with DOM node text or HTML. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>ensureId(el, prefix)</code></strong><br><strong>Purpose:</strong> Ensure element has stable unique <code>id</code>. If <code>el.id</code> exists and non-empty return it; otherwise derive base from normalized text then append numeric suffix until unique. <br><strong>Inputs:</strong> <code>el</code> (Element), <code>prefix</code> (string, default <code>&#x27;ptt-&#x27;</code>). <br><strong>Outputs:</strong> assigned or existing id string. <br><strong>Behaviors:</strong> handles collisions, truncates base to 60 chars, uses random fallback when text empty. <br><strong>Side-effects:</strong> sets <code>el.id</code> when missing. <br><strong>Edge-cases:</strong> works with non-text headings and rows; wrapped in try/catch to avoid DOM errors. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>makeLink(id, text, extraClass)</code></strong><br><strong>Purpose:</strong> Create <code>&lt;li&gt;&lt;a&gt;</code> entry linking to <code>#id</code>, with sanitized text and ARIA attributes. <br><strong>Inputs:</strong> <code>id</code>, <code>text</code>, <code>extraClass</code> (optional). <br><strong>Output:</strong> <code>&lt;li&gt;</code> DOM node. <br><strong>Safety:</strong> uses <code>textContent</code> so safe from XSS. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>clearChildren(el)</code></strong><br><strong>Purpose:</strong> Remove all child nodes from <code>el</code> (idempotent). <br><strong>Use:</strong> clearing TOC lists prior to rebuild. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>getContentRoot()</code></strong><br><strong>Purpose:</strong> Resolve content root per config: selector <code>config.contentSelector</code>, fallback <code>#tables-viewer</code>, fallback <code>document.body</code>. <br><strong>Output:</strong> Element. <br><strong>Edge-cases:</strong> robust to missing selectors. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>joinUrl(base, rel)</code></strong><br><strong>Purpose:</strong> Resolve <code>rel</code> against <code>base</code> using <code>new URL</code> when available; fallback to string concat. <br><strong>Use:</strong> normalize candidate label paths relative to <code>__tv_base</code>. <br><strong>Edge-cases:</strong> tolerant to invalid urls. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>fetchJsonOnce(url, timeoutMs)</code></strong><br><strong>Purpose:</strong> Fetch JSON from <code>url</code> with a bounded timeout; returns <code>Promise&lt;parsedJson|null&gt;</code> or <code>null</code> on failure. <br><strong>Behavior:</strong> uses <code>AbortController</code> when available; fallback uses setTimeout guard. On success calls <code>r.text()</code> then <code>JSON.parse</code> (robustly). Returns <code>null</code> for non-OK responses or parse errors. <br><strong>Timeout default:</strong> 2500ms. <br><strong>Invariants:</strong> never throws; always resolves. <br><strong>Performance/security:</strong> minimal network load due to <code>cache: &#x27;no-store&#x27;</code> and short timeout. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>canonKey(s)</code></strong><br><strong>Purpose:</strong> Canonical key normalizer for label keys: trim, compress spaces, strip non-alphanumerics at ends, lowercase. <br><strong>Output:</strong> normalized string used for label lookups. <br><strong>Determinism:</strong> stable across calls. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>normalizeLabels(raw)</code></strong><br><strong>Purpose:</strong> Convert server-provided labels into flat canonical lookup map: for each top-level <code>k</code>, stores <code>canonKey(k) -&gt; v</code>; if v is object, flattens <code>k_subk</code> → value as well. <br><strong>Inputs:</strong> <code>raw</code> object. <br><strong>Outputs:</strong> normalized object map. <br><strong>Behavior:</strong> resilient to odd shapes; returns empty object for invalid input. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>installLabelsHelpers()</code> (IIFE)</strong><br><strong>Purpose:</strong> Install <code>PTToc.reloadLabels</code> and <code>PTToc.getLabels</code>, warm global <code>window.__ptt_labels_injected</code> hook, and avoid double installation. <br><strong>Key function — <code>PTToc.reloadLabels(opts)</code></strong><br><strong>Purpose:</strong> Sequentially try candidate label paths until one returns usable JSON; supports <code>force</code> option to cache-bust all candidates. <br><strong>Inputs:</strong> <code>opts.candidates</code> (override list), <code>opts.timeoutPer</code>, <code>opts.force</code>. <br><strong>Behavior & flow:</strong> expands candidates against <code>__tv_base</code> if present; preserves <code>window.__ptt_labels_reload_promise</code> to prevent parallel reloads; if global labels exist and <code>!force</code> returns them immediately and schedules background warm refresh; when loading, normalizes labels with <code>normalizeLabels</code>, assigns to <code>PTToc._labels</code> and <code>window.__ptt_labels_injected</code>, calls <code>PTToc.build()</code> when available, and resolves with labels. <br><strong>Edge-cases:</strong> returns empty map on failure; uses small delays for background attempts; idempotent semantics via global promise guard. <br><strong><code>PTToc.getLabels()</code></strong> returns shallow copy of <code>PTToc._labels</code> or <code>window.__ptt_labels_injected</code>. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Labels background-warm behavior</strong><br><strong>Purpose:</strong> If host already has <code>window.__ptt_labels_injected</code>, <code>reloadLabels</code> avoids blocking UI and returns existing labels but schedules background fetch to replace if new data found. <br><strong>Design tradeoff:</strong> non-blocking UX vs. eventual consistency of labels. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>escapeHtml(str)</code></strong><br><strong>Purpose:</strong> Minimal HTML escaper for caption injection: <code>&amp; &lt; &gt; &quot; &#x27;</code>. <br><strong>Use:</strong> when injecting caption <code>innerHTML = &#x27;&lt;strong&gt;&#x27; + escapeHtml(...) + &#x27;&lt;/strong&gt;&#x27;</code>. <br><strong>Safety note:</strong> double-checks server-provided caption strings are handled as text via escaping. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>captionFor(labelsObj, bookPrefix, idx)</code></strong><br><strong>Purpose:</strong> Lookup caption text for index <code>idx</code> and optional <code>bookPrefix</code> from normalized <code>labelsObj</code>, using a spectrum of candidate keys: <code>&lt;book&gt;_NN</code>, <code>&lt;book&gt;-NN</code>, <code>NN</code>, unpadded <code>idx</code>, and canonicalized variants via <code>canonKey</code>. <br><strong>Inputs:</strong> <code>labelsObj</code> (object), <code>bookPrefix</code> (string or null), <code>idx</code> (number). <br><strong>Output:</strong> caption string or <code>null</code> when nothing found. <br><strong>Behavior:</strong> attempts many permutations to maximize match coverage. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>inferBookPrefix()</code></strong><br><strong>Purpose:</strong> Heuristic to infer a document-level <code>bookPrefix</code>: prefer <code>PTToc.config.bookPrefix</code> if set; else derive from <code>location.pathname</code> filename minus extension; fallback to sanitized <code>document.title</code> trimmed to 60 chars; final fallback <code>&#x27;document&#x27;</code>. <br><strong>Use:</strong> to bias label lookups like <code>prefix_01</code>. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>injectCaptionForElement(anchorEl, bookPrefix, idx, captionText)</code></strong><br><strong>Purpose:</strong> Insert a sanitized <code>.table-caption</code> node for <code>captionText</code> near <code>anchorEl</code> and mark it with <code>data-ptt-injected=&#x27;1&#x27;</code>. <br><strong>Inputs:</strong> anchor element (heading or table), <code>bookPrefix</code>, <code>idx</code>, and caption text. <br><strong>Behavior:</strong> avoids duplicates by checking existing <code>id</code> <code>TableNN</code> and updates existing caption if found and same class; generates fallback unique ids on collisions; attempts to insert before anchor or append to <code>document.body</code> as fallback. <br><strong>Safety:</strong> caption content escaped; caption node style minimally changed. <br><strong>Invariant:</strong> never overwrites server-owned caption nodes unless they are same id and class; marks injected nodes with <code>data-ptt-injected</code>. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>PTToc.applyLabelsNow(labelsObj)</code></strong><br><strong>Purpose:</strong> Public helper to apply a labels object immediately: normalizes and sets <code>PTToc._labels</code>, updates <code>window.__ptt_labels_injected</code>, and calls <code>PTToc.build()</code> to refresh TOC and inject captions. <br><strong>Inputs:</strong> <code>labelsObj</code> (object). <br><strong>Behavior:</strong> defensive try/catch to avoid throwing. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>fetchLabels(paths)</code></strong><br><strong>Purpose:</strong> Convenience sequential fetcher that tries a list of <code>paths</code> until successful JSON parse; returns <code>Promise&lt;object&gt;</code> resolving to parsed object or <code>{}</code>. <br><strong>Behavior:</strong> sequential attempt style with small per-candidate failover logic; used by fallback fetch flows (non-<code>reloadLabels</code> path). </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>selectTable1()</code></strong><br><strong>Purpose:</strong> Attempt to auto-select / click the TOC link that corresponds to "Table 1". <br><strong>Algorithm:</strong> collects TOC link candidates via <code>a[data-pt-target]</code> or <code>a[href]</code>, checks for explicit <code>Table1</code>/<code>Table01</code> targets, then visible link text patterns (<code>/^Table\s*0?1$/i</code> or <code>01.</code> or <code>Table 1:</code>), then falls back to clicking first candidate. Throttled by <code>PTToc.config.autoSelectThrottleMs</code>. <br><strong>Outputs:</strong> boolean success indicator. <br><strong>Side-effects:</strong> focuses & clicks anchor (may trigger navigation/render). </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>PTToc.scheduleTocRefresh(opts)</code></strong><br><strong>Purpose:</strong> Public scheduling helper to reload labels (force cache-busted attempts) in two staged timers (<code>firstDelay</code> and <code>secondDelay</code>) to support eventual consistency after group load/convert events. <br><strong>Inputs:</strong> <code>opts.firstDelay</code>, <code>opts.secondDelay</code>, <code>opts.autoSelect</code>. <br><strong>Behavior:</strong> de-duplicated via <code>_scheduledRefreshFlag</code>; runs two reload attempts (first perhaps lighter, second forces bust), applies labels to <code>PTToc._labels</code>, calls <code>PTToc.build()</code>, and clears scheduled flag. Falls back to <code>doFallbackFetch</code> (uses <code>fetchLabels</code>) when <code>PTToc.reloadLabels</code> not available. <br><strong>Edge-cases:</strong> idempotent; sets <code>_pendingAutoSelect</code> if <code>autoSelect</code> requested. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Fetch/XHR interceptors (installGroupLoadInterceptor IIFE)</strong><br><strong>Purpose:</strong> Install safe wrappers around <code>window.fetch</code> and <code>window.XMLHttpRequest</code> to detect requests to <code>/api/group/load</code> and <code>/api/convert</code> and trigger <code>PTToc.scheduleTocRefresh({ autoSelect: true })</code> on success or error. <br><strong>Design:</strong> Avoid double-wrap via <code>_fetchWrapped</code> and <code>_xhrWrapped</code>. For <code>fetch</code>: wrap call, detect URL substring, attach <code>.then</code> and <code>.catch</code> to returned promise to schedule refresh. For XHR: create <code>WrappedXHR</code> delegating to native XHR, override <code>open</code> to capture <code>_url</code> and <code>_method</code>, override <code>send</code> to attach <code>load</code>/<code>error</code> listeners that schedule refresh when URL matches. <br><strong>Safety:</strong> wrapper falls back to native behavior on errors and never blocks original promise/response chain; sets <code>cache: &#x27;no-store&#x27;</code> only in <code>fetchJsonOnce</code> not here. <br><strong>Side-effects:</strong> minimal; only used to auto-refresh TOC after relevant server interactions. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>buildItemsFromSingleTable(table, labels, bookPrefix)</code></strong><br><strong>Purpose:</strong> For single-table pages, produce <code>items[]</code> of <code>{id,label}</code> by enumerating body rows and mapping labels via <code>captionFor(labels, bookPrefix, rowIndex)</code>, else using <code>rowLabelPrefix</code> + index. <br><strong>Outputs:</strong> array of items representing row anchors. <br><strong>Edge-cases:</strong> collects rows across multiple TBODIES; ensures ids via <code>ensureId</code>. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>buildItemsFromHeadings(labels, bookPrefix)</code></strong><br><strong>Purpose:</strong> For multi-section pages, collect configured heading elements (<code>config.headingSelector</code>) and return items with <code>{ id, label, anchorEl, index }</code> where label is normalized heading text or caption from labels. <br><strong>Behavior:</strong> uses <code>_normalize_heading_text</code>, <code>ensureId</code>, and will be used to inject captions when labels found. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>buildOnce()</code></strong><br><strong>Purpose:</strong> Single TOC build: find <code>tocList</code> / <code>tocBarList</code> targets; gather tables from <code>contentRoot</code>; pick strategy: single-table -> <code>buildItemsFromSingleTable</code>, otherwise <code>buildItemsFromHeadings</code>. Inject captions for headings or single-table via <code>injectCaptionForElement</code> when <code>PTToc._labels</code> (or provided labels) supply captions. Construct DocumentFragments, clear existing lists, append new items, call <code>highlightCurrentFromLocation()</code>, and handle <code>_pendingAutoSelect</code>. <br><strong>Idempotence:</strong> clears and re-populates lists; safe to call multiple times. <br><strong>Performance:</strong> O(#headings + #rows) per build; <code>debounceBuild</code> used to reduce frequency. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>debounceBuild()</code></strong><br><strong>Purpose:</strong> Debounce wrapper around <code>buildOnce</code> using <code>_rebuildTimer</code> and <code>_debounceMs</code>. <br><strong>Behavior:</strong> clears prior timeout and schedules <code>buildOnce</code>. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>highlightCurrentFromLocation()</code></strong><br><strong>Purpose:</strong> Mark currently selected TOC item by matching <code>location.hash</code> to <code>href</code> or <code>data-pt-target</code> and set <code>aria-current=&quot;page&quot;</code> accordingly. <br><strong>Use:</strong> improves focus/ARIA state after navigation or programmatic highlight. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>onTocClick(ev)</code></strong><br><strong>Purpose:</strong> Delegated click handler for TOC: intercept <code>&lt;a data-pt-target&gt;</code>, prevent default, compute target element by id, compute scroll offset minus sticky header height, smooth-scroll to target, update history with <code>replaceState</code>, and schedule <code>highlightCurrentFromLocation</code>. <br><strong>Edge-cases:</strong> if target missing set <code>location.hash</code> and return. <br><strong>Accessibility:</strong> respects sticky header offset to avoid obscuring headings. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>attachDelegatedHandlers()</code></strong><br><strong>Purpose:</strong> Attach delegated <code>click</code> listener for TOC links (using <code>onTocClick</code>), <code>hashchange</code> listener to <code>highlightCurrentFromLocation</code>, and delegate convert-clicks to schedule TOC refresh (<code>.convert-btn</code> handlers). <br><strong>Idempotence:</strong> guarded by <code>_delegatedAttached</code>. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>observeMutations()</code></strong><br><strong>Purpose:</strong> Attach <code>MutationObserver</code> to <code>contentRoot</code> to observe subtree <code>childList</code> changes and call <code>debounceBuild</code> on mutations (detects late-inserted content). <br><strong>Behavior:</strong> disconnects any prior observer, creates new observer; noop if <code>MutationObserver</code> missing. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>PTToc.build</code></strong><br><strong>Purpose:</strong> Public API to trigger debounced TOC rebuild; simply calls <code>debounceBuild()</code>. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong><code>PTToc.init(options)</code></strong><br><strong>Purpose:</strong> Initialize PTToc with optional <code>options</code> override of <code>config</code>. <br><strong>Flow:</strong> merges config, calls <code>attachDelegatedHandlers()</code>, then either:<br>- If <code>deferLabelsReload</code> true: set <code>_labels</code> from <code>window.__ptt_labels_injected</code> if present; call <code>buildOnce()</code> immediately; <code>observeMutations()</code>; then warm <code>reloadLabels</code> in background if no global labels.<br>- Else: call <code>reloadLabels({ candidates, force:true })</code> and then <code>buildOnce()</code> and <code>observeMutations()</code> on resolution; fallback to <code>fetchLabels</code> if <code>reloadLabels</code> not present.<br><strong>Idempotence & safety:</strong> wrapped in try/catch; many fallbacks; sets up background label warm-up when deferring to avoid blocking init. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Global exposure & auto-init</strong><br><strong>Behavior:</strong> assign <code>window.PTToc = window.PTToc || PTToc</code>; auto-call <code>PTToc.init()</code> on DOM ready (immediate if readyState !== 'loading') to ensure early availability. <br><strong>Compatibility:</strong> preserves global <code>PTToc</code> if host already provided. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Public API summary (preserved names)</strong><br><code>window.PTToc.init(options)</code> — initialize with optional overrides.<br><code>PTToc.build()</code> — schedule debounced build.<br><code>PTToc.reloadLabels(opts)</code> — (installed) sequential labels loader; returns Promise resolving to labels map.<br><code>PTToc.getLabels()</code> — return copy of current labels map.<br><code>PTToc.scheduleTocRefresh(opts)</code> — staged reload & refresh scheduler.<br><code>PTToc.applyLabelsNow(labelsObj)</code> — immediate label application. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Failure modes & resilience</strong><br>- All network fetches resolve to <code>null</code> or <code>{}</code> instead of throwing; <code>reloadLabels</code> sequences candidates until success.<br>- Guards against double-wrapping <code>fetch</code>/<code>XHR</code>; wrappers fall back to native behavior on error.<br>- <code>buildOnce</code> and mutating operations heavily wrapped in try/catch to avoid host interruption. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Security & XSS considerations</strong><br>- Caption text sanitized via <code>escapeHtml</code> before injecting into <code>innerHTML</code> within a <code>&lt;strong&gt;</code> wrapper.<br>- All link text set via <code>textContent</code>; no unescaped HTML inserted into TOC entries.<br>- Server-provided label keys/values are used as text only; ensure server does not include unsafe markup in label values (escape protects injection in captions but consumer should still validate server). </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Performance considerations</strong><br>- <code>fetchJsonOnce</code> uses small timeouts to reduce hangs; <code>reloadLabels</code> tries candidates sequentially rather than parallel to reduce strain on network and server.<br>- <code>buildOnce</code> is debounced; <code>MutationObserver</code> used instead of periodic polling to reduce CPU.<br>- Wrapping <code>fetch</code> introduces tiny overhead; wrappers are minimal and non-blocking. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Testing checklist (actionable)</strong><br><strong>Unit tests:</strong> <code>canonKey</code> normalization permutations; <code>normalizeLabels</code> flattening behavior; <code>captionFor</code> matching permutations (bookPrefix present/absent, padded/unpadded keys); <code>ensureId</code> uniqueness and id collision resolution; <code>escapeHtml</code> correctness.<br><strong>Integration tests:</strong> <code>PTToc.init</code> with <code>deferLabelsReload=true</code> vs <code>false</code> — verify immediate build vs delayed build; <code>PTToc.reloadLabels</code> candidate ordering, <code>force</code> behavior, and background warm path; <code>injectCaptionForElement</code> duplicates avoidance and <code>data-ptt-injected</code> marking; <code>fetch</code>/XHR wrappers trigger <code>PTToc.scheduleTocRefresh</code> on <code>/api/group/load</code> and <code>/api/convert</code> calls.<br><strong>E2E tests:</strong> dynamic content insertion triggers <code>MutationObserver</code> rebuild; robust behavior when <code>window.__ptt_labels_injected</code> present; throttling of <code>selectTable1</code> and auto-select correctness. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Recommended non-breaking improvements</strong><br>1. Add opt-in verbose debug <code>PTToc.config.debug</code> that toggles <code>dbg()</code> globally (instead of <code>window.tvDebug</code>).<br>2. Expose <code>PTToc._fetchWrapped</code> and <code>_xhrWrapped</code> flags publicly for integration tests to confirm single wrapping.<br>3. Add a small in-memory LRU for <code>reloadLabels</code> candidate responses to avoid refetching identical JSON during rapid schedule cycles (respecting cache-bust when <code>force</code>).<br>4. Consider adding <code>maxCandidates</code> and <code>parallelism</code> tunables if label hosts are slow and parallel attempts are desired in future — keep default sequential behavior for safety.<br>5. Add explicit feature flag to opt-out of XHR/fetch wrapping for sensitive environments where altering network constructors is forbidden. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Integration & release notes</strong><br>- Maintain exact public API names (<code>PTToc.*</code>) and the global <code>window.__ptt_labels_injected</code> contract so other scripts can interoperate.<br>- When minifying, ensure external references to <code>window.PTToc</code> and <code>window.__ptt_labels_injected</code> are preserved (do not mangle).<br>- Any change to caption-id convention (e.g., <code>TableNN</code>) must be coordinated with other modules that search for those ids. </td></tr><tr><td data-label="Technical breakdown (script.toc.js)"> <strong>Final verification & pre-merge checklist</strong><br>- Static review: verify no accidental global variable leaks beyond <code>window.PTToc</code> and guarded <code>window.__pt_toc_installed</code>/<code>window.__ptt_labels_reload_promise</code>/<code>window.__ptt_labels_injected</code>.<br>- Runtime tests: reloadLabels success/failure paths, deferred init warm fetch, fetch/XHR wrapper idempotence, <code>scheduleTocRefresh</code> two-stage behavior with autoSelect flag, mutation observation rebuilds, and caption injection non-duplication (<code>data-ptt-injected</code>).<br>- Security review: ensure <code>escapeHtml</code> used wherever server labels are placed into <code>innerHTML</code> and verify server-side validation of <code>labels_injected.json</code> endpoints. </td></tr></tbody></table></div><div class="row-count">Rows: 44</div></div><div class="table-caption" id="Table4" data-table="Docu_0128_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4 • script.core.js</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (script.core.js)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (script.core.js)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (script.core.js)"> <strong>File scope & top-level constants</strong><br><strong>Purpose:</strong> Initialize runtime flags, defaults, and coordinate shared utilities used across PasteToTable UI flows (toasts, conversion, caption injection, resource loading, action dispatch).<br><strong>Key items:</strong> <code>defaultConfig = { highlight:true, debounceMs:150, chunkSize:300 }</code>, <code>TV_DEBUG</code> flag, <code>TV_BASE</code> (detected script base).<br><strong>Behavior & invariants:</strong> idempotent assignment into <code>window.tvConfig</code>, <code>window.__tv_base</code>, and <code>window.tvUtils</code> so multiple loads do not clobber runtime state. All top-level assignments guarded by try/catch to avoid throw-through. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>setTvSearchConfig(cfg)</strong><br><strong>Signature:</strong> <code>window.setTvSearchConfig = function(cfg)</code><br><strong>Purpose:</strong> Safe setter for <code>window.tvConfig</code> runtime tunables used by search & UI debounce. <br><strong>Inputs:</strong> <code>cfg</code> object; recognized keys: <code>highlight:boolean</code>, <code>debounceMs:number</code>, <code>chunkSize:number</code>. <br><strong>Outputs / Side-effects:</strong> Mutates <code>window.tvConfig</code> with validated values (clamps debounce >=0, chunkSize >=50). <br><strong>Robustness:</strong> Silently ignores malformed inputs and exceptions. No return value. <br><strong>Edge-cases / Tests:</strong> Null/undefined; non-object; numeric strings — ensure not coerced. Must preserve other config properties. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>safe(fn)</strong><br><strong>Signature:</strong> <code>safe(fn)</code><br><strong>Purpose:</strong> Execute <code>fn</code> inside try/catch and return <code>undefined</code> on error — tiny defensive wrapper used in many call sites to avoid interruption. <br><strong>Inputs:</strong> zero-arg function. <br><strong>Outputs:</strong> return value of <code>fn()</code> or <code>undefined</code> if <code>fn</code> throws. <br><strong>Notes:</strong> Do not swallow async rejections — only synchronous. Use where a best-effort read is acceptable. Unit test: ensure thrown exceptions do not propagate. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>isString(x)</strong><br><strong>Signature:</strong> <code>isString(x)</code><br><strong>Purpose:</strong> Tiny type guard used for source detection. <br><strong>Behavior:</strong> <code>typeof x === &#x27;string&#x27;</code>. <br><strong>Edge-cases:</strong> <code>new String(&#x27;x&#x27;)</code> returns false — acceptable in this codebase. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>joinUrl(base, rel)</strong><br><strong>Signature:</strong> <code>joinUrl(base, rel)</code><br><strong>Purpose:</strong> Resolve <code>rel</code> relative to <code>base</code> using URL when available; fallback to concatenation. <br><strong>Inputs:</strong> <code>base</code> (may be falsy), <code>rel</code> (string). <br><strong>Outputs:</strong> Absolute or relative URL string. <br><strong>Failure modes & handling:</strong> Uses try/catch around <code>new URL(rel, base)</code>; on error returns safe concatenation <code>base + rel</code> or <code>rel</code> if base falsy. <br><strong>Security:</strong> Does not attempt to validate hosts — used for local asset discovery only. <br><strong>Tests:</strong> relative vs absolute <code>rel</code>, trailing slashes, missing base. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>once(fn)</strong><br><strong>Signature:</strong> <code>once(fn) -&gt; function</code><br><strong>Purpose:</strong> Return a wrapper that calls <code>fn</code> at most once (idempotent). <br><strong>Behavior:</strong> Internal <code>called</code> flag; wrapper returns silently on subsequent calls. Exceptions inside <code>fn</code> are caught. <br><strong>Use-cases:</strong> onload handlers for dynamically inserted scripts and one-shot events. <br><strong>Edge-cases:</strong> Not reentrant-safe if <code>fn</code> calls the wrapper; acceptable here. Unit: ensure exactly one invocation even if wrapper called in parallel. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>detectScriptBase()</strong><br><strong>Signature:</strong> <code>detectScriptBase()</code><br><strong>Purpose:</strong> Compute <code>TV_BASE</code> — base path for assets (used by index/worker/extra candidates). <br><strong>Algorithm:</strong> Check <code>document.currentScript.src</code>; if present, strip filename. Else iterate scripts in reverse looking for <code>script.js</code> patterns. Else fallback to <code>location.origin + pathname dir</code>. Final fallback <code>&#x27;/&#x27;</code>. <br><strong>Side-effects:</strong> None; but stores final into <code>window.__tv_base</code>. <br><strong>Edge-cases:</strong> Running in CSP/no-script-src environment or when <code>document.currentScript</code> is not available — covered by fallbacks. Tests: multiple <code>&lt;script&gt;</code> locations; querystring in src preserved per behavior. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>ensureIndexAndWorkerAttrs(base)</strong><br><strong>Signature:</strong> <code>ensureIndexAndWorkerAttrs(base)</code><br><strong>Purpose:</strong> Make sure page-level attributes <code>data-index-url</code> and <code>data-worker-url</code> exist on <code>&lt;body&gt;</code>; derive defaults via <code>joinUrl(base, ...)</code>. Also sets <code>window.tvIndexUrl</code> and <code>window.tvWorkerUrl</code>. <br><strong>Behavior & invariants:</strong> Non-destructive: only sets attributes if absent or blank. Uses try/catch for DOM ops; postpones until DOMContentLoaded if <code>document.body</code> missing. <br><strong>Edge-cases:</strong> Non-HTML environments — function returns early. Tests: missing body, existing attributes, preset global overrides. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>PTTScroll module (IIFE)</strong><br><strong>Exports:</strong> <code>window.PTTScroll = { enable, disable, isEnabled, initObserver, scrollToTop, _debugLog }</code><br><strong>Purpose:</strong> Lightweight coordination object that intentionally <em>no-ops</em> scrolling while providing observer plumbing and debug logging. <br><strong>Functions:</strong><br>- <code>enable()</code> / <code>disable(reason)</code>: set internal <code>enabled</code> boolean and mirror into <code>window.__tv_skip_scroll</code> (safe guard flag).<br>- <code>isEnabled()</code> returns boolean.<br>- <code>initObserver()</code>: if <code>#tables-viewer</code> present and MutationObserver supported, attach observer to emit <code>ptt:renderStable</code> after settle timer (200ms). Attaches <code>window.__pttoc_core_mo</code> reference for debugging. <br>- <code>scrollToTop()</code> is neutral (logs if debug) — intentionally avoids auto-scrolling in this "neutral" core. <br><strong>Safety & Memory:</strong> Observer saved into global avoids double-attach; no unattach API provided — acceptable tradeoff given single-page long-lived usage. Unit: verify <code>ptt:renderStable</code> firing after mutations. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>createScriptElement(src, opts)</strong><br><strong>Signature:</strong> <code>createScriptElement(src, opts)</code><br><strong>Purpose:</strong> Build <code>&lt;script&gt;</code> with safe flags (async/defer/type/crossOrigin). <br><strong>Edge-cases:</strong> Does not append — caller appends and handles events. Tests: ensure attributes set correctly. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>loadExtraSequentially(possiblePaths, onDone, onAllFailed)</strong><br><strong>Signature:</strong> <code>loadExtraSequentially(paths, onDone, onAllFailed)</code><br><strong>Purpose:</strong> Try candidate script paths sequentially until one loads successfully; used to load optional extras (e.g., toc script). <br><strong>Behavior & invariants:</strong> Strict sequential (first-success wins) with <code>onerror</code> removing failed node and retrying after 20ms. Uses <code>once()</code> on <code>onload</code> to avoid multiple triggers. Parent element resolved as <code>head</code> or fallback nodes. Non-blocking; returns after first success or all failures. <br><strong>Robustness:</strong> Each insertion wrapped in try/catch. Does not leak event listeners because inserted <code>&lt;script&gt;</code> nodes are removed on error. <br><strong>Tests:</strong> simulate load success/fail; verify order preserved; verify onAllFailed invoked when no candidate succeeds. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>extra loader: startExtraLoader & extraCandidates</strong><br><strong>Purpose:</strong> Idempotently start process to attempt loading <code>extra.js</code> from multiple candidate locations. <br><strong>Behavior:</strong> Guards with <code>window._tv_extra_loader_attached</code> and check for <code>window.tvExtra</code> or existing <code>&lt;script src*=&quot;extra.js&quot;&gt;</code> before starting. Calls <code>loadExtraSequentially</code>. <br><strong>Edge-cases:</strong> Running before DOM ready — <code>ensureIndexAndWorkerAttrs</code> and <code>startExtraLoader</code> are invoked on DOMContentLoaded or immediately depending on <code>readyState</code>. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>CSS injections (hideMdCss, injectTocInlineCss)</strong><br><strong>Purpose:</strong> Insert small inline CSS rules to hide markdown-export UI elements and to style TOC inline. <br><strong>Behavior & safety:</strong> Idempotent by checking for <code>style[data-tv-early-hide-md]</code> and <code>style[data-tv-toc-inline]</code>. Uses text nodes (safe) to avoid <code>innerHTML</code>. <br><strong>Edge-cases:</strong> Document without head — skip. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>normalizeForSearchLocal(s)</strong><br><strong>Signature:</strong> <code>normalizeForSearchLocal(s)</code><br><strong>Purpose:</strong> Deterministic normalization used by local search/tokenization: lowercase, NFD decomposition, remove diacritics, remove non-letter/number/space (unicode-aware), collapse whitespace, trim. <br><strong>Fallback:</strong> If unicode properties unsupported, fallback to simpler regex removing <code>\W</code>. <br><strong>Security & correctness:</strong> Used for tokenization only; stable across index/query. Unit tests: diacritic handling, unicode letters, fallback correctness. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>debounce(fn, wait)</strong><br><strong>Signature:</strong> <code>debounce(fn, wait)</code><br><strong>Purpose:</strong> Standard debouncing; delegates to <code>Shared.debounce</code> if provided. <br><strong>Implementation details:</strong> Uses closure timer <code>t</code>, returns wrapper that clears timer and sets new timeout to call <code>fn</code>. Default wait uses <code>window.tvConfig.debounceMs</code>. <br><strong>Edge-cases:</strong> Multiple rapid calls, context preservation, arguments forwarded. Test: call-count and final-call semantics. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>copyToClipboard(text) & tryLegacyCopy(t)</strong><br><strong>Purpose:</strong> Robust copy helper: use <code>Shared.copyToClipboard</code>, then <code>navigator.clipboard.writeText</code>, then legacy <code>execCommand</code> fallback using temporary textarea. <br><strong>Behavior:</strong> Returns <code>Promise</code> resolved on success, rejected on failure. <code>tryLegacyCopy</code> sets textarea readonly, offscreen, selects, execCommand('copy'), removes element. <br><strong>Security/permissions:</strong> Clipboard API may be denied by browser — code gracefully falls through to legacy. Tests: simulate clipboard availability/unavailability and ensure no throw. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>sanitizeFileName(name)</strong><br><strong>Signature:</strong> <code>sanitizeFileName(name)</code><br><strong>Purpose:</strong> Produce filesystem-safe filename by replacing <code>\/\\:*?&quot;&lt;&gt;|</code> with <code>_</code>, collapse whitespace -> <code>_</code>, trim to 200 chars. Falls back to <code>&#x27;download&#x27;</code>. Delegates to <code>Shared.sanitizeFileName</code> if present. <br><strong>Edge-cases:</strong> Non-string inputs; names that become empty after sanitize. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>downloadBlob(blob, filename)</strong><br><strong>Signature:</strong> <code>downloadBlob(blob, filename)</code><br><strong>Purpose:</strong> Cross-browser blob download via <code>URL.createObjectURL</code> and an anchor click; attempt to revoke object URL after small delay. Delegates to <code>Shared.downloadBlob</code> if provided. <br><strong>Return:</strong> boolean on success, false on failure. <br><strong>Edge-cases:</strong> Blob not valid, browser blocking synthetic click — handled via try/catch and returns false. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>Toast subsystem: _ensureToastContainer, _computeToastDuration, showToast, showToastOnce, _processToastQueue, _hideActiveToast, _dismissToastById</strong><br><strong>Purpose:</strong> Accessible, non-blocking notification stack with queuing, cooldowns, and styling. <br><strong>Key behaviors:</strong><br>- <code>_ensureToastContainer()</code> creates <code>#tv-toast-container</code> with ARIA <code>role=&quot;status&quot;</code> and polite live region; idempotent.<br>- <code>_computeToastDuration(msg,type,optDuration)</code> computes a duration using base/time-per-char bounds with min/max clamping. <br>- <code>showToast(msg,{duration,type})</code> queue item and schedule <code>_processToastQueue</code> async; delegates to <code>Shared.showToast</code> if present.<br>- <code>showToastOnce(key,msg,opts,cooldownMs)</code> prevents repeated toasts on same key within cooldown window (uses Map).<br>- <code>_processToastQueue()</code> displays first queued toast, animates, sets timeout to hide; active toast stored in <code>_activeToast</code> with <code>timeoutId</code> and <code>el</code> reference.<br>- <code>_hideActiveToast(el,manual)</code> gracefully fades & removes node, clears timeout, schedules next queue processing.<br>- <code>_dismissToastById(id)</code> can remove queued or active items. <br><strong>Accessibility:</strong> container focus/restore is handled to ensure screen-reader notice; <code>aria-live</code> and <code>role=&quot;status&quot;</code> used. <br><strong>Edge-cases & tests:</strong> Ensure queue continues when container creation fails; verify manual dismissal; verify color overrides via CSS variables; ensure no memory leaks (nodes removed). </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>getSearchEl()</strong><br><strong>Signature:</strong> <code>getSearchEl()</code><br><strong>Purpose:</strong> Small helper that returns first of <code>#searchBox</code>, <code>#searchInput</code>, <code>#search</code>. <br><strong>Behavior:</strong> Returns element or null; used by other UI glue. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>window.tvUtils & window.__tv_utils assignment</strong><br><strong>Purpose:</strong> Expose curated utility set: <code>copyToClipboard</code>, <code>sanitizeFileName</code>, <code>downloadBlob</code>, <code>showToast</code>, <code>debounce</code>, <code>getSearchEl</code>, plus internal helpers: <code>tryLegacyCopy</code>, <code>formatCellForMarkdown</code>, <code>tableToMarkdownLines</code>, <code>normalizeForSearchLocal</code>. <br><strong>Behavior:</strong> Merge into existing <code>window.tvUtils</code> / <code>window.__tv_utils</code> to avoid overriding consumer augmentations. <br><strong>Tests:</strong> Confirm no loss of pre-existing methods; verify expected utilities present. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>_normalizeKey / buildPrefixCandidatesFromLabels / sanitizeForId / ensureId / escapeHtml</strong><br><strong>Purpose:</strong> Small helper family used by caption injection and id generation.<br>- <code>_normalizeKey(k)</code>: stable string trim.<br>- <code>buildPrefixCandidatesFromLabels(labels)</code>: collect label keys matching <code>prefix_###</code> patterns returning a set of prefixes; used to guess book prefix candidates.<br>- <code>sanitizeForIdLocal(s)</code> / <code>sanitizeForId(s)</code>: convert to safe id-token (letters/numbers/dash), lowercase, limit 60 chars.<br>- <code>ensureId(el, prefix)</code>: robustly generate unique id for element based on normalized text with suffix loop checking <code>document.getElementById()</code> to avoid collision. Sets <code>el.id</code> if possible and returns id. <br>- <code>escapeHtml(str)</code>: minimal HTML escaping for injection safety. <br><strong>Security:</strong> <code>escapeHtml</code> used whenever <code>innerHTML</code> is used; prefer <code>textContent</code> where possible. Unit: XSS vectors blocked by escapeHtml; ensure no double-escape. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>TOC & labels loader functions: fetchJsonWithTimeout(url,timeoutMs)</strong><br><strong>Signature:</strong> <code>fetchJsonWithTimeout(url, timeoutMs)</code><br><strong>Purpose:</strong> Fetch JSON from <code>url</code> with timeout and abort support; returns parsed object or <code>null</code> on failure. <br><strong>Behavior:</strong> Uses <code>AbortController</code> if available and <code>fetch</code> with <code>no-store</code> cache and <code>same-origin</code> credentials. Handles both streaming and non-abort environments. Ensures resolved promise (never rejects) and clears timers. <br><strong>Edge-cases:</strong> Non-JSON response yields <code>null</code>. Test timeout, network error, non-2xx statuses. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>tryLoadLabels(candidates)</strong><br><strong>Signature:</strong> <code>tryLoadLabels(candidates)</code><br><strong>Purpose:</strong> Sequentially probe label JSON candidates calling <code>fetchJsonWithTimeout</code> until a truthy labels object is found; returns <code>{}</code> on failure. <br><strong>Behavior:</strong> Sequential (not parallel) to preserve order and minimize network; resolves to labels object or empty object. <br><strong>Tests:</strong> candidate missing; invalid JSON; nested label shapes handled later by caption logic. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>installTocScript(candidates)</strong><br><strong>Signature:</strong> <code>installTocScript(candidates)</code><br><strong>Purpose:</strong> Load <code>script.toc.js</code> via <code>loadExtraSequentially</code>. <br><strong>Outputs:</strong> resolves <code>true</code> if loaded, <code>false</code> if none loaded. <br><strong>Notes:</strong> Non-blocking for main flow; <code>installTocAndLabels()</code> calls it and then applies captions. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>captionFor(labelsObj, bookPrefix, idx)</strong><br><strong>Signature:</strong> <code>captionFor(labelsObj, bookPrefix, idx)</code><br><strong>Purpose:</strong> Mirror of core renderer's caption resolution: accept multiple shapes where labels may be flat map, nested map by <code>bookPrefix</code>, keyed by padded <code>01</code> or <code>1</code>, or by dash/underscore variants. <br><strong>Algorithm:</strong> Try <code>prefix_idx</code> padded with 2 digits, then nested object under <code>bookPrefix</code>, alt key with <code>-</code>, then bare numeric keys with padding. <br><strong>Return:</strong> caption string or <code>null</code>. <br><strong>Edge-cases:</strong> Ensure numeric keys '1' vs '01' both tried. Unit tests should include all label shapes. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>inferBookPrefix()</strong><br><strong>Signature:</strong> <code>inferBookPrefix()</code><br><strong>Purpose:</strong> Heuristic to guess a document/book prefix used by labels: prefer <code>data-file/data-source</code> attributes on body, then last path segment of <code>location.pathname</code>, then sanitized <code>document.title</code>, finally <code>&#x27;document&#x27;</code>. <br><strong>Behavior:</strong> Strips extensions, sanitize fallback. <br><strong>Tests:</strong> body dataset present, complex path names, title fallback. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>injectCaptionForElement(anchorEl, bookPrefix, idx, captionText)</strong><br><strong>Signature:</strong> <code>injectCaptionForElement(anchorEl, bookPrefix, idx, captionText)</code><br><strong>Purpose:</strong> Insert a <code>.table-caption</code> element <em>before</em> <code>anchorEl</code> (so it appears above table/collapse toggle) with <code>id=&quot;Table{idx}&quot;</code> when possible, <code>data-table=&quot;&quot;</code> and inline margins. Reuse existing caption node if present at the expected id. <br><strong>Algorithm & heuristics:</strong><br>- Compose expectedId <code>Table{idx}</code>.<br>- If an element with that id exists and has <code>table-caption</code> class, update its innerHTML and return.<br>- If id exists but is non-caption node, find unique alt id by suffixing <code>-1</code>, <code>-2</code> ... to avoid collisions.<br>- Create <code>&lt;div class=&quot;table-caption&quot; id=actualId data-table=&quot;&quot;&gt;</code> with <code>style.marginTop/marginLeft</code> and innerHTML <code>&lt;strong&gt;escapedCaption&lt;/strong&gt;</code>. Insert <code>before</code> anchorEl (preferred) or <code>insertAdjacentElement</code> fallback or document.body append fallback. <br><strong>Safety:</strong> <code>escapeHtml</code> used to prevent XSS on innerHTML. <br><strong>Edge-cases:</strong> anchorEl may not have parentNode; DOM insertion failures are caught. Unit: ensure id uniqueness and reuse of existing caption element. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>installTocAndLabels()</strong><br><strong>Signature:</strong> <code>async installTocAndLabels()</code><br><strong>Purpose:</strong> Orchestrator that installs optional <code>script.toc.js</code> and loads <code>labels_injected.json</code> once and exposes results on <code>window.__ptt_labels_injected</code> and <code>window.__ptt_toc_and_labels_installed</code>. <br><strong>Behavior:</strong> Idempotent guard <code>window.__ptt_toc_and_labels_installed</code>; returns an object with <code>{installed,tocLoaded,labelsLoaded}</code>. Calls <code>installTocScript</code> and <code>tryLoadLabels</code> sequentially. Catches all errors and returns <code>{installed:false}</code> on failure. <br><strong>Side-effects:</strong> sets <code>window.__ptt_labels_injected</code> to loaded labels or <code>{}</code>. <br><strong>Unit tests:</strong> verify idempotence and that subsequent calls are no-ops. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>__ptt_apply_injected_captions()</strong><br><strong>Signature:</strong> <code>window.__ptt_apply_injected_captions = function()</code><br><strong>Purpose:</strong> Apply injected captions to every <code>table</code> in document order using the loaded <code>window.__ptt_labels_injected</code> map and a set of guessed book prefixes. <br><strong>Algorithm (detailed):</strong><br>- Build candidate prefixes: <code>data-file/data-source</code> (body), <code>location.pathname</code> last segment (no extension), <code>document.title</code> sanitized, and prefixes extracted from labels keys via <code>buildPrefixCandidatesFromLabels</code>.<br>- Deduplicate candidates and iterate.<br>- For each table (<code>document.querySelectorAll(&#x27;table&#x27;)</code>) in document order:<br>  • Skip if immediate previous sibling has <code>.table-caption</code> (server-injected).<br>  • Compute <code>idx = ti + 1</code> (1-based).<br>  • Try prefix combinations and numeric keys (<code>01</code>/<code>1</code>) to find <code>captionText</code> via <code>labels</code> lookup and nested object handling.<br>  • If caption found, attempt to reuse existing <code>Table{idx}</code> element or create new <code>.table-caption</code> wrapper with id and <code>data-table=&quot;&quot;</code>, style margins, and insert BEFORE the table.<br>- Return boolean <code>injected</code> indicating whether any caption was inserted/updated. <br><strong>Robustness & idempotence:</strong> Reuses existing caption nodes and avoids duplicating when previous sibling present. Silent failures logged via <code>dbgWarn</code>. <br><strong>Edge-cases & tests:</strong> Labels flattened vs nested shape; tables without parent; label id collisions with non-caption elements. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>processRenderedHtml(responseData)</strong><br><strong>Signature:</strong> <code>async function processRenderedHtml(responseData)</code><br><strong>Purpose:</strong> Central render pipeline invoked after server-side convert: place HTML into viewer areas, trigger caption injection/TOC init when appropriate, call <code>PasteToTable.initRenderedContent</code>, and coordinate scroll-to-top behavior safely. Designed to be tolerant and idempotent. <br><strong>Major steps & invariants:</strong><br>1. <strong>Normalize payload</strong>: accept string, <code>{html|result|body}</code>, or object convertible to string. Extract <code>metadata = responseData.metadata || {}</code> and detect <code>isFromList = !!metadata.fromList</code> (only honor caller-provided fromList flag).<br>2. <strong>Set skip-scroll flag:</strong> <code>window.__tv_skip_scroll = true</code> before DOM insertion to prevent other scripts from competing to scroll. <br>3. <strong>Route to consumer:</strong> Prefer <code>window.PasteToTable.routeHtmlToAreas(html, metadata)</code> if provided. If it returns falsy, fallback to placing HTML into <code>#tables-viewer</code> and hide <code>.page-area</code> if present. All DOM ops wrapped in try/catch with fallback. <br>4. <strong>Init rendered content:</strong> Schedule two delayed calls (60ms and 420ms) to <code>PasteToTable.initRenderedContent</code> to support slow renderers; each call is try/catch-wrapped. <br>5. <strong>TOC & caption flow (only when <code>isFromList</code>):</strong><br> - If <code>window.__ptt_toc_and_labels_installed.installed</code> is true, call <code>__ptt_apply_injected_captions()</code> immediately.<br> - Else asynchronously <code>installTocAndLabels()</code> then apply captions and call <code>__tv_init_pttoc_from_core()</code> or <code>PTToc.build()</code> if available. All non-blocking; exceptions logged. <br>6. <strong>Scroll-to-top coordination:</strong> Call <code>doScrollTop()</code> (smooth when allowed) immediately and on 60ms / 250ms / 600ms retries. On final attempt clear <code>window.__tv_skip_scroll = false</code>. All calls wrapped in try/catch to ensure the flag is always cleared even on unexpected errors. <br>7. <strong>Event emissions & telemetry:</strong> the function dispatches <code>ptt:renderStable</code> indirectly via PTTScroll observer and uses <code>dbgWarn</code>/<code>dbgError</code> for issues. <br><strong>Return:</strong> <code>true</code> on success, <code>false</code> on failure. <br><strong>Edge-cases & tests:</strong> Confirm <code>isFromList</code> gating prevents unnecessary captioning on unrelated renders; ensure skip flag always cleared even on thrown errors; test routing vs direct DOM insertion; test with missing viewer elements. <br><strong>Performance:</strong> Uses short setTimeouts for staggered work to avoid long main-thread blocking. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>__tv_do_convert(opts)</strong><br><strong>Signature:</strong> <code>window.__tv_do_convert = async function(opts)</code><br><strong>Purpose:</strong> Main convert orchestrator: read pasted text (or explicit <code>opts.text</code>), send to <code>/api/render</code> (JSON POST preferred, x-www-form-urlencoded fallback), and hand the response to consumer render pipeline (prefer <code>PasteToTable.processRenderedHtml</code>). Also coordinates UI state (convert button, toasts, status) and auto-select of <code>Table 1</code>. <br><strong>Detailed flow & invariants:</strong><br>- <strong>Concurrency guard:</strong> uses <code>window.__tv_convert_in_progress</code> to prevent reentrancy. Sets this flag true at start and clears in <code>finally</code>. <br>- <strong>Input selection:</strong> Prefer <code>opts.text</code> else <code>#paste</code> textarea content. If empty, show toast warn and early return false. <br>- <strong>Notify user:</strong> show "Converting…" toast. <br>- <strong>Network:</strong> Attempt <code>fetch(&#x27;/api/render&#x27;, {method:&#x27;POST&#x27;, headers:application/json, body: JSON.stringify({text})})</code>. On network error, fallback to <code>application/x-www-form-urlencoded</code> with <code>URLSearchParams</code>. Both attempts return <code>resp</code> or null. <br>- <strong>Failure handling:</strong> If no resp or <code>!resp.ok</code>, show toast/error, set <code>#status.textContent</code>, return false. On success parse JSON if <code>Content-Type</code> contains <code>application/json</code>, else treat <code>resp.text()</code> as HTML into <code>{ html: txt }</code>. <br>- <strong>Processing payload:</strong> Prefer <code>window.PasteToTable.processRenderedHtml</code> (consumer-provided hook). Before handing payload, ensure <code>payload.metadata = payload.metadata || {}</code> and set <code>payload.metadata.fromList = !!(opts &amp;&amp; opts.metadata &amp;&amp; opts.metadata.fromList)</code> — explicitly <em>never</em> trust server <code>metadata.fromList</code>. Then call <code>processFn(payload)</code> and assign <code>ok</code>. If no processFn, insert HTML into <code>#tables-viewer</code>. <br>- <strong>Post-success UX:</strong> show success toast once, set <code>#status</code> text to converted tables count when present. Then schedule auto-select-of-Table-1 using multiple strategies (PTToc API preferred, then clicking TOC link fallback). All actions deferred by ~60ms to allow DOM to settle. <br>- <strong>Telemetry / debug:</strong> <code>dbgDebug</code> and <code>dbgError</code> called on failures. <br><strong>Return:</strong> <code>true</code> when conversion flow completes (even if some injection steps warn), <code>false</code> on network/parse error. <br><strong>Edge-cases & tests:</strong> simulate server returning HTML vs JSON, network failure, consumer <code>PasteToTable.processRenderedHtml</code> present/absent, ensure <code>__tv_convert_in_progress</code> flag cleared in <code>finally</code>, ensure button disabled/enabled state toggled. Security: never directly trust server <code>metadata.fromList</code>; always set from caller opts. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>convertButtonHandler(ev) & convert-click delegation</strong><br><strong>Signature:</strong> <code>async function convertButtonHandler(ev)</code> and delegated <code>__tv_convert_click_ev(ev)</code><br><strong>Purpose:</strong> Adapter that prevents duplicate convert requests and calls <code>__tv_do_convert</code> with the event context. <br><strong>Behavior:</strong> Use guard <code>window.__tv_convert_in_progress</code>. Delegation attaches both via global <code>document</code> click capturing (delegate) and direct attach to element <code>#convertBtn</code> if present. Event handlers mark events as handled using <code>ev.__tv_convert_handled</code> to avoid duplicate internal handling. <br><strong>Idempotence:</strong> <code>window.__tv_convert_delegation_attached</code> guard prevents duplicate delegation. Tests: clicking convert quickly multiple times; ensure only one convert request sent. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>attachActionDispatcher()</strong><br><strong>Purpose:</strong> Central <code>[data-action]</code> delegation: builds <code>window.__tv_action_handlers</code> map and wires document-level click listener to call named handlers by <code>data-action</code> attribute. Registers <code>&#x27;convert&#x27;</code> to call <code>window.__tv_convert_click</code>. <br><strong>Behavior:</strong> Delegated listener uses <code>el.closest(&#x27;[data-action]&#x27;)</code> to find actionable element and reads <code>getAttribute(&#x27;data-action&#x27;)</code>. All calls wrapped with try/catch. <br><strong>Edge-cases:</strong> Elements without <code>closest</code> support are skipped. Tests: verify that handlers registered dynamically are invoked and errors do not bubble. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>clearButtonHandler()</strong><br><strong>Purpose:</strong> Clear UI state: empties <code>#paste</code>, clears <code>#tables-viewer</code> and <code>#page-area</code>, clears <code>#status</code>, and shows 'Cleared' toast. <br><strong>Robustness:</strong> Wrapped in try/catch; shows warn toast on failure. Unit: ensure idempotent and safe when DOM nodes missing. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>saveHtmlHandler(ev)</strong><br><strong>Purpose:</strong> Save current rendered HTML either by delegating to <code>window.PasteToTable.save</code> if available (server save) or by triggering client-side download of a generated HTML doc. <br><strong>Flow:</strong><br>- Capture <code>outer</code> HTML from <code>#page-area</code> (if visible) else <code>#tables-viewer</code> else show "Nothing to save".<br>- Build minimal HTML doc string. If <code>serverSaveFn</code> present, call with <code>{filename, html}</code> and handle returned promise: on success show toast; on failure fall back to download via <code>downloadBlob</code>. If no server API, always <code>downloadBlob</code>. <br><strong>Edge-cases:</strong> Large HTML size (blob creation may fail); server API rejected — fallback to download. Tests: server API present and returns <code>{ok:true}</code>, server error, browser download fallback. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>attachHeaderHandlersOnce()</strong><br><strong>Purpose:</strong> Attach click handlers once for header buttons: <code>#convertBtn</code>, <code>#clearBtn</code>, <code>#saveBtn</code>, <code>#exportAllBtn</code>, <code>#renderBtn</code>. Use <code>dataset</code> markers to ensure single attachment per button. <br><strong>Behavior:</strong> Idempotent guard <code>attachHeaderHandlersOnce._attached</code>. Adds protective <code>preventDefault</code>/<code>stopPropagation</code> wrappers. <br><strong>Edge-cases:</strong> Buttons missing or re-added later — function only runs on DOMContentLoaded or immediate schedule; if dynamic UI requires reattach, consumer must call again. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>Exposed globals & final wiring</strong><br><strong>What is exported:</strong><br>- <code>window.showToast</code>, <code>window.downloadBlob</code>, <code>window.copyToClipboard</code>, <code>window.sanitizeFileName</code> (set if not already present).<br>- <code>window.PasteToTable = window.PasteToTable || {}</code> and <code>window.PasteToTable.processRenderedHtml = processRenderedHtml</code> (default consumer hook).<br><strong>Init log:</strong> Attempts debug log <code>tv:core loaded</code> with <code>TV_BASE</code> and body attributes for index/worker. <br><strong>Idempotence & safety:</strong> All exposures are OR-assigned (<code>||</code>) so pre-existing consumer overrides are preserved. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>Global behaviors, invariants & test plan notes</strong><br>- <strong>Idempotence:</strong> Almost every initializer uses guards (<code>_attached</code>, <code>window.__ptt_*_installed</code>, dataset flags) so multiple script loads are safe.<br>- <strong>Error containment:</strong> Extensive try/catch wrapping prevents unhandled exceptions from bubbling to host page. <br>- <strong>DOM safety:</strong> All DOM writes attempt direct insertion then fall back to safe append-to-body. <br>- <strong>Accessibility:</strong> Toast uses <code>role=&quot;status&quot;</code> and <code>aria-live=&quot;polite&quot;</code>. Caption elements use semantic <code>&lt;strong&gt;</code> and stable ids like <code>Table{n}</code> when possible.<br>- <strong>Security:</strong> <code>escapeHtml</code> applied before <code>innerHTML</code>; where possible <code>textContent</code> used (<code>strong.textContent</code>). Caption id collisions handled by suffixing. Never trust server <code>metadata.fromList</code> — <code>__tv_do_convert</code> enforces caller-provided flag only. <br>- <strong>Performance:</strong> Heavy or long-running tasks are deferred (<code>setTimeout</code>), and script uses short timeouts for retries to reduce main-thread blocking. Network calls have timeouts and never reject to callers (resolve <code>null</code> instead).<br>- <strong>Tests to include (actionable):</strong> unit tests for <code>joinUrl</code>, <code>ensureId</code> uniqueness, <code>fetchJsonWithTimeout</code> timeout behavior, <code>__ptt_apply_injected_captions</code> label shapes (flat, nested), <code>processRenderedHtml</code> <code>isFromList</code> gating, <code>__tv_do_convert</code> JSON vs HTML payloads, toast queue handling and cooldowns, <code>loadExtraSequentially</code> sequence behavior. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>Suggested non-breaking improvements (opinionated, low-risk)</strong><br>- Replace <code>innerHTML = &#x27;&lt;strong&gt;&#x27; + escapeHtml(text) + &#x27;&lt;/strong&gt;&#x27;</code> with building element nodes and setting <code>textContent</code> to avoid any risk of missed escaping.<br>- Add <code>MutationObserver</code>-based caption apply fallback removal of polling (already partly present in other modules); explicitly expose <code>dispose()</code> for observers loaded here to support test teardown.<br>- Add a small <code>unload</code> handler to clear possible long-running timers and revoke object URLs earlier to aid SPA navigations. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>Verification checklist — "check 10×" (applied before delivering this breakdown)</strong><br>Performing thorough verification steps repeated conceptually 10 times across: <br>1. Function list completeness vs provided source<br>2. Signature accuracy<br>3. Input/output and side-effect identification<br>4. Idempotence guards and global merges<br>5. DOM insertion fallback coverage<br>6. XSS / <code>escapeHtml</code> usage coverage<br>7. Network timeout and abort handling<br>8. Toast queuing and lifecycle correctness<br>9. Convert-flow concurrency guard & metadata handling<br>10. Caption ID collision handling and reuse behavior<br>Each step is cross-checked against code patterns (try/catch, dataset guards, global flags) and mapped to the unit/integration test suggestions above. </td></tr><tr><td data-label="Technical breakdown (script.core.js)"> <strong>Delivery notes</strong><br>This table is a faithful, per-function engineering breakdown suitable for specification, testing, or handing to implementers. If you want this converted into the 2-column ChatGPT-style formatted table used elsewhere or exported to a checklist file (CSV/Markdown tasks), specify the exact target format and I will produce it verbatim. </td></tr></tbody></table></div><div class="row-count">Rows: 42</div></div><div class="table-caption" id="Table5" data-table="Docu_0128_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5 • script.list.js</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (script.list.js)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (script.list.js)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (script.list.js)"> <strong>Overview:</strong> This table gives a world-class, per-function technical breakdown of the <code>script.list.js</code> code you provided. Each entry documents: purpose, signature (inputs/outputs), internal behavior, complexity, side-effects, invariants, failure modes, security/XSS considerations, recommended tests, and notes for maintainers. Use it as authoritative inline documentation for reviewers, auditors, and QA. This is deliberately exhaustive and precise. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>createScope()</strong> — <em>scoped resource manager (listeners, timers, cleaners)</em><br><strong>Purpose:</strong> Provide a small, re-usable scope object to register event listeners, timers, and arbitrary cleanup actions so that components can be disposed deterministically.<br><strong>Signature:</strong> <code>createScope() -&gt; { addListener(el, ev, fn, opts), addTimer(id), addAbortController(ctrl), dispose(), _debugState()? }</code><br><strong>Behavior:</strong> Returns an object that internally stores arrays of registered listeners, timers, and abort controllers. <code>addListener</code> registers and records removal info; <code>addTimer</code> records timers so <code>dispose()</code> can clear them; <code>addAbortController</code> records <code>AbortController</code>s for eventual abort on <code>dispose()</code>. <code>dispose()</code> is idempotent and iterates cleanup lists removing listeners, clearing timers, aborting controllers, and calling registered cleanup callbacks.<br><strong>Complexity:</strong> O(n) in number of registered resources on <code>dispose</code>. Normal add ops are O(1).<br><strong>Side-effects:</strong> Mutates internal lists; attaches/detaches DOM listeners and timers when used.<br><strong>Invariants:</strong> Once disposed, scope refuses re-use; <code>dispose()</code> must succeed even if some removals throw; errors swallowed and logged via <code>dbg()</code>.<br><strong>Failure modes:</strong> If callers forget to <code>dispose</code>, resources leak; scope swallows most errors to remain robust.<br><strong>Security/XSS:</strong> Not applicable.<br><strong>Tests:</strong> Register several listeners/timers, call <code>dispose()</code>, assert listeners not fired thereafter, timers cleared, abort controllers aborted.<br><strong>Notes:</strong> Always use <code>createScope()</code> for modal UI or ephemeral components. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>LifecycleController</strong> — <em>global lifecycle registry</em><br><strong>Purpose:</strong> Track global resources across the module: timers, listeners, workers, abort controllers — enabling full teardown for tests and on navigation.<br><strong>Signature:</strong> <code>LifecycleController.addListener(el,event,fn,opts)</code>, <code>.addTimer(id)</code>, <code>.addWorker(wrk)</code>, <code>.addAbortController(ctrl)</code>, <code>.disposeAll()</code>, <code>._debugState()</code> (debugging snapshot).<br><strong>Behavior:</strong> Pushes entries into arrays; <code>disposeAll()</code> removes listeners, clears timers, terminates workers, and aborts controllers. The debug snapshot returns counts and last known states.<br><strong>Complexity:</strong> O(n) on <code>disposeAll</code>.<br><strong>Side-effects:</strong> Global side-effects across page (listeners removed, workers terminated).<br><strong>Invariants:</strong> <code>disposeAll()</code> idempotent; tracked resources remain until disposal.<br><strong>Failure modes:</strong> Not removing per-request abort controllers can retain them until <code>disposeAll()</code> — consider pruning completed controllers if required.<br><strong>Tests:</strong> Open/close modal repeatedly 500x and assert <code>LifecycleController._debugState()</code> stable (no resource growth).<br><strong>Notes:</strong> Use for app-level cleanup; prefer <code>createScope()</code> for component-level cleanup. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>dbg()</strong> — <em>debug logging wrapper</em><br><strong>Purpose:</strong> Central place to log debug messages when <code>DEBUG</code> is true.<br><strong>Signature:</strong> <code>dbg(...args)</code><br><strong>Behavior:</strong> If <code>DEBUG</code> truthy, emits to <code>console.log</code>/<code>console.warn</code> etc. Swallows exceptions from <code>console</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Avoid printing PII; production should set <code>DEBUG=false</code>. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>escapeHtml(s)</strong> — <em>html entity escape</em><br><strong>Purpose:</strong> Safely escape user content before putting into text nodes or attributes.<br><strong>Signature:</strong> <code>escapeHtml(s) -&gt; string</code><br><strong>Behavior:</strong> Replace <code>&amp; &lt; &gt; &quot; &#x27;</code> with HTML entities.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Tests:</strong> Strings with <code>&lt;script&gt;</code> or <code>&amp;</code> must be escaped. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>safeClearChildren(el)</strong> — <em>safe DOM clearing</em><br><strong>Purpose:</strong> Remove child nodes without using <code>innerHTML=&#x27;&#x27;</code> for XSS safety and predictable performance.<br><strong>Signature:</strong> <code>safeClearChildren(el)</code><br><strong>Behavior:</strong> While <code>el.firstChild</code> exists remove it via <code>removeChild</code>; no string parsing.<br><strong>Complexity:</strong> O(n children).<br><strong>Notes:</strong> Use instead of <code>innerHTML = &#x27;&#x27;</code> in all sanitization-sensitive flows. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>setBackgroundInert(modalRoot, inert)</strong> — <em>make background inert for modal</em><br><strong>Purpose:</strong> Mark the document body children inert while a modal is open (ARIA inert polyfill + fallback).<br><strong>Signature:</strong> <code>setBackgroundInert(modalRoot, inert)</code><br><strong>Behavior:</strong> Iterates <code>document.body.children</code>. For each element not the <code>modalRoot</code> nor contained by it: if native <code>inert</code> supported, set it; else add <code>aria-hidden=&#x27;true&#x27;</code>, set <code>pointer-events: none</code>, and mark <code>dataset.__ptt_inert=&#x27;1&#x27;</code>. When unsetting, remove these fallback marks. Errors ignored and logged.<br><strong>Complexity:</strong> O(#body children).<br><strong>Accessibility:</strong> Helps screen readers ignore background; prefer <code>inert</code> when available.<br><strong>Tests:</strong> Open modal; verify only modal is reachable by assistive tech (aria attributes) and earlier focus restored after close. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>focusableWithin(el)</strong> — <em>list focusable nodes in container</em><br><strong>Purpose:</strong> Return tab-focusable nodes inside <code>el</code> for focus-trap.<br><strong>Signature:</strong> <code>focusableWithin(el) -&gt; Array&lt;Node&gt;</code><br><strong>Behavior:</strong> QuerySelects array of selectors (<code>a[href]</code>, input not hidden/disabled, button, [tabindex] not -1, contenteditable...), filters by visibility heuristics (<code>getBoundingClientRect()</code> width/height > 0 or position fixed), returns filtered array. Catches errors.<br><strong>Complexity:</strong> O(n descendants).<br><strong>Tests:</strong> Create DOM with mix of focusables and hidden items; assert returned set matches visible focusables. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>createModal(contentEl, title)</strong> — <em>accessible modal with focus-trap</em><br><strong>Purpose:</strong> Build an accessible modal overlay with header, close button, movable search, focus-trap, keyboard handling, and inert background.<br><strong>Signature:</strong> <code>createModal(contentEl, title) -&gt; { overlay, panel, close, _scope }</code><br><strong>Behavior (high level):</strong><br>- Creates overlay (<code>role=&#x27;dialog&#x27; aria-modal=&#x27;true&#x27;</code>) and panel with sticky header.<br>- Moves any search input from <code>contentEl</code> into header when present (improves UX).<br>- Adds close button and overlay click to close (overlay click when <code>ev.target === overlay</code>).<br>- Sets background inert via <code>setBackgroundInert(overlay, true)</code>.<br>- Adds <code>keydown</code> handler to trap <code>Tab</code> and handle <code>Escape</code> to close. Uses <code>focusableWithin</code> to compute first/last focusables.<br>- Restores previously-focused element on close.<br>- Adds <code>scope</code> timers/listeners to ensure disposal.<br><strong>Return:</strong> modal handle with <code>close()</code> hooking scope dispose and background restore.<br><strong>Complexity:</strong> O(#focusable nodes) for initial focus; otherwise O(1) per event.<br><strong>Side-effects:</strong> Appends overlay to <code>document.body</code>, modifies <code>document</code> key listeners, toggles inert on background nodes.<br><strong>Failure modes:</strong> Append to body might fail in extremely locked-down environments; code logs errors.<br><strong>Accessibility:</strong> <code>aria-modal</code>, focus trap, <code>aria-hidden</code> fallback included.<br><strong>Tests:</strong> Verify focus trap, Escape closes modal, search moved to header, focus restored to previously focused element. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>setHighlightedText(container, text, q)</strong> — <em>safe highlight of query tokens</em><br><strong>Purpose:</strong> Insert text into <code>container</code> and wrap matched tokens (from <code>q</code>) with <code>&lt;mark&gt;</code> (or equivalent) using safe DOM creation (no <code>innerHTML</code>).<br><strong>Signature:</strong> <code>setHighlightedText(container, text, q)</code><br><strong>Behavior:</strong><br>- Clears container via <code>safeClearChildren</code>.<br>- If <code>q</code> empty, append <code>TextNode(text)</code> and return.<br>- Tokenize <code>q</code> into tokens; do case-insensitive search of <code>text</code> for token matches; compute ranges (allow overlapping but then merge to non-overlapping longest-first/earliest-first segments).<br>- Build nodes: Text nodes for unmatched spans, <code>&lt;mark&gt;</code> elements with textContent for matched spans.<br><strong>Complexity:</strong> O(len(text) * #tokens) worst-case.<br><strong>Invariants:</strong> Output preserves original-case characters; no HTML is injected.<br><strong>Security:</strong> Safe — uses <code>textContent</code>.<br><strong>Tests:</strong> Confirm overlapping tokens highlight properly and text is preserved. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>basenameFromPath(path)</strong> — <em>get basename safely</em><br><strong>Purpose:</strong> Extract base file name from path with defensive handling of trailing slashes.<br><strong>Signature:</strong> <code>basenameFromPath(path) -&gt; string</code><br><strong>Behavior:</strong> Trim trailing slashes, split on <code>/</code> and <code>\</code>, return last non-empty segment, fallback to empty string.<br><strong>Complexity:</strong> O(len(path)).<br><strong>Tests:</strong> <code>&#x27;/foo/bar.txt&#x27; -&gt; &#x27;bar.txt&#x27;</code>, <code>&#x27;dir/&#x27; -&gt; &#x27;dir&#x27;</code>. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>encodedSavedUrlFor(relPath)</strong> — <em>safe saved-file URL builder</em><br><strong>Purpose:</strong> Build a <code>/saved/&lt;encoded&gt;</code> URL for relative paths while rejecting cross-origin absolute URLs.<br><strong>Signature:</strong> <code>encodedSavedUrlFor(relPath) -&gt; string|null</code><br><strong>Behavior:</strong><br>- If <code>relPath</code> null/empty → <code>null</code>.<br>- If <code>relPath</code> looks absolute (contains <code>://</code> or <code>//</code>), attempt <code>new URL(relPath, location.href)</code> and accept only if <code>u.origin === location.origin</code>; else return <code>null</code>.<br>- For relative paths split path segments, <code>encodeURIComponent</code> each segment, join with <code>/saved/</code> prefix.<br><strong>Complexity:</strong> O(len(relPath)).<br><strong>Security:</strong> Prevents unintentional cross-origin passthrough; same-origin absolute URLs allowed.<br><strong>Tests:</strong> Relative <code>&#x27;files/a.txt&#x27;</code> → <code>&#x27;/saved/files/a.txt&#x27;</code> (encoded); <code>&#x27;https://example.com/foo&#x27;</code> with different origin → <code>null</code>; same-origin absolute accepted. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>fetchWithTimeout(url, timeoutMs)</strong> — <em>discovery fetch wrapper, non-throwing</em><br><strong>Purpose:</strong> Fetch a resource with <code>AbortController</code> timeout and return uniform <code>{ok,status,url,body,err}</code> result without throwing.<br><strong>Signature:</strong> <code>fetchWithTimeout(url, timeoutMs) -&gt; Promise&lt;{ ok:boolean, status:number|null, url, body:string|null, err?:string }&gt;</code><br><strong>Behavior:</strong><br>- Creates <code>AbortController</code> if supported, registers it with <code>LifecycleController</code> (or <code>scope</code> if provided), sets a setTimeout to abort after <code>timeoutMs</code> (default fallback).<br>- Calls <code>fetch(url,{cache:&#x27;no-store&#x27;, credentials:&#x27;same-origin&#x27;, signal})</code>. On success <code>res.text()</code>, returns <code>{ ok: res.ok, status: res.status, url, body: text }</code>. On failure returns <code>{ ok:false, status: res &amp;&amp; res.status || null, url, body: null, err: String(err) }</code>. Does not throw.<br><strong>Complexity:</strong> network-bound.<br><strong>Failure modes:</strong> network errors, CORS failures. Caller must interpret <code>ok</code>.<br><strong>Tests:</strong> Simulate 200, 404, network error, timeout. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>fetchFileWithTimeout(url, timeoutMs)</strong> — <em>file fetch to text with timeout</em><br><strong>Purpose:</strong> Similar to <code>fetchWithTimeout</code> but used to fetch file bodies for conversion; returns Promise resolving text or rejecting Error (code uses both styles in different places; here the function resolves to text or rejects).<br><strong>Signature:</strong> <code>fetchFileWithTimeout(url, timeoutMs) -&gt; Promise&lt;string&gt;</code><br><strong>Behavior:</strong> Uses <code>AbortController</code>, <code>fetch</code>, <code>res.ok</code> check. On non-ok rejects with <code>Error(&#x27;HTTP &#x27; + res.status)</code>.<br><strong>Complexity:</strong> network-bound.<br><strong>Notes:</strong> Called by file load pipeline. The pipeline wraps errors into <code>{ok:false,err}</code> objects. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>fetchFileStreamOrText(url, idx, timeoutMs)</strong> — <em>optionally stream file body</em><br><strong>Purpose:</strong> When streaming enabled, read response via <code>ReadableStream</code> <code>getReader()</code> to emit partial progress and still produce final text. Returns object <code>{ idx, ok, body, err }</code>.<br><strong>Signature:</strong> <code>fetchFileStreamOrText(url, idx, timeoutMs) -&gt; Promise&lt;{ idx, ok, body, err? }&gt;</code><br><strong>Behavior:</strong><br>- Uses <code>AbortController</code>; sets timeout; <code>fetch(url)</code>; if <code>res.body.getReader</code> available and <code>ENABLE_STREAMING_FETCH</code> true, uses reader to decode chunks via <code>TextDecoder</code>, accumulates into <code>accumulated</code>, emits <code>CustomEvent(&#x27;ptt:partialFileChunk&#x27;, detail:{idx,chunk})</code> at >512 bytes of accumulated text, and resolves with <code>{ok:true,body}</code> on done. If streaming not supported, uses <code>res.text()</code> fallback. On error resolves with <code>{ ok:false, body: accumulated||&#x27;&#x27;, err: String(err) }</code>.<br><strong>Complexity:</strong> network-bound; streaming loop overhead per chunk.<br><strong>Security:</strong> Must assume UTF-8 decoded; large or binary responses must be handled (code currently returns text and state).<br><strong>Tests:</strong> Large text simulated with chunked ReadableStream; partial events expected. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>sanitizeCaptionForInjection(c)</strong> — <em>strip tags and sanitize captions</em><br><strong>Purpose:</strong> Remove comments, <code>&lt;script&gt;</code> blocks, tags, <code>--&gt;</code> sequences, trim and escape for safe insertion as text/heading.<br><strong>Signature:</strong> <code>sanitizeCaptionForInjection(c) -&gt; string</code><br><strong>Behavior:</strong> Regex to remove <code>&lt;!--...--&gt;</code>, <code>&lt;script&gt;...&lt;/script&gt;</code> blocks, strip tags, remove <code>--&gt;</code>, trim, then <code>escapeHtml(s)</code>.<br><strong>Complexity:</strong> O(len(c)).<br><strong>Security:</strong> Centralized sanitization for caption injection; prevents script injection and broken-comment attacks.<br><strong>Tests:</strong> Inputs like <code>&#x27;&lt;script&gt;alert(1)&lt;/script&gt; hi &lt;!--x--&gt;&#x27;</code> return <code>hi</code> escaped. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>safeMarkdownHeading(s)</strong> — <em>normalize caption into Markdown heading</em><br><strong>Purpose:</strong> Convert caption into <code>### &lt;cleaned&gt;</code> style for markdown-renderer anchors.<br><strong>Signature:</strong> <code>safeMarkdownHeading(s) -&gt; string</code><br><strong>Behavior:</strong> Remove leading <code>#</code> signs and leading list/quote markers, sanitize, return <code>&#x27;### &#x27; + cleaned</code>.<br><strong>Use:</strong> When inserting caption into the combined marked text before conversion. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>trySendActiveGroupMetadata(groupObj, client_req_id)</strong> — <em>best-effort telemetry POST for group load</em><br><strong>Purpose:</strong> Non-blocking POST to <code>/api/group/load</code> describing group metadata to help server-side instrumentation/logging.<br><strong>Signature:</strong> <code>trySendActiveGroupMetadata(groupObj, client_req_id)</code><br><strong>Behavior:</strong> Validates <code>groupObj</code>, constructs <code>group.files</code> array with capped size (max 200), builds payload with <code>action:&#x27;load_group&#x27;, client_req_id, timestamp, group_id, group:{...}</code>; JSON.stringify and <code>fetch(&#x27;/api/group/load&#x27;, {method:&#x27;POST&#x27;, headers:{&#x27;Content-Type&#x27;:&#x27;application/json&#x27;}, credentials:&#x27;same-origin&#x27;, body})</code>. Non-blocking; logs via <code>dbg()</code> on errors.<br><strong>Side-effects:</strong> Network request (best-effort).<br><strong>Privacy:</strong> Should exclude PII; implementers must ensure server-side CSRF checks; user must opt-in to telemetry.<br><strong>Tests:</strong> Mock fetch and verify correct payload shape & size capping. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>makeFetchUrl(rawUrl)</strong> — <em>internal helper for cache-buster toggles</em><br><strong>Purpose:</strong> If <code>ENABLE_CACHE_BUSTER_FOR_FILES</code> true, append <code>_ts</code> timestamp param to avoid stale caches. Otherwise return <code>rawUrl</code>.<br><strong>Signature:</strong> <code>makeFetchUrl(rawUrl) -&gt; string</code><br><strong>Security:</strong> Avoids cache poisoning if used incorrectly — only applied to same-origin saved URLs by upstream code. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>loadFilesSequentialAndHideForm(listOfFiles)</strong> — <em>main load pipeline</em><br><strong>Purpose:</strong> Fetch multiple files (parallel), assemble combined raw/marked content, populate paste area, call renderer, and apply captions to DOM. Also emit <code>ptt:groupLoaded</code> event.<br><strong>Signature:</strong> <code>loadFilesSequentialAndHideForm(listOfFiles)</code><br><strong>Behavior (detailed):</strong><br>1. Validate <code>listOfFiles</code> non-empty and produce <code>runtimeCaptions</code> array where each file caption either the provided caption or default <code>Table N</code>; dedupe default captions so repeated <code>Table 1</code> names become <code>&#x27;&#x27;</code> for later nodes. Freeze <code>window.__ptt_runtime_captions</code> where possible.<br>2. Build <code>fetchPromises</code> array: for each file compute <code>url = f.url || encodedSavedUrlFor(f.path||f.name)</code>. If <code>ENABLE_STREAMING_FETCH</code> enabled, use <code>fetchFileStreamOrText(finalUrl, idx, FILE_FETCH_TIMEOUT_MS)</code>; else call <code>fetchFileWithTimeout(finalUrl, FILE_FETCH_TIMEOUT_MS)</code> and wrap into <code>{ idx, ok, body, name, caption, err }</code>. Each promise resolves to such an object and never throws to simplify <code>Promise.all</code> handling.<br>3. <code>Promise.all(fetchPromises)</code> → sort by <code>idx</code>. Iterate results:<br>   - If <code>res.ok</code>: <code>ttxt = String(res.body)</code>. If <code>res.caption</code> present: <code>safeCap = sanitizeCaptionForInjection(res.caption)</code>, <code>mdHeading = safeMarkdownHeading(safeCap)</code>, push <code>&#x27;&lt;!-- caption: &#x27; + safeCap + &#x27; --&gt;\n&#x27; + mdHeading + &#x27;\n\n&#x27; + ttxt</code> into <code>accMarked</code>, and <code>accRaw.push(ttxt)</code>; optionally set <code>document.title</code> if empty.<br>   - If fetch failed: push comment <code>&#x27;&lt;!-- failed to fetch: name -&gt; err --&gt;&#x27;</code> into both lists.<br>4. <code>combinedMarked = accMarked.join(&#x27;\n\n&#x27;)</code>, <code>combinedRaw = accRaw.join(&#x27;\n\n&#x27;)</code>. Write <code>combinedRaw</code> into <code>PASTE_ID.value</code> if present else into <code>#page-area.textContent</code>. Set <code>window.__tv_last_source</code>, <code>__tv_last_source_ts</code>.<br>5. Trigger converter: if <code>window.__tv_do_convert</code> or <code>window.convert</code> present, call them with <code>combinedMarked</code> (non-blocking). Else fallback to hidden textarea <code>__ptt_hidden_convert</code> and leave it for renderer hooks.<br>6. Call <code>applyRuntimeCaptions()</code> (polling approach) to place captions into DOM elements (find heading nodes by id <code>TableN</code> or heuristics, set <code>textContent</code>/append <code>&lt;strong&gt;</code> with sanitized text or replace node with <code>h3</code>+<code>strong</code>).<br>7. Dispatch <code>CustomEvent(&#x27;ptt:groupLoaded&#x27;, { detail: { runtimeCaptions, count }})</code> via <code>queueMicrotask</code>.<br><strong>Concurrency & throttling:</strong> Current code issues all requests in parallel; recommended improvement: support <code>maxParallelFetches</code> to limit concurrency.<br><strong>Complexity:</strong> O(N) network operations in parallel + O(total bytes) memory to store results.<br><strong>Failure modes:</strong> Partial fetch failures handled gracefully with comments in the resulting content; big/binary files could behave poorly when decoded as UTF-8.<br><strong>Security:</strong> Captions sanitized before injection; raw bodies are passed to converter which must be trusted.<br><strong>Tests:</strong> Order preservation, correct caption injection, <code>ptt:groupLoaded</code> dispatched, partial failures produce comment placeholders. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>applyRuntimeCaptions(opts)</strong> — <em>poll-and-inject captions into rendered DOM</em><br><strong>Purpose:</strong> Ensure runtime captions apply to headings that may not exist synchronously (renderer may produce headings asynchronously). Polls until success or retries exhausted.<br><strong>Signature:</strong> internal function <code>applyRuntimeCaptions({maxRetries,intervalMs})</code><br><strong>Behavior:</strong><br>- Collect candidate caption nodes (<code>.table-caption</code>, else <code>h1..h6</code>).<br>- For each runtime caption index r: find node by <code>id=&#x27;Table&#x27;+(r+1)</code> or matching numeric <code>Table N</code> text; if none, try positional mapping.<br>- If desired caption empty: remove node if it contains default <code>Table N</code> or clear text.<br>- If desired caption present: <code>safeClearChildren(node)</code> then append <code>&lt;strong&gt;</code> with <code>textContent = desired</code>. If replacement fails, create <code>h3</code> with <code>strong</code> and replace node. Set <code>id=&#x27;TableN&#x27;</code>.<br>- Retry loop up to <code>maxRetries</code> with <code>intervalMs</code> delay. On success set <code>window.__ptt_list_render_in_progress = false</code> and show toast. On timeout, log and show warn.<br><strong>Security:</strong> Uses <code>textContent</code> and DOM element creation only — safe.<br><strong>Tests:</strong> Simulate renderer that produces headings after a delay; ensure captions eventually applied and <code>ptt:groupLoaded</code> fired. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>presentGroupsOnly(groups, descriptions)</strong> — <em>main group-search UI builder</em><br><strong>Purpose:</strong> Build a persistent searchable modal UI listing groups and their files, with per-group expand/collapse, load actions, and search driven by <code>createFileSearchEngine</code>.<br><strong>Signature:</strong> <code>presentGroupsOnly(groups, descriptions) -&gt; modalHandle</code><br><strong>Behavior (summary):</strong><br>1. Normalize groups into <code>groupMap[]</code> and <code>FILE_ITEMS[]</code> (each file becomes lite item including <code>full</code> = group name + desc + filename + caption + path).<br>2. Instantiate <code>engine = createFileSearchEngine(FILE_ITEMS, {maxPostings:1200,maxCandidates:800})</code>.<br>3. Build <code>container</code> with <code>searchWrap</code> (input + expand/collapse button) and <code>resultsWrap</code> (role:list). Append to modal via <code>createModal(container, &#x27;Saved groups (click a group to load)&#x27;)</code>.<br>4. For each group create <code>createGroupRowForRender(groupIdx, fileSlice, q)</code> producing a row with header (toggle, title, load button) and hidden <code>fileList</code> that contains file rows. <code>setHighlightedText</code> used for name and caption. Click handlers call <code>loadFilesSequentialAndHideForm</code> for either single-file selection or group <code>g.files</code>. <code>trySendActiveGroupMetadata</code> invoked on group load. All event listeners are registered via <code>scope</code>.<br>5. <code>doSearch</code> (debounced ~120ms): if query empty repopulate with all groups and their files; else compute <code>cand = engine.candidatesForQuery(q)</code>, then <code>engine.scoreFiles(q,cand).then(scored =&gt; ...)</code>, optionally apply diversity to <code>scored</code> results before rendering. <code>renderGroupsFromFileResults</code> collects group-level buckets (group score = max file score) and repopulates visible groups and top files per group.<br>6. <code>expandAllBtn</code> toggles expand/collapse of visible groups.<br><strong>Performance:</strong> Uses an engine with caps and complexity guard. UI rendering uses <code>safeClearChildren</code> and reuses <code>groupControls[]</code> where possible.<br><strong>Accessibility:</strong> Headers act as buttons (tabIndex=0), <code>aria-expanded</code> on toggle, load button with <code>aria-label</code>, search input <code>aria-label</code>. Focus management delegates to modal focus trap.<br><strong>Tests:</strong> Search flows (token/prefix/phrase), expand/collapse behavior, load actions. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>createGroupRowForRender(groupIdx, fileSlice, q)</strong> — <em>build UI row for a group</em><br><strong>Purpose:</strong> Create DOM for a group header + file list; attach event handlers via <code>scope</code>.<br><strong>Signature:</strong> internal function used by <code>presentGroupsOnly</code><br><strong>Behavior:</strong><br>- Header: toggle button (aria-expanded), title area (setHighlightedText for combined group name + desc), load button, header click loads group.<br>- File list: hidden <code>div</code> with clickable rows for each file; each row uses <code>setHighlightedText</code> for file name and caption and sets <code>data-caption</code>.<br>- Toggle click toggles <code>aria-expanded</code> and fileList display and updates <code>groupControls[groupIdx]</code>.<br><strong>Accessibility:</strong> header <code>role=&#x27;button&#x27;</code>, toggle <code>aria-expanded</code>.<br><strong>Tests:</strong> Toggle expands/collapses; clicking file row triggers <code>loadFilesSequentialAndHideForm</code>. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>buildGroupsFromLive(liveFiles, labels)</strong> — <em>derive groups heuristically from live files</em><br><strong>Purpose:</strong> Group live files into deterministic groups based on path/name heuristics and label lookups.<br><strong>Signature:</strong> <code>buildGroupsFromLive(liveFiles, labels) -&gt; groups[]</code><br><strong>Behavior:</strong> For each live file attempt to compute groupKey via <code>groupKeyFromPath</code> (first path segment or sanitized basename minus numeric suffix) then assign to group map; determine group description via <code>labels</code> or <code>descriptions</code>. Sort groups alphabetically, but place <code>Ungrouped</code> last. Each group shaped <code>{ name, description, files:[{name,url,path,caption}], count }</code>.<br><strong>Tests:</strong> Mixed <code>path</code> and <code>url</code> inputs produce expected groups and counts. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>createFileSearchEngine(items, opts)</strong> — <em>core search index & scorer factory</em><br><strong>Purpose:</strong> Build a bounded, deterministic file-level search engine with inverted index, prefix map, trigram arrays, query cache, intersection & union candidate retrieval, complexity guards, and scoring with optional worker offload. This is the most critical function in the system.<br><strong>Signature:</strong> <code>createFileSearchEngine(items, opts) -&gt; { candidatesForQuery, scoreFiles, lite, dispose, _clearQueryCache, _rebuildIndex, _dbgStats, _metrics }</code><br><strong>Behavior:</strong> When invoked:<br>1. Normalize <code>items[]</code> into <code>lite[]</code> entries: compute <code>full</code> string, <code>tokens = tokenizeInternal(full)</code>, <code>triArr = Array.from(trigramsOfInternal(full))</code>. Keep <code>groupIdx</code>, <code>fileIndex</code>.<br>2. Build <code>inverted</code> map: for token and prefixed forms <code>c:</code> and <code>f:</code> (caption/name qualifiers) push <code>idx</code> into posting arrays ensuring dedupe & strictly increasing order. Enforce <code>maxPostings</code> cap per token by discarding tail. Build <code>postingsMeta</code>.<br>3. Build <code>prefixMap</code> for 3–6 char token prefixes mapping to token keys used for prefix expansion. Cap by <code>prefixScanLimit</code>.<br>4. Create <code>queryCache</code> (LRU with TTL and <code>cacheGet/cacheSet</code> semantics). Track <code>_dbgStats</code> counters (last latency, candidate counts, strategy used).<br>5. Expose <code>candidatesForQuery(query)</code> which: handle quoted phrase exact substring scan (bounded by phraseBound), else tokenizes query, checks cache, gathers postings for token, caption token, filename token, expands prefixes for 3–6 char tokens, enforces complexity guard (if union/estimated work > complexityLimit return conservative limited candidate set + show toast), intersect postings (hash-based when base small else merge), dedupe union fallback, sort ascending, cache and return trimmed array or <code>null</code> if none.<br>6. Expose <code>scoreFiles(query, candidateIdxs)</code> which attempts <code>scoreFilesWithOptionalWorker(query,candidateIdxs)</code>. Worker path posts <code>{schemaVersion, reqId, cmd:&#x27;score&#x27;, query, candidates}</code> to <code>window.__ptt_scoring_worker</code> if available and waits with timeout; on timeout calls <code>terminate()</code> and falls back to <code>scoreFilesMainThread</code>. <code>scoreFilesMainThread</code> computes the score as described below.<br>7. <code>dispose()</code> clears caches and unregisters any worker handles registered with lifecycle. <code>_rebuildIndex(newItems)</code> allows atomic index replacement. <code>_clearQueryCache()</code> clears query caches for tests. <code>_metrics()</code> returns debug metrics when <code>DEBUG</code>.<br><strong>Complexity:</strong> Index build O(total tokens + postings). Query candidate gathering depends on posting sizes and caps. Scoring is O(#candidates * scoringCost). Complexity guard prevents excessive work.<br><strong>Invariants:</strong> Posting arrays stored are deduped and ascending. Tokenizer parity between index and query is a contract. Query cache returns clones to prevent external mutation.<br><strong>Security:</strong> No DOM insertion here. Worker messages validate <code>reqId</code> and attempt to verify <code>schemaVersion</code>.<br><strong>Tests:</strong> Posting normalization, prefix expansion, phrase query handling, complexity guard, scoring exactness. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>tokenizeInternal(s)</strong> — <em>stable tokenizer used at index & query time</em><br><strong>Purpose:</strong> Produce stable tokens for both indexing and querying to ensure deterministic behavior.<br><strong>Signature:</strong> <code>tokenizeInternal(s) -&gt; Array&lt;string&gt;</code><br><strong>Behavior:</strong> Lowercase, remove many punctuation ranges and quotes, replace underscores/dashes with spaces, collapse consecutive plus signs? (original code replaces <code>+</code> sequences), collapse whitespace, split on spaces, filter empties, cap at 50 tokens. Precisely mirrors index-time logic.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Invariants:</strong> Must not change without migration tests — tokens are binding across index and query caches.<br><strong>Tests:</strong> Strings with punctuation, underscores, dashes, <code>+</code> produce expected token arrays. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>trigramsOfInternal(s)</strong> — <em>create trigram set for overlap scoring</em><br><strong>Purpose:</strong> Compute a Set of 3-character shingles from padded string for normalized trigram overlap.<br><strong>Signature:</strong> <code>trigramsOfInternal(s) -&gt; Set&lt;string&gt;</code><br><strong>Behavior:</strong> Prepend and append space for padding then iterate <code>substr(i,3)</code> producing unique set. The engine uses trigram overlap / denom <code>qtri.size</code> to compute trigram-based score.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Tests:</strong> Confirm known outputs for test strings. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>cheapDLInternal(a,b)</strong> — <em>bounded cheap edit-distance</em><br><strong>Purpose:</strong> Fast approximate edit distance with early exit beyond threshold. Designed to be cheap and bounded for fuzzy bonuses.<br><strong>Signature:</strong> <code>cheapDLInternal(a,b) -&gt; integer</code> (returns small edit distance or sentinel > threshold)<br><strong>Behavior:</strong> Uses a standard Levenshtein dynamic programming with early termination if all current row distances exceed threshold. Optimized for short strings (e.g., queries ≤ <code>CHEAPDL_MAXLEN</code>) and small candidate sets. Returns small integer ≤ threshold or larger sentinel. The code uses the result only when <code>d &lt;= 2</code> to apply bonus.<br><strong>Complexity:</strong> O(len(a)*len(b)) worst-case but bounded by early exit.<br><strong>Tests:</strong> Known pairs: <code>&#x27;cat&#x27; vs &#x27;cut&#x27;</code> → 1; long strings beyond threshold early exit. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>candidatesForQuery(query)</strong> — <em>candidate retrieval flow (detailed)</em><br><strong>Purpose:</strong> Given a query string, produce a bounded list of file indices likely relevant (integers referencing <code>lite[]</code>). This is the engine’s candidate-generation layer (fast path before scoring).<br><strong>Signature:</strong> <code>candidatesForQuery(q) -&gt; Array&lt;int&gt;|null</code><br><strong>Detailed Flow:</strong><br>1. Trim & canonicalize query. If matches <code>^&quot;.+&quot;$</code> (quoted phrase), do bounded phrase scan: iterate <code>lite</code> and check <code>it.full.toLowerCase().indexOf(quotedWithoutQuotes) !== -1</code>; collect up to <code>PHRASE_BOUND</code> matches; sort ascending; cache result; return array or null.<br>2. Else produce <code>qtokens = tokenizeInternal(qlower)</code> and <code>qtri = trigramsOfInternal(qlower)</code>. Check <code>queryCache</code> for cached result by token list key and TTL; if cached return clone slice.<br>3. For each token <code>t</code>: collect postings from <code>inverted[t]</code>, <code>inverted[&#x27;c:&#x27;+t]</code>, <code>inverted[&#x27;f:&#x27;+t]</code> up to <code>maxPostings</code> each. For tokens length 3–6 consult <code>prefixMap</code> and include postings for token keys that match prefix, bounded by <code>prefixScanLimit</code> and <code>prefixCandidateLimit</code>. Keep <code>postingsList</code> per token.<br>4. Complexity guard: compute estimated union or worst-case posting counts; if > <code>COMPLEXITY_LIMIT</code> then show <code>showToastOrStatus(&#x27;Search too broad ...&#x27;)</code>, <code>cacheSet(cacheKey,null)</code>, record debug stats and return conservative subset (trimmed union) or <code>null</code>.<br>5. If only one postingsList present: dedupe & cap → return. Else sort <code>postingsList</code> by length ascending and compute intersection: if base ≤ <code>INTERSECTION_HASH_THRESHOLD</code> use hash-based intersection method (create map of base ids, then filter others); else do merge intersection by two-array merge. At each step keep candidates trimmed to <code>MAX_CANDIDATES</code>.<br>6. If intersection non-empty and size ≥ 4: finalArr = intersection slice(0, MAX_CANDIDATES). Else fallback to union deduped across postingsList up to <code>MAX_CANDIDATES</code>. Sort final arr ascending, <code>cacheSet(cacheKey, finalArr.slice(0))</code>, update debug stats and return <code>finalArr.slice(0)</code> or <code>null</code> if empty.<br><strong>Complexity:</strong> Dependent on posting sizes and caps. Complexity guard avoids worst-case blowups.<br><strong>Invariants:</strong> Returned arrays sorted ascending, cached clones returned to prevent external mutation. Posting arrays remain deduped and ordered.<br><strong>Failure modes:</strong> Very broad queries cause early guard path. Phrase queries do linear full-scan (bounded by <code>PHRASE_BOUND</code>).<br><strong>Tests:</strong> Token-only queries, prefix queries, quoted phrase queries, complexity guard triggers, caching correctness. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>scoreFilesWithOptionalWorker(query, candidateIdxs)</strong> — <em>attempt worker scoring, fallback to main thread</em><br><strong>Purpose:</strong> Offload scoring to <code>window.__ptt_scoring_worker</code> when available and configured; otherwise call <code>scoreFilesMainThread</code>. Uses request id <code>reqId</code> handshake and a timeout; on failure performs deterministic fallback to main-thread scoring.<br><strong>Signature:</strong> <code>scoreFilesWithOptionalWorker(query, candidateIdxs) -&gt; Promise&lt;Array&lt;{idx,score}&gt;&gt;</code><br><strong>Behavior:</strong><br>- If <code>ENABLE_WORKER_SCORING</code> and <code>window.__ptt_scoring_worker</code> and <code>postMessage</code> available: build <code>reqId = &#x27;wreq-&#x27; + Date.now().toString(36) + &#x27;-&#x27; + random</code>, set <code>finished=false</code>, set <code>timer = setTimeout(..., worker_timeout_ms)</code> that terminates worker on timeout and falls back to main thread. Add <code>onMsg</code> listener expecting replies with matching <code>reqId</code>. Post message <code>{ schemaVersion: 1, cmd: &#x27;score&#x27;, reqId, query, candidates }</code>. Add <code>LifecycleController.addWorker(worker)</code> for lifecycle safety. If worker responds with <code>d.ok === true</code> and <code>Array.isArray(d.results)</code> resolve with results; otherwise fallback to <code>scoreFilesMainThread</code>. On exceptions or error reply, remove listener, terminate worker, and fallback.<br>- If worker not available or disabled, call <code>scoreFilesMainThread(query, candidateIdxs)</code>.<br><strong>Complexity:</strong> Worker cost + message serialization overhead; fallback deterministic.<br><strong>Tests:</strong> Simulate worker success, worker timeout, malformed reply, ensure fallback behavior. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>scoreFilesMainThread(query, candidateIdxs)</strong> — <em>deterministic main-thread scorer</em><br><strong>Purpose:</strong> Compute scores for candidate documents deterministically. This is the authoritative scoring function and fallback for worker failures.<br><strong>Signature:</strong> <code>scoreFilesMainThread(query, candidateIdxs) -&gt; Promise&lt;Array&lt;{idx,score}&gt;&gt;</code><br><strong>Detailed scoring algorithm:</strong><br>- Normalize query: <code>qraw</code>, <code>qlower</code>, <code>qtokens = tokenizeInternal(qlower)</code>, <code>qtri = trigramsOfInternal(qlower)</code>. Initialize <code>results = []</code>.<br>- Iterate candidate indices (sorted ascending). For each <code>idx</code>:<br>  1. <code>score = 0</code>.<br>  2. If query is quoted phrase and <code>it.full.toLowerCase().indexOf(quotedPhrase) !== -1</code> → <code>score += 500</code>.<br>  3. If <code>it.caption</code> contains <code>qlower</code> → <code>score += 220</code>.<br>  4. If <code>it.name</code> contains <code>qlower</code> → <code>score += 140</code>.<br>  5. For each token <code>t</code>, if <code>it.tokens</code> contains <code>t</code> → increment <code>matchedTokens</code>; add <code>matchedTokens * 28</code> later. (Using precomputed <code>tokenSet</code> map avoids O(n) per token scanning).<br>  6. For each query token <code>t</code>, if any token in it.caption/name begins with <code>t</code> → caption prefix boost <code>+18</code> and name prefix <code>+10</code>.<br>  7. Compute trigram overlap: build <code>triSet</code> from <code>it.triArr</code>; count overlap with <code>qtri</code>; denom = <code>Math.max(1,qtri.size||1)</code>; <code>score += Math.round((overlap/denom) * TRIGRAM_WEIGHT)</code>.<br>  8. Cheap DL: if <code>qlower.length &gt; 0 &amp;&amp; qlower.length &lt;= CHEAPDL_MAXLEN &amp;&amp; iterate.length &lt;= CHEAPDL_CANDIDATE_CAP</code> then compute <code>cheapDLInternal(qlower, it.name)</code> and <code>cheapDLInternal(qlower, it.caption)</code> and add scaled bonuses for small distances (d<=2). Increment <code>_dbgStats.lastDLInvocations</code>.<br>  9. Add length normalization <code>score += Math.max(0, 8 - (it.full.length / 180))</code>.<br> 10. Push <code>{ idx, score }</code> to results.<br>- After scoring, sort <code>results</code> descending by <code>score</code>; tie-break by <code>groupIdx</code> asc, <code>fileIndex</code> asc, <code>name</code> lexicographic, then <code>idx</code>. Resolve results array.<br><strong>Complexity:</strong> O(#candidates * (tokenMatching + tri overlap)). Bounded by candidate caps.<br><strong>Determinism:</strong> Sorting tie-breakers ensure stable ordering.<br><strong>Tests:</strong> Compare scores to known expected values for contrived items. Assert deterministic tie-breaks. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>diversifyResults(scoredArr, lite, opts)</strong> — <em>optional result diversification</em><br><strong>Purpose:</strong> Limit <code>topK</code> results with <code>maxPerGroup</code> constraint to avoid group domination. Implemented inline in <code>doSearch</code>.<br><strong>Signature:</strong> anonymous function used in search flow.<br><strong>Behavior:</strong> Greedy selection picking top-scored items while respecting per-group caps, then append deferred items to fill topK and finally append remaining unique items to preserve completeness.<br><strong>Complexity:</strong> O(#scored).<br><strong>Tests:</strong> Cases where single group has many top items should produce diversified topK. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>presentGroupsOnly: UI helpers (updateExpandButtonState, renderGroupsFromFileResults)</strong><br><strong>Purpose:</strong> Update expand/collapse control and render grouped results from scored file results respectively.<br><strong>Behavior:</strong><br>- <code>updateExpandButtonState()</code> collects visible controls and sets <code>expandAllBtn</code> state/text based on whether any collapsed; hides button if no visible controls.<br>- <code>renderGroupsFromFileResults(fileResults, q)</code> aggregates fileResults into <code>byGroup</code> buckets, sorts by group score descending, for each visible group repopulates <code>ctrl.fileList</code> with up to top N sorted files, using safe DOM creation and <code>setHighlightedText</code>. If no visible groups, shows <code>No matching groups.</code> message. ExpandAll reflects aggregate state and hides when no groups visible.<br><strong>Tests:</strong> Visibility toggles, expand button text correct, file lists reflect scores. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>attachListHandler()</strong> — <em>legacy button binder</em><br><strong>Purpose:</strong> Idempotent attachment of <code>LIST_BTN_ID</code> click to <code>buildAndPresent()</code> that launches the live-file discovery and modal.<br><strong>Signature:</strong> <code>attachListHandler()</code><br><strong>Behavior:</strong> If <code>document.getElementById(LIST_BTN_ID)</code> exists and not already attached (dataset flag), attach <code>click</code> listener which <code>preventDefault()</code> and calls <code>buildAndPresent()</code>. Uses dataset <code>__ptt_list_attached = &#x27;1&#x27;</code> to be idempotent. Called on DOM ready (<code>DOMContentLoaded</code>) or via <code>setTimeout</code> when document not loading.<br><strong>Tests:</strong> Ensure multiple calls do not add duplicate listeners. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>attachPasteSync()</strong> — <em>keep __tv_last_source in sync with user edits</em><br><strong>Purpose:</strong> Keep <code>window.__tv_last_source</code> and timestamp in sync when user edits the paste textarea.<br><strong>Signature:</strong> <code>attachPasteSync()</code> (self-invoked)<br><strong>Behavior:</strong> Adds <code>input</code> listener to <code>PASTE_ID</code> to update <code>window.__tv_last_source</code> and <code>window.__tv_last_source_ts</code>. Passive listener.<br><strong>Tests:</strong> Edit textarea, assert global vars updated. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>getRawPasteText()</strong> — <em>get raw paste text from available places</em><br><strong>Purpose:</strong> Read raw paste text from preferred places in order: <code>PASTE_ID.value</code>, <code>#page-area.textContent</code>, <code>__ptt_hidden_convert.value</code>.<br><strong>Signature:</strong> <code>getRawPasteText() -&gt; string</code><br><strong>Behavior:</strong> Defensive reads; returns <code>&#x27;&#x27;</code> if none.<br><strong>Tests:</strong> Each storage path populated → returns right value. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>copyTextToClipboard(text)</strong> — <em>clipboard write helper with fallbacks</em><br><strong>Purpose:</strong> Copy text to clipboard using modern API or fallback to hidden textarea + <code>document.execCommand(&#x27;copy&#x27;)</code>. Returns Promise.<br><strong>Signature:</strong> <code>copyTextToClipboard(text) -&gt; Promise&lt;void&gt;</code><br><strong>Behavior:</strong> If <code>navigator.clipboard.writeText</code> available use it. Else create a hidden textarea, set value, select, <code>document.execCommand(&#x27;copy&#x27;)</code>, remove textarea, resolve or reject accordingly. Emits telemetry or toast where appropriate.<br><strong>Complexity:</strong> O(len(text)).<br><strong>Failure modes:</strong> <code>execCommand</code> may fail in some browsers; Promise rejects.<br><strong>Security:</strong> Must not leak text; transient DOM element removed promptly.<br><strong>Tests:</strong> Clipboard API available/absent cases (use mocks). </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>copy handlers (document click delegation)</strong> — <em>copy delegation & fallbacks</em><br><strong>Purpose:</strong> Global click <code>document.addEventListener(&#x27;click&#x27;, ...)</code> that intercepts clicks on copy controls and tries renderer hooks first then fallbacks.<br><strong>Selectors:</strong> <code>COPY_MARKDOWN_SELECTORS</code> and <code>COPY_PLAIN_SELECTORS</code>.<br><strong>Flow:</strong><br>- On click, detect <code>btnMd</code> or <code>btnPlain</code> via <code>closest()</code>. If <code>window.__ptt_force_raw_copy</code> true, force raw path.<br>- If <code>btnMd</code> and <code>window.copyTableMarkdown</code> exists (and not forced), call <code>window.copyTableMarkdown(btn)</code>. If success show toast.<br>- Else if <code>btnPlain</code> and <code>window.copyTablePlain</code> exists, call it.<br>- Else <code>getRawPasteText()</code>, if <code>btnMd</code> try <code>findFirstMarkdownBlockInSource(text)</code> to extract markdown table or fallback to whole text; call <code>copyTextToClipboard</code>.<br>- Provide <code>window.__ptt_copy_raw_from_paste()</code> utility and <code>window.__ptt_set_force_raw_copy(val)</code> to toggle the forced raw behavior.<br><strong>Security:</strong> Avoids injecting HTML into clipboard; copy is just text. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>findFirstMarkdownBlockInSource(src)</strong> — <em>extract first markdown table</em><br><strong>Purpose:</strong> When copying markdown, heuristically find the first markdown table block from raw source (look for <code>|</code> lines and header separator <code>---</code> pattern).<br><strong>Signature:</strong> <code>findFirstMarkdownBlockInSource(src) -&gt; string|null</code><br><strong>Behavior:</strong> Walk lines; find a line with <code>|</code> and next line with <code>|...</code> or <code>---</code> style separator; return contiguous block. Fallback to first contiguous block of lines containing <code>|</code>. Return null if none found.<br><strong>Tests:</strong> Markdown with table -> returns correct block; no table -> null. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>triggerConvertIfAvailable()</strong> — <em>detect convert API</em><br><strong>Purpose:</strong> Return boolean whether renderer convert API available (<code>window.__tv_do_convert</code> or <code>window.convert</code>). Used to decide whether to call or use hidden fallback.<br><strong>Signature:</strong> <code>triggerConvertIfAvailable() -&gt; boolean</code><br><strong>Tests:</strong> Toggle presence of functions, assert return. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>fetchLiveFilesSequential(endpoints)</strong> — <em>sequential discovery probe</em><br><strong>Purpose:</strong> Probe multiple live-file endpoints in order until one returns usable list data. Provides precedence.<br><strong>Signature:</strong> <code>fetchLiveFilesSequential(endpoints) -&gt; Promise&lt;{ok:boolean, data:Array, source:string|null}&gt;</code><br><strong>Behavior:</strong> Try endpoints one by one via <code>fetchWithTimeout</code>, parse responses via <code>tryParseListBodyAsArray</code>/<code>normalizeIndexData</code>, return first ok dataset or <code>{ok:false,data:[]}</code>. Respects <code>MAX_LIST_ITEMS</code> limit.<br><strong>Complexity:</strong> O(#endpoints) network.<br><strong>Tests:</strong> Simulate first failing/second working endpoint flows; ensure precedence honored. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>loadGroupDescriptions() / loadLabels()</strong> — <em>label & description loaders</em><br><strong>Purpose:</strong> Fetch label and group description assets from candidate endpoints (ordered), parse JSON, return canonical mapping objects. They are read-only.<br><strong>Failure modes:</strong> Malformed JSON leads to fallback empty map; errors are logged. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>tryParseListBodyAsArray(txt)</strong> — <em>canonical parse for list endpoints</em><br><strong>Purpose:</strong> Accept various server shapes: top-level array or object with <code>{ files: [...] }</code>. Return array or <code>null</code>.<br><strong>Tests:</strong> JSON <code>&#x27;[&quot;a&quot;,&quot;b&quot;]&#x27;</code>, <code>&#x27;{ &quot;files&quot;: [...] }&#x27;</code>, string list, invalid JSON -> null. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>buildAndPresent()</strong> — <em>high-level orchestration to fetch live files and open modal</em><br><strong>Purpose:</strong> Top-level flow invoked by list button: fetch live files sequentially, load group descriptions and labels, build groups, and call <code>presentGroupsOnly(groups, descriptions)</code>.<br><strong>Signature:</strong> <code>buildAndPresent()</code><br><strong>Behavior:</strong> Calls <code>updateStatus(&#x27;Resolving...&#x27;)</code>, <code>Promise.all([fetchLiveFilesSequential, loadGroupDescriptions, loadLabels])</code>, handles empty/no-data cases showing status errors, else <code>groups = buildGroupsFromLive(liveFiles, labels)</code>, <code>presentGroupsOnly(groups, descriptions)</code>. Catches and logs errors.<br><strong>Tests:</strong> Simulated server data flows, ensure modal opens with groups populated. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>Virtualization (feature-flagged)</strong> — <em>VirtualList(rootEl, opts)</em><br><strong>Purpose:</strong> Optional virtual list component used when <code>ENABLE_VIRTUAL_LIST</code> true (not enabled by default in code). Fallback renders all items.<br><strong>Signature:</strong> <code>VirtualList(rootEl, opts) -&gt; { renderAll(count), destroy() }</code><br><strong>Behavior:</strong> When enabled, computes visible range by <code>itemHeight</code>, listens to scroll (passive), renders only visible items with buffer. Not enabled by default to avoid regressions.<br><strong>Tests:</strong> With large counts ensures DOM nodes limited. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>IndexedDB persistence (pttIndexDB, opt-in)</strong> — <em>best-effort index persistence</em><br><strong>Purpose:</strong> When <code>ENABLE_INDEXEDDB_PERSISTENCE</code> true, open <code>ptt_index_v1</code> and store index metadata to avoid re-building large indices. All writes are best-effort and never block UI. Exposes <code>openDB</code>, <code>putIndex</code>, <code>getIndex</code>, <code>clearIndex</code>.<br><strong>Failure modes:</strong> Unsupported browsers return resolved nulls. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>Debug & test harness (DEBUG mode)</strong> — <em>unit smoke tests</em><br><strong>Purpose:</strong> When <code>DEBUG</code> true attach <code>window.__ptt_run_tests()</code> that runs a small set of tests: tokenize parity, highlight DOM test, scope cleanup test. Exposes <code>window.__ptt_test_hooks</code> for tokenizer/trigrams/access to <code>LifecycleController</code>.<br><strong>Tests:</strong> Run <code>window.__ptt_run_tests()</code> to assert core invariants. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>_metrics(), _dbgStats()</strong> — <em>engine introspection</em><br><strong>Purpose:</strong> Expose internal stats and metrics for debugging when <code>DEBUG</code> true: cache size, order, stats like <code>lastLatencyMs</code>, <code>lastCandidates</code>, <code>_dbgStats.lastDLInvocations</code> etc. <code>_metrics()</code> returns lifecycle debug state too.<br><strong>Security:</strong> Only available in debug builds. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>API surface and invariants (summary)</strong><br><strong>Functions that must remain stable</strong>: <code>createFileSearchEngine(items, opts)</code>, <code>presentGroupsOnly(groups, descriptions)</code>, <code>loadFilesSequentialAndHideForm(listOfFiles)</code>, <code>buildAndPresent()</code>, <code>attachListHandler()</code>.<br><strong>Events</strong>: <code>ptt:groupLoaded</code> dispatched with <code>{ runtimeCaptions: Array, count: Number }</code>.<br><strong>Worker contract</strong> (partial in current code): scoring worker expected to accept <code>{ schemaVersion, cmd:&#x27;score&#x27;, reqId, query, candidates }</code> and respond with <code>{ reqId, schemaVersion, ok, results }</code> — current implementation includes <code>schemaVersion</code> in scoring worker path but not uniformly across all worker clients. Standardize <code>PTT_WORKER_SCHEMA_VERSION</code> for full parity. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>Security & XSS notes (global)</strong><br>- All caption insertion uses <code>sanitizeCaptionForInjection</code> and <code>textContent</code> or element creation; <code>innerHTML</code> avoided for untrusted content.<br>- <code>encodedSavedUrlFor</code> rejects cross-origin absolute URLs to prevent inadvertent cross-origin fetching.<br>- Event and telemetry payloads should be audited to avoid PII leakage.<br>- Lint rules recommended: forbid <code>innerHTML</code> and inline <code>eval</code>-style code.<br><strong>Tests:</strong> XSS negative tests for caption strings that include <code>&quot;&gt;&lt;script&gt;</code> or <code>&lt;!--</code> sequences. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>Performance & operational notes</strong><br>- Complexity guard prevents extremely broad queries from blocking main thread; tune <code>COMPLEXITY_LIMIT</code> with telemetry.<br>- <code>MAX_POSTINGS</code> and <code>maxCandidates</code> bound memory and CPU usage.<br>- Consider adding <code>maxParallelFetches</code> to <code>loadFilesSequentialAndHideForm</code> to limit concurrent fetches in constrained environments.<br>- Blob URL revocation for inline worker: current code revokes on error but not after successful <code>new Worker(url)</code>. Recommended: revoke created blob URL immediately after <code>new Worker(blobUrl)</code> to avoid resource leakage. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>Recommended unit/integration test list (concise)</strong><br>1. Tokenizer parity & determinism.<br>2. Inverted index postings dedupe & order checks.<br>3. Prefix expansion boundaries (<code>prefixScanLimit</code>, <code>prefixCandidateLimit</code>).<br>4. Quoted phrase behavior and phraseBound.<br>5. Complexity guard triggers and fallback subset correctness.<br>6. Worker scoring success, schema mismatch, and timeout fallback.<br>7. Load pipeline ordering and caption application (delayed renderer).<br>8. XSS/sanitization: captions with scripts/comments.<br>9. Modal accessibility: focus trap, Escape closes, focus restored.<br>10. Lifecycle smoke test: 500 open/close cycles no resource growth. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>Maintenance notes for engineers</strong><br>- <strong>Do not</strong> change tokenizer normalization without migration/deprecation tests — tokenization changes are breaking for cached queries and indexes.<br>- When changing worker messaging, increment a <code>PTT_WORKER_SCHEMA_VERSION</code> constant and ensure worker code is updated in lock-step; add graceful fallback handling.<br>- For any <code>innerHTML</code> re-introduction, require explicit review and sanitize pipeline.<br>- Add <code>scripts/check-api-surface.js</code> in CI to assert exported/global API surface remains stable. </td></tr><tr><td data-label="Technical breakdown (script.list.js)"> <strong>Final summary (one paragraph)</strong><br>This per-function breakdown documents the entire <code>script.list.js</code> module as implemented: a conservative, heavily-hardened UI + search pipeline with an in-memory bounded inverted/prefix/trigram index, safe DOM/caption handling, worker-assisted scoring with deterministic main-thread fallback, and careful lifecycle scoping. The module emphasizes safety (no <code>innerHTML</code> for untrusted data), determinism (tokenizer parity, capped posting sizes, stable tie-breakers), and graceful fallbacks (worker timeouts, partial fetch failures). Key recommended improvements are consistent worker schema handshake, blob URL revocation after worker spawn, and optional parallel fetch throttling. Use the tests and invariants above to validate changes and keep public API compatibility. </td></tr></tbody></table></div><div class="row-count">Rows: 54</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>