<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771612983">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0204_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Per-function technical breakdown — **modConfigUI** (VBA)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Per-function technical breakdown — <strong>modConfigUI</strong> (VBA)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Module purpose (short)</strong><br><code>modConfigUI</code> is the authoritative UI/controller module for all configuration management tasks in UpdateHR+. It provides a controlled, auditable, role-gated worksheet and macro surface for editing, validating, snapshotting, promoting, and exporting runtime configuration. It enforces governance rules, persists config snapshots, records change history into <code>Macro_ChangeLog</code>, and exposes safe import/export operations for environment promotion (dev → test → prod). The module separates UI behavior from storage (modConfig) and from validation logic (modConfig.ValidateConfig), providing a deterministic, testable admin surface. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Design principles & constraints</strong><br>1. Single responsibility: UI orchestration only; no business rules or matching logic implemented here — call <code>modConfig</code> for canonical behavior. <br>2. Least privilege: actions gated by <code>modConfig.UserRoles</code> and enforced in both UI controls and server-side guards; any write operations verify caller role before commit. <br>3. Auditable: every config change produces an entry in <code>Macro_ChangeLog</code> and an <code>Audit_Log</code> event referencing the changeId and pathway. <br>4. Reproducible: <code>PersistConfigSnapshot</code> writes JSON snapshot and <code>explainVersion</code> so runs can be replayed deterministically. <br>5. Safe edit model: edits occur in temporary edition area and require explicit <code>Apply</code> with review/approval if the change touches high-risk keys. <br>6. Validation-first: <code>Apply</code> triggers <code>modConfig.ValidateConfig()</code> — changes rejected until validated. <br>7. No external side-effects during preview: preview operations must be read-only and must not modify <code>__Run_Config</code> or production keys until applied. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Public surface (summary)</strong><br>Key public procedures/functions exposed by <code>modConfigUI</code> (other modules call these or the UI binds to them):<br>1. <code>RenderConfigSheet()</code> — draw and bind UI controls to live config values. <br>2. <code>BeginEditConfig()</code> — create a safe editable copy of config into <code>__Config_Edit_&lt;sessionId&gt;</code>. <br>3. <code>ValidateAndPreviewChanges(sessionId As String) As Scripting.Dictionary</code> — validate edits and produce preview diff. <br>4. <code>ApplyConfigChanges(sessionId As String, appliedBy As String, Optional requireSignOff As Boolean = False)</code> — commit changes after validation and optionally require reviewer signoff. <br>5. <code>ExportConfigToJSON(path As String, format As String)</code> — canonical export (pretty/compact) with manifest. <br>6. <code>ImportConfigFromJSON(path As String, previewOnly As Boolean)</code> — import flow with validation and diff preview. <br>7. <code>RevertConfigToSnapshot(snapshotId As String, revertedBy As String)</code> — controlled revert to a prior config snapshot. <br>8. <code>ListConfigSnapshots()</code> — return list of snapshots with metadata for UI. <br>9. <code>OpenConfigApprovalDialog(changeId As String)</code> — UI helper to present approvers with change details and accept/reject. <br>10. <code>AuditConfigChange(changeMeta As Scripting.Dictionary)</code> — helper to write <code>Macro_ChangeLog</code> and <code>Audit_Log</code> entries consistently. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: RenderConfigSheet</strong><br>Purpose: build and bind the admin worksheet UI for live configuration review and editing.<br>Behavior & responsibilities:<br>1. When called, the routine ensures <code>__Config</code> sheet exists and has protected cells laid out into grouped sections: <code>Matching</code>, <code>Fuzzy</code>, <code>GoalSeek</code>, <code>Batch</code>, <code>Security</code>, <code>Telemetry</code>, <code>Environment</code>. <br>2. Render static explanatory text and per-key controls: data validation lists, numeric sliders (emulated via cells + spin buttons), and protected cells for admin-only keys. <br>3. Provides clickable macro buttons: <code>Begin Edit</code>, <code>Preview Changes</code>, <code>Apply</code>, <code>Export</code>, <code>Import</code>, <code>Revert</code>, <code>View History</code>. Each button calls the corresponding public procedure. <br>4. Bindings: the sheet shows current live values from <code>modConfig.LoadConfig(env)</code> and a <code>Lock</code> indicator reflecting <code>__Run_Locks</code>. <br>5. UX accessibility: ensure large-font headers, tooltips in adjacent cells, and keyboard navigation support (tab-index via cell order); ensure the sheet is readable for screen readers (use plain labels, avoid merged cells where possible). <br>6. Security: cells that must not be edited by non-Admins are protected; <code>RenderConfigSheet</code> sets protection flags and records the protector in <code>__Config_Audit</code>. <br>7. Audit: <code>RenderConfigSheet</code> writes a <code>UI_RENDER</code> entry in <code>__Telemetry</code> containing <code>userId</code> and timestamp. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: BeginEditConfig</strong><br>Purpose: create an edit session and safe sandbox for making changes without impacting live config until Apply.<br>Signature concept: <code>BeginEditConfig(userId As String) As String (sessionId)</code>.<br>Flow & mechanics:<br>1. Generate <code>sessionId</code> (GUID) and create <code>__Config_Edit_&lt;sessionId&gt;</code> hidden sheet copied from live <code>__Config</code> or <code>modConfig.LoadConfig(&quot;env&quot;)</code> snapshot. <br>2. Mark the session owner <code>userId</code> and <code>startedAt</code> in <code>__Edit_Sessions</code> registry sheet. <br>3. Create a <code>ChangeDraft</code> object (Scripting.Dictionary) in memory for staging and bind the edit sheet cells to the draft using standard cell addresses and named ranges. <br>4. Enforce concurrency: if user already has open session or if a conflicting session editing critical keys exists, either allow multiple ephemeral sessions for non-overlapping keys or block via <code>LOCK_CONFLICT</code> with helpful message. <br>5. Add a session expiry TTL (e.g., 48 hours) to avoid stale sessions; show warning if TTL exceeded. <br>6. Audit: append <code>EDIT_SESSION_START</code> to <code>Macro_ChangeLog</code> with <code>sessionId</code>, <code>userId</code>, <code>diff</code> empty, and <code>codeVersion</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: ValidateAndPreviewChanges</strong><br>Purpose: validate draft changes and show deterministic preview diffs and impact notes for reviewers/operators.<br>Signature concept: <code>ValidateAndPreviewChanges(sessionId As String) As Scripting.Dictionary</code> returning a <code>preview</code> dictionary containing <code>isValid</code>, <code>errors[]</code>, <code>warnings[]</code>, <code>diff[]</code>, <code>impactSummary</code>.<br>Validations performed (detailed):<br>1. Schema validations: presence and type checks for required keys. <br>2. Range validations: ensure numeric keys within policy ranges (e.g., <code>0 &lt; AutoApplyThreshold &lt; 1</code>). <br>3. Inter-key validations: ensure <code>ReviewerThreshold &gt;= AutoApplyThreshold</code>, <code>BatchSize</code> positive and <= <code>MaxBatchAcceptable</code> config. <br>4. Policy checks: whether changes to critical keys (monetary thresholds, reviewerHighDollarThreshold) require reviewer or admin approval as defined by <code>modConfig.ChangeApprovalPolicy</code>. <br>5. External checks: if <code>ExternalScorerUrl</code> changed, validate reachable and auth info format (optionally ping via external helper service call in test mode only; do not perform in local offline-only installs unless allowed). <br>6. Produce <code>diff[]</code> as array of objects: <code>{key, oldValue, newValue, severity}</code> sorted by severity. <br>7. Produce <code>impactSummary</code> textual list of potential run-time effects (e.g., expected reviewer load increase from threshold change, by using <code>modFuzzyScores.ProfileFuzzyComparisons</code> results if available). <br>8. Return <code>isValid</code> false if any critical validation fails; write <code>VALIDATION_FAILED</code> entry to <code>Macro_ChangeLog</code> with <code>sessionId</code> and errors. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: ApplyConfigChanges</strong><br>Purpose: commit validated changes to live config with audit trail and optional approval gating.<br>Signature concept: <code>ApplyConfigChanges(sessionId As String, appliedBy As String, Optional requireSignOff As Boolean = False) As Scripting.Dictionary</code> returning <code>applyResult</code> {success:Boolean, changeId:String, notes}.<br>Commit flow & governance:<br>1. Re-validate: call <code>ValidateAndPreviewChanges</code> as a last gate to avoid TOCTOU issues; if invalid, abort with errors. <br>2. Approval path: if <code>requireSignOff</code> or if <code>diff</code> touches keys marked <code>highRisk</code>, create <code>changeId</code> and set <code>status=AWAITING_APPROVAL</code>; write <code>Macro_ChangeLog</code> entry and send UI signal to reviewers via <code>OpenConfigApprovalDialog</code>. <br>3. If no approval required, create <code>snapshotId = PersistConfigSnapshot(runId=NA or &quot;configChange:&lt;changeId&gt;&quot;)</code> with before/after JSON, persist to <code>__Run_Config</code> with <code>appliedAt</code> and <code>appliedBy</code>. <br>4. Update <code>__Config</code> sheet and in-memory <code>modConfig</code> cache atomically; write <code>APPLY</code> <code>Audit_Log</code> row with <code>changeId</code>, <code>appliedBy</code>, <code>beforeSnapshot</code>, <code>afterSnapshot</code>, <code>signatureHash</code> (lightweight), and <code>codeVersion</code>. <br>5. If failure occurs while writing to <code>__Config</code> sheet, automatically revert to <code>beforeSnapshot</code> and write <code>APPLY_FAILED</code> audit row and notify operator; preserve the <code>sessionId</code> for reattempt. <br>6. If external agent (e.g., central config DB) is configured, call <code>ExportConfigToJSON</code> and push to ingestion endpoint in <code>modAuditExportHelpers</code> with signed manifest (if enabled) and record response. <br>7. Return <code>applyResult</code> with <code>success=true</code> and <code>changeId</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: ExportConfigToJSON</strong><br>Purpose: export canonical, signed (if available) configuration artifacts for promotion or archival.<br>Signature concept: <code>ExportConfigToJSON(path As String, format As String = &quot;pretty&quot;, Optional includeSecrets As Boolean = False, Optional sign As Boolean = False) As Scripting.Dictionary</code>.<br>Details:<br>1. Read live configuration via <code>modConfig.LoadConfig(env)</code> and create JSON payload including <code>metadata</code>: <code>exportedAt</code>, <code>exportedBy</code>, <code>codeVersion</code>, <code>configVersion</code>, <code>envTag</code>. <br>2. If <code>includeSecrets=False</code>, redact or replace secret fields (API keys) with placeholder <code>&lt;&lt;REDACTED&gt;&gt;</code> and store secret references in a separate <code>secrets_manifest</code> if <code>sign=True</code> uses external signer. <br>3. Format options: <code>pretty</code> for human readable; <code>compact</code> for machine ingestion. <br>4. If <code>sign=True</code>, call helper (external) to compute a recommended signature and include <code>signature</code> and <code>signerId</code> in manifest (note: local-only workbooks may not have PKI — then document that signature absent and write <code>signatureStatus=UNSIGNED</code>). <br>5. Write <code>manifest.json</code> alongside exported file with checksums (file-level and row-level if enabled) to allow downstream verification. <br>6. Append <code>EXPORT_CONFIG</code> <code>Macro_ChangeLog</code> entry with path and manifest checksum. <br>7. Return <code>{path, checksum, manifestPath}</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: ImportConfigFromJSON</strong><br>Purpose: safely import config artifacts with preview and validation before commit.<br>Signature concept: <code>ImportConfigFromJSON(path As String, previewOnly As Boolean) As Scripting.Dictionary</code>.<br>Flow:<br>1. Load JSON, verify manifest and optionally verify signature if present. If manifest signature missing and <code>modConfig.ImportRequireSignature=True</code>, abort. <br>2. Parse set of keys and compute <code>diff</code> vs current config using <code>ValidateAndPreviewChanges</code> logic (mapping keys in JSON to <code>__Config</code> keys). <br>3. If <code>previewOnly=True</code> return <code>diff</code> and <code>impactSummary</code> without writing. <br>4. If preview accepted and changes valid, proceed through <code>ApplyConfigChanges</code> using a temporary <code>sessionId</code> representing the import. <br>5. If import contains unknown keys, treat them as warnings and require admin confirmation to persist unknown keys. <br>6. Write <code>IMPORT</code> entry to <code>Macro_ChangeLog</code> with <code>sourcePath</code> and <code>signature</code> status. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: RevertConfigToSnapshot</strong><br>Purpose: revert live config to an identified snapshot in an auditable manner.<br>Signature concept: <code>RevertConfigToSnapshot(snapshotId As String, revertedBy As String) As Scripting.Dictionary</code>.<br>Behavior:<br>1. Confirm snapshot presence in <code>ListConfigSnapshots</code>. <br>2. If snapshot affects <code>highRisk</code> keys, require dual approval (admin + reviewer) before applying revert. <br>3. When confirmed, write <code>beforeSnapshot</code> and <code>afterSnapshot</code> (the snapshot) to <code>__Stage_Config_Revert_&lt;revertId&gt;</code>, call <code>ApplyConfigChanges</code> logic but categorize entry as <code>REVERT</code>. <br>4. Add <code>revertId</code> to <code>Macro_ChangeLog</code> and <code>Audit_Log</code> with full provenance and signature. <br>5. Provide a <code>ForensicPack</code> link with both snapshots for security and compliance teams. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: ListConfigSnapshots</strong><br>Purpose: enumerate stored config snapshots and metadata for UI selection.<br>Returns: collection of snapshot metadata: <code>snapshotId</code>, <code>createdAt</code>, <code>createdBy</code>, <code>changeId</code> (if part of a change), <code>notes</code>, <code>checksum</code>, <code>codeVersion</code>. <br>UI usage: used in <code>RenderConfigSheet</code> <code>View History</code> panel and in <code>RevertConfigToSnapshot</code> chooser. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: OpenConfigApprovalDialog</strong><br>Purpose: bring up a compact UI for approvers showing <code>diff</code>, <code>impactSummary</code>, required sign-off options, and approve/reject controls.<br>Dialog features:<br>1. Show compact diff table with color-coded severity badges and <code>before</code> / <code>after</code> values. <br>2. Show <code>impactSummary</code> including estimated reviewer load, impacted modules, and <code>requiredEscalation</code> reasons. <br>3. Require approver comment and provide optional <code>signatureHash</code> entry; for high-dollar approvals require dual approver workflow. <br>4. On approve -> call <code>ApplyConfigChanges(sessionId, approverId)</code> to complete commit; on reject -> write <code>APPROVAL_REJECTED</code> and keep session open for edits. <br>5. Approver actions always audited with comment required. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Function: AuditConfigChange</strong><br>Purpose: single-source utility to write consistent change records to <code>Macro_ChangeLog</code> and <code>Audit_Log</code> with provenance.<br>Inputs: <code>changeMeta</code> dictionary includes: <code>changeId</code>, <code>sessionId</code>, <code>userId</code>, <code>beforeSnapshot</code>, <code>afterSnapshot</code>, <code>diff</code>, <code>approvalStatus</code>, <code>changeType</code> (APPLY/IMPORT/REVERT), <code>signatureHash</code>.<br>Behavior: write to <code>Macro_ChangeLog</code> (human readable change description) and an <code>Audit_Log</code> structured row with JSON-encoded <code>before</code>/<code>after</code> and <code>componentBreakdown</code> for downstream PQ; compute row checksum and write to <code>__Audit_Seals</code> if sealing enabled. <br>Idempotency: if <code>changeId</code> already present, do not duplicate entries; instead update an <code>auditUpdate</code> column with a version increment. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>UI layout & control mapping (recommended)</strong><br>1. Config grouped into panels: <code>Identification &amp; Environment</code>, <code>Matching</code>, <code>Fuzzy</code>, <code>GoalSeek</code>, <code>Batch</code>, <code>Security &amp; Auth</code>, <code>Telemetry &amp; TelemetryExport</code>, <code>Advanced</code> (developer-only). <br>2. Each key occupies a single row: <code>KeyName</code>, <code>CurrentValue</code> (readonly), <code>EditValue</code> (unlocked during edit session), <code>HelpTip</code>, <code>RiskLevel</code> badge, <code>LastChanged</code> (snapshot id). <br>3. Top-right: session controls and <code>Begin Edit</code> / <code>End Edit</code> / <code>Preview</code> / <code>Apply</code> buttons with clear disabled states for non-privileged roles. <br>4. Bottom pane: <code>ChangeDraft</code> diff viewer and <code>ImpactSummary</code> panel produced by <code>ValidateAndPreviewChanges</code>. <br>5. Right-side: <code>History</code> list with <code>ViewSnapshot</code> and <code>Revert</code> actions. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Accessibility & internationalization</strong><br>1. Use localized labels from <code>__ConfigUI_Labels</code> to support global deployments; language key selected by workbook property or admin UI. <br>2. Provide keyboard-first navigation and avoid merged cells where possible. <br>3. Ensure high-contrast mode compatibility for visually impaired users and provide <code>Help</code> text in plain language. <br>4. Ensure date/time displayed in UTC and provide local time rendering on demand. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Security & secrets handling</strong><br>1. For any keys containing secrets (API keys, tokens), <code>modConfigUI</code> must not render plaintext unless <code>UserRoles.Admin</code> and <code>modConfigUI</code> <code>showSecretsMode=True</code> AND the session is flagged as <code>secureLocal</code>. Prefer placeholder masked values <code>********</code> and <code>Reveal</code> button requiring secondary authentication step. <br>2. When exporting, redact secrets unless <code>ExportConfigToJSON(includeSecrets=True)</code> is used with explicit admin consent, and require an extra confirmation and a record in <code>Macro_ChangeLog</code> stating the reason for secret export. <br>3. Use <code>signatureHash</code> only as a provenance token; do not treat it as cryptographic guarantee unless integrated with PKI. Recommend external signing step for compliance-critical flows. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Integration with modConfig and modAudit</strong><br>1. <code>modConfigUI</code> delegates validation to <code>modConfig.ValidateConfig()</code> and uses <code>modConfig.PersistConfigSnapshot</code> to store snapshots. <br>2. All change commits call <code>modConfig.LoadConfig(env)</code> to refresh in-memory config and then call <code>modCoreEngine</code> or other modules as required to pick up new config. <br>3. Every UI-initiated action is recorded via <code>modAudit.AppendAuditRow</code> using <code>AuditConfigChange</code> helper for consistent structure. <br>4. When applying changes that affect behavior of long-running runs (e.g., BatchSize, MaxFuzzyComparisonsPerRow), <code>modConfigUI</code> triggers a <code>ConfigChangeWarning</code> that is stored in telemetry and optionally displayed to active operators. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Power Query (PQ) conceptual flows & examples</strong><br>1. <strong>Ingesting Macro_ChangeLog into PQ for BI</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;a) Source: exported CSV/ndjson from <code>ExportConfigToJSON</code> or workbook <code>Macro_ChangeLog</code> worksheet. <br>&nbsp;&nbsp;&nbsp;&nbsp;b) Use <code>Json.Document</code> to parse nested <code>beforeSnapshot</code> and <code>afterSnapshot</code> JSON fields. <br>&nbsp;&nbsp;&nbsp;&nbsp;c) Expand snapshots to relational columns <code>AutoApplyThreshold</code>, <code>ReviewerThreshold</code>, <code>BatchSize</code>, etc. <br>&nbsp;&nbsp;&nbsp;&nbsp;d) Create <code>ChangeDelta</code> computed columns using <code>if before &lt;&gt; after then 1 else 0</code> to quickly quantify number of keys changed per changeId. <br>&nbsp;&nbsp;&nbsp;&nbsp;e) Output: <code>ConfigChanges</code> table for BI with columns: <code>changeId</code>, <code>changedBy</code>, <code>changeTime</code>, <code>numKeysChanged</code>, <code>impactNotes</code>. <br>2. <strong>Training dataset join</strong>:<br>&nbsp;&nbsp;&nbsp;&nbsp;a) Join <code>ConfigChanges</code> with <code>FuzzyAudit</code> or <code>RunMetrics</code> by date to analyze effect of config changes on metrics like <code>AutoApplyRate</code> or <code>AvgGoalSeekAttempts</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;b) Example PQ step: after expanding <code>before</code>/<code>after</code>, add <code>AppliedOn</code> and perform <code>Group By</code> <code>AppliedOn</code> to compute pre/post metric deltas. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Conceptual DAX measures (recommended)</strong><br>After ingesting <code>ConfigChanges</code> and relevant run metrics into a Power BI model, these DAX measures help monitor and explain config impact:<br>1. <code>ConfigChangeCount = COUNTROWS(ConfigChanges)</code>.<br>2. <code>AvgKeysChangedPerConfig = AVERAGE(ConfigChanges[NumKeysChanged])</code>.<br>3. <code>AutoApplyDelta = CALCULATE([AutoApplyRate], FILTER(Runs, Runs[Date] &gt;= EARLIER(ConfigChanges[AppliedOn]) &amp;&amp; Runs[Date] &lt; EARLIER(ConfigChanges[AppliedOn])+1)) - CALCULATE([AutoApplyRate], FILTER(Runs, Runs[Date] &lt; EARLIER(ConfigChanges[AppliedOn]) ))</code> — show short-term delta in AutoApplyRate after config change. <br>4. <code>ReviewerLoadAtChange = CALCULATE([ReviewerQueueDepth],Runs, Runs[Date] = ConfigChanges[AppliedOn])</code>. <br>5. <code>ConfigRiskScore = SUMX(ConfigChanges[ChangedKeys], RELATED(RiskWeight[Key]))</code> — where <code>RiskWeight</code> is a small lookup table assigning weights to keys. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Testing & acceptance criteria (detailed)</strong><br>1. Unit tests for UI bindings: ensure <code>RenderConfigSheet</code> correctly reflects the values from <code>modConfig.LoadConfig</code> for each env and that UI control state matches <code>UserRoles</code>. <br>2. Validation tests: create malformed edits (e.g., <code>AutoApplyThreshold=1.2</code>, negative <code>BatchSize</code>) and assert <code>ValidateAndPreviewChanges</code> returns expected errors and does not allow Apply. <br>3. Approval tests: verify <code>ApplyConfigChanges</code> places changes into <code>AWAITING_APPROVAL</code> when a high-risk key changed and that <code>OpenConfigApprovalDialog</code> accepts/rejects properly. <br>4. Export/Import tests: round-trip <code>ExportConfigToJSON</code> then <code>ImportConfigFromJSON(previewOnly=False)</code> and verify config parity and correct <code>Macro_ChangeLog</code> entries. <br>5. Revert test: after applying a change, <code>RevertConfigToSnapshot</code> shall restore previous values and write <code>REVERT</code> audit with forensic bundle. <br>6. Security test: ensure non-admin cannot reveal secrets; secret reveal requires admin role and additional confirmation. <br>7. Integration test: Changing <code>AutoApplyThreshold</code> triggers recalculation in a dry-run <code>SimulateRunPreview</code> and produces changed reviewer counts in the simulation output. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Operational runbook snippets (how to use in practice)</strong><br>1. <strong>Small change (safe):</strong> Operator opens <code>RenderConfigSheet</code> → <code>BeginEditConfig</code> → change <code>Telemetry.UploadInterval</code> → <code>Preview</code> → <code>Apply</code> (no sign-off) → confirm <code>Macro_ChangeLog</code> entry created. <br>2. <strong>High-risk change (policy):</strong> Admin edits <code>ReviewerHighDollarThreshold</code> → <code>Preview</code> shows <code>requireSignOff=True</code> → <code>Apply</code> moves to <code>AWAITING_APPROVAL</code> → Reviewer receives UI prompt and approves → system applies and sends <code>ExportConfigToJSON</code> to central store. <br>3. <strong>Emergency revert:</strong> Operator detects issue post-change → open <code>History</code> → select <code>snapshotId</code> → <code>Revert</code> → require dual approval if <code>MaterialFlag</code> present → revert executed and <code>ForensicPack</code> created. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Change governance & CI/CD hooks</strong><br>1. Pre-commit hook: repository must run <code>modTestingHarness.RunRegressionSuite</code> for config UI changes and ensure <code>RenderConfigSheet</code> does not introduce references to missing named ranges. <br>2. Release pipeline: produce signed workbook artifact and include <code>Macro_ChangeLog</code> diff for config defaults; store <code>__Run_Config</code> snapshot in release notes. <br>3. Post-deploy smoke: <code>AutoSmokeTests()</code> ensure <code>RenderConfigSheet</code> loads and that <code>BeginEditConfig</code> creates sandbox correctly. <br>4. Promotion flow: <code>ExportConfigToJSON</code> for dev → CI validation → <code>ImportConfigFromJSON</code> into test with <code>previewOnly=True</code> to ensure no schema mismatches; after approval apply in test then promote to prod. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Edge cases & mitigations</strong><br>1. <strong>Stale edits conflict:</strong> Two admins edit overlapping keys concurrently — mitigation: <code>BeginEditConfig</code> warns on overlap and provides a 3-way merge preview showing <code>commonKeys</code> and requires explicit resolution. <br>2. <strong>Large secret exports:</strong> If admin tries to export secrets to an insecure path, <code>ExportConfigToJSON</code> rejects the operation with <code>SECURITY_POLICY_VIOLATION</code> unless override with <code>AdminTwoFactor</code>. <br>3. <strong>Schema drift:</strong> Imported JSON contains unknown keys — treat as warnings and require admin ack before writing unknown keys into <code>__Config</code> to avoid silent acceptance of typos. <br>4. <strong>Networked external scorer validation failure:</strong> When <code>ExternalScorerUrl</code> unreachable during preview, mark <code>externalScorerStatus=UNAVAILABLE</code> and allow import but set <code>impactSummary</code> and <code>warnings</code> accordingly. <br>5. <strong>Disk/full workbook:</strong> On apply, if workbook cannot persist due to disk errors or locked file, write <code>APPLY_FAILED</code> to local <code>__Diagnostics</code> and keep <code>sessionId</code> for retry; alert operator. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Examples & conceptual narratives</strong><br>Example 1 — Tuning Auto-apply Threshold:<br>&nbsp;&nbsp;&nbsp;&nbsp;• Admin opens <code>RenderConfigSheet</code>, <code>BeginEditConfig</code>, changes <code>AutoApplyThreshold</code> from <code>0.88</code> to <code>0.90</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• <code>ValidateAndPreviewChanges</code> runs <code>ProfileFuzzyComparisons</code> to estimate <code>AutoApplyPrecision</code> at <code>0.90</code> and shows expected reviewer load decreased by X rows. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Admin chooses <code>Apply</code> → because threshold change is not high-risk, commit occurs with <code>Macro_ChangeLog</code> entry; telemetry shows immediate drop in <code>ReviewQueueDepth</code> on next runs. <br>Example 2 — Enabling External Scorer (risky):<br>&nbsp;&nbsp;&nbsp;&nbsp;• Admin imports JSON with <code>ExternalScorerUrl</code> and credentials placeholders. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Preview shows <code>ExternalScorer</code> unreachable in test ping; because config includes new external dependency <code>requireSignOff=True</code>, change goes to <code>AWAITING_APPROVAL</code> and must be signed off by security team. <br>&nbsp;&nbsp;&nbsp;&nbsp;• On approval, UI runs <code>ExportConfigToJSON</code> and makes signed artifact available to integration team. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Conceptual Power Query (PQ) examples (detailed)</strong><br>1. <strong>Config change analysis PQ steps:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;a) Source: export <code>Macro_ChangeLog</code> CSV produced monthly by <code>modConfigUI</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;b) Parse JSON columns <code>beforeSnapshot</code> and <code>afterSnapshot</code> using <code>Json.Document</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;c) Expand to columns and pivot keys to create a <code>KeyChanges</code> normalized table with <code>changeId</code>, <code>keyName</code>, <code>oldValue</code>, <code>newValue</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;d) Join <code>KeyChanges</code> with <code>RunMetrics</code> on date window to compute <code>deltaAutoApplyRate</code> and <code>deltaReviewerLoad</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;e) Build a visual showing the top-10 keys by <code>configRiskScore</code> and their post-change KPI deltas. <br>2. <strong>Training/Model drift PQ flow:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;a) Ingest <code>FuzzyAudit</code> and <code>ConfigChanges</code> into PQ; align by date and changeId. <br>&nbsp;&nbsp;&nbsp;&nbsp;b) Produce a dataset where each row is <code>changeId</code> with features: <code>numKeysChanged</code>, <code>numHighRiskKeys</code>, <code>preAutoApplyRate</code>, <code>postAutoApplyRate</code>, <code>deltaPrecision</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;c) Export dataset for model monitoring to detect config changes that cause drift. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Conceptual DAX examples (expanded)</strong><br>1. <code>ConfigImpactAvgDelta = AVERAGEX( ConfigChanges, [PostMetric] - [PreMetric] )</code> — average metric delta after changes. <br>2. <code>HighRiskChangeCount = COUNTROWS(FILTER(ConfigChanges, ConfigChanges[RiskScore] &gt; 0.7))</code> — monitor dangerous changes. <br>3. <code>TimeToApproveAvg = AVERAGE( DATEDIFF(ConfigChanges[submittedAt], ConfigChanges[approvedAt], HOUR) )</code> — governance SLA for approvals. <br>4. <code>ConfigChangeAdoption = DIVIDE(COUNTROWS(FILTER(Runs, Runs[ConfigVersion] = EARLIER(ConfigChanges[ConfigVersion]))), COUNTROWS(Runs))</code> — measure how quickly runs use the new config. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Troubleshooting & diagnostics</strong><br>1. <strong>UI not rendering / missing named ranges:</strong> <code>RenderConfigSheet</code> writes <code>UI_RENDER_FAILED</code> to <code>__Diagnostics</code> with error codes; recommended steps: run <code>modTestingHarness.AutoSmokeTests()</code> and ensure workbook named ranges exist. <br>2. <strong>Apply failing with file IO error:</strong> check disk/SharePoint permissions; the module writes <code>APPLY_FAILED</code> and retains <code>__Config_Edit_&lt;sessionId&gt;</code> so operator can reattempt; use <code>RevertConfigToSnapshot</code> to restore safe state if needed. <br>3. <strong>Approval stuck:</strong> check <code>__ApprovalQueue</code> sheet for orphaned approvals; ability to force-accept requires <code>AdminOverride</code> and will be recorded in <code>Macro_ChangeLog</code> with justification. <br>4. <strong>Import signature mismatch:</strong> <code>ImportConfigFromJSON</code> rejects unsigned imports if policy requires signature — check <code>manifest.signature</code> and contact signing team. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Developer guidance (implementation notes)</strong><br>1. Keep UI logic and core persistence separated: <code>modConfigUI</code> must call <code>modConfig</code> for reading/validation and <code>modAudit</code> for appended logs. <br>2. Use Scripting.Dictionary consistently for data interchange between UI and core engine to limit COM marshalling cost. <br>3. Avoid writing to <code>Audit_Log</code> in tight loops; batch up audit rows into <code>__Audit_Buffer</code> and flush on chunk commit. <br>4. Protect secret fields with masked UI and require two-step explicit reveal. <br>5. Use <code>Option Explicit</code> and consistent naming <code>cfgKey_</code> prefix for all named ranges. <br>6. Keep unit tests for <code>ValidateAndPreviewChanges</code> deterministic: test with fixed sample snapshots and expected diffs. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Acceptance criteria (for release)</strong><br>1. <code>RenderConfigSheet</code> loads and shows correct values for dev/test/prod envs. <br>2. <code>BeginEditConfig</code> creates sandbox and <code>ValidateAndPreviewChanges</code> returns accurate diffs. <br>3. <code>ApplyConfigChanges</code> persists snapshot and writes <code>Macro_ChangeLog</code> and <code>Audit_Log</code> entries; revert works and generates forensic pack. <br>4. Approval gating correctly blocks high-risk keys and requires reviewer sign-off. <br>5. Export/Import round-trip yields identical config when signatures and secrets handled according to policy. <br>6. All critical UI actions produce telemetry events for monitoring. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Change log & versioning guidance</strong><br>1. Store <code>modConfigUI</code> version and <code>explainVersion</code> in every snapshot for reproducibility. <br>2. On breaking UI changes (rename keys, change validation logic), include migration scripts under <code>modMigration</code> and update <code>__Migration_History</code>. <br>3. Maintain golden UI test dataset for <code>AutoSmokeTests</code> to detect regressions in UI rendering and permissions. </td></tr><tr><td data-label="Per-function technical breakdown — modConfigUI (VBA)"> <strong>Final operational checklist for admins</strong><br>1. Always run <code>ValidateAndPreviewChanges</code> before <code>Apply</code>. <br>2. When in doubt about signature/secret export, export with <code>includeSecrets=False</code> and provide separate secure secret handover. <br>3. Use <code>ListConfigSnapshots</code> to tag snapshots before major runs as a pre-change safety net. <br>4. Keep <code>Macro_ChangeLog</code> review as part of deployment checklist and archive signed artifacts in central repository. </td></tr></tbody></table></div><div class="row-count">Rows: 31</div></div><div class="table-caption" id="Table2" data-table="Docu_0204_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Per-function technical breakdown — **modTelemetry** (VBA)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Per-function technical breakdown — <strong>modTelemetry</strong> (VBA)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Module purpose (short)</strong><br><code>modTelemetry</code> provides the instrumentation, buffering, export, privacy controls, and lightweight alerting required to observe, measure, and improve UpdateHR+. It centralises event capture for runs, GoalSeek attempts, scoring engine behaviour, external helper reliability, and performance. It also provides safe export formats for Power Query/BI, retains telemetry for local troubleshooting, and supports optional push to an external telemetry API with circuit-breaker behaviour. The module is intentionally small on privilege: it does not mutate business data, only writes to telemetry sheets and produces export artifacts. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Design principles & constraints</strong><br>1. Separation of concerns: telemetry capture is orthogonal to business logic; all other modules call <code>modTelemetry</code> rather than writing telemetry themselves. <br>2. Minimal PII: telemetry must avoid storing raw PII unless explicitly allowed via config; when needed, PII must be hashed/salted and the salt stored only in <code>__Run_Config</code> with restricted admin access. <br>3. In-run buffering: to reduce sheet writes and COM overhead, <code>modTelemetry</code> buffers events in memory and flushes periodically or on chunk commit. <br>4. Idempotency & sequence: events carry <code>telemetrySeq</code> per-runId to allow deduplication and replay ordering. <br>5. Fail-safe: if the external telemetry endpoint is unavailable, <code>modTelemetry</code> persists telemetry locally and marks events <code>unsent</code> for later flush; it must not block business processing. <br>6. Audit linkability: every telemetry record includes <code>runId</code>, <code>rowId</code> (if applicable), <code>codeVersion</code> and <code>configVersion</code> for traceability. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>High-level responsibilities</strong><br>1. Capture structured telemetry points from all modules: run-level, row-level, GS attempts, matching timings, external scorer results, errors, and UI actions. <br>2. Buffer telemetry and persist to <code>__Telemetry</code> sheet in batches. <br>3. Export telemetry to CSV/ndjson for PQ ingestion or push to external API with retries and backoff. <br>4. Provide summary metrics and sampling functions for dashboards. <br>5. Anonymize/hashing utilities to protect PII. <br>6. Simple alerting thresholds and health checks for operations. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Public surface (functions summary)</strong><br>1. <code>RecordTelemetryPoint(category As String, metrics As Scripting.Dictionary)</code> — primary in-memory capture API for other modules. <br>2. <code>FlushTelemetry(runId As String, Optional force As Boolean = False)</code> — flush buffer to <code>__Telemetry</code> sheet and optionally push to external endpoint. <br>3. <code>FlushTelemetryToExternal(endpointUrl As String, apiKey As String, Optional batchSize As Long)</code> — push persisted telemetry to endpoint with circuit-breaker. <br>4. <code>TelemetrySummary(startDate As Date, endDate As Date, Optional runId As String)</code> — compute aggregated metrics for PQ/UI. <br>5. <code>ComputeTelemetryMetrics(runId As String) As Scripting.Dictionary</code> — compute derived metrics (avg timings, failure rates). <br>6. <code>ExportTelemetry(runId As String, format As String, destPath As String)</code> — create CSV / NDJSON artifact for ingestion. <br>7. <code>AnonymizeTelemetryRecord(record As Scripting.Dictionary, options As Scripting.Dictionary) As Scripting.Dictionary</code> — hash or redact PII fields per policy. <br>8. <code>InitTelemetry(runId As String, config As Scripting.Dictionary)</code> — init in-memory buffer, sequence counters, and config from <code>modConfig</code>. <br>9. <code>TelemetryHealthCheck()</code> — internal health check for telemetry system (buffer sizes, queue length, external endpoint health). <br>10. <code>RegisterAlertRule(ruleId As String, ruleDefinition As Scripting.Dictionary)</code> — add operational alerting rule (e.g., <code>GS_TIMEOUT_RATE&gt;2%</code>). <br>11. <code>EvaluateAlerts(runId As String)</code> — evaluate alert rules against recent telemetry and raise events into <code>Audit_Log</code> or <code>__Telemetry_Alerts</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: InitTelemetry</strong><br>Purpose: initialise telemetry state for a run and load telemetry-specific config.<br>Inputs: <code>runId</code>, <code>config</code> dictionary (contains <code>TelemetryEndpoint</code>, <code>BatchSize</code>, <code>FlushIntervalSec</code>, <code>HashSaltRef</code>, <code>TelemetryRetentionDays</code>, <code>AnonymizePII</code>).<br>Behavior & operational notes:<br>1. Allocate in-memory buffer (Collection or dynamic array) and set <code>telemetrySeq = 0</code>. <br>2. Load <code>HashSaltRef</code> from <code>__Run_Config</code> if <code>AnonymizePII=True</code>. <br>3. Start <code>lastFlushTime = NowUTC</code> and configure <code>FlushIntervalSec</code> default (e.g., 30s or chunk commit triggered). <br>4. Validate <code>TelemetryEndpoint</code> format but do not test connectivity synchronously (non-blocking). <br>Audit contract: write <code>TELEMETRY_INIT</code> event to <code>__Telemetry</code> immediately with config snapshot (anonymize as needed). </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: RecordTelemetryPoint</strong><br>Purpose: canonical single-way to record metrics and events for the run.<br>Signature: <code>RecordTelemetryPoint(category As String, metrics As Scripting.Dictionary)</code>.<br>Core contract and recommended fields in <code>metrics</code>:<br> - <code>runId</code> (string) — optional (module may set if not provided).<br> - <code>rowId</code> (long) — optional for per-row events.<br> - <code>eventType</code> (string) — e.g., <code>GS_ATTEMPT</code>, <code>MATCH_SCORE</code>, <code>EXTERNAL_SCORER_CALL</code>, <code>UI_ACTION</code>, <code>ERROR</code>.<br> - <code>timestamp</code> (UTC iso) — if not provided module sets <code>NowUTC</code>.<br> - <code>durationMs</code> — numeric timing for operation.<br> - <code>details</code> — short string status or small dictionary for extra keys (consistent shapes encouraged).<br>Behavior:<br>1. Validate <code>category</code> non-empty and metrics typed correctly. <br>2. Increment <code>telemetrySeq</code> and attach <code>seq</code> and <code>codeVersion</code>/<code>configVersion</code>. <br>3. If <code>AnonymizePII</code> true, call <code>AnonymizeTelemetryRecord</code> to hash name/id fields. <br>4. Append to in-memory buffer; if buffer size > <code>BatchSize</code> or <code>NowUTC - lastFlushTime &gt; FlushIntervalSec</code>, call <code>FlushTelemetry</code> (non-blocking pattern; see flush notes). <br>5. Return <code>telemetryId</code> (composed <code>runId</code> + seq) for trace referencing. <br>Edge policies: if buffer memory exceed safe limit, persist immediately to <code>__Telemetry</code> and clear buffer; write a warning telemetry event documenting persistence fallback. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: FlushTelemetry</strong><br>Purpose: persist in-memory buffer to workbook sheet <code>__Telemetry</code> and optionally trigger external push.<br>Signature: <code>FlushTelemetry(Optional force As Boolean = False) As Long</code> — returns number of rows flushed.<br>Behavior:<br>1. If buffer empty and not <code>force</code>, return 0. <br>2. Batch write to <code>__Telemetry</code> sheet in a single Range.Value assignment; ensure column schema stable: <code>telemetryId, runId, seq, category, eventType, rowId, timestamp, durationMs, metricsJson, sentFlag, sentAt</code>.<br>3. After write, update <code>lastFlushTime</code> and reset in-memory buffer. <br>4. If <code>TelemetryEndpoint</code> configured, call <code>FlushTelemetryToExternal</code> in background fashion — but since VBA cannot spawn threads, <code>FlushTelemetryToExternal</code> must be non-blocking: it attempts synchronous push but with short <code>connectTimeout</code> and returns quickly; if push fails it marks rows <code>unsent</code> with <code>attempts</code> count and leaves them for later flush. <br>5. Return number of rows persisted. <br>Important: to avoid expensive COM round-trips write an array of variant arrays to the sheet instead of row-by-row writes. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: FlushTelemetryToExternal</strong><br>Purpose: push persisted telemetry artifacts to an external telemetry ingestion endpoint with resilience.<br>Signature: <code>FlushTelemetryToExternal(endpointUrl As String, apiKey As String, Optional batchSize As Long)</code>.<br>Behavior and resilience patterns:<br>1. Query <code>__Telemetry</code> for <code>sentFlag=0</code> rows ordered by <code>seq</code> and take up to <code>batchSize</code>. <br>2. Construct ndjson payload where each line is telemetry JSON; include <code>manifest</code> metadata when first batch for a run. <br>3. Use <code>WinHttp</code> or <code>MSXML2.ServerXMLHTTP</code> with a short connect timeout (configurable in modConfig). <br>4. Implement retry with incremental backoff: on HTTP 5xx retry up to <code>maxRetries</code>, on 429 honour <code>Retry-After</code> if returned, on network failure mark as <code>attempts++</code> and backoff. <br>5. Circuit-breaker: maintain <code>failureCount</code> and if failures exceed <code>circuitThreshold</code> within <code>circuitWindowSec</code>, set <code>circuitOpen = True</code> and skip attempts for <code>circuitCooldownSec</code>. Log <code>TELEMETRY_ENDPOINT_TRIPPED</code> event and surface to <code>__Telemetry_Alerts</code>. <br>6. On success mark rows <code>sentFlag=1</code> and set <code>sentAt</code>. Optionally write response <code>receiptId</code> from server into <code>sentReceipt</code> column. <br>Security: send via TLS; include <code>apiKey</code> in <code>Authorization</code> header; avoid PII in payload unless hashed and permitted. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: TelemetrySummary</strong><br>Purpose: produce an aggregated summary for UI and PQ ingestion.<br>Signature: <code>TelemetrySummary(startDate As Date, endDate As Date, Optional runId As String) As Scripting.Dictionary</code>.<br>Aggregates produced:<br> - <code>totalEvents</code> — total telemetry rows in period.<br> - <code>eventsByCategory</code> — dictionary counts per category.<br> - <code>avgDurationByEventType</code> — average durations for types like <code>MATCH_SCORE</code>, <code>GS_ATTEMPT</code>. <br> - <code>failureRates</code> — fraction of <code>ERROR</code> events over all events and specific failure types (e.g., <code>GS_TIMEOUT_RATE</code>). <br> - <code>externalScorerUptime</code> — derived from success/failure events for external scorer. <br> - <code>telemetryLagSeconds</code> — median time between event <code>timestamp</code> and <code>sentAt</code> for pushed rows. <br>Implementation notes: compute using <code>Range</code> read into memory and aggregate via dictionaries to avoid many cross-calls. Provide outputs formatted for direct PQ consumption (flat key-value rows) and return also as Scripting.Dictionary for calling VBA UI. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: ComputeTelemetryMetrics</strong><br>Purpose: compute derived metrics used for dashboards and gates.<br>Signature: <code>ComputeTelemetryMetrics(runId As String) As Scripting.Dictionary</code>.<br>Derived metrics include:<br> - <code>AvgMatchTimeMs</code> — average time taken by matching per row.<br> - <code>MedianGSAttempts</code> — median attempts across GoalSeek events. <br> - <code>PctGSConverged</code> — proportion of GS attempts survived with <code>Status=CONVERGED</code>. <br> - <code>AutoApplyPrecisionEstimate</code> — estimated precision of auto-applied rows if ground truth available. <br> - <code>ExternalScorerErrorRate</code> — percent of <code>EXTERNAL_SCORER_CALL</code> marked failed. <br> - <code>TelemetryFlushRate</code> — average rows flushed per minute. <br>Notes: return dictionary with numeric values and also small diagnostic arrays (e.g., slowest N events). Use robust statistics to handle outliers. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: ExportTelemetry</strong><br>Purpose: produce canonical export artifacts for BI ingestion or archive.<br>Signature: <code>ExportTelemetry(runId As String, format As String, destPath As String) As Boolean</code>.<br>Behavior:<br>1. Supported formats: <code>CSV</code>, <code>NDJSON</code>, <code>ZIP</code> (pack with manifest). <br>2. Exports must be idempotent: use canonical ordering (runId, seq) and stable column sets. <br>3. Include <code>manifest.json</code>: <code>runId</code>, <code>exportedAt</code>, <code>codeVersion</code>, <code>configSnapshotRef</code>, <code>rowCount</code>, <code>fileChecksum</code>. <br>4. Compute a simple checksum (CRC32 or VBA-based) and write into manifest; if high-integrity hashes needed, recommend external signing process. <br>Usage: production pipeline reads ndjson via PQ <code>Json.Document</code> or CSV via PQ <code>Csv.Document</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: AnonymizeTelemetryRecord</strong><br>Purpose: apply hashing/redaction policy to PII fields in a telemetry dictionary before persistence.<br>Signature: <code>AnonymizeTelemetryRecord(record As Scripting.Dictionary, options As Scripting.Dictionary) As Scripting.Dictionary</code>.<br>Policy options and behavior:<br>1. <code>options(&quot;hashPII&quot;) = True</code> — hash fields <code>userId</code>, <code>employeeName</code>, <code>employeeId</code> with salted SHA1 or HMAC-SHA256 if helper available; store <code>piiHash</code> but drop raw values. <br>2. <code>options(&quot;redactFields&quot;)</code> — list of fields to redact entirely. <br>3. <code>options(&quot;keepPartial&quot;)</code> — e.g., keep last-4 digits for ids, or only store domain part of email. <br>4. <code>options(&quot;saltRef&quot;)</code> — pointer to secret salt retrieved by <code>modUtilities.GetSecret</code>. <br>Logs: append a short <code>PII_REDAC</code> telemetry event recording which PII fields redacted and which saltRef used (but do not include salt). </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: TelemetryHealthCheck</strong><br>Purpose: quick operational checks that can be wired into the Operator UI.<br>Checks performed:<br> - Buffer size < threshold. <br> - Unsent persisted rows count. <br> - Circuit state for external endpoint. <br> - Rate of new telemetry events per minute compared to expected (spike detection). <br>Outputs: <code>status</code> (<code>OK</code>, <code>WARN</code>, <code>CRITICAL</code>) plus <code>details</code> dictionary. <br>On <code>CRITICAL</code> produce <code>__Telemetry_Alerts</code> row and optional popup in <code>frmOperatorUI</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Function: RegisterAlertRule / EvaluateAlerts</strong><br>Purpose: admin-defined alerting rules and on-demand evaluation.<br>Rule specification (ruleDefinition) fields include:<br> - <code>metric</code> (string) e.g., <code>GS_TIMEOUT_RATE</code>.<br> - <code>windowSec</code> e.g., 600 (10 minutes). <br> - <code>threshold</code> numeric or expression. <br> - <code>severity</code> (<code>WARN</code>, <code>CRITICAL</code>). <br>Rules are stored in <code>__Telemetry_Rules</code> sheet and evaluated by <code>EvaluateAlerts</code> which aggregates metrics from <code>__Telemetry</code> for the configured window and writes triggered alerts into <code>__Telemetry_Alerts</code> with <code>alertId</code>, <code>ruleId</code>, <code>metricValue</code>, <code>triggeredAt</code>, <code>runId</code>, <code>contextSample</code> (first few offending telemetry rows). Alerts may optionally create <code>Audit_Log</code> entries if <code>ruleDefinition(&quot;escalateToAudit&quot;)=True</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Telemetry schema (recommended persistent columns)</strong><br>1. <code>telemetryId</code> (string) — <code>runId_seq</code> unique key. <br>2. <code>runId</code> (string). <br>3. <code>seq</code> (long). <br>4. <code>category</code> (string) — e.g., <code>match</code>, <code>gs</code>, <code>external</code>, <code>ui</code>, <code>error</code>. <br>5. <code>eventType</code> (string). <br>6. <code>rowId</code> (long, nullable). <br>7. <code>timestampUtc</code> (iso string). <br>8. <code>durationMs</code> (double, nullable). <br>9. <code>metricsJson</code> (text) — small JSON object for extra fields. <br>10. <code>sentFlag</code> (0/1). <br>11. <code>sentAtUtc</code> (iso string, nullable). <br>12. <code>attempts</code> (int) — external push attempts. <br>13. <code>sentReceipt</code> (string, nullable) — external server receipt id. <br>14. <code>rowChecksum</code> (string) — small checksum for integrity. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Power Query (PQ) conceptual ingestion recipe</strong><br>1. <strong>Source</strong>: export NDJSON/CSV created by <code>ExportTelemetry</code> or direct CSV export of <code>__Telemetry</code> sheet. <br>2. <strong>Parse</strong>: when NDJSON use <code>Json.Document</code> to parse each line; when CSV use <code>Csv.Document</code>. <br>3. <strong>Expand <code>metricsJson</code></strong>: use <code>Json.Document</code> again to expand nested <code>metricsJson</code> into columns such as <code>eventTypeDetails</code>, <code>externalStatus</code>. <br>4. <strong>Time conversions</strong>: convert <code>timestampUtc</code> to local time zone if needed; create <code>eventDate</code> and <code>eventHour</code> columns for aggregation. <br>5. <strong>Aggregations</strong>: compute <code>AvgDurationByEventType</code>, <code>FailureRates</code>, and time-windowed metrics for alerts. <br>6. <strong>Model output</strong>: produce <code>TelemetrySummaryTable</code> with fields <code>runId, eventDate, eventType, totalEvents, avgDurationMs, failureRate</code>. <br>7. <strong>Training exports</strong>: prepare ML feature table by joining <code>Telemetry</code> with <code>Audit_Log</code> via <code>runId,rowId</code>. <br>Notes: ensure PQ steps are deterministic and documented in the workbook so future runs produce stable artifacts. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Conceptual DAX measures for telemetry dashboards</strong><br>1. <code>TotalTelemetryEvents = COUNTROWS(&#x27;Telemetry&#x27;)</code>.<br>2. <code>AvgMatchDurationMs = AVERAGE(&#x27;Telemetry&#x27;[durationMs])</code> with filter <code>Telemetry[eventType]=&quot;MATCH_SCORE&quot;</code>. <br>3. <code>GsTimeoutRate = DIVIDE(CALCULATE(COUNTROWS(&#x27;Telemetry&#x27;),Telemetry[eventType]=&quot;GS_ATTEMPT&quot;,Telemetry[metricsJson].Status=&quot;TIMEOUT&quot;), CALCULATE(COUNTROWS(&#x27;Telemetry&#x27;),Telemetry[eventType]=&quot;GS_ATTEMPT&quot;))</code>. <br>4. <code>ExternalScorerUptime = 1 - DIVIDE([ExternalScorerFailures],[ExternalScorerRequests])</code> where failures and requests are computed via filtered measures. <br>5. <code>TelemetryLagSeconds = AVERAGE(DATEDIFF(&#x27;Telemetry&#x27;[timestampUtc],&#x27;Telemetry&#x27;[sentAtUtc],SECOND))</code>. <br>Use these measures in operational dashboards and set report-level filters to adjust windows. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Alerting examples & recommended thresholds (configurable)</strong><br>1. <code>GS_TIMEOUT_RATE &gt; 2% over 1 hour</code> → severity <code>WARN</code>. <br>2. <code>GS_TIMEOUT_RATE &gt; 5% over 15 minutes</code> → severity <code>CRITICAL</code> and escalate to reviewer. <br>3. <code>ExternalScorerErrorRate &gt; 1% for 15 minutes</code> → <code>WARN</code> and flip circuit-breaker open. <br>4. <code>TelemetryQueueLength &gt; BatchSize * 5</code> → <code>WARN</code>, suggests backlog. <br>Each rule stored with <code>owner</code> and <code>escalation contact</code> in <code>__Telemetry_Rules</code>. Alerts write to <code>__Telemetry_Alerts</code> and can trigger <code>Audit_Log</code> entries for governance. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Operational retention & GDPR-like concerns</strong><br>1. <code>TelemetryRetentionDays</code> default 90 days. <br>2. Provide <code>PurgeTelemetryOlderThan(date)</code> to delete older rows; this function should be admin-only and write a <code>PURGE</code> audit entry. <br>3. For GDPR/requests, <code>FindAndRedactPIIByHash(hash)</code> to locate telemetry rows referencing a hashed identifier; provide export for compliance. <br>4. When <code>AnonymizePII=True</code> by default telemetry never contains raw personal identifiers; only hashed tokens that can be reversed only with internal, restricted salts. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Integration patterns (external telemetry)</strong><br>1. Preferred external endpoints: aggregated telemetry ingestion APIs (ndjson / batch POST) that return <code>receiptId</code> and status per record. <br>2. Authentication: support <code>Bearer</code> tokens and rotation; store token reference in <code>__Run_Config</code> rather than raw in sheet; <code>modUtilities.GetSecret</code> retrieves securely where possible. <br>3. Backfill: on outage, <code>FlushTelemetryToExternal</code> supports <code>retries</code> and <code>backfill</code> mode that slices historical <code>unsent</code> rows by time windows and pushes them when endpoint healthy. <br>4. Rate limiting: if <code>429</code> received, read <code>Retry-After</code> header and delay next attempts; log <code>RATE_LIMIT</code> telemetry event. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Performance & scaling considerations</strong><br>1. Bulk write to sheet: always write an array of variant arrays to minimize COM calls. <br>2. Buffer sizing: default <code>BatchSize</code> 200–2000 depending on expected row width; tune for workbook size and CPU. <br>3. Avoid heavy JSON marshalling per row in inner loops: serialize <code>metricsJson</code> using a compact method and only when flushing. <br>4. Memory safety: limit in-memory buffer to <code>MaxBufferedRows</code> and force disk flush when reached. <br>5. External push: keep synchronous pushes short with <code>connectTimeout</code> and <code>sendTimeout</code> to avoid blocking UI. Prefer push during quiet periods (post-chunk commit) rather than during tight inner loops. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Testing checklist (unit & integration)</strong><br>Unit tests to include:<br>1. <code>RecordTelemetryPoint</code> sequence numbering and basic field validation, ensure seq monotonicity. <br>2. Mock <code>FlushTelemetry</code> to verify sheet writes in correct schema and all buffer items persisted. <br>3. <code>AnonymizeTelemetryRecord</code> hashing determinism: same PII and same salt produce same hash. <br>4. <code>RecommendThresholds</code> integration: ensure <code>TelemetrySummary</code> computed correctly from sample telemetry. <br>Integration tests:<br>1. Simulated external endpoint returning 200, 500, 429 to validate retry/backoff and circuit-breaker. <br>2. Large-run stress test: 50k telemetry events — verify memory bounds and final persisted counts. <br>3. GDPR test: redact sample hashed PII and verify deletion. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Troubleshooting guidance (common issues & remediation)</strong><br>1. <strong>Symptom:</strong> Telemetry queue length grows and not flushed.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Check <code>lastFlushTime</code>, <code>FlushIntervalSec</code>, and whether <code>FlushTelemetryToExternal</code> is failing with circuit open. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Inspect <code>__Telemetry_Alerts</code> for <code>TRIPPED</code> events. <br>2. <strong>Symptom:</strong> External endpoint returns 401/403.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Verify <code>apiKey</code> rotation and token stored in <code>__Run_Config</code>. <br>3. <strong>Symptom:</strong> Telemetry contains raw names unexpectedly.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Validate <code>modConfig.AnonymizePII</code> and re-run <code>AnonymizeTelemetryRecord</code> on persisted rows; run audit to find offending modules. <br>4. <strong>Symptom:</strong> PQ ingest fails to parse <code>metricsJson</code>.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Verify <code>ExportTelemetry</code> used NDJSON with one JSON per line; ensure no trailing commas and consistent property ordering if PQ steps expect keys. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Operational runbook snippets</strong><br>1. Daily checks: run <code>TelemetryHealthCheck</code>, review <code>__Telemetry_Alerts</code>, check <code>AvgCompareTimeMs</code> and <code>ExternalScorerUptime</code>. <br>2. If <code>GS_TIMEOUT_RATE</code> rises above threshold, set <code>modConfig.GS_TimeoutSec</code> higher temporarily and investigate function shape / dataset anomalies. <br>3. On telemetry endpoint outage: set <code>TelemetryEndpoint</code> to blank (pause pushes), ensure persisted telemetry copies are backed up (export NDJSON) and follow <code>Backfill</code> plan when endpoint recovers. <br>4. Quarterly: run <code>ProfileFuzzyComparisons</code> and update fuzzy thresholds in <code>modConfig</code> if drift observed. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Example telemetry event narrative (auditable)</strong><br>Event: GoalSeek attempt for <code>runId=abc</code>, <code>rowId=345</code> — sequence flow: <br> - <code>modGoalSeekController</code> calls <code>RecordTelemetryPoint</code> with <code>category=&quot;gs&quot;</code>, <code>eventType=&quot;GS_ATTEMPT&quot;</code>, <code>rowId=345</code>, <code>durationMs=1200</code>, <code>status=&quot;TIMEOUT&quot;</code>, <code>attempts=12</code>, <code>traceRef=&quot;gs_trace_abc_345&quot;</code>. <br> - <code>modTelemetry</code> buffers event (seq=1024). <br> - After chunk commit, <code>FlushTelemetry</code> writes batch to <code>__Telemetry</code>. <br> - <code>FlushTelemetryToExternal</code> attempts push; endpoint returns 500; telemetry row <code>attempts=1</code> updated; circuit counts increment and after threshold reached circuit opens and <code>TELEMETRY_ENDPOINT_TRIPPED</code> written to <code>__Telemetry_Alerts</code>. <br> - <code>modCoreEngine</code> sees alert and routes run to reviewer queue if the GS <code>materialFlag=TRUE</code>. <br>All telemetry rows include <code>codeVersion</code> and <code>configVersion</code> for forensic replay. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>PQ / DAX conceptual examples (concise)</strong><br>Power Query: ingest NDJSON from <code>ExportTelemetry</code>, parse <code>metricsJson</code>, expand into columns <code>status, attempts, errorCode</code>, compute <code>EventHour</code> and group by <code>EventHour,eventType</code> to produce <code>AvgDurationMs</code>. <br>DAX sample measures (textual): <code>AvgDuration = AVERAGE(Telemetry[durationMs])</code>, <code>GsTimeoutPct = DIVIDE(CALCULATE(COUNTROWS(Telemetry),Telemetry[eventType]=&quot;GS_ATTEMPT&quot;,Telemetry[metricsJson].Status=&quot;TIMEOUT&quot;), CALCULATE(COUNTROWS(Telemetry),Telemetry[eventType]=&quot;GS_ATTEMPT&quot;))</code>. <br>Use PQ to create dimension tables (date, run, eventType) for richer BI. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Security & governance checklist</strong><br>1. Telemetry endpoint credentials stored as secret references in <code>__Run_Config</code>, not in code. <br>2. Access to <code>__Telemetry</code> and <code>__Telemetry_Alerts</code> sheets restricted to Reviewer/Admin roles. <br>3. Telemetry exports signed or checksummed and preserved in secure network location per retention policy. <br>4. Anonymization policy documented and applied by default; opt-in to include raw PII only with documented approvals and <code>Audit_Log</code> sign-off. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Extensibility & helper service hooks</strong><br>1. <code>modTelemetry</code> exposes lightweight hooks for external ingestion microservice that can accept HTTP POST or write to a secure queue; keep payload small and batched. <br>2. If using cloud telemetry (e.g., Application Insights, Datadog), map <code>category/eventType</code> to platform concepts (e.g., customEvents, metrics) and remap <code>durationMs</code> to platform metric names. <br>3. Provide export adapter functions that convert telemetry rows into the specific JSON schema expected by each provider; keep mapping in <code>__Telemetry_Adapters</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Acceptance & delivery checklist for implementers</strong><br>1. Unit tests exist for <code>RecordTelemetryPoint</code>, <code>FlushTelemetry</code>, <code>AnonymizeTelemetryRecord</code>, and <code>FlushTelemetryToExternal</code> with simulated outcomes (200, 500, 429). <br>2. Integration test for full-run telemetry collection with sample runs; PQ ingestion pipeline validated against exported NDJSON. <br>3. Telemetry retention/purge tested and documented in runbook. <br>4. Admin UI panels for telemetry health and rule management provided in <code>frmOperatorUI</code> or <code>modConfigUI</code>. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Developer notes & heuristics</strong><br>1. Keep <code>metricsJson</code> compact — avoid verbose nested objects; only include keys required for diagnosis. <br>2. Prefer numeric-coded <code>eventType</code> where possible to reduce string size; provide mapping table <code>__Telemetry_EventTypes</code>. <br>3. Avoid logging full trace dumps in telemetry—store traceRef pointer to <code>__Diagnostics</code> sheet for heavy dumps. <br>4. When in doubt about including PII in telemetry, opt to hash or redact. </td></tr><tr><td data-label="Per-function technical breakdown — modTelemetry (VBA)"> <strong>Final summary</strong><br><code>modTelemetry</code> is the lightweight, resilient instrumentation backbone of UpdateHR+. It provides deterministic buffering, privacy-aware capture, efficient sheet persistence, export formats for PQ/BI, external push with circuit-breaker and retries, and an alerting surface that ties directly into operations and audit. Implementers should focus on batching, memoization, and stable telemetry schemas to ensure both performance and long-term analytical value. </td></tr></tbody></table></div><div class="row-count">Rows: 31</div></div><div class="table-caption" id="Table3" data-table="Docu_0204_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Per-function technical breakdown — **frmOperatorUI** (VBA UserForm + worksheet macros)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Per-function technical breakdown — <strong>frmOperatorUI</strong> (VBA UserForm + worksheet macros)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Module purpose (summary)</strong><br><code>frmOperatorUI</code> is the controlled operator-facing entry point for UpdateHR+. It collects operator input, enforces policy, validates preconditions, launches runs (dry-run or commit), previews impact, initiates safe rollbacks, exports artifacts, displays run summaries and telemetry, and records every UI action to the append-only audit store. The form is strictly a presentation/controller layer: business logic, matching, scoring, commit/rollback semantics, and heavy compute belong in <code>modCoreEngine</code>, <code>modMatchingEngine</code>, <code>modFuzzyScores</code>, <code>modGoalSeekController</code>, and <code>modBatchProcessing</code>. The form must remain lightweight, deterministic in how it calls core modules, fully auditable, and role-respecting. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Design principles & non-functional constraints</strong><br>1. Separation of concerns — UI only orchestrates and validates; never contain core business rules. <br>2. Deterministic audit-first behavior — every operator action writes a pre-action <code>ACTION_PENDING</code> audit row with an <code>actionToken</code> before any write/commit. <br>3. Role-based control surface — visibility and enabled state of controls driven by <code>modConfig.UserRoles</code>. <br>4. Safe defaults — run defaults conservative (dry-run on initial runs, smaller batch sizes). <br>5. Non-blocking UX — long tasks display progress, allow controlled cancelation, and respect chunk boundaries to avoid inconsistent partial commits. <br>6. Recoverability — all destructive actions require pre-commit snapshot and an <code>ApplyDescriptor</code> for full revertability. <br>7. Config-driven UI — thresholds, caps, batch sizes read from <code>modConfig</code> and persisted per-run. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Public procedures & event handlers — per-function technical breakdown</strong><br>1. <code>InitializeForm()</code> — bootstrap & bind UI on load.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Purpose: set initial control states, load runtime config, display recent runs, enforce role visibility, and ensure no stale locks. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Inputs: none; reads <code>modConfig.LoadConfig</code>, <code>modUtilities.GetCurrentUserId</code>, <code>__Run_Summary</code>, <code>__Run_Locks</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Behavior details:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Load config snapshot and populate <code>txtBatchSize</code>, <code>txtAutoApplyThreshold</code>, <code>ddlRunProfiles</code> with defaults. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- If <code>UserRoles(operator)</code> false, disable <code>btnRun</code> and show locked message; log <code>UI_ACCESS_DENIED</code> attempt. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Call <code>LoadRecentRuns(10)</code> to fill <code>lstRecentRuns</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- If <code>__Run_Locks</code> indicates a lock older than <code>modConfig.LockExpirySecs</code>, show a recoverable orphan-lock modal with <code>RecoverLock</code> action. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Audit: append <code>UI_INIT</code> <code>Audit_Log</code> row with <code>userId</code>, <code>uiVersion</code>, <code>configSnapshot</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Error handling: if <code>modConfig.ValidateConfig</code> flags critical, disable run controls and present a blocking modal with link to admin. <br>2. <code>BtnRun_Click()</code> — run orchestration entry invoked from Run button.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Purpose: validate options and start a run (dry or commit) via <code>modCoreEngine.RunUpdateHR</code> or <code>modBatchProcessing.StartBatch</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Inputs (collected from UI): <code>staffRangeName</code> (preselected), <code>dryRun</code> (checkbox), <code>maxRows</code> (number), <code>runProfile</code> (selection), <code>autoApplyThreshold</code> (percentage), <code>operatorNotes</code> (free text). <br>&nbsp;&nbsp;&nbsp;&nbsp;• Validation & gating (in order):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) <code>ValidateOperator(&quot;run&quot;)</code> — calls <code>modCoreEngine.ValidatePreRun</code> and <code>modConfig.ValidateConfig</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) daily caps check: <code>modBatchProcessing.EnforceDailyLimits</code> for operator and for runProfile impacts. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3) reviewer gating: if <code>expectedRows &gt; modConfig.ReviewerGateRows</code> then require reviewer pre-approval (call <code>PromptReviewerSignOff</code>). <br>&nbsp;&nbsp;&nbsp;&nbsp;• Execution steps:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Build <code>runOptions</code> dictionary and compute <code>actionToken = Hash(userId|timestamp|nonce)</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Append <code>Audit_Log</code> <code>ACTION_PENDING</code> with <code>actionToken</code>, <code>runOptions</code>, <code>userId</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Lock UI (<code>LockUI(&quot;Running&quot;)</code>), show <code>progressPane</code> and <code>Cancel</code> enabled. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Call <code>modCoreEngine.RunUpdateHR(staffRangeName, runOptions)</code> and receive <code>runResult</code> (dictionary: runId, status, rowsProcessed, autoAppliedCount, reviewCount, errors). <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- On return: append <code>ACTION_COMPLETE</code> audit row including <code>runResult</code>, <code>actionToken</code>, <code>signatureHash</code> if reviewer signoff used. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Failure & partial commit handling:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- If <code>runResult.status=&quot;FAILED&quot;</code> and partial commit detected, set UI to display <code>OfferRollback</code> with <code>runId</code> and pre-commit snapshot preview; log <code>PARTIAL_COMMIT</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- If exception at UI level, call <code>HandleUIError(err, &quot;Run_Click&quot;)</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Telemetry: call <code>modTelemetry.RecordTelemetryPoint(&quot;UI_Run&quot;, {userId, dryRun, rowsRequested, runDurationMs})</code>. <br>3. <code>BtnPreview_Click()</code> — show non-destructive impact simulation.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Purpose: run <code>modImpactSimulation.SimulateRunPreview</code> and surface <code>ImpactReport</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Inputs: <code>sampleSize</code>, <code>periodRange</code>, <code>simulateOptions</code> from UI. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Flow:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Validate: call <code>ValidateOperator(&quot;preview&quot;)</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Append <code>AUDIT</code> row <code>PREVIEW_INIT</code> with <code>simulateOptions</code> and <code>userId</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Call <code>modImpactSimulation.SimulateRunPreview(runIdTemp, simulateOptions)</code> which returns <code>impactSummary</code>, <code>evidenceRef</code>, <code>simSheetName</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Render <code>ImpactReportPane</code>: aggregate by <code>DisclosureBucket</code> x <code>Period</code>, show <code>Delta</code>, <code>DeltaPct</code>, and <code>MaterialFlag</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Provide <code>ExportImpactCSV</code> button that calls <code>modAuditExportHelpers.WriteCSVFile</code> for downloads. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Audit: append <code>PREVIEW_COMPLETE</code> with <code>impactSummary</code> and <code>evidenceRef</code>. <br>4. <code>BtnRollback_Click()</code> — rollback confirmed committed run.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Purpose: allow safe revert using <code>modCoreEngine.RollbackRun</code> and show before/after preview to operator. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Inputs: <code>rollbackRunId</code>, <code>reason</code>, optional <code>overrideCredentials</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Prechecks:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Confirm run exists and <code>status=COMMITTED</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Compute <code>materialitySummary = modMateriality.AggregateMateriality(rollbackRunId)</code>; if materialities exceed reviewer threshold, require reviewer second-approval before proceeding. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Execution:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Append <code>Audit_Log</code> <code>ROLLBACK_INIT</code> with <code>runId</code>, <code>userId</code>, <code>reason</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Display <code>BeforeSnapshotPreview</code> fetched from <code>__Stage_Backup_&lt;runId&gt;</code>; require user confirm. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Call <code>modCoreEngine.RollbackRun(runId, reason)</code>. On success append <code>ROLLBACK_COMPLETE</code> with <code>rollbackSummary</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Forensics: if rollback fails, call <code>modAuditExportHelpers.PackageExport</code> to create <code>ForensicPack</code> and log <code>ROLLBACK_FAIL</code>. <br>5. <code>BtnExportAudit_Click()</code> — export run artifacts and manifest.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Purpose: create signed artifacts (CSV/NDJSON, manifest, checksums) and optionally push to network location or present for download. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Inputs: <code>runId</code>, <code>format</code> (csv/json), <code>destPath</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Security: if <code>includeSensitive=True</code> require Admin role. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Action:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Append <code>EXPORT_REQUEST</code> to <code>Audit_Log</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Call <code>modAudit.ExportAudit(runId, format, tmpDir)</code>, then <code>modAuditExportHelpers.PackageExport(tmpDir, destZip)</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- Optionally call secure uploader (if provided) and append <code>EXPORT_COMPLETE</code> with <code>artifactChecksum</code> and <code>dest</code>. <br>6. <code>ShowLastRunSummary()</code> — populate the UI with last-run metrics.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Purpose: rapid visibility of last run with key metrics: <code>rowsProcessed</code>, <code>autoApplied</code>, <code>reviewCount</code>, <code>GSStats</code>, <code>errorsCount</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Source: <code>__Run_Summary</code> sheet or call <code>modCoreEngine.GetRunSummary(lastRunId)</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Rendering: show sparklines & small tiles; allow double-click to open <code>OpenRunArtifacts(lastRunId)</code>. <br>7. <code>RenderRunProgress(runId As String, progress As Scripting.Dictionary)</code> — update progress UI in near-real-time.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Input keys: <code>percent</code>, <code>currentStage</code>, <code>currentRow</code>, <code>chunkId</code>, <code>lastMessage</code>, <code>estimatedRemainingSec</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Behavior: throttle UI updates to avoid overhead (e.g., update every 250–500ms), write progress snapshots to <code>__Run_Progress_&lt;runId&gt;</code> for later forensic replay, and call <code>modTelemetry.RecordTelemetryPoint</code> periodically. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Cancel behavior: if <code>Cancel</code> pressed set <code>cancellationRequested=True</code> in <code>__UI_Flags</code> and append <code>CANCEL_REQUEST</code> audit row; core engine must poll this flag. <br>8. <code>ValidateOperator(action As String) As Scripting.Dictionary</code> — consolidated pre-action validation helper.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Checks: role allowed for action, PQ transforms present, named ranges exist, <code>Calculator</code> integrity test (small formula checks), no orphan locks, daily caps, and config validity. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Returns: <code>validationResult</code> dictionary: <code>{ok:Boolean, errors:Collection, warnings:Collection}</code> used by calling handlers to block or show warnings. <br>9. <code>ConfirmActionDialog(prompt As String, requirePassword As Boolean, requireSecondApprover As Boolean) As Boolean</code> — secure confirmation modal.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Purpose: secure gating for destructive actions and high-dollar approvals. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Implementation: if <code>requirePassword</code> call <code>modUtilities.ValidateUserCredential</code> for immediate check; if <code>requireSecondApprover</code> create <code>__ApprovalQueue</code> row and notify reviewer and block until approval appended; append <code>ACTION_CONFIRMED</code> audit row when confirmed. <br>10. <code>LockUI(reason As String)</code> and <code>UnlockUI()</code> — UI lock management.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Behavior: disable interactive controls, set visual dim, write <code>UI_LOCK</code> row to <code>Audit_Log</code> including <code>userId</code>, <code>reason</code>, timestamp. <code>UnlockUI</code> reverses state and writes <code>UI_UNLOCK</code>. <br>11. <code>HandleUIError(err As Object, context As String)</code> — centralized UI error handler.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Behavior: capture full Err object, stack, context, <code>userId</code>, and write to <code>__Diagnostics_&lt;timestamp&gt;</code>; append <code>UI_ERROR</code> row to <code>Audit_Log</code> with <code>diagnosticRef</code>; present user-friendly modal with <code>DiagnosticRef</code>. <br>12. <code>LogUIAction(actionType As String, details As Scripting.Dictionary)</code> — small helper that writes pre/post audit rows with <code>actionToken</code> and computes <code>actionHash</code> using <code>modSignatures.ComputeRunSignature</code> partially for local provenance. <br>13. <code>LoadRecentRuns(n As Long)</code> — read <code>__Run_Summary</code> to populate recent runs grid.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Support sorting, filtering, and pagination to keep UI responsive. <br>14. <code>OpenRunArtifacts(runId As String)</code> — show artifact folder and allow download of <code>manifest</code>, <code>auditExport</code>, <code>simReport</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Calls <code>modAuditExportHelpers.PackageExport</code> if artifacts are not packaged yet. <br>15. <code>OnConfigChange(newConfig As Scripting.Dictionary)</code> — apply config changes made via UI (admin-only). <br>&nbsp;&nbsp;&nbsp;&nbsp;• Validate with <code>modConfig.ValidateConfig</code>, call <code>modConfig.PersistConfigSnapshot</code>, and write <code>CONFIG_CHANGE</code> audit row including diff and <code>appliedBy</code>. <br>16. <code>ShutdownForm()</code> — teardown on unload.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Tasks: flush <code>modTelemetry</code> buffers, flush <code>__Fuzzy_Profile</code> and <code>__Telemetry</code> to disk (or network), ensure any run locks released if UI owned, append <code>UI_SHUTDOWN</code> audit row. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Control mapping (controls → behavior)</strong><br>1. <code>btnRun</code> → <code>BtnRun_Click</code> <br>2. <code>chkDryRun</code> → read by <code>BtnRun_Click</code> <br>3. <code>txtMaxRows</code> → parameter used by <code>BtnRun_Click</code> <br>4. <code>ddlRunProfiles</code> → preconfigured run profiles applied to <code>runOptions</code> <br>5. <code>btnPreview</code> → <code>BtnPreview_Click</code> <br>6. <code>btnRollback</code> → <code>BtnRollback_Click</code> <br>7. <code>btnExportAudit</code> → <code>BtnExportAudit_Click</code> <br>8. <code>progressBar</code>, <code>lblStatus</code>, <code>lstRecentRuns</code> → updated by <code>RenderRunProgress</code> and <code>LoadRecentRuns</code> <br>9. <code>btnCancel</code> → sets cancellation flag polled by core engine <br>10. <code>btnSettings</code> → opens admin config UI via <code>modConfigUI</code> (admin-only) </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Data flows & cross-module interactions</strong><br>1. UI → <code>modConfig</code> for thresholds and caps. <br>2. UI → <code>modCoreEngine</code> for run orchestration (Run/Commit/CommitChunk). <br>3. UI → <code>modImpactSimulation</code> for preview/simulation. <br>4. UI → <code>modBatchProcessing</code> for chunked and scheduled runs. <br>5. UI → <code>modAudit</code> / <code>modAuditExportHelpers</code> for append-only audit lines and exports. <br>6. UI → <code>modTelemetry</code> for operational metrics. <br>7. UI reads <code>modMappingStore</code> <code>__Run_Summary</code>, <code>__Run_Locks</code>, and <code>__Stage_Backup_&lt;runId&gt;</code> for previews and rollbacks. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Audit & explainability rules enforced by UI</strong><br>1. Pre-action audit row (<code>ACTION_PENDING</code>) always written prior to any action that modifies state. <br>2. Post-action audit row (<code>ACTION_COMPLETE</code> or <code>ACTION_FAILED</code>) written after completion with <code>actionToken</code> linking to pending row. <br>3. For commit operations, attach <code>ApplyDescriptor</code> (or pointer) and <code>beforeJSON</code> snapshot in the audit row for forensic replay. <br>4. For reviewer-required actions, additionally store <code>approverId</code>, <code>approverTimestamp</code>, and <code>signatureHash</code>. <br>5. For exports, write <code>EXPORT_REQUEST</code> and <code>EXPORT_COMPLETE</code> rows with artifact checksums and dest. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Telemetry and KPI metrics surfaced by UI</strong><br>1. <code>AutoApplyRate</code> — percent of rows auto-applied in run. <br>2. <code>OverrideRate</code> — proportion of reviewer overrides vs suggestions. <br>3. <code>AvgGoalSeekAttempts</code> — average GS attempts across run rows. <br>4. <code>RunThroughput</code> — rows processed per minute. <br>5. <code>CommitErrorRate</code> — chunk commit failures per run. <br>These metrics emitted to <code>modTelemetry</code> and displayed in <code>frmOperatorUI</code> summary tiles and exported to BI via PQ-friendly CSV. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Power Query (PQ) conceptual workflows & operator BI snapshot</strong><br>1. <strong>Audit ingestion PQ</strong> — recommended PQ steps for operator dashboards:<br>&nbsp;&nbsp;&nbsp;&nbsp;a) Source: exported <code>Audit_Log</code> NDJSON/CSV from <code>modAudit.ExportAudit</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;b) Parse <code>componentBreakdown</code> JSON into relational columns. <br>&nbsp;&nbsp;&nbsp;&nbsp;c) Add <code>Delta = after.amount - before.amount</code>, cast datatypes, and trim long textual fields for dashboard performance. <br>&nbsp;&nbsp;&nbsp;&nbsp;d) Group by <code>runId</code> to build <code>RunSummary</code> table with metrics: rowsProcessed, autoApplied, reviewCount. <br>&nbsp;&nbsp;&nbsp;&nbsp;e) Export <code>RunSummary</code> to Power BI dataset or store <code>bi_snapshot.csv</code> in <code>__Artifacts/&lt;runId&gt;</code>. <br>2. <strong>ImpactReport PQ</strong> — ingest <code>ImpactReport</code> CSV produced by preview:<br>&nbsp;&nbsp;&nbsp;&nbsp;a) Expand <code>evidenceRef</code> sample posting lists into normalized table. <br>&nbsp;&nbsp;&nbsp;&nbsp;b) Aggregate by <code>DisclosureBucket</code> and <code>Period</code> to produce disclosure-ready totals. <br>3. <strong>Scheduler & nightly parity check</strong> — PQ job that pulls <code>Audit_Log</code> from last 24h and compares parity against golden-run expected rows; if mismatch produce alert CSV for operator. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Conceptual DAX measures for operator dashboards</strong><br>1. <code>AutoApplyRate = DIVIDE([AutoAppliedRows],[TotalRowsProcessed])</code>.<br>2. <code>AvgRunDurationSeconds = AVERAGE(&#x27;RunSummary&#x27;[DurationSeconds])</code>.<br>3. <code>ReviewerOverrideRate = DIVIDE([ReviewerOverrides],[RowsRequiringReview])</code>.<br>4. <code>PctGSConverged = DIVIDE(CALCULATE(COUNTROWS(&#x27;GSMetrics&#x27;),&#x27;GSMetrics&#x27;[Status]=&quot;CONVERGED&quot;), COUNTROWS(&#x27;GSMetrics&#x27;))</code>.<br>5. <code>MaterialExposure = SUMX(FILTER(&#x27;RunDetail&#x27;,&#x27;RunDetail&#x27;[MaterialFlag]=1),&#x27;RunDetail&#x27;[Delta])</code>. <br>Use these measures for operator KPIs and to trigger thresholds for governance emails or alerts. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Security & role model enforcement</strong><br>1. UI uses <code>modConfig.UserRoles</code> to determine control access, with three primary roles: <code>Operator</code>, <code>Reviewer</code>, <code>Admin</code>. <br>2. Sensitive actions (exports including PII, high-dollar rollbacks) require <code>Admin</code> or <code>Reviewer</code> plus second approver and recorded rationale. <br>3. UI should never cache plaintext credentials; use ephemeral validate calls (<code>modUtilities.ValidateUserCredential</code>) and discard tokens. <br>4. For external uploads, require TLS endpoints and verify server certificates; log destination domain and operator confirmation in audit. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Testing checklist for frmOperatorUI</strong><br>1. Unit tests (automated where possible using workbook test harness): control enable/disable behavior across roles; <code>ValidateOperator</code> returns expected failures for missing named ranges; <code>ConfirmActionDialog</code> enforces second-approver workflow. <br>2. Integration tests: simulate full run (dry-run and commit) on golden workbook and assert audit rows <code>RUN_INIT</code> and <code>RUN_COMPLETE</code> with same <code>ApplyDescriptor</code> produced by headless <code>modCoreEngine</code>. <br>3. Failure tests: simulate exception in <code>modCoreEngine</code> mid-run and confirm UI shows <code>Rollback</code> option and forensic pack generated. <br>4. Security tests: attempt unauthorized export; UI must block and log attempt. <br>5. Telemetry tests: run a small run and assert <code>UI_Run</code> telemetry points appear in <code>__Telemetry</code>. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Operational runbook snippets (operator quick guide)</strong><br>1. Pre-run checklist (UI enforces): named ranges present, <code>Calculator</code> key cells validated, PQ refreshed, codeVersion matches supported release, no active locks. <br>2. Typical safe run flow: open UI → <code>InitializeForm</code> → select run profile → <code>chkDryRun</code> on first runs → <code>btnPreview</code> → review <code>ImpactReport</code> → request reviewer signoff if material → <code>btnRun</code>. <br>3. If partial commit detected: open <code>Rollback</code> dialog, load <code>runId</code>, review snapshot, request reviewer override if needed, and execute <code>BtnRollback_Click</code>. <br>4. Export artifacts: use <code>ExportAudit</code> with Admin permission for migration to central audit DB; always verify manifest checksum after export. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Edge cases & mitigations in frmOperatorUI</strong><br>1. Orphaned lock at form open: show recover modal and call <code>RecoverLock</code> only if lock older than <code>LockExpirySecs</code> and admin confirms. <br>2. User cancels during commit: <code>Cancel</code> sets cancellation flag; commit must be chunk-atomic to avoid partial writes; UI must guide user to rollback if partial commit occurred. <br>3. PQ stale results: if <code>ImpactReport</code> mismatches expected data shapes, block commit and require PQ refresh; the UI shows <code>PQ_STALE</code> warning. <br>4. Network upload failure during export: UI writes <code>EXPORT_FAIL</code> with error detail and stores artifact locally; operator retries or uses manual hand-off. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Detailed examples (narrative) — step-by-step operator scenarios</strong><br>Example 1: Small dry-preview and commit with no reviewer required:<br>&nbsp;&nbsp;&nbsp;&nbsp;• Operator opens <code>frmOperatorUI</code> → <code>InitializeForm</code> loads <code>AutoApplyThreshold=0.88</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Operator selects <code>profile=standard</code>, checks <code>DryRun</code>, clicks <code>Preview</code> → <code>SimulateRunPreview</code> returns <code>ImpactReport</code> showing low material deltas. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Operator unchecks <code>DryRun</code>, clicks <code>Run</code> → <code>BtnRun_Click</code> validates and writes <code>ACTION_PENDING</code>, <code>LockUI</code>, calls <code>modCoreEngine.RunUpdateHR</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• UI shows progress; <code>RunUpdateHR</code> returns <code>COMMITTED</code>, <code>Audit_Log</code> contains <code>COMMITTED</code> rows and <code>ApplyDescriptor</code> saved. <br>Example 2: Large run requires reviewer pre-approval:<br>&nbsp;&nbsp;&nbsp;&nbsp;• Operator configures run with <code>maxRows=1200</code> where <code>ReviewerGateRows=500</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• On <code>Run</code> UI calls <code>PromptReviewerSignOff</code> → creates <code>__ApprovalQueue</code> entry and notifies reviewer. <br>&nbsp;&nbsp;&nbsp;&nbsp;• After reviewer signs in <code>frmReviewerUI</code>, UI receives <code>approval</code> and resumes <code>RunUpdateHR</code>. <br>Example 3: Post-commit material error requiring rollback:<br>&nbsp;&nbsp;&nbsp;&nbsp;• Operator sees material delta in disclosure → opens <code>Rollback</code> and previews <code>__Stage_Backup_&lt;runId&gt;</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• Because <code>materiality &gt; reviewerThreshold</code>, UI requires reviewer override; upon approval <code>BtnRollback_Click</code> calls <code>modCoreEngine.RollbackRun</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• <code>Audit_Log</code> shows <code>ROLLBACK_INIT</code> and <code>ROLLBACK_COMPLETE</code>; <code>ForensicPack</code> produced for incident review. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>PQ & DAX conceptual content for operator dashboards (expanded)</strong><br>Power Query steps for <code>Audit_Log</code> snapshot ingestion:<br>&nbsp;&nbsp;&nbsp;&nbsp;1) Source: <code>Audit_Log</code> CSV/ndjson exported by <code>modAudit.ExportAudit</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;2) Parse <code>componentBreakdown</code> JSON (use <code>Json.Document</code>) and expand to columns: <code>tokenOverlap</code>, <code>jaccard</code>, <code>fuzzyScore</code>, <code>combinedScore</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;3) Convert <code>beforeJSON</code>/<code>afterJSON</code> to records and compute <code>Delta = after.amount - before.amount</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;4) Create <code>RunSummary</code> by grouping by <code>runId</code> and aggregating counts and sums. <br>Expanded DAX measures (examples operators will use):<br>&nbsp;&nbsp;&nbsp;&nbsp;• <code>AutoApplyRate = DIVIDE([AutoAppliedRows],[TotalRowsProcessed])</code> — show as tile. <br>&nbsp;&nbsp;&nbsp;&nbsp;• <code>RunFailureRate = DIVIDE([FailedRuns],[TotalRuns])</code> — trend line. <br>&nbsp;&nbsp;&nbsp;&nbsp;• <code>ExpectedReviewerLoad = COUNTROWS(FILTER(&#x27;RunDetail&#x27;,&#x27;RunDetail&#x27;[combinedScore] &lt; [AutoThreshold] &amp;&amp; &#x27;RunDetail&#x27;[combinedScore] &gt;= [ReviewThreshold]))</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;• <code>MaterialDeltaByOrg = SUMMARIZE(&#x27;RunDetail&#x27;,&#x27;RunDetail&#x27;[orgUnit],&quot;TotalDelta&quot;,SUM(&#x27;RunDetail&#x27;[Delta]))</code>. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Testing & acceptance criteria for frmOperatorUI (delivery checklist)</strong><br>1. UI unit tests pass: control states correct for roles and config permutations. <br>2. Integration acceptance: perform 3 golden runs (dry-run, small commit, large commit with reviewer) and verify <code>Audit_Log</code> parity with expected artifacts. <br>3. Security acceptance: attempted unauthorized export blocked and logged. <br>4. Resilience: simulate core engine crash mid-run and verify UI surfaces rollback option and telemetry and <code>ForensicPack</code> created. <br>5. Usability: operators can complete pre-run checklist and run within target clicks (≤5) after training. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Developer implementation notes & heuristics</strong><br>1. Keep UI code minimal: prefer calling <code>modCoreEngine</code> synchronous API and relying on it for heavy-lifting; only small helpers belong in UI code. <br>2. Avoid thousands of UI writes: write progress to a hidden <code>__Run_Progress</code> sheet and refresh UI every 250–500ms. <br>3. When constructing <code>actionHash</code>, combine <code>actionToken</code> with <code>userId</code>, <code>timestamp</code> and short HMAC using a key stored in secure store (or request external signer). <br>4. Use stable layout and avoid dynamic control creation where possible; instead use template rows in worksheet-based grid controls for recent runs. <br>5. Provide clear <code>DiagnosticRef</code> codes mapped to <code>__Diagnostics</code> artifacts for support teams. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Common pitfalls & mitigations</strong><br>1. Pitfall: UI blocks while calling heavy synchronous core API and Excel becomes unresponsive.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Mitigation: show progress and allow <code>DoEvents</code>; ensure long operations provide frequent progress callbacks and chunk boundaries. <br>2. Pitfall: operator accidentally exports PII to shared drive.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Mitigation: block export of sensitive artifacts to network paths unless <code>includeSensitive</code> flagged and Admin permission provided; require explicit confirmation. <br>3. Pitfall: missing pre-run audit row because of UI error.<br>&nbsp;&nbsp;&nbsp;&nbsp;• Mitigation: write <code>ACTION_PENDING</code> before any remote call and persist it to disk immediately; have UI retry if append fails. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Deliverables & documentation to ship with frmOperatorUI</strong><br>1. UI control mapping document (control id → binding → permission). <br>2. Quick-run operator manual (checklist, typical flows, rollback steps). <br>3. Acceptance test scenarios and golden audit exports. <br>4. Example PQ queries and DAX measures for BI team. <br>5. Runbook for on-call support with <code>DiagnosticRef</code> mapping. </td></tr><tr><td data-label="Per-function technical breakdown — frmOperatorUI (VBA UserForm + worksheet macros)"> <strong>Summary (final)</strong><br><code>frmOperatorUI</code> is the safe, auditable operator surface for UpdateHR+. It must validate inputs, enforce policy, call core modules for heavy logic, present progress and previews, ensure recoverability via pre-commit snapshots and <code>ApplyDescriptor</code>s, and record all actions to <code>Audit_Log</code> with robust telemetry. Implementers must focus on role-enforcement, audit-first writes before actions, chunked commit visibility, and clear reviewer/approval flows so that operations are safe, traceable, and re-playable. </td></tr></tbody></table></div><div class="row-count">Rows: 20</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>