<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1761541226">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      // Delegate addEventListener/removeEventListener to visible button
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      // Delegate onclick assignments
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      // Delegate focus/blur
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
      // If legacy code used direct addEventListener earlier than this script, listeners would already exist
      // on alias element; attempt to re-dispatch those by cloning them to visible button is non-trivial.
      // This approach covers the common case where legacy scripts query the alias and bind after DOM ready.
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Book_8039_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Analysis**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Analysis</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Analysis"> <strong>Step 1 — Collect Source Files and Prepare Environment</strong><br><br>1. Locate <code>PTT convert.py</code>, <code>TV convert.py</code>, and <code>core_renderer.py</code> in the working directory. Verify that each file is the latest edited version by checking last modified timestamps, file sizes, and optionally SHA256 or MD5 checksums to ensure integrity.  <br>2. Create a versioned backup folder, e.g., <code>backup_YYYYMMDD_HHMMSS</code>, and copy all three files there. This prevents accidental data loss during debugging.  <br>3. Verify Python environment consistency: ensure Python 3.10+ is installed. Use <code>python --version</code> and <code>pip list</code> to confirm dependencies.  <br>4. Confirm that the <code>saved_tables</code> folder exists, is writable, and has correct file system permissions. Check for read/write access using <code>os.access(path, os.W_OK)</code> to prevent runtime permission errors.  <br>5. Optionally, create a virtual environment for testing to prevent conflicts with system-level packages. Activate it using <code>venv</code> or <code>virtualenv</code> to isolate dependencies. </td></tr><tr><td data-label="Analysis"> <strong>Step 2 — Map Complete Data Flow</strong><br><br>1. Document the full pipeline: user input → parsing → internal table structure → HTML rendering → browser preview → saving to <code>saved_tables</code>. Use a diagram or flowchart if necessary.  <br>2. Identify all intermediate data structures: lists of rows, dictionaries for metadata, string buffers, or custom objects representing table contents. Label them clearly for debugging.  <br>3. Add debug logging at each stage: capture table data after parsing, after HTML generation, and immediately before saving. Example: <code>logging.debug(&quot;Table content: %s&quot;, table_obj)</code>.  <br>4. Compare content at each stage to detect divergence between preview and saved HTML. This ensures any mismatch is traced back to the exact transformation step.  <br>5. Document whether preview applies any dynamic changes (inline JS, CSS injection) that are not present in the saved file. This is a common source of inconsistencies.                                                                   </td></tr><tr><td data-label="Analysis"> <strong>Step 3 — Isolate Rendering Functions in <code>core_renderer.py</code></strong><br><br>1. Locate all functions generating HTML, e.g., <code>render_html()</code>, <code>generate_table_html()</code>, <code>table_to_html()</code>, <code>save_html_file()</code>.  <br>2. Trace how table rows (<code>&lt;tr&gt;</code>) and cells (<code>&lt;td&gt;</code> / <code>&lt;th&gt;</code>) are created. Confirm correct nesting and proper handling of multi-line cells.  <br>3. Check whether preview adds inline styles or class attributes dynamically that are not included in the saved HTML.  <br>4. Confirm that template strings or format strings are not partially evaluated or modified differently between preview and save.  <br>5. Document any optional parameters that affect formatting, e.g., <code>include_styles=True</code>, <code>inline_css=False</code>, or <code>escape_html=True</code>. Verify these flags are consistently applied.  <br>6. Test with multiple sample tables to ensure the rendering function handles edge cases: empty cells, long text, special characters, nested tables, and mixed markdown/HTML content.                                          </td></tr><tr><td data-label="Analysis"> <strong>Step 4 — Verify Asset References and Paths</strong><br><br>1. Inspect all <code>&lt;link&gt;</code> tags for CSS and <code>&lt;script&gt;</code> tags for JS. Verify that relative paths correctly point from <code>saved_tables</code> to the <code>assets</code> folder.  <br>2. For image <code>&lt;img&gt;</code> tags, confirm that the <code>src</code> path is valid and points to an existing file. Test with both relative and absolute paths.  <br>3. If preview relies on external CDNs, decide whether to embed assets locally for offline consistency.  <br>4. Check file permissions for CSS, JS, and images (readable by Python process).  <br>5. Adjust path handling: convert absolute paths used in preview to relative paths in saved HTML or copy assets to the same folder.  <br>6. Consider embedding critical CSS and JS inline for small tables to eliminate path issues entirely.                                                                                                                                                                                                                              </td></tr><tr><td data-label="Analysis"> <strong>Step 5 — Verify Encoding, Line Breaks, and Whitespace</strong><br><br>1. Ensure saved HTML includes <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> in the <code>&lt;head&gt;</code> section.  <br>2. Save files explicitly with UTF-8 encoding: <code>with open(path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;)</code>. Avoid default encodings that may differ by OS.  <br>3. Preserve line breaks (<code>\n</code>) and indentation for readability and to match preview output.  <br>4. Check that no string operations during saving (<code>strip()</code>, <code>replace()</code>) remove necessary whitespace or break tags.  <br>5. Validate line breaks and indentation by opening saved HTML in multiple editors.  <br>6. Confirm that any embedded multi-line content, e.g., <code>&lt;pre&gt;</code> or <code>&lt;code&gt;</code> blocks, maintain line integrity.                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="Analysis"> <strong>Step 6 — Adjust Save Function in Convert Modules</strong><br><br>1. In <code>PTT convert.py</code> and <code>TV convert.py</code>, modify save routines to use: <code>with open(save_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(html_content)</code>.  <br>2. Ensure no transformations are applied to <code>html_content</code> between rendering and saving.  <br>3. Add logging before and after saving to confirm exact content: <code>logging.debug(&quot;Saving HTML length: %d&quot;, len(html_content))</code>.  <br>4. Ensure atomicity if multiple processes may write: consider writing to a temporary file and renaming (<code>os.replace</code>) to avoid partial writes.  <br>5. Test save function with extremely long tables and content containing special HTML characters, emojis, or non-Latin scripts. Confirm fidelity.  <br>6. Include exception handling for permission errors or disk full conditions, and log meaningful messages for troubleshooting.                                                                                                                                                 </td></tr><tr><td data-label="Analysis"> <strong>Step 7 — Ensure Table Styling is Preserved</strong><br><br>1. Confirm all CSS classes applied in preview are included in saved HTML.  <br>2. If preview uses JS to inject inline styles, replicate equivalent inline CSS in the saved file.  <br>3. Verify table borders, padding, font sizes, and alignment are consistent.  <br>4. Test hover effects and background colors to confirm preservation.  <br>5. Open saved HTML in Chrome, Firefox, Edge, and optionally Safari to check cross-browser consistency.  <br>6. Include special cases: multi-line cells, merged cells, text wrapping, and emojis.  <br>7. Verify that dynamic table features (sorting, highlighting) degrade gracefully when JS is unavailable.                                                                                                                                                                                                                                                                                                                          </td></tr><tr><td data-label="Analysis"> <strong>Step 8 — Perform Diff and Visual Verification</strong><br><br>1. Use <code>diff</code>, <code>Beyond Compare</code>, or VS Code compare to inspect raw HTML line-by-line.  <br>2. Check for missing tags, reordered elements, broken inline styles, truncated content, or misplaced assets.  <br>3. Take screenshots of preview vs saved HTML for reference.  <br>4. Log all differences and iterate fixes in rendering functions.  <br>5. Repeat comparison with multiple sample tables including edge cases (empty rows, special characters, nested tables).  <br>6. Confirm that after fixes, diff reports zero differences between preview HTML and saved HTML.                                                                                                                                                                                                                                                                                                                                                                                                       </td></tr><tr><td data-label="Analysis"> <strong>Step 9 — Automate Verification with Test Script</strong><br><br>1. Write a Python test script to: generate a sample table → render HTML → save → re-open saved HTML → compare string or DOM tree to preview.  <br>2. Include multiple test cases: empty table, multi-line content, Unicode text, long tables, tables with images, tables with embedded Markdown.  <br>3. Log discrepancies and highlight line numbers.  <br>4. Automate repeated runs to verify deterministic behavior.  <br>5. Optionally, integrate into CI pipeline to catch regressions.  <br>6. Include visual verification step using headless browser (e.g., Selenium or Playwright) to ensure rendered appearance matches preview.                                                                                                                                                                                                                                                                                                                                          </td></tr><tr><td data-label="Analysis"> <strong>Step 10 — QA, Backup, and Documentation</strong><br><br>1. After all corrections, back up final versions of <code>core_renderer.py</code>, <code>PTT convert.py</code>, and <code>TV convert.py</code>.  <br>2. Document changes: functions modified, encoding adjustments, path fixes, CSS/JS handling, and new flags or parameters.  <br>3. Test multiple sample tables: small, large, nested, with special characters, with multi-line content, with images. Confirm saved HTML matches preview in all cases.  <br>4. Maintain a checklist for future updates to prevent regression.  <br>5. Consider adding automated CI checks for HTML fidelity.  <br>6. Optionally, include embedded unit tests in modules to verify rendering and saving behavior.  <br>7. Maintain a changelog for audit purposes, noting dates, authors, and verification results.                                                                                                                                                                                                                         </td></tr><tr><td data-label="Analysis"> <strong>Step 11 — Optional Enhancements for Absolute Fidelity</strong><br><br>1. Embed CSS directly into HTML <code>&lt;style&gt;</code> tags to eliminate external asset dependencies.  <br>2. Include critical JS inline if preview relies on dynamic features.  <br>3. Add file integrity verification: hash CSS, JS, and image assets to prevent corruption.  <br>4. Test across Windows, macOS, Linux for consistent path handling and newline characters.  <br>5. Consider adding verbose debug mode for live preview vs saved comparison.  <br>6. Use automated screenshot comparisons to detect visual regressions.  <br>7. Implement configuration for toggling between inline vs external assets depending on table size.                                                                                                                                                                                                                                                                                                                                          </td></tr></tbody></table></div><div class="row-count">Rows: 11</div></div><div class="table-caption" id="Table2" data-table="Book_8039_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Analysis**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Analysis</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Analysis"> <strong>Step 1 — Collect Source Files and Prepare Environment</strong><br><br>1. <strong>Locate Critical Modules:</strong> Confirm presence of <code>PTT convert.py</code>, <code>TV convert.py</code>, and <code>core_renderer.py</code>. Example: <code>ls -l *.py</code> in the working directory.  <br>2. <strong>Verify Integrity:</strong> Compare last modified timestamps (<code>os.path.getmtime</code>), file sizes, and optionally generate SHA256 hashes for each file to confirm no accidental edits.  <br>3. <strong>Backup:</strong> Create a timestamped backup folder: <code>backup_YYYYMMDD_HHMMSS</code>. Copy all three files there. Example: <code>cp PTT\ convert.py backup_20251023_1700/</code>. This prevents accidental loss during editing.  <br>4. <strong>Environment Validation:</strong> Ensure Python 3.10+ is installed. Verify with <code>python --version</code>. Confirm all required packages are installed with <code>pip list</code>. Example: ensure <code>beautifulsoup4</code> or <code>markdown</code> if used in rendering pipeline.  <br>5. <strong>Directory Permissions:</strong> Verify <code>saved_tables</code> exists and has read/write access. Example: <code>os.access(&#x27;saved_tables&#x27;, os.W_OK)</code> returns True.  <br>6. <strong>Optional Virtual Environment:</strong> For isolation, create a venv: <code>python -m venv venv</code>, activate with <code>source venv/bin/activate</code> (Linux/macOS) or <code>venv\Scripts\activate.bat</code> (Windows). Install all dependencies in the virtual environment to prevent conflicts.  <br>7. <strong>Warning:</strong> Skipping backups or using inconsistent Python environments can lead to unpredictable HTML formatting and data corruption. </td></tr><tr><td data-label="Analysis"> <strong>Step 2 — Map Complete Data Flow</strong><br><br>1. <strong>Document Pipeline:</strong> Map each stage: user input → parsing → internal table objects → HTML rendering → preview → saving to disk. Example: draw a diagram showing function calls: <code>parse_table()</code> → <code>generate_html()</code> → <code>preview_render()</code> → <code>save_html()</code>.  <br>2. <strong>Identify Data Structures:</strong> Document types for each stage: list of lists for rows/columns, dictionaries for metadata, string buffers for HTML. Example: <code>table_obj = {&#x27;headers&#x27;: [...], &#x27;rows&#x27;: [...]}</code>.  <br>3. <strong>Add Debug Logging:</strong> Use <code>logging.debug</code> to capture content at each stage. Example: <code>logging.debug(&quot;Parsed table: %s&quot;, table_obj)</code>. Confirm preview content matches pre-save HTML.  <br>4. <strong>Detect Divergences:</strong> Compare HTML after generation and after saving; note missing tags, attributes, or style differences.  <br>5. <strong>Check for Dynamic Changes:</strong> Determine whether preview injects JS or CSS dynamically. Example: sorting scripts or hover effects applied via browser DOM manipulation. Document these and plan for static replication in saved HTML.  <br>6. <strong>Best Practice:</strong> Use a consistent data format (dicts/lists) and avoid inline mutations during rendering to prevent unexpected differences.                                                                                                                                                                                                      </td></tr><tr><td data-label="Analysis"> <strong>Step 3 — Isolate Rendering Functions in <code>core_renderer.py</code></strong><br><br>1. <strong>Identify Functions:</strong> Locate <code>render_html()</code>, <code>generate_table_html()</code>, <code>table_to_html()</code>, <code>save_html_file()</code>.  <br>2. <strong>Trace Tag Generation:</strong> Confirm <code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code>, <code>&lt;td&gt;</code>, <code>&lt;th&gt;</code> are properly nested. Example: multi-line cells wrapped with <code>&lt;pre&gt;</code> or <code>&lt;div&gt;</code> to preserve line breaks.  <br>3. <strong>Verify Styling:</strong> Check if preview adds inline <code>style</code> attributes dynamically. Document which attributes are missing in save routine. Example: <code>style=&quot;padding:4px;border:1px solid #ccc;&quot;</code>.  <br>4. <strong>Template Strings:</strong> Ensure that placeholders in HTML templates are correctly substituted in both preview and saved output. Example: <code>{cell_value}</code> replaced with actual content consistently.  <br>5. <strong>Optional Parameters:</strong> Record flags affecting formatting: <code>include_styles</code>, <code>inline_css</code>, <code>escape_html</code>. Confirm consistency.  <br>6. <strong>Test Edge Cases:</strong> Use tables with empty cells, very long text, embedded images, special Unicode, or nested tables. Document how each edge case is rendered in preview vs saved file.  <br>7. <strong>Warning:</strong> Failure to handle multi-line or special characters correctly often leads to broken saved HTML.                                                                                                                                                                                                                </td></tr><tr><td data-label="Analysis"> <strong>Step 4 — Verify Asset References and Paths</strong><br><br>1. <strong>Inspect CSS/JS:</strong> Examine <code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> tags. Confirm relative paths point to <code>saved_tables</code>. Example: <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;../assets/style.css&quot;&gt;</code>.  <br>2. <strong>Check Images:</strong> Ensure <code>&lt;img src&gt;</code> paths exist and are readable. Example: <code>assets/logo.png</code> must exist.  <br>3. <strong>External CDNs:</strong> Decide whether to embed critical CSS/JS locally for offline usage.  <br>4. <strong>Permissions:</strong> CSS/JS/image files must be readable by Python process.  <br>5. <strong>Path Handling:</strong> Convert absolute paths in preview to relative paths in saved HTML, or copy assets alongside saved HTML.  <br>6. <strong>Best Practice:</strong> For small tables, inline critical CSS/JS to eliminate external dependencies and improve portability.  <br>7. <strong>Example:</strong> Inline style for table borders: <code>&lt;style&gt;table { border-collapse: collapse; } td, th { border: 1px solid #ccc; padding: 4px; }&lt;/style&gt;</code>.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="Analysis"> <strong>Step 5 — Verify Encoding, Line Breaks, and Whitespace</strong><br><br>1. <strong>Meta Charset:</strong> Include <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> in <code>&lt;head&gt;</code>.  <br>2. <strong>File Encoding:</strong> Save using <code>encoding=&#x27;utf-8&#x27;</code> in <code>open()</code>.  <br>3. <strong>Preserve Line Breaks:</strong> Ensure <code>\n</code> is preserved for multi-line content and code blocks.  <br>4. <strong>Avoid String Transformations:</strong> Do not <code>strip()</code> or <code>replace()</code> content between generation and save; it can remove whitespace or break tags.  <br>5. <strong>Verify Multi-line Cells:</strong> Cells with <code>&lt;pre&gt;</code> or <code>&lt;code&gt;</code> must retain line breaks and indentation.  <br>6. <strong>Cross-Editor Check:</strong> Open in multiple editors to confirm formatting. Example: VS Code, Notepad++, Sublime.  <br>7. <strong>Warning:</strong> Skipping UTF-8 encoding or losing line breaks can render special characters unreadable or break table layout.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td></tr><tr><td data-label="Analysis"> <strong>Step 6 — Adjust Save Function in Convert Modules</strong><br><br>1. <strong>Python Save Routine:</strong> Use: <code>with open(save_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(html_content)</code>.  <br>2. <strong>Avoid Transformations:</strong> Ensure HTML content is not altered post-render.  <br>3. <strong>Logging:</strong> Log length and snippet of saved content: <code>logging.debug(&quot;Saved HTML first 200 chars: %s&quot;, html_content[:200])</code>.  <br>4. <strong>Atomic Write:</strong> Consider writing to temporary file and using <code>os.replace()</code> to prevent partial writes:  <br>  Example: <code>tmp = save_path + &#x27;.tmp&#x27;</code>, <code>f.write(html_content)</code>, <code>os.replace(tmp, save_path)</code>.  <br>5. <strong>Exception Handling:</strong> Catch permission errors, disk full, or I/O errors and log with actionable messages.  <br>6. <strong>Edge Case Testing:</strong> Save tables with special characters, emojis, and very long content. Confirm output matches preview.  <br>7. <strong>Best Practice:</strong> Always test save function with representative tables to catch edge cases before deployment.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="Analysis"> <strong>Step 7 — Ensure Table Styling is Preserved</strong><br><br>1. <strong>CSS Classes:</strong> Verify all classes in preview are present in saved HTML.  <br>2. <strong>Inline Styles:</strong> If preview uses JS to inject styles, replicate inline in saved HTML.  <br>3. <strong>Borders, Padding, Alignment:</strong> Confirm consistency visually and via HTML inspection.  <br>4. <strong>Hover and Background:</strong> Test hover effects and background colors.  <br>5. <strong>Cross-Browser Testing:</strong> Chrome, Firefox, Edge, optionally Safari.  <br>6. <strong>Edge Cases:</strong> Multi-line cells, merged cells, text wrapping, emojis.  <br>7. <strong>Dynamic Features:</strong> Sorting/highlighting should degrade gracefully without JS.  <br>8. <strong>Best Practice:</strong> Include critical styles inline for offline fidelity; reference large external CSS only for non-critical enhancements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Analysis"> <strong>Step 8 — Perform Diff and Visual Verification</strong><br><br>1. <strong>Raw HTML Diff:</strong> Use <code>diff</code> or VS Code to compare preview-generated vs saved HTML line-by-line.  <br>2. <strong>Visual Comparison:</strong> Open both files in browser and compare tables visually.  <br>3. <strong>Screenshot Documentation:</strong> Take screenshots of differences for records.  <br>4. <strong>Log Differences:</strong> Note missing tags, reordered elements, broken inline styles, or truncated content.  <br>5. <strong>Iterate Fixes:</strong> Adjust rendering functions until diff reports zero differences.  <br>6. <strong>Multiple Samples:</strong> Test multiple tables including edge cases.  <br>7. <strong>Best Practice:</strong> Combine automated diffing and visual verification to catch subtle issues like spacing or cell wrapping differences.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </td></tr><tr><td data-label="Analysis"> <strong>Step 9 — Automate Verification with Test Script</strong><br><br>1. <strong>Test Script:</strong> Generate table → render HTML → save → compare string or DOM tree.  <br>2. <strong>Test Cases:</strong> Empty table, multi-line content, Unicode text, long tables, images, nested Markdown.  <br>3. <strong>Logging:</strong> Log discrepancies and line numbers.  <br>4. <strong>Automated Repeats:</strong> Run script multiple times to ensure deterministic output.  <br>5. <strong>CI Integration:</strong> Include in CI/CD pipeline to prevent regression.  <br>6. <strong>Visual Validation:</strong> Use headless browser (Selenium/Playwright) to capture screenshots and verify appearance.  <br>7. <strong>Warning:</strong> Omitting automated verification risks undetected discrepancies in production tables.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </td></tr><tr><td data-label="Analysis"> <strong>Step 10 — QA, Backup, and Documentation</strong><br><br>1. <strong>Backup:</strong> Preserve final versions of all modules.  <br>2. <strong>Document Changes:</strong> Functions modified, encoding fixes, path corrections, CSS/JS handling, parameters added.  <br>3. <strong>Comprehensive Testing:</strong> Small/large tables, nested, multi-line, special characters, images. Confirm preview = saved HTML.  <br>4. <strong>Checklist:</strong> Maintain QA checklist for future updates.  <br>5. <strong>Automated Checks:</strong> Optionally implement CI verification of table HTML fidelity.  <br>6. <strong>Unit Tests:</strong> Embed tests in modules to verify rendering and saving.  <br>7. <strong>Changelog:</strong> Maintain date, author, verification results for audit.  <br>8. <strong>Best Practice:</strong> Periodically re-run QA when dependencies or Python versions change.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </td></tr><tr><td data-label="Analysis"> <strong>Step 11 — Optional Enhancements for Absolute Fidelity</strong><br><br>1. <strong>Embed CSS Inline:</strong> For small tables, include critical CSS directly in <code>&lt;style&gt;</code> tags.  <br>2. <strong>Inline JS if Needed:</strong> Include minimal JS for dynamic features.  <br>3. <strong>Asset Integrity:</strong> Hash CSS/JS/images to ensure no corruption.  <br>4. <strong>Cross-Platform Testing:</strong> Windows, macOS, Linux.  <br>5. <strong>Debug Mode:</strong> Optionally enable verbose comparison between preview and saved HTML.  <br>6. <strong>Screenshot Comparison:</strong> Automate screenshot comparisons for visual verification.  <br>7. <strong>Configurable Assets:</strong> Allow toggling between inline and external assets depending on table size and project needs.  <br>8. <strong>Warning:</strong> Avoid excessive inline CSS/JS on very large tables; prefer external files for maintainability.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td></tr></tbody></table></div><div class="row-count">Rows: 11</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>