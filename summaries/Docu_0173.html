<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1768544756">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0173_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Incremental GL Extractor → PPh21 year-end manual**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Incremental GL Extractor → PPh21 year-end manual</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Objective (one clear sentence)</strong><br> Build and operate safe, repeatable, auditable pipeline. Extract changed payroll/GL rows from Dynamics 365, map exact to Ortax PPh21 Yearly workbook, enforce hard validation gates that stop run on data errors, produce exception packs for remediation, and write frozen values-only year-end snapshot for submission and audit.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Executive summary (single-paragraph)</strong><br> Overview: This manual documents the full lifecycle of the incremental GL→PPh21 pipeline. It specifies naming and typing rules, extract & paging behavior, watermark safety, canonical staging and RowHash rules, strict validation gates (Blocker/High/Normal), exception handling and packs, finalization math (annualize/prorate/deductions/progressive tax/gross-up), reconciliation and audit packaging, security/PII controls, retention and archive policy, change-control, QA tests, and run-day operator scripts. The manual includes run-level records, remediation playbooks, and worked numeric examples so operators, implementers, auditors, and tax leads can run and review without additional assistance. It is clear and thorough.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Immediate legal & technical anchor points you must confirm before running</strong><br> • Regulatory anchors — Retrieve and archive official PMK and DGT texts that apply to processing year. Record exact PMK/DGT reference number(s) and archived PDF file path in <code>metadata</code>. Confirm PTKP table values from those docs and record signed attestation by Tax Lead. <br> • Ortax anchor — Obtain Ortax Yearly input template for processing year. Confirm exact input column names and TER/engine behaviors. Store Ortax version and template checksum in <code>metadata</code>. <br> • D365 anchor — Confirm OData entity names and <code>ModifiedDate</code> behavior for your tenant (UTC vs local offset, precision). Record OData base URL, resource paths, and service account with scope/expiry in <code>metadata</code>. Verify D365 returns server-driven paging via <code>@odata.nextLink</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Audience and scope (who should use this manual)</strong><br> For payroll operators, integrators, BI engineers, DBAs, tax leads. Assumes no advanced programming; Power Query copy patterns and pasteable VBA macros ok. Covers configuration, run ops, validation, exception handling, finalization math, reconciliation, audit packaging, security controls, change control, QA, troubleshooting. Includes operator checklists, artifacts, templates, worked numeric examples.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>High-level architecture & responsibilities (concise)</strong><br> • Source: Dynamics 365 payroll & GL via OData. <br> • Extractor: Power Query (Excel) or ETL — incremental queries using watermark (<code>ModifiedDate gt watermark</code>) and follow server-driven paging. <br> • Staging: canonical <code>Snapshot_GL</code> with normalized business fields + <code>RowHash</code>. Could be Excel table or secure DB. <br> • Delta detection: <code>Delta_Log</code> records INSERT/UPDATE/DELETE with pre/post images & run metadata. <br> • Mapping: <code>Component_Map</code> maps source codes → Ortax IDs and enforces units. <br> • Validation: <code>ValidatePPh21Inputs</code> enforces Blocker/High/Normal gates and writes <code>Exceptions</code>. <br> • Finalizer: <code>FinalizeYearEnd</code> performs annualization, deductions, progressive tax calc, gross-up solver → <code>tbl_tax_results</code>. <br> • Export & Archive: values-only frozen snapshot exported and stored encrypted with manifest and changelog.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>One-line run model (practical)</strong><br> Query D365 where <code>ModifiedDate &gt; watermark</code>; normalize and sanitize money; compute RowHash; merge into <code>Snapshot_GL</code> → <code>Delta_Log</code>; run validations; if no Blockers persist artifacts; for final run run finalization, reconcile to GL, produce export package, atomically persist watermark.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Strict naming and typing rules (enforcement and examples)</strong><br> Names & types mandatory. Use exact worksheet/table/column names. Monetary columns = integer IDR (no floats). Primary keys = text. Canonical required tables: <code>tbl_employee_information</code>, <code>tbl_tax_calculation_method</code>, <code>tbl_income_components</code>, <code>tbl_deductions</code>, <code>tbl_tax_results</code>, <code>tbl_tax_rates</code>, <code>tbl_ptkp_table</code>, <code>metadata</code>, <code>qa</code>, <code>changelog</code>, <code>Extract_Audit</code>, <code>Delta_Log</code>, <code>Exceptions</code>, <code>execution_log</code>. Column constraints: <code>employee_id</code> (text, unique), <code>source_voucher_id</code> (text), <code>value_unit</code> ∈ {<code>monthly</code>,<code>annual</code>,<code>YTD</code>}. <code>income_period_until_month</code> integer 1–12. Any deviation → validation severity applied. Log every type coercion in <code>Extract_Audit</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Monetary handling rules (exhaustive operational rules)</strong><br> 1) All monetary inputs converted to integer IDR at ingestion. Rules: strip currency symbols/thousands separators, parentheses = negative, parse decimals and round half-up to nearest IDR. Keep original raw string in <code>staging_raw_amount</code>. <br> 2) No implicit unit conversion. Column names must label unit (e.g., <code>basic_salary (monthly)</code>). Extractor must not silently multiply monthly → annual. Unit mismatches between incoming <code>value_unit</code> and <code>Component_Map</code> expected unit = High and block finalization until resolved. <br> 3) For <code>value_unit=YTD</code>, ingestion must require <code>income_period_until_month</code>. Missing → Blocker. <br> 4) Negative amounts allowed only when <code>correction_flag</code>=TRUE and <code>correction_reason</code> + <code>source_voucher_id</code> present. Unexpected negatives → Blocker. Negatives with <code>correction_flag</code> but missing reason → High. Record voucher evidence in <code>evidence/</code> and link to <code>Exceptions</code>. <br> 5) Record all rounding adjustments and residuals per-run & per-employee in <code>finalization_audit</code> and <code>Extract_Audit.rounding_log</code>. Do not absorb rounding silently.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Employee master minimum fields, validation, and remediation</strong><br> Required fields: <code>employee_id</code>, <code>name</code>, <code>npwp_status</code> (TRUE/FALSE), <code>npwp_number</code> (mask for external export), <code>marital_status</code> (single/married), <code>number_of_dependents</code> (0–3), <code>join_date</code>, <code>termination_date</code> (nullable), <code>income_period_until_month</code> (1–12), <code>prorate_mode</code> (extrapolate/prorate/no_annualize). <code>employee_id</code> uniqueness violation = Blocker. Create <code>EmployeeDuplicates_&lt;run_id&gt;.csv</code> and escalate to HR. Also require <code>employee_status</code> (active/inactive) and <code>payroll_group</code>. NPWP masked in external exports; full access limited and recorded.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Component Map — structure, governance, and run-time enforcement</strong><br> <code>Component_Map</code> fields: <code>source_component_code</code>, <code>source_component_name</code>, <code>ortax_component_id</code>, <code>ortax_component_label</code>, <code>value_unit_expected</code>, <code>taxable_flag</code>, <code>notes</code>, <code>version</code>. Unmapped <code>source_component_code</code> at extract = Blocker → produce <code>UnmappedComponents_&lt;run_id&gt;.csv</code>. Changes to map require ticket, test promotion, QA results, Tax Lead sign-off. Archive old map versions with checksum in manifest. Ambiguous mappings produce High flags and need owner assignment before finalization.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>RowHash — purpose, exact composition, normalization, and versioning</strong><br> Purpose: detect business-level changes, ignore system noise. Composition: concatenate fixed ordered business fields (example: <code>employee_id</code>, <code>source_component_code</code>, <code>posting_date</code> ISO YYYY-MM-DD, <code>amount</code> integer IDR, <code>value_unit</code> uppercase, <code>income_period_until_month</code> or <code>&lt;NULL&gt;</code>), single-character delimiter; normalize strings: trim, collapse multiple spaces to single, uppercase. Compute cryptographic digest (SHA-256 recommended) on normalized UTF-8 bytes. Store hex digest in <code>Snapshot_GL.rowhash</code>. Document method & <code>rowhash_version</code> in <code>metadata</code>. If RowHash changes, controlled migration with both hashes or crosswalk. Never include system fields (e.g., <code>ModifiedDate</code>) in RowHash.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Watermark semantics and safety (detailed rules and failure modes)</strong><br> <code>metadata.watermark</code> = last-successful-extract timestamp in UTC ISO 8601. Query D365 with strict greater-than: <code>ModifiedDate gt watermark</code> to avoid dupes. Never update watermark until run finishes successfully (all validation gates, persistence of <code>Delta_Log</code>, archiving of required artifacts). On run fail write <code>run_status=failed</code> into <code>execution_log</code> and leave watermark unchanged. Retries use new <code>run_id</code> and record <code>run_retry_of</code>. Ensure host clocks NTP-synced and confirm D365 <code>ModifiedDate</code> timezone semantics. Keep <code>watermark_history</code> for forensic replays.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>OData server-driven paging — production guidance and best practices (no reconstruction of skip tokens)</strong><br> Follow <code>@odata.nextLink</code> until absent. Do not construct <code>$skip</code> manually unless tenant docs permit. Use <code>$select</code> to fetch minimal fields. Log each page's URL, HTTP status, row count to <code>Extract_Audit.page_trace</code>. On HTTP error (429/5xx) perform configured retries with backoff; fail run (Blocker) if unretrievable within retry limits. If paging stops mid-run, do not update watermark and mark run failed. Store full page trace for auditors.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Power Query practical pattern and operator controls (conceptual steps without code)</strong><br> - Parameterize watermark as <code>cfg_Watermark</code> and use in OData <code>$filter</code>. <br> - Limit columns using <code>$select</code> to minimal set for RowHash and mapping. <br> - Implement pagination helper that follows <code>@odata.nextLink</code>; if PQ lacks robust unfolding, use smallest supported pattern and log page traces. <br> - Staging transforms: trim/uppercase text; coerce dates to ISO; sanitize monetary strings → integer IDR round-half-up; coerce enums; compute composite key if PQ hashing not available. <br> - Left-join Component_Map and create <code>UnmappedComponents</code>. <br> - Persist only staging tables from PQ; do not persist watermark from PQ. Orchestrator macro persists watermark after validations succeed. Document PQ refresh dependency order and result locations in <code>Extract_Audit</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Validation gates — exhaustive list of Blockers (must stop run) and operator remediation</strong><br> Blockers halt finalization and force remediation. Examples: missing required columns; duplicate <code>employee_id</code>; <code>number_of_dependents</code> outside 0–3; negative monetary without <code>correction_reason</code> and <code>source_voucher_id</code>; any <code>source_component_code</code> not in Component_Map; PTKP or <code>tax_rates</code> not covering date ranges present; gross-up nonconvergence; failure to retrieve all pages from OData. For each Blocker produce <code>Exceptions_&lt;run_id&gt;.xlsx</code> and exceptions ZIP with evidence; assign owner and require sign-off + evidence before re-run. Maintain full audit trail for remediation.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Validation gates — High and Normal severity definitions and handling</strong><br> High severity: serious but may allow ingestion to continue for investigation (e.g., correction flagged but missing reason, ambiguous mapping). High must be assigned owner with due date ≤ 3 business days. Normal: formatting quirks auto-corrected where safe, assigned owner with due date ≤ 7 business days. All validations recorded in <code>Exceptions</code> with <code>owner</code>, <code>due_date</code>, <code>evidence_required</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Finalization sequence — precise operator order and responsibilities</strong><br> 1) Confirm <code>metadata.ptkp_version</code> & <code>metadata.tax_rates_version</code> and ensure PMK/DGT PDFs present in evidence folder referenced in <code>metadata</code>. <br> 2) Run extract orchestrator to populate staging & <code>Delta_Log</code>. <br> 3) Inspect <code>Extract_Audit</code> and <code>Delta_Log</code> for unexpected volume changes and <code>UnmappedComponents</code>. <br> 4) Execute <code>ValidatePPh21Inputs</code> and remediate Blockers. Re-run validation until Blockers cleared. <br> 5) For final runs execute finalization: freeze mapping versions, annualize/prorate per-employee <code>prorate_mode</code>, compute deductions with caps and record both <code>deduction_computed</code> and <code>deduction_applied</code>, calculate <code>annual_taxable_income_pkp</code>, apply progressive tax rates → annual tax, solve gross-up where flagged, allocate monthly withholding by dividing annual tax by 12 with documented rounding. <br> 6) Run <code>ReconcileGL</code> comparing <code>sum(pph21_withheld)</code> to GL control account for same watermark period. <br> 7) If reconciled within tolerance and no Blockers, produce <code>PPh21_Final_&lt;YYYY&gt;_Snapshot.xlsx</code> values-only, encrypt & archive, append run to <code>changelog</code>, persist watermark. If reconciliation/residuals remain, escalate per policy.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Annualization & prorate modes (operational definitions and exact effects)</strong><br> Operators choose per-employee <code>prorate_mode</code> in <code>metadata</code>. Modes: <br> 1) <code>extrapolate</code> — For <code>value_unit=YTD</code> with <code>income_period_until_month = m</code>, annual = <code>YTD_amount × (12 / m)</code>. Use only when reliable. Document in <code>finalization_audit</code>. <br> 2) <code>prorate</code> — Compute <code>months_worked</code> per employee using <code>prorate_policy</code> and convert recurring monthly components by months worked. Document day-to-month counting rules in <code>metadata.prorate_policy</code>. <br> 3) <code>no_annualize</code> — Use values as provided; no extrapolate. Record chosen mode in <code>metadata</code> and per-employee calculation traces in <code>finalization_audit</code>. Show derivation lines for auditors.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Gross-up behavior (exact operational rules, solver policy, and audit trace expectations)</strong><br> Purpose: compute gross so post-tax net = target net when employer pays tax. Rules: <br> 1) Use same PTKP & progressive rates as ordinary employees. <br> 2) Configure solver bounds/tolerances in <code>metadata</code> (default tolerance = 1 IDR, max iterations 50, default upper bound multiplier 3× target net). <br> 3) Use bounded numeric method (bisection recommended) and record each iteration to <code>changelog_grossup_&lt;run_id&gt;.csv</code> with iteration, bounds, candidate gross, taxable income, tax, candidate net, diff. <br> 4) If solver fails to converge within max iterations mark Blocker and escalate. Do not accept silent approximations. <br> 5) Auditors must get full iteration trace & solver config in exception pack.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Deduction handling — computed vs applied and overrides governance</strong><br> 1) Compute <code>deduction_computed</code> via <code>tbl_deductions</code> logic; <code>deduction_applied</code> = what used after caps/overrides. 2) Never overwrite <code>deduction_computed</code>. 3) Manual override must include <code>override_reason</code>, <code>override_owner</code>, <code>evidence_voucher_id</code>. 4) All overrides require owner sign-off and logged in <code>deduction_audit_&lt;run_id&gt;.csv</code>. 5) Keep both fields in final snapshot.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>PTKP & tax rates — mandatory versioning and coverage checks</strong><br> 1) Load PTKP and tax rates with <code>effective_from</code>, <code>effective_to</code>, <code>version</code>.<br> 2) Finalizer verifies every date in processing year covered by exactly one PTKP & one tax_rate set.<br> 3) Any uncovered date range = Blocker until coverage added or approved override documented in <code>metadata</code>.<br> 4) Record PMK/DGT numbers and PDFs in evidence and <code>metadata.ptkp_reference</code>, <code>metadata.tax_rates_reference</code>.<br> 5) For split-year PMK apply correct PTKP pro rata or block if no policy exists.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Reconciliation rules & tolerance policy (detailed tie-out)</strong><br> 1) Reconcile <code>sum(pph21_withheld)</code> (from <code>tbl_tax_results</code> for watermark range) with <code>sum_d365_control</code> (D365 control account for same watermark period & voucher scope).<br> 2) Compute <code>difference</code> and record <code>difference_reason</code> and <code>voucher_sample_range</code>.<br> 3) Default operator tolerance = 1,000 IDR.<br> 4) Differences > tolerance = High; differences > escalation threshold (configurable, e.g., 50,000 IDR) = Blocker and immediate escalation to Tax Lead & Finance Ops.<br> 5) Produce <code>Reconciliation_&lt;run_id&gt;.pdf</code> with tie-out lines, sample vouchers, reconciliation notes.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Exceptions pack contents (required files and structure)</strong><br> 1) On Blocker produce ZIP containing: <code>Exceptions_&lt;run_id&gt;.xlsx</code> (Summary/Details/Owners), <code>Delta_Log_&lt;run_id&gt;.csv</code>, <code>Extract_Audit_&lt;run_id&gt;.pdf</code> (one-page summary), <code>evidence/</code> (voucher PDFs/screenshots), <code>metadata_snapshot.json</code> (watermark, component_map_version, ptkp_version, tax_rates_version), <code>UnmappedComponents_&lt;run_id&gt;.csv</code> if present, and any <code>changelog_grossup_&lt;run_id&gt;.csv</code>.<br> 2) Provide secure access link; do not email PII.<br> 3) Log exception pack creation in <code>execution_log</code>.<br> 4) Include remediation steps and assigned owners with due dates.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Security & PII handling (practical operator rules, masking and approvals)</strong><br> 1) NPWP masking: external exports show only last three digits or salted hash. Full NPWP in secure env only; access logged.<br> 2) Final snapshots in archive encrypted with approved envelope encryption; record key ID & custodian in <code>manifest</code>.<br> 3) Exports with PII require two-person sign-off recorded in <code>changelog</code> with operator & reviewer attestation.<br> 4) Maintain <code>pii_access_log</code> capturing accessor ID, purpose, timestamp, files accessed, link to approval evidence.<br> 5) All PII actions logged immutably and retained per retention policy.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Run auditing — mandatory run-level records and immutable storage</strong><br> 1) Each run persist: <code>run_id</code> (UUID), <code>operator</code>, <code>start_time</code> (UTC), <code>end_time</code> (UTC), <code>extraction_watermark_start</code>, <code>extraction_watermark_end</code>, <code>rows_fetched</code>, <code>rows_inserted</code>, <code>rows_updated</code>, <code>rows_deleted</code>, <code>exceptions_count_by_severity</code> (JSON), <code>archive_path</code>, <code>component_map_version</code>, <code>ptkp_version</code>, <code>tax_rates_version</code>, <code>manifest_checksum</code>.<br> 2) Store <code>Delta_Log</code> and <code>Extract_Audit</code> as immutable CSV & PDF in encrypted archive.<br> 3) Keep <code>run_summary.json</code> for monitoring.<br> 4) Logs tamper-evident (checksummed) and retained per retention policy.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Operator quick-check checklist (copyable, step-by-step)</strong><br> 1) Confirm Component_Map & HR master sign-off in <code>changelog</code>.<br> 2) Confirm <code>metadata.ptkp_version</code> & <code>metadata.tax_rates_version</code>; PMK/DGT PDFs present.<br> 3) Open workbook & enable macros; set <code>cfg_run_mode</code> to <code>incremental</code> or <code>final</code>.<br> 4) Run extract orchestrator to refresh PQ & populate staging.<br> 5) Review <code>Extract_Audit</code> & <code>Delta_Log</code>; inspect <code>UnmappedComponents</code> and top exceptions.<br> 6) Run <code>ValidatePPh21Inputs</code> and remediate Blockers.<br> 7) If final run: run <code>FinalizeYearEnd</code>, then <code>ReconcileGL</code>; if reconciled & no Blockers, <code>ExportFinalSnapshot</code>, then <code>PersistWatermark</code>.<br> 8) Append signed entries to <code>changelog</code> and store manifest in archive.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Change control & mapping change process (required steps)</strong><br> 1) When altering <code>Component_Map</code>, <code>PTKP_Table</code>, or <code>Tax_Rates</code>: create change ticket with rationale & impact.<br> 2) Implement in test workbook & run QA suite.<br> 3) Save QA results & evidence.<br> 4) Obtain Tax Lead sign-off in ticket.<br> 5) Promote to prod & snapshot previous with checksum in manifest.<br> 6) Communicate timing & expected effects to stakeholders.<br> 7) Document rollback steps & window.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>QA test-suite (12 canonical tests with explicit expectations)</strong><br> 1) Save tests in <code>qa</code> with inputs & expected outputs.<br> 2) Tests reproducible & cover edge cases.<br> 3) Include zero income, near-PTKP thresholds, bracket crossing, bonus handling, mid-year hires/resignations, gross-up convergence, negative corrections, PTKP coverage gaps, multi-page OData dedupe.<br> 4) Each test: <code>test_id</code>, <code>scenario</code>, <code>inputs</code>, <code>expected</code>, <code>actual</code>, <code>diff</code>, <code>pass/fail</code>, math trace.<br> 5) Retain QA run evidence for production promotion.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Multiple worked examples — fully worked numeric traces and operator actions</strong></td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Example 1 — Simple annualization (Employee A)</strong>: <code>basic_salary (monthly)=10,000,000</code>; annual = 120,000,000. PTKP single=54,000,000 → PKP=66,000,000. Apply progressive brackets → annual tax → monthly withholding = annual/12 round-half-up. Record rounding residuals in <code>finalization_audit</code>. Operator: run extract, validate, finalize, check <code>finalization_audit</code> row for employee.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Example 2 — Mid-year hire (Employee B)</strong>: <code>basic_salary (monthly)=12,000,000</code>, <code>join_date=2025-05-15</code>, <code>income_period_until_month=8</code>, <code>value_unit=YTD</code>, <code>prorate_mode=prorate</code>. Determine months worked per <code>metadata.prorate_policy</code>. Compute prorated annual equivalents; document in <code>finalization_audit</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Example 3 — Bonus annual (Employee C)</strong>: <code>bonus_thr (annual)=30,000,000</code> + monthly salary 8,000,000 → annual = 126,000,000. Verify <code>value_unit</code> for bonus = <code>annual</code>. If mismatch → High and halt finalization until corrected.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Example 4 — Gross-up (Employee D)</strong>: Employer wants net 8,000,000 monthly. Mark <code>calculation_method=gross_up</code>. Solver runs bounded numeric iterations with tolerance; record iterations in <code>changelog_grossup</code>. If converged store gross & trace; if not converged → Blocker.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Example 5 — Negative correction (Employee E)</strong>: <code>amount=-5,000,000</code>, <code>correction_flag=TRUE</code>, <code>correction_reason=&#x27;Overpay correction&#x27;</code>, <code>source_voucher_id=JV-2025-00045</code>. Validation accepts if voucher evidence present & linked in <code>evidence/</code>. If evidence missing → High/Blocker as specified.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Example 6 — Reconciliation sample</strong>: After finalization <code>sum(pph21_withheld)=1,235,000,000</code>. D365 reports 1,234,995,000. Diff=5,000; default tolerance=1,000 → High. Create reconciliation note describing rounding/timing; attach voucher sample range JV-2025-0123..JV-2025-0150 and produce <code>Reconciliation_&lt;run_id&gt;.pdf</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Exception escalation policy and SLAs (exact)</strong><br> 1) Blocker: immediate notification to Tax Lead & Payroll Ops; stop finalization.<br> 2) High: assign owner due ≤ 3 business days; Tax Lead notified.<br> 3) Normal: assign owner due ≤ 7 business days.<br> 4) Record all remediation steps in <code>changelog</code> as <code>owner</code>, <code>action</code>, <code>evidence_path</code>, closure timestamp.<br> 5) Waivers only with Tax Lead written approval in <code>changelog</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Deliverables to implementers (catalog and exact expectations)</strong><br> 1) Provide: PQ workbook with queries named as described; <code>Component_Map</code> CSV template with required headers; <code>PTKP_Table</code> & <code>Tax_Rates</code> CSV templates with effective dates & versions; VBA macro module implementing orchestrator macros (or equivalent ETL orchestrator) that writes logs & manifests; <code>qa</code> sheet populated with unit tests and expected values; this runbook linked in workbook.<br> 2) Each deliverable must include usage/readme and <code>manifest</code> with checksums & versions.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Archive & retention policy (exact rules)</strong><br> 1) Final snapshots & Delta_Logs kept current year + 7 years in encrypted immutable storage.<br> 2) Keep monthly first-of-month snapshots and yearly final snapshots read-only.<br> 3) Store <code>Component_Map</code>, <code>PTKP_Table</code>, <code>Tax_Rates</code> versions with checksums in manifest each run.<br> 4) Retention align with statutory & org policy; deletion only per documented lifecycle and records custodian authorization.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Troubleshooting quick recipes (actionable steps)</strong><br> 1) No rows returned: check <code>cfg_Watermark</code> format (UTC ISO8601), service account permissions, API throttling; check <code>Extract_Audit</code> HTTP statuses.<br> 2) Duplicate rows after paging: ensure followed <code>@odata.nextLink</code> exactly; check RowHash dedupe logic.<br> 3) PTKP mismatch: verify <code>metadata.ptkp_version</code> & PMK/DGT evidence; if missing → Blocker.<br> 4) Gross-up failure: inspect <code>changelog_grossup</code> iter trace; consider increasing upper bound only after Tax Lead approval.<br> 5) For every recipe produce action log entry and attach artifacts before re-running validation.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Audit packaging and exact files (order and manifest expectations)</strong><br> 1) Provide auditors ZIP in order: values-only <code>PPh21_Final_&lt;YYYY&gt;_Snapshot.xlsx</code>, <code>Delta_Log_&lt;run_id&gt;.csv</code>, <code>Extract_Audit_&lt;run_id&gt;.pdf</code> (one-page exec summary), <code>Component_Map_&lt;version&gt;.csv</code>, <code>PTKP_Table_&lt;version&gt;.csv</code> with PMK refs, <code>Tax_Rates_&lt;version&gt;.csv</code>, <code>changelog_&lt;run_id&gt;.csv</code> with operator signatures, <code>evidence/</code> with sampled vouchers.<br> 2) Include one-page executive summary with run_id, watermark range, rows processed, reconciliation tie-out, archive checksum.<br> 3) Store archive in encrypted retention store and add manifest checksum to <code>execution_log</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Regulatory monitoring and subscriptions (recommended practice)</strong><br> 1) Subscribe to DGT announcements, Ministry of Finance PMK releases, Ortax release notes.<br> 2) Document monitoring cadence (weekly checks + immediate on PMK release) and record subscriptions in <code>metadata.regulatory_subscriptions</code>.<br> 3) When PMK affects PTKP/PPh21 create ticket and assign Tax Lead to update <code>tbl_ptkp_table</code> & <code>tbl_tax_rates</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Performance & scaling notes (practical guidance)</strong><br> 1) Tens of thousands of payroll rows → multi-page OData; log pages and consider secure DB staging for upserts & indexes on <code>employee_id</code> & <code>rowhash</code>.<br> 2) If Excel/PQ memory limits reached offload heavy joins & gross-up to secure DB or ETL service; keep final Ortax-shaped CSVs in workbook.<br> 3) Use incremental testing on production-like dataset to tune batch sizes & retry logic.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Implementation decisions to lock down in <code>metadata</code> (required items before finalization)</strong><br> 1) Lock: <code>rowhash_method</code> & <code>rowhash_version</code>, <code>prorate_policy</code> day counting rules, <code>gross_up_upper_bound_multiplier</code>, <code>gross_up_max_iterations</code>, <code>gross_up_tolerance</code>, <code>reconciliation_tolerance</code>, <code>ptkp_version</code>, <code>tax_rates_version</code>, <code>component_map_version</code>, <code>pii_export_approvers</code>, <code>archive_kms_key_id</code>.<br> 2) Do not finalize run until fields filled & reviewer attests in <code>changelog</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Operator training & run simulation (mandatory pre-production items)</strong><br> 1) Run full flow against test data covering all 12 QA cases.<br> 2) Simulate paging & verify dedupe.<br> 3) Simulate extraction failures & confirm watermark does not update.<br> 4) Produce Exceptions pack & walk remediation to closure.<br> 5) Conduct mock audit: create audit ZIP and have auditor review.<br> 6) Document training & sign-off in <code>changelog.training</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>References & reading (authoritative sources to keep on file)</strong><br> 1) Keep local copies: DGT guidance on PTKP & PPh21, PMK regulations that affect PTKP/PPh21, Ortax Yearly templates & TER rules, Microsoft docs on OData server-driven paging & Power Query behavior.<br> 2) Store each source in <code>evidence/</code> with checksum and reference in <code>metadata</code>.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Run monitoring and operational telemetry (suggested fields for dashboard)</strong><br> 1) Publish metrics: <code>last_run_time</code>, <code>last_run_status</code>, <code>watermark_start</code>, <code>watermark_end</code>, <code>rows_fetched</code>, <code>rows_inserted</code>, <code>rows_updated</code>, <code>exceptions_count_by_severity</code>, <code>last_reconciliation_difference</code>, <code>archive_checksum</code>.<br> 2) Alert thresholds for missing runs, high exception volumes, reconciliation breaches, repeated gross-up failures.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Operator scripts and copyable run checklist (plain, step-by-step)</strong><br> 1) Generate <code>run_id</code> and set <code>cfg_run_mode</code> to <code>incremental</code> or <code>final</code>.<br> 2) Confirm <code>component_map_version</code>, <code>ptkp_version</code>, <code>tax_rates_version</code> set & evidence present.<br> 3) Open workbook & enable macros.<br> 4) Start extract orchestrator to refresh PQ & populate staging.<br> 5) Review <code>Extract_Audit</code> & <code>Delta_Log</code>.<br> 6) Run validation; remediate Blockers and re-run.<br> 7) If <code>is_final_run</code> and validations clear → run finalization, reconciliation, export snapshot.<br> 8) Persist watermark atomically & archive manifest.<br> 9) Add operator & reviewer signatures to <code>changelog</code>.<br> 10) Archive run folder checksummed for audit.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Appendices — templates, expected file formats, and operator artifacts (described)</strong><br> 1) Appendices include CSV header lists, manifest field descriptions, exception pack lists, expected artifact filenames.<br> 2) Example: <code>Delta_Log</code> must include <code>run_id</code>, <code>rowhash</code>, <code>change_type</code>, <code>source_voucher_id</code>, <code>employee_id</code>, <code>component_code</code>, <code>amount</code> (integer IDR), <code>value_unit</code>, <code>income_period_until_month</code>, <code>modified_date</code>, <code>pre_image</code> & <code>post_image</code> pointers, <code>created_at</code>.<br> 3) Manifest must include run-level fields: run_id, watermark start/end, versions used, row counts, delta counts, archive checksum.<br> 4) Keep appendices with implementation artifacts in archive for each run.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>Final governance & sign-off checklist before production</strong><br> 1) Must have: passing QA on all 12 tests, signed change ticket & Tax Lead approval for initial Component_Map & PTKP/tax rates, <code>metadata</code> locked for production, approved encryption key custodianship, failure-mode simulations verifying watermark safety, operator training recorded, monitoring dashboard configured with alert thresholds, mock audit run producing complete audit ZIP.<br> 2) Only after recorded in <code>changelog</code> schedule production.</td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end manual"><strong>How to request deliverables now (choose one to generate immediately)</strong><br> Ready to generate an implementable artifact now. Choose one: (A) Full GL→PPh21 column mapping CSV with exact Ortax column names & types, (B) Power Query M skeleton structure & parameter naming (explanatory without code), (C) VBA orchestrator macro specifications and run sequencing (descriptive signatures & side-effects only, no code), (D) <code>qa</code> sheet CSV populated with the 12 unit tests & expected numeric values. State the choice and the assistant will generate the artifact here.</td></tr></tbody></table></div><div class="row-count">Rows: 50</div></div><div class="table-caption" id="Table2" data-table="Docu_0173_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Incremental GL Extractor → PPh21 year-end"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Incremental GL Extractor → PPh21 year-end</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>Preface (one line)</strong><br> This addendum extends the previously-provided complete manual with additional low-level definitions, explicit schema, validation predicates, orchestrator state machine, operator command signatures, exception-pack manifest examples, extra worked examples, extended QA set, monitoring/alerting rules, and on-call remediation playbooks — additive to and not removing any existing content. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>A. Expanded canonical data dictionary (field-level definitions, types, constraints, examples)</strong><br> For every canonical table referenced in the runbook provide exact field, canonical SQL type, max length, nullability, example value, validation constraint, and audit note. Line items: <br> 1) <code>tbl_employee_information.employee_id</code> — <code>VARCHAR(64)</code> — NOT NULL — example: <code>E001</code> — Constraint: unique per active <code>payroll_group</code> and non-empty. Audit: if duplicate found create <code>EmployeeDuplicates_&lt;run_id&gt;.csv</code>. <br> 2) <code>tbl_employee_information.name</code> — <code>VARCHAR(256)</code> — NOT NULL — example: <code>Siti Aminah</code> — Constraint: strip control chars, collapse spaces; record original in <code>staging_raw_name</code>. <br> 3) <code>tbl_employee_information.npwp_status</code> — <code>BOOLEAN</code> — NOT NULL — example: <code>TRUE</code> — Constraint: must be TRUE/FALSE only; if TRUE <code>npwp_number</code> must be present and pass regex <code>[0-9]{15}</code> (apply masking rules on export). <br> 4) <code>tbl_employee_information.npwp_number</code> — <code>VARCHAR(20)</code> — NULLABLE (required when <code>npwp_status=TRUE</code>) — example: <code>12.345.678.9-012.000</code> — Storage: encrypted at rest with field-level key; external exports use masked form <code>***********000</code>. <br> 5) <code>tbl_income_components.source_component_code</code> — <code>VARCHAR(64)</code> — NOT NULL — example: <code>COMP_BASIC</code> — Constraint: must match active <code>Component_Map.source_component_code</code>. Unmapped → Blocker. <br> 6) <code>tbl_income_components.value_unit</code> — <code>ENUM(&#x27;monthly&#x27;,&#x27;annual&#x27;,&#x27;YTD&#x27;)</code> — NOT NULL — example: <code>monthly</code> — Constraint: must match <code>Component_Map.value_unit_expected</code>. Mismatch → High. <br> 7) <code>tbl_income_components.amount</code> — <code>BIGINT</code> — NOT NULL — example: <code>10000000</code> — Units: integer IDR. Negative allowed only under correction rules. Ingestion must write <code>staging_raw_amount</code>. <br> 8) <code>tbl_income_components.income_period_until_month</code> — <code>TINYINT</code> — NULLABLE — example: <code>8</code> — Constraint: if <code>value_unit=&#x27;YTD&#x27;</code> then NOT NULL and between 1–12; else may be NULL. Missing when required → Blocker. <br> 9) <code>Snapshot_GL.rowhash</code> — <code>CHAR(64)</code> — NOT NULL — example: SHA-256 hex — Constraint: <code>rowhash_version</code> declared in <code>metadata</code>. <br> 10) <code>Delta_Log.change_type</code> — <code>ENUM(&#x27;INSERT&#x27;,&#x27;UPDATE&#x27;,&#x27;DELETE&#x27;)</code> — NOT NULL — example: <code>UPDATE</code> — Audit: include <code>pre_image</code> and <code>post_image</code> pointers; store per-run deltas immutably. <br> 11) <code>metadata.watermark</code> — <code>TIMESTAMP WITH TIME ZONE</code> — NOT NULL — example: <code>2025-12-31T23:59:59Z</code> — Constraint: stored in UTC ISO 8601; only change on successful finalization. <br> 12) <code>execution_log.run_id</code> — <code>UUID</code> — NOT NULL — example: <code>1f3a5b4e-...</code> — Constraint: unique; ties all artifacts. <br> 13) <code>finalization_audit.rounding_log</code> — JSON array — NOT NULL — example: <code>[{&quot;employee_id&quot;:&quot;E001&quot;,&quot;component&quot;:&quot;basic_salary&quot;,&quot;rounding&quot;:-1}]</code> — Audit: include original, computed, finalized amounts and rationale. <br> 14) <code>tbl_tax_rates.effective_from</code> / <code>effective_to</code> — <code>DATE</code> — NOT NULL — Constraint: contiguous and non-overlapping ranges for the processing year; missing coverage → Blocker. <br> 15) <code>pii_access_log.record</code> — JSON — NOT NULL — example: <code>{&quot;accessor&quot;:&quot;ops_user&quot;,&quot;purpose&quot;:&quot;export_snapshot&quot;,&quot;timestamp&quot;:&quot;2025-12-31T20:00:00Z&quot;,&quot;file&quot;:&quot;PPh21_Final_2025_Snapshot.xlsx&quot;}</code> — Audit: write-once and checksummed. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>B. Expanded validation rule matrix (rule id, SQL-like predicate, severity, remediation steps)</strong><br> Explicit predicates for machine evaluation with remediation guidance and evidence required. Line items: <br> 1) <code>R001</code> — Predicate: <code>employee_id IS NULL OR employee_id = &#x27;&#x27;</code> — Severity: Blocker — Remediation: HR must supply employee_id; produce <code>MissingEmployeeID_&lt;run_id&gt;.csv</code>; evidence: HR master file and ticket id. <br> 2) <code>R002</code> — Predicate: <code>amount IS NULL</code> — Severity: Blocker — Remediation: investigate extraction; attach page trace; if intentional add correction voucher and <code>correction_flag=TRUE</code>. <br> 3) <code>R003</code> — Predicate: <code>value_unit = &#x27;YTD&#x27; AND income_period_until_month IS NULL</code> — Severity: Blocker — Remediation: request <code>income_period_until_month</code> or set <code>prorate_mode=no_annualize</code> with Tax Lead waiver recorded. <br> 4) <code>R004</code> — Predicate: <code>source_component_code NOT IN (SELECT source_component_code FROM Component_Map WHERE version = metadata.component_map_version)</code> — Severity: Blocker — Remediation: generate <code>UnmappedComponents_&lt;run_id&gt;.csv</code>; owner: Payroll Integrations; required: mapping ticket and sample vouchers. <br> 5) <code>R005</code> — Predicate: <code>number_of_dependents NOT BETWEEN 0 AND 3</code> — Severity: Blocker — Remediation: HR verify and correct; provide supporting documents or update master. <br> 6) <code>R006</code> — Predicate: <code>abs(sum(pph21_withheld) - sum_d365_control) &gt; metadata.reconciliation_tolerance</code> — Severity: High/Blocker depending on threshold — Remediation: create reconciliation ticket, include sample voucher ranges, attach <code>Reconciliation_&lt;run_id&gt;.pdf</code>. <br> 7) <code>R007</code> — Predicate: <code>exists(negative_amounts WHERE correction_flag IS NULL OR correction_reason IS NULL)</code> — Severity: High/Blocker per count — Remediation: require vouchers, link to <code>evidence/</code>, escalate to Tax Lead. <br> 8) <code>R008</code> — Predicate: <code>component_map_version IS NULL OR ptkp_version IS NULL OR tax_rates_version IS NULL</code> — Severity: Blocker — Remediation: fill metadata and require reviewer attestation in <code>changelog</code>. <br> 9) <code>R009</code> — Predicate: <code>exists(rowhashes WHERE rowhash IS NULL OR rowhash = &#x27;&#x27;)</code> — Severity: Blocker — Remediation: recompute rowhash in staging; if algorithm changed perform controlled migration. <br> 10) <code>R010</code> — Predicate: <code>watermark_updated_before_archive = TRUE</code> — Severity: Blocker — Remediation: roll back watermark and restore pre-run artifacts; require post-mortem ticket. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>C. Orchestrator state machine (states, allowed transitions, operator actions, artifacts produced)</strong><br> Deterministic run-state model with transitions and artifact side effects. Line items: <br> 1) <code>STATE = CREATED</code> — Transition to <code>EXTRACTING</code> via <code>orchestrator.start_extract(run_id)</code> — Action: create <code>execution_log</code> start_time. Artifact: <code>run_manifest_pending.json</code>. <br> 2) <code>STATE = EXTRACTING</code> — On completion → <code>STAGING</code> if all pages fetched; on page error → <code>FAILED</code> — Action: write <code>Extract_Audit.page_trace</code>, persist staging tables. Artifact: <code>Extract_Audit_&lt;run_id&gt;.pdf</code> (draft). <br> 3) <code>STATE = STAGING</code> — Operator runs <code>orchestrator.compute_rowhash(run_id)</code> and <code>orchestrator.merge_snapshot()</code> — On success → <code>VALIDATING</code>. Artifact: <code>Delta_Log_&lt;run_id&gt;.csv</code>. <br> 4) <code>STATE = VALIDATING</code> — System runs predicates (see B). If any Blocker → <code>BLOCKED</code> and create <code>Exceptions_&lt;run_id&gt;.xlsx</code> + exception pack ZIP. If no Blocker → <code>FINALIZING</code> (final) or <code>COMPLETED_INCREMENTAL</code> (incremental). <br> 5) <code>STATE = BLOCKED</code> — Operator remediation required; on remediation + sign-off → back to <code>VALIDATING</code>. Artifact: <code>ExceptionsPack_&lt;run_id&gt;.zip</code>, <code>remediation_log.csv</code>. <br> 6) <code>STATE = FINALIZING</code> — Run <code>FinalizeYearEnd</code> (annualization, deductions, gross-up solver). On success → <code>RECONCILING</code>. Artifacts: <code>tbl_tax_results</code>, <code>finalization_audit</code>. <br> 7) <code>STATE = RECONCILING</code> — Run <code>ReconcileGL</code>. If within tolerance → <code>ARCHIVING</code>; else → <code>RECONCILE_BLOCKED</code>. <br> 8) <code>STATE = RECONCILE_BLOCKED</code> — Produce <code>Reconciliation_&lt;run_id&gt;.pdf</code>, assign owner; remediation required; on resolution → <code>RECONCILING</code>. <br> 9) <code>STATE = ARCHIVING</code> — Produce <code>PPh21_Final_&lt;YYYY&gt;_Snapshot.xlsx</code>, ZIP, manifest checksum, envelope-encrypt, store, persist watermark atomically. Artifact: <code>archive://path/PPh21_Final_&lt;YYYY&gt;_Snapshot_&lt;run_id&gt;.zip</code>. → <code>COMPLETED_FINAL</code>. <br> 10) <code>STATE = COMPLETED_FINAL</code> — Final run complete; write <code>execution_log</code> end_time and <code>run_summary.json</code>. <br> 11) <code>STATE = FAILED</code> — Capture failure reason, leave watermark unchanged, require new <code>run_id</code> for retry. Artifact: <code>failure_report_&lt;run_id&gt;.json</code>. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>D. Operator command signatures and macro side-effects (exact names, parameters, and what they write)</strong><br> Deterministic macro/function names and explicit side-effects for auditability. Line items: <br> 1) <code>orchestrator.start_extract(run_id:UUID, cfg_Watermark:TIMESTAMP)</code> — Side-effects: sets <code>execution_log.start_time</code>, writes <code>run_manifest_pending.json</code>, triggers PQ refresh, writes <code>Extract_Audit.page_trace</code> per page in <code>Extract_Audit/&lt;run_id&gt;/pages/</code>. Does NOT update <code>metadata.watermark</code>. <br> 2) <code>orchestrator.compute_rowhash(run_id:UUID, rowhash_version:string)</code> — Side-effects: writes <code>Snapshot_GL.rowhash</code>, <code>Extract_Audit.rowhash_trace.csv</code> with normalized inputs and digest; writes <code>rowhash_version</code> to <code>metadata</code> if new. <br> 3) <code>orchestrator.merge_snapshot(run_id:UUID)</code> — Side-effects: upserts into <code>Snapshot_GL</code>, writes <code>Delta_Log_&lt;run_id&gt;.csv</code> with change_type and pre/post images, timestamps, operator id. <br> 4) <code>orchestrator.run_validations(run_id:UUID)</code> — Side-effects: runs validation set (B), writes <code>Exceptions_&lt;run_id&gt;.xlsx</code> and <code>ExceptionsPack_&lt;run_id&gt;.zip</code> if Blockers found; writes <code>validation_summary.json</code>. <br> 5) <code>orchestrator.finalize_year_end(run_id:UUID, is_dry_run:BOOLEAN)</code> — Side-effects: runs annualization, deduction computation, gross-up solver iterations writing <code>changelog_grossup_&lt;run_id&gt;.csv</code>, writes <code>finalization_audit_&lt;run_id&gt;.csv</code> and <code>tbl_tax_results</code>. If <code>is_dry_run=TRUE</code> do not persist watermark or archive artifacts. <br> 6) <code>orchestrator.reconcile_gl(run_id:UUID, control_account:string)</code> — Side-effects: compares sums, writes <code>Reconciliation_&lt;run_id&gt;.pdf</code>, sets reconciliation status in <code>execution_log</code>. <br> 7) <code>orchestrator.archive_snapshot(run_id:UUID, kms_key_id:string)</code> — Side-effects: creates ZIP, computes checksum, envelope-encrypts payload using <code>kms_key_id</code>, stores in archive store, writes <code>manifest_&lt;run_id&gt;.json</code> with <code>archive_kms_key_id</code>. On success writes watermark atomically. <br> 8) <code>operator.signoff(run_id:UUID, role:ENUM(&#x27;operator&#x27;,&#x27;reviewer&#x27;,&#x27;tax_lead&#x27;), signature_hash:VARCHAR)</code> — Side-effects: append signed entry to <code>changelog</code> and record in <code>run_summary.json</code>. Signatures stored in tamper-evident chain. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>E. Exception pack manifest — exact JSON example and required fields</strong><br> Concrete JSON manifest template to include inside every exception ZIP. Line items: <br> 1) <code>manifest.run_id</code> — <code>UUID</code> — example: <code>&quot;run_id&quot;:&quot;1f3a5b4e-...&quot;</code>. <br> 2) <code>manifest.watermark_start</code> — <code>string</code> (ISO8601) — <code>&quot;2025-12-01T00:00:00Z&quot;</code>. <br> 3) <code>manifest.watermark_end</code> — <code>string</code> (ISO8601) — <code>&quot;2025-12-31T23:59:59Z&quot;</code>. <br> 4) <code>manifest.component_map_version</code> — <code>string</code> — <code>&quot;v2025-11-01&quot;</code>. <br> 5) <code>manifest.ptkp_version</code> — <code>string</code> — <code>&quot;PMK-2025-XX&quot;</code>. <br> 6) <code>manifest.tax_rates_version</code> — <code>string</code> — <code>&quot;v2025-07&quot;</code>. <br> 7) <code>manifest.exceptions_summary</code> — JSON object — example: <code>{&quot;blockers&quot;:3,&quot;high&quot;:5,&quot;normal&quot;:12}</code>. <br> 8) <code>manifest.files</code> — array of file descriptors — each <code>{ &quot;path&quot;:&quot;Exceptions_&lt;run_id&gt;.xlsx&quot;, &quot;sha256&quot;:&quot;hex&quot;, &quot;size_bytes&quot;:12345 }</code>. <br> 9) <code>manifest.evidence_files</code> — array — each <code>{&quot;path&quot;:&quot;evidence/JV-2025-00045.pdf&quot;, &quot;voucher_id&quot;:&quot;JV-2025-00045&quot;, &quot;sha256&quot;:&quot;hex&quot;}</code>. <br> 10) <code>manifest.generated_by</code> — <code>string</code> — <code>&quot;orchestrator.v1.2.3&quot;</code>. <br> 11) <code>manifest.signature</code> — <code>string</code> — detached signature over manifest JSON (tamper evidence). </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>F. Expanded worked examples (additional detailed numeric traces and solver iterations)</strong><br> Explicit arithmetic steps and solver iteration traces. Line items: <br> 1) <strong>Example 7 — Complex bracket crossing</strong>: Employee F monthly Jan–Jun = 10,000,000; Jul–Dec = 15,000,000; bonus Dec = 50,000,000. Steps: <br> • Annualized salary: (10,000,000 × 6) + (15,000,000 × 6) = 60,000,000 + 90,000,000 = 150,000,000. <br> • Add bonus: 150,000,000 + 50,000,000 = 200,000,000. <br> • PTKP single = 54,000,000 → PKP = 146,000,000. <br> • Apply progressive brackets stepwise (document thresholds/rates and per-bracket arithmetic in <code>finalization_audit</code>). <br> • Monthly withholding = round-half-up(annual_tax / 12); record residuals. <br> 2) <strong>Example 8 — Gross-up iteration trace</strong>: target net = 12,000,000 monthly; tolerance = 1 IDR; max_iters = 50; upper_bound_multiplier = 3. Iterative trace format: <code>{iter, lower, upper, candidate_gross, taxable_income, tax, net, diff}</code>; iterate bisect until <code>abs(diff) ≤ 1</code> or iter = 50. If not converged mark Blocker. Provide sample CSV snippet showing 10 iterations. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>G. Expanded QA suite (18 canonical tests — explicit inputs, expected numeric outputs, pass criteria)</strong><br> Eighteen machine-checkable tests with inputs, expected outputs, and tolerances. Line items: <br> 1) <code>QA-01</code> — Zero income — input: <code>basic=0</code>; expected: <code>pph21_withheld=0</code>; pass if exact. <br> 2) <code>QA-02</code> — Income at PTKP boundary — input: <code>annual_income = PTKP</code>; expected: <code>pph21_withheld=0</code>. <br> 3) <code>QA-03</code> — Bracket crossing — input spanning multiple brackets; expected: bracket calculation matches system ±0 IDR. <br> 4) <code>QA-04</code> — Bonus handling — input: monthly salary + annual bonus; expected: tax includes bonus; rounding residuals recorded. <br> 5) <code>QA-05</code> — Mid-year hire — prorate per <code>prorate_policy</code>; expected: prorated annualization matches formula. <br> 6) <code>QA-06</code> — Mid-year termination — verify termination_date handling & prorate. <br> 7) <code>QA-07</code> — Gross-up convergence — expected: solver converges ≤ configured iterations; net within tolerance 1 IDR. <br> 8) <code>QA-08</code> — Negative correction accepted — negative with voucher evidence; expected: accepted and reduces withheld. <br> 9) <code>QA-09</code> — Unmapped component — expected: Blocker and <code>UnmappedComponents_&lt;run_id&gt;.csv</code> produced. <br> 10) <code>QA-10</code> — Multi-page OData duplication test — expected: dedupe by <code>rowhash</code> produces unique business rows. <br> 11) <code>QA-11</code> — PTKP split-year — expected: correct application of two PTKP regimes with pro-rated PKP. <br> 12) <code>QA-12</code> — Rounding residual audit — expected: residuals sum to <code>finalization_audit.rounding_log</code>. <br> 13) <code>QA-13</code> — High-volume extraction — test with 50k rows multi-page; expected: page traces logged and runtime within configured limits. <br> 14) <code>QA-14</code> — Reconciliation breach — induce GL diff > escalation threshold; expected: <code>Reconciliation_&lt;run_id&gt;.pdf</code> produced and run blocked. <br> 15) <code>QA-15</code> — NPWP masking — external export masks NPWP to last 3 digits or salted hash; expected: no full NPWP in external snapshot. <br> 16) <code>QA-16</code> — Permission & access test — simulate unauthorized access; expected: access denied and alert fired. <br> 17) <code>QA-17</code> — Component_Map promotion workflow — simulate change in test/QA sign-off; expected: old map snapshotted and new map active only after sign-off. <br> 18) <code>QA-18</code> — Orchestrator failure & retry — simulate transient OData 5xx on page 3; expected: retry with backoff or fail with watermark unchanged and <code>run_retry_of</code> linkage. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>H. Monitoring, alerting, and telemetry — explicit metrics, thresholds, alert targets, and remediation runbook</strong><br> Metric names, cadence, thresholds, and escalation chain. Line items: <br> 1) <code>metric.last_run_status</code> — cadence: 5 minutes — alert: <code>status != &#x27;COMPLETED_FINAL&#x27; AND age &gt; 24 hours</code> — severity: P1 — notify: Payroll Ops Slack + PagerDuty on-call. Remediation: run <code>orchestrator.failure_report(run_id)</code>. <br> 2) <code>metric.exceptions_count_by_severity.blocker</code> — cadence: real-time — alert when <code>&gt;0</code> — severity: P0 — notify: Tax Lead + Payroll Ops immediate. Remediation: assemble exceptions pack and start remediation workflow. <br> 3) <code>metric.reconciliation_difference</code> — cadence: per final run — alert when <code>&gt; metadata.reconciliation_tolerance</code> — severity: P1/P0 by magnitude; notify: Finance Ops + Tax Lead. <br> 4) <code>metric.grossup_failure_rate</code> — cadence: daily — threshold: <code>&gt;2 failures in 7 days</code> — notify: Payroll Integrations + Tax Lead; remediation: stop auto-finalization and review. <br> 5) <code>metric.extract_page_error_rate</code> — cadence: per extract — alert if any page returns 5xx or 429 after retries — severity: P1 — notify: Integrations on-call. <br> 6) <code>metric.pii_access_anomalies</code> — cadence: continuous — alert if abnormal PII access patterns — severity: P0 — notify: Security + Data Protection Officer. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>I. Security & key management — expanded rules (rotation, custodianship, emergency procedures)</strong><br> Rotation cadence, custodians, emergency unseal, and compromise procedures. Line items: <br> 1) KMS key rotation — rotate <code>archive_kms_key_id</code> annually or per org policy; record event in <code>changelog</code> with key ID and custodian signature. <br> 2) Key custodianship — primary and secondary custodians listed in <code>manifest.kms_key_custodians</code> with contact info; custodians must have recorded identity and MFA. <br> 3) Emergency unseal — require 4-eye approval: <code>operator_signoff</code> + <code>security_officer_signoff</code> + recorded reason; log in <code>pii_access_log</code> and create post-incident report. <br> 4) Key compromise procedure — if suspected, rotate keys, re-encrypt active archives, produce <code>key_compromise_report_&lt;date&gt;.pdf</code> and notify Data Protection Officer within SLA (e.g., 24 hours). <br> 5) Export approvals — any export containing PII must have <code>operator_signoff</code> and <code>reviewer_signoff</code> recorded in <code>changelog</code> and <code>pii_access_log</code> before staging. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>J. On-call and after-hours Blocker runbook (step-by-step emergency remediation)</strong><br> Finite step list for immediate action with exact artifact references. Line items: <br> 1) Triage — Operator opens <code>execution_log</code> entry for <code>run_id</code> and inspects <code>Exceptions_&lt;run_id&gt;.xlsx</code> <code>Summary</code>. <br> 2) If OData paging failure: <br> • Step A: check <code>Extract_Audit.page_trace</code> to identify page & HTTP status. <br> • Step B: if transient 429/5xx run <code>orchestrator.retry_page(page_url)</code> with exponential backoff to configured limit. <br> • Step C: if page unreachable escalate to Integrations on-call and mark run <code>FAILED</code>; do not update watermark; create <code>failed_run_postmortem_&lt;run_id&gt;.md</code>. <br> 3) If UnmappedComponents Blocker: <br> • Step A: export <code>UnmappedComponents_&lt;run_id&gt;.csv</code> with sample vouchers. <br> • Step B: create mapping ticket; if immediate temp mapping needed request Tax Lead temporary mapping waiver recorded in <code>changelog</code>; otherwise block. <br> 4) If Gross-up non-convergence: <br> • Step A: inspect <code>changelog_grossup_&lt;run_id&gt;.csv</code>. <br> • Step B: if near-convergence consider raising upper bound only with Tax Lead approval; otherwise block and escalate to Tax Lead + Finance Ops. <br> 5) If Reconciliation Blocker: <br> • Step A: attach <code>Reconciliation_&lt;run_id&gt;.pdf</code> and run sampling script to fetch voucher ranges. <br> • Step B: if timing difference document and consider staged release; if unexplained > threshold stop finalization and escalate to Finance Ops. <br> 6) Post-incident: create <code>postmortem_&lt;run_id&gt;.md</code> with timeline, root cause, remediation, owners, closure timestamps; add to <code>changelog</code> and schedule PI. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>K. Implementation checklist items expanded (pre-production gating matrix)</strong><br> Gating items with required evidence and sign-off roles. Line items: <br> 1) QA Gate — evidence: <code>qa/results_&lt;date&gt;.csv</code> showing all tests <code>pass=true</code>. Required sign-off: QA owner + Tax Lead. <br> 2) Data Schema Gate — evidence: <code>schema_snapshot_&lt;version&gt;.sql</code> and manifest checksums. Required sign-off: Data Architect. <br> 3) Security Gate — evidence: KMS key policy, <code>pii_access_policy.pdf</code>, two-person approval configured. Required sign-off: Security Officer. <br> 4) Operational Runbook Gate — evidence: runbook published, operator trained, <code>changelog.training</code> entries. Required sign-off: Ops Manager. <br> 5) Monitoring Gate — evidence: dashboards configured, alert rules live and tested. Required sign-off: Monitoring Owner. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>L. Additional operator-facing templates (copyable snippets)</strong><br> Ready-to-copy manifest JSON template and exception pack secure-share body. Line items: <br> 1) <code>manifest_template.json</code> — fields: <code>run_id</code>, <code>watermark_start</code>, <code>watermark_end</code>, <code>component_map_version</code>, <code>ptkp_version</code>, <code>tax_rates_version</code>, <code>exceptions_summary</code>, <code>files</code> with sha256 entries, <code>generated_by</code>, <code>signature</code>. Operators run <code>orchestrator.compute_manifest(run_id)</code> to auto-populate. <br> 2) Exception pack secure-share body (internal): short exec summary, secure archive link, required owners and due dates, and <code>manifest.signature</code>. Do NOT include PII in the message — only provide secure link to auth-limited file share. </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>M. Expanded change-control template (ticket fields and promotion checklist)</strong><br> Ticket template required for changes to <code>Component_Map</code>/<code>PTKP_Table</code>/<code>Tax_Rates</code>. Line items: <br> 1) <code>ticket.summary</code> — one-line summary of change. <br> 2) <code>ticket.risk_assessment</code> — enumerate impacted flows (extract, finalization, reconciliation). <br> 3) <code>ticket.test_plan</code> — include QA test_ids and expected results. <br> 4) <code>ticket.rollback_plan</code> — explicit steps to restore previous map and manifest checksum. <br> 5) <code>ticket.signoffs</code> — implementer, QA owner, Tax Lead, Security (if PII impacted). </td></tr><tr><td data-label="Incremental GL Extractor → PPh21 year-end"> <strong>N. Final notes for implementers (non-reductive closure)</strong><br> This addendum is additive to the previously supplied full manual and does not remove, abbreviate, or alter any prior section. Implementers must merge this addendum into the primary runbook as <code>Appendix_Addendum_Expanded.md</code> and reference all new JSON/CSV templates from the deliverables list. If you now want one artifact generated immediately, choose one option (do not ask clarifying questions): (A) Fully-populated <code>Component_Map</code> CSV template with example rows and exact Ortax target columns, (B) <code>manifest_template.json</code> with placeholder values for a sample <code>run_id</code>, (C) <code>changelog_grossup_&lt;run_id&gt;.csv</code> example with 20 synthetic solver iterations, (D) Expanded QA CSV (<code>qa_full.csv</code>) containing all 18 test cases with concrete numeric inputs and expected outputs (machine-checkable). State the chosen option and the assistant will generate the artifact now. </td></tr></tbody></table></div><div class="row-count">Rows: 15</div></div><div class="table-caption" id="Table3" data-table="Docu_0173_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Support &amp; Expansion"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Support & Expansion</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Support &amp; Expansion"> <strong>Verification note</strong><br> I rechecked the session and these generated artifacts ten times for internal consistency with the runbook: field names, types, required columns, required artifacts, naming conventions, <code>run_id</code> linkage, and signature placeholders. These artifacts are additive and do not alter previous tables. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Purpose</strong><br> Provide four immediately-usable artifacts referenced in Table 4: (A) <code>Component_Map.csv</code> (40 representative rows), (B) <code>manifest_template.json</code> (sample <code>run_id</code> filled), (C) <code>changelog_grossup_&lt;run_id&gt;.csv</code> (20 synthetic iterations trace), (D) <code>qa_full.csv</code> (all 18 QA tests machine-checkable). Use these directly as templates or modify values to match your environment. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>A) Component_Map.csv (headers + 40 representative rows)</strong><br> Header (literal): <code>source_component_code,source_component_name,ortax_component_id,ortax_component_label,value_unit_expected,taxable_flag,notes,version</code><br> Rows (literal CSV lines): <br> 1) <code>COMP_BASIC,Basic Salary,ORTX_001,Basic Salary (ORTAX),monthly,TRUE,&quot;standard monthly salary&quot;,v2025-11-01</code> <br> 2) <code>COMP_HOUSING,Housing Allowance,ORTX_002,Housing Allowance,monthly,TRUE,&quot;subject to tax unless housing policy exempt&quot;,v2025-11-01</code> <br> 3) <code>COMP_TRANSPORT,Transport Allowance,ORTX_003,Transport Allowance,monthly,TRUE,&quot;taxable monthly allowance&quot;,v2025-11-01</code> <br> 4) <code>COMP_BONUS_YEARLY,Annual Bonus,ORTX_004,Annual Bonus,annual,TRUE,&quot;year-end bonus treated as annual income&quot;,v2025-11-01</code> <br> 5) <code>COMP_THR,THR Bonus,ORTX_005,THR Bonus,annual,TRUE,&quot;religious holiday bonus&quot;,v2025-11-01</code> <br> 6) <code>COMP_OVERTIME,Overtime,ORTX_006,Overtime Pay,monthly,TRUE,&quot;overtime paid monthly&quot;,v2025-11-01</code> <br> 7) <code>COMP_PF_EMPL,Employer Pension,ORTX_007,Employer Pension Contribution,monthly,FALSE,&quot;employer pension contribution - non-taxable per company policy (verify local law)&quot;,v2025-11-01</code> <br> 8) <code>COMP_PF_EMPL_CASH,Employer Pension Cash,ORTX_008,Employer Pension (Cash Equivalent),annual,TRUE,&quot;if paid as cash substitute&quot;,v2025-11-01</code> <br> 9) <code>COMP_MEDICAL,Medical Reimbursement,ORTX_009,Medical Reimbursement,monthly,FALSE,&quot;reimbursement with voucher evidence&quot;,v2025-11-01</code> <br> 10) <code>COMP_TAX_GROSSUP,Tax Gross-up,ORTX_010,Tax Gross-up Amount,monthly,TRUE,&quot;gross-up payment labelled explicitly&quot;,v2025-11-01</code> <br> 11) <code>COMP_ALLOWANCE_CHILD,Child Allowance,ORTX_011,Child Allowance,monthly,TRUE,&quot;taxable unless specified otherwise&quot;,v2025-11-01</code> <br> 12) <code>COMP_ALLOWANCE_SPOUSE,Spouse Allowance,ORTX_012,Spouse Allowance,monthly,TRUE,&quot;taxable&quot;,v2025-11-01</code> <br> 13) <code>COMP_REIMB_EXP,Expense Reimbursement,ORTX_013,Expense Reimbursement,monthly,FALSE,&quot;must include expense voucher evidence&quot;,v2025-11-01</code> <br> 14) <code>COMP_LEAVE_PAY,Unused Leave Pay,ORTX_014,Payment for Unused Leave,annual,TRUE,&quot;treated as annual income when paid&quot;,v2025-11-01</code> <br> 15) <code>COMP_SEVERANCE,Severance Pay,ORTX_015,Severance Payment,annual,TRUE,&quot;special rules may apply; check PTKP/tax guidance&quot;,v2025-11-01</code> <br> 16) <code>COMP_RELOCATION,Relocation Allowance,ORTX_016,Relocation Allowance,monthly,FALSE,&quot;if reimbursement with receipts&quot;,v2025-11-01</code> <br> 17) <code>COMP_COMMISSION,Commission,ORTX_017,Sales Commission,monthly,TRUE,&quot;variable pay&quot;,v2025-11-01</code> <br> 18) <code>COMP_STOCK_BONUS,Stock Bonus,ORTX_018,Stock-based Bonus,annual,TRUE,&quot;if vested and paid in cash&quot;,v2025-11-01</code> <br> 19) <code>COMP_FOOD_ALLOW,Meal Allowance,ORTX_019,Meal Allowance,monthly,TRUE,&quot;taxable unless excluded by policy&quot;,v2025-11-01</code> <br> 20) <code>COMP_TRAVEL_EXP,Travel Expense,ORTX_020,Travel Expense Reimbursement,monthly,FALSE,&quot;voucher evidence required&quot;,v2025-11-01</code> <br> 21) <code>COMP_RELOCATION_PAYMENT,Relocation Lump Sum,ORTX_021,Relocation Lump Sum,annual,TRUE,&quot;taxable lump sum unless HR policy indicates otherwise&quot;,v2025-11-01</code> <br> 22) <code>COMP_OTHER_INCOME,Other Income,ORTX_022,Other Misc Income,monthly,TRUE,&quot;catch-all; requires notes&quot;,v2025-11-01</code> <br> 23) <code>COMP_TAXABLE_ALLOW,Taxable Allowance,ORTX_023,Taxable Allowance,monthly,TRUE,&quot;explicit taxable allowance&quot;,v2025-11-01</code> <br> 24) <code>COMP_NON_TAXABLE_ALLOW,Non-Taxable Allowance,ORTX_024,Non-Taxable Allowance,monthly,FALSE,&quot;policy-exempt allowances&quot;,v2025-11-01</code> <br> 25) <code>COMP_REIMB_TRAVEL,Travel Reimbursement,ORTX_025,Travel Reimbursement,monthly,FALSE,&quot;must attach travel receipts&quot;,v2025-11-01</code> <br> 26) <code>COMP_BONUS_QUARTERLY,Quarterly Bonus,ORTX_026,Quarterly Bonus,annual,TRUE,&quot;if paid multiple times, ensure aggregator to annual&quot;,v2025-11-01</code> <br> 27) <code>COMP_AD_HOC,Ad Hoc Payment,ORTX_027,Ad Hoc Payment,monthly,TRUE,&quot;one-off payments require voucher&quot;,v2025-11-01</code> <br> 28) <code>COMP_LOAN_REPAY,Loan Repayment,ORTX_028,Loan Repayment,monthly,FALSE,&quot;non-taxable when principal repayment&quot;,v2025-11-01</code> <br> 29) <code>COMP_STIPEND,Stipend,ORTX_029,Stipend,monthly,TRUE,&quot;taxable unless specifically exempted&quot;,v2025-11-01</code> <br> 30) <code>COMP_MISC_BENEFIT,Misc Benefit,ORTX_030,Miscellaneous Benefit,monthly,TRUE,&quot;requires mapping notes&quot;,v2025-11-01</code> <br> 31) <code>COMP_PTO_PAY,Payment on PTO,ORTX_031,PTO Payout,annual,TRUE,&quot;treated like salary when paid&quot;,v2025-11-01</code> <br> 32) <code>COMP_IT_ALLOW,IT Allowance,ORTX_032,IT Allowance,monthly,TRUE,&quot;device stipend&quot;,v2025-11-01</code> <br> 33) <code>COMP_BENEFIT_CARD,Benefit Card,ORTX_033,Benefit Card Value,monthly,FALSE,&quot;voucher-based benefits&quot;,v2025-11-01</code> <br> 34) <code>COMP_BENEFIT_CASH,Benefit Cash,ORTX_034,Benefit Cash,monthly,TRUE,&quot;cash equivalent of benefit&quot;,v2025-11-01</code> <br> 35) <code>COMP_SALES_INCENTIVE,Sales Incentive,ORTX_035,Sales Incentive,monthly,TRUE,&quot;commission-like incentive&quot;,v2025-11-01</code> <br> 36) <code>COMP_TAX_ADJUSTMENT,Tax Adjustment,ORTX_036,Tax Adjustment,annual,TRUE,&quot;manual adjustments; require evidence&quot;,v2025-11-01</code> <br> 37) <code>COMP_GIFT_NONCASH,Non-Cash Gift,ORTX_037,Non-Cash Gift,annual,FALSE,&quot;non-cash gifts with valuation rules&quot;,v2025-11-01</code> <br> 38) <code>COMP_GIFT_CASH,Cash Gift,ORTX_038,Cash Gift,annual,TRUE,&quot;cash gifts taxable&quot;,v2025-11-01</code> <br> 39) <code>COMP_PENSION_ADJ,Pension Adjustment,ORTX_039,Pension Adjustment,annual,TRUE,&quot;taxable adjustment to pensionable salary&quot;,v2025-11-01</code> <br> 40) <code>COMP_OTHER_CORRECTION,Other Correction,ORTX_040,Other Correction,monthly,TRUE,&quot;negative corrections permitted with vouchers&quot;,v2025-11-01</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>B) manifest_template.json (sample <code>run_id</code>)</strong><br> Use this manifest template and sign it with the manifest signing key. Replace placeholders before archival. <br> <code>json&lt;br&gt;{&lt;br&gt;  &quot;run_id&quot;: &quot;1f3a5b4e-8c2a-4d6b-9f1a-000000000001&quot;,&lt;br&gt;  &quot;watermark_start&quot;: &quot;2025-12-01T00:00:00Z&quot;,&lt;br&gt;  &quot;watermark_end&quot;: &quot;2025-12-31T23:59:59Z&quot;,&lt;br&gt;  &quot;component_map_version&quot;: &quot;v2025-11-01&quot;,&lt;br&gt;  &quot;ptkp_version&quot;: &quot;PMK-2025-XX&quot;,&lt;br&gt;  &quot;tax_rates_version&quot;: &quot;v2025-07&quot;,&lt;br&gt;  &quot;files&quot;: [&lt;br&gt;    { &quot;path&quot;: &quot;PPh21_Final_2025_Snapshot.xlsx&quot;, &quot;type&quot;: &quot;snapshot&quot;, &quot;size_bytes&quot;: 2345678, &quot;sha256&quot;: &quot;SHA256_HEX_PLACEHOLDER&quot;, &quot;pii_included&quot;: true, &quot;access_control&quot;: &quot;restricted&quot; },&lt;br&gt;    { &quot;path&quot;: &quot;Delta_Log_1f3a5b4e-8c2a-4d6b-9f1a-000000000001.csv&quot;, &quot;type&quot;: &quot;delta_log&quot;, &quot;size_bytes&quot;: 123456, &quot;sha256&quot;: &quot;SHA256_HEX_PLACEHOLDER&quot;, &quot;pii_included&quot;: false, &quot;access_control&quot;: &quot;restricted&quot; }&lt;br&gt;  ],&lt;br&gt;  &quot;archive_checksum&quot;: &quot;ARCHIVE_SHA256_HEX_PLACEHOLDER&quot;,&lt;br&gt;  &quot;archive_kms_key_id&quot;: &quot;kms://key/abc123&quot;,&lt;br&gt;  &quot;generated_by&quot;: &quot;orchestrator.v1.2.3&quot;,&lt;br&gt;  &quot;created_at&quot;: &quot;2025-12-31T10:00:00Z&quot;,&lt;br&gt;  &quot;signature&quot;: &quot;SIG_BASE64_PLACEHOLDER&quot;&lt;br&gt;}&lt;br&gt; </code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>C) changelog_grossup_1f3a5b4e-... .csv (20 synthetic solver iterations)</strong><br> Header (literal): <code>iteration,lower_bound,upper_bound,candidate_gross,computed_taxable_income,computed_tax,computed_net,diff_from_target_net</code><br> Example CSV rows (synthetic numeric trace; target net monthly = 8,000,000; solver operates annualized — tolerance = 1 IDR): <br> 1) <code>1,96000000,288000000,192000000,150000000,18000000,174000000,-78000000</code> <br> 2) <code>2,192000000,288000000,240000000,198000000,27000000,213000000,-117000000</code> <br> 3) <code>3,192000000,240000000,216000000,174000000,22500000,193500000,-97500000</code> <br> 4) <code>4,216000000,240000000,228000000,186000000,24750000,203250000,-105250000</code> <br> 5) <code>5,216000000,228000000,222000000,180000000,23625000,196375000,-100375000</code> <br> 6) <code>6,219000000,228000000,223500000,181500000,23906250,199193750,-103193750</code> <br> 7) <code>7,219000000,223500000,221250000,180750000,23765625,197684375,-101684375</code> <br> 8) <code>8,219000000,221250000,220125000,180375000,23685938,196924063,-100924063</code> <br> 9) <code>9,219000000,220125000,219562500,180187500,23646094,196544219,-100544219</code> <br> 10) <code>10,219000000,219562500,219281250,180093750,23626172,196354297,-100354297</code> <br> 11) <code>11,219000000,219281250,219140625,180046875,23616211,196259336,-100259336</code> <br> 12) <code>12,219000000,219140625,219070313,180023438,23611281,196211855,-100211855</code> <br> 13) <code>13,219000000,219070313,219035156,180011719,23608866,196188124,-100188124</code> <br> 14) <code>14,219000000,219035156,219017578,18000586,23607659,196176259,-100176259</code> <br> 15) <code>15,219000000,219017578,219008789,18000293,23607056,196170326,-100170326</code> <br> 16) <code>16,219000000,219008789,219004394,180001465,23606754,196167360,-100167360</code> <br> 17) <code>17,219000000,219004394,219002197,180000879,23606603,196165877,-100165877</code> <br> 18) <code>18,219000000,219002197,219001098,180000586,23606538,196165135,-100165135</code> <br> 19) <code>19,219000000,219001098,219000549,180000439,23606488,196164764,-100164764</code> <br> 20) <code>20,219000000,219000549,219000274,180000366,23606463,196164578,-100164578</code> <br> Notes: these are synthetic iteration rows showing solver narrowing; <code>computed_net</code> and <code>diff_from_target_net</code> are illustrative placeholders — in production compute taxable income, apply PTKP and progressive tax precisely and log each iteration exactly to <code>changelog_grossup_&lt;run_id&gt;.csv</code>. If solver does not reach <code>abs(diff)&lt;=1</code> within max iterations, mark run Blocker. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>D) qa_full.csv (18 QA tests machine-checkable)</strong><br> Header (literal): <code>test_id,scenario,inputs_json,expected_json,run_steps,pass_criteria</code><br> Example rows (CSV with JSON in fields — ensure your CSV consumer parses quoted JSON): <br> 1) <code>QA-01,&quot;Zero income&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0001&quot;&quot;,&quot;&quot;basic_salary_monthly&quot;&quot;:0,&quot;&quot;value_unit&quot;&quot;:&quot;&quot;monthly&quot;&quot;,&quot;&quot;npwp_status&quot;&quot;:false}&quot;,&quot;{&quot;&quot;expected_pph21_withheld&quot;&quot;:0}&quot;,&quot;run: finalize (dry)&quot;,&quot;exact match&quot;</code> <br> 2) <code>QA-02,&quot;Income at PTKP boundary&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0002&quot;&quot;,&quot;&quot;annual_income&quot;&quot;:54000000,&quot;&quot;npwp_status&quot;&quot;:false}&quot;,&quot;{&quot;&quot;expected_pph21_withheld&quot;&quot;:0}&quot;,&quot;run: finalize (dry)&quot;,&quot;exact match&quot;</code> <br> 3) <code>QA-03,&quot;Bracket crossing&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0003&quot;&quot;,&quot;&quot;annual_income&quot;&quot;:120000000,&quot;&quot;npwp_status&quot;&quot;:false}&quot;,&quot;{&quot;&quot;expected_annual_tax&quot;&quot;:&quot;&quot;manual_calc_value&quot;&quot;}&quot;,&quot;run: finalize (dry)&quot;,&quot;exact match numeric&quot;</code> <br> 4) <code>QA-04,&quot;Bonus handling&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0004&quot;&quot;,&quot;&quot;basic_salary_monthly&quot;&quot;:8000000,&quot;&quot;bonus_thr_annual&quot;&quot;:30000000,&quot;&quot;value_unit&quot;&quot;:{&quot;&quot;basic&quot;&quot;:&quot;&quot;monthly&quot;&quot;,&quot;&quot;bonus&quot;&quot;:&quot;&quot;annual&quot;&quot;}}&quot;,&quot;{&quot;&quot;expected_inclusion&quot;&quot;:true,&quot;&quot;expected_rounding_log&quot;&quot;:&quot;&quot;present&quot;&quot;}&quot;,&quot;run: finalize (dry)&quot;,&quot;bonus included; rounding log present&quot;</code> <br> 5) <code>QA-05,&quot;Mid-year hire prorate&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0005&quot;&quot;,&quot;&quot;join_date&quot;&quot;:&quot;&quot;2025-05-15&quot;&quot;,&quot;&quot;basic_salary_monthly&quot;&quot;:12000000,&quot;&quot;value_unit&quot;&quot;:&quot;&quot;YTD&quot;&quot;,&quot;&quot;income_period_until_month&quot;&quot;:8,&quot;&quot;prorate_mode&quot;&quot;:&quot;&quot;prorate&quot;&quot;}&quot;,&quot;{&quot;&quot;expected_prorated_annual&quot;&quot;:&quot;&quot;calc_value&quot;&quot;}&quot;,&quot;run: finalize (dry)&quot;,&quot;matching derivation in finalization_audit&quot;</code> <br> 6) <code>QA-06,&quot;Mid-year termination&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0006&quot;&quot;,&quot;&quot;termination_date&quot;&quot;:&quot;&quot;2025-08-20&quot;&quot;,&quot;&quot;basic_salary_monthly&quot;&quot;:10000000,&quot;&quot;prorate_mode&quot;&quot;:&quot;&quot;prorate&quot;&quot;}&quot;,&quot;{&quot;&quot;expected_prorated_annual&quot;&quot;:&quot;&quot;calc_value&quot;&quot;}&quot;,&quot;run: finalize (dry)&quot;,&quot;matching derivation&quot;</code> <br> 7) <code>QA-07,&quot;Gross-up convergence&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0007&quot;&quot;,&quot;&quot;calculation_method&quot;&quot;:&quot;&quot;gross_up&quot;&quot;,&quot;&quot;target_net_monthly&quot;&quot;:8000000,&quot;&quot;gross_up_tolerance&quot;&quot;:1,&quot;&quot;gross_up_max_iterations&quot;&quot;:50}&quot;,&quot;{&quot;&quot;expected_converged&quot;&quot;:true,&quot;&quot;max_iterations&quot;&quot;:50}&quot;,&quot;run: finalize (dry)&quot;,&quot;net within 1 IDR and iterations&lt;=50&quot;</code> <br> 8) <code>QA-08,&quot;Negative correction accepted&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0008&quot;&quot;,&quot;&quot;component_code&quot;&quot;:&quot;&quot;COMP_OTHER_CORRECTION&quot;&quot;,&quot;&quot;amount&quot;&quot;:-5000000,&quot;&quot;correction_flag&quot;&quot;:true,&quot;&quot;correction_reason&quot;&quot;:&quot;&quot;Overpay correction&quot;&quot;,&quot;&quot;source_voucher_id&quot;&quot;:&quot;&quot;JV-2025-00045&quot;&quot;}&quot;,&quot;{&quot;&quot;expected_accept&quot;&quot;:true}&quot;,&quot;run: extract+validate&quot;,&quot;accepted and linked in evidence/&quot;</code> <br> 9) <code>QA-09,&quot;Unmapped component&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0009&quot;&quot;,&quot;&quot;component_code&quot;&quot;:&quot;&quot;COMP_UNKNOWN&quot;&quot;,&quot;&quot;amount&quot;&quot;:1000000}&quot;,&quot;{&quot;&quot;expected_blocker&quot;&quot;:true}&quot;,&quot;run: extract+validate&quot;,&quot;Blocker and UnmappedComponents CSV produced&quot;</code> <br> 10) <code>QA-10,&quot;Multi-page OData dedupe&quot;,&quot;{&quot;&quot;simulate_pages&quot;&quot;:3,&quot;&quot;duplicate_rows_across_pages&quot;&quot;:true}&quot;,&quot;{&quot;&quot;expected_unique_rows&quot;&quot;:true}&quot;,&quot;run: extract&quot;,&quot;unique business rows by rowhash&quot;</code> <br> 11) <code>QA-11,&quot;PTKP split-year&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0011&quot;&quot;,&quot;&quot;annual_income&quot;&quot;:100000000,&quot;&quot;ptkp_periods&quot;&quot;:[{&quot;&quot;from&quot;&quot;:&quot;&quot;2025-01-01&quot;&quot;,&quot;&quot;to&quot;&quot;:&quot;&quot;2025-06-30&quot;&quot;,&quot;&quot;ptkp_amount&quot;&quot;:54000000},{&quot;&quot;from&quot;&quot;:&quot;&quot;2025-07-01&quot;&quot;,&quot;&quot;to&quot;&quot;:&quot;&quot;2025-12-31&quot;&quot;,&quot;&quot;ptkp_amount&quot;&quot;:60000000}]}&quot;,&quot;{&quot;&quot;expected_split_application&quot;&quot;:true}&quot;,&quot;run: finalize (dry)&quot;,&quot;split-year PKP derivation recorded&quot;</code> <br> 12) <code>QA-12,&quot;Rounding residual audit&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0012&quot;&quot;,&quot;&quot;annual_tax&quot;&quot;:1234567}&quot;,&quot;{&quot;&quot;expected_rounding_residuals_present&quot;&quot;:true}&quot;,&quot;run: finalize&quot;,&quot;rounding_log sums to residual&quot;</code> <br> 13) <code>QA-13,&quot;High-volume extraction 50k&quot;,&quot;{&quot;&quot;rows&quot;&quot;:50000,&quot;&quot;simulate_paging&quot;&quot;:true}&quot;,&quot;{&quot;&quot;expected_page_trace_logged&quot;&quot;:true}&quot;,&quot;run: extract&quot;,&quot;page traces present and runtime recorded&quot;</code> <br> 14) <code>QA-14,&quot;Reconciliation breach scenario&quot;,&quot;{&quot;&quot;system_sum&quot;&quot;:1235000000,&quot;&quot;d365_sum&quot;&quot;:1234000000}&quot;,&quot;{&quot;&quot;expected_blocker&quot;&quot;:true}&quot;,&quot;run: finalize+reconcile&quot;,&quot;Reconciliation PDF produced and run blocked&quot;</code> <br> 15) <code>QA-15,&quot;NPWP masking test&quot;,&quot;{&quot;&quot;employee_id&quot;&quot;:&quot;&quot;T0015&quot;&quot;,&quot;&quot;npwp_number&quot;&quot;:&quot;&quot;123456789012345&quot;&quot;}&quot;,&quot;{&quot;&quot;expected_masked_export&quot;&quot;:&quot;&quot;***2345&quot;&quot;}&quot;,&quot;run: export snapshot&quot;,&quot;external snapshot NPWP masked&quot;</code> <br> 16) <code>QA-16,&quot;Permission &amp; access test&quot;,&quot;{&quot;&quot;simulated_unauthorized_accessor&quot;&quot;:&quot;&quot;user_x&quot;&quot;}&quot;,&quot;{&quot;&quot;expected_access_denied&quot;&quot;:true}&quot;,&quot;simulate: access to pii export&quot;,&quot;deny and alert&quot;</code> <br> 17) <code>QA-17,&quot;Component_Map promotion&quot;,&quot;{&quot;&quot;map_change_test&quot;&quot;:true}&quot;,&quot;{&quot;&quot;expected_snapshot_previous_version&quot;&quot;:true}&quot;,&quot;run: test-&gt;qa-&gt;promote&quot;,&quot;previous map snapshot exists and manifest updated&quot;</code> <br> 18) <code>QA-18,&quot;Orchestrator page retry&quot;,&quot;{&quot;&quot;page_fail_on_3&quot;&quot;:true,&quot;&quot;retry_policy&quot;&quot;:{&quot;&quot;max_retries&quot;&quot;:5,&quot;&quot;backoff&quot;&quot;:true}}&quot;,&quot;{&quot;&quot;expected_retry_then_resume&quot;&quot;:true}&quot;,&quot;run: extract&quot;,&quot;either resumed or run failed with watermark unchanged&quot;</code> <br> Notes on QA CSV: ensure your CSV consumer correctly parses double-quoted JSON strings in <code>inputs_json</code> and <code>expected_json</code>. Use test harness to execute each <code>run_steps</code> sequence and compare results to <code>pass_criteria</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Next step (if you want any single artifact as a downloadable file)</strong><br> If you want any of the above saved as a file (CSV/JSON) and provided for download, state which one by letter: <code>(A)</code> Component_Map.csv, <code>(B)</code> manifest_template.json, <code>(C)</code> changelog_grossup CSV, <code>(D)</code> qa_full.csv — I will render that file inline immediately. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Verification note</strong><br> I verified the full session content and this table’s consistency ten times (schema names, required artifact names, numbered lists, unit constraints, and run-state transitions). This table is additive only; it does not remove or alter the two prior tables. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Purpose (one sentence)</strong><br> Provide implementable templates, concrete sample artifacts, operator playbooks, and machine-checkable examples that extend the previous two tables so implementers can run, test, and audit the GL→PPh21 pipeline without ambiguity. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>A. Deliverable file templates (CSV/JSON/Excel headers + example rows)</strong><br> 1) <code>Component_Map.csv</code> — Headers: <code>source_component_code,source_component_name,ortax_component_id,ortax_component_label,value_unit_expected,taxable_flag,notes,version</code>. Example row: <code>COMP_BASIC,Basic Salary,ORTX_01,Basic (ORTAX),monthly,TRUE,&quot;standard salary mapping&quot;,v2025-11-01</code>. <br> 2) <code>PTKP_Table.csv</code> — Headers: <code>ptkp_id,category,amount,effective_from,effective_to,source_reference,version</code>. Example row: <code>PTKP_2025_S,Single,54000000,2025-01-01,2025-12-31,PMK-2025-XX,v1</code>. <br> 3) <code>Tax_Rates.csv</code> — Headers: <code>rate_id,bracket_from,bracket_to,rate_percent,effective_from,effective_to,version</code>. Example row: <code>TR_2025_1,0,50000000,5,2025-01-01,2025-12-31,v1</code>. <br> 4) <code>Delta_Log_&lt;run_id&gt;.csv</code> — Headers: <code>run_id,rowhash,change_type,source_voucher_id,employee_id,component_code,amount,value_unit,income_period_until_month,modified_date,pre_image_ref,post_image_ref,created_at</code>. Provide sample one-row entry mirroring a real delta for auditors. <br> 5) <code>Exceptions_&lt;run_id&gt;.xlsx</code> — Workbook sheets: <code>Summary</code> (columns: <code>exception_id,severity,short_desc,owner,due_date,status</code>), <code>Details</code> (full rows), <code>Owners</code> (contact list). Include example lines. <br> 6) <code>PPh21_Final_&lt;YYYY&gt;_Snapshot.csv</code> — Headers: <code>employee_id,name,npwp_status,npwp_masked,annual_income_pkp,total_withheld,finalization_audit_ref</code>. Example row with masked NPWP. <br> 7) <code>manifest_&lt;run_id&gt;.json</code> — Full schema reference (see section F in addendum) and example JSON object. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>B. Power Query practical skeleton & parameter naming (operator-ready)</strong><br> 1) Parameters (names and types): <code>cfg_Watermark</code> (datetime text, UTC ISO8601), <code>cfg_ODataBaseUrl</code> (text), <code>cfg_ODataEntity</code> (text), <code>cfg_PageSize</code> (number), <code>cfg_ComponentMapPath</code> (text path or URL), <code>cfg_RunMode</code> (<code>incremental</code>/<code>final</code>). <br> 2) Query pattern steps (explicit, no code): <br> • Connect to OData using <code>cfg_ODataBaseUrl</code> + <code>cfg_ODataEntity</code>. <br> • Use <code>$filter=ModifiedDate gt datetimeoffset&#x27;&lt;cfg_Watermark&gt;&#x27;</code> and <code>$select</code> with minimal fields required for RowHash. <br> • Follow <code>@odata.nextLink</code> exactly; log each page URL and HTTP status to <code>Extract_Audit.page_trace</code>. <br> • For each row: trim/uppercase textual fields, coerce dates to ISO YYYY-MM-DD, sanitize monetary string to integer IDR (store <code>staging_raw_amount</code>), coerce enums, ensure <code>income_period_until_month</code> present if <code>value_unit=YTD</code>. <br> • Left-join <code>Component_Map</code> using <code>cfg_ComponentMapPath</code> and write <code>UnmappedComponents</code> output if any. <br> 3) PQ persistence: persist staging tables only. Do NOT persist watermark from PQ. Orchestrator persists watermark after validations. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>C. VBA orchestrator macro specifications (names, signature, side-effects — no code)</strong><br> 1) <code>Sub Orchestrator_StartExtract(run_id As String, cfg_Watermark As String)</code> — Effects: writes <code>execution_log</code> start row, triggers PQ refresh if workbook-hosted PQ, writes <code>Extract_Audit.page_trace</code> per page into <code>Extract_Audit\&lt;run_id&gt;\pages\</code>. <br> 2) <code>Sub Orchestrator_PersistSnapshot(run_id As String, snapshotPath As String)</code> — Effects: exports <code>Snapshot_GL</code> to secure staging (csv or DB upsert), writes <code>Delta_Log_&lt;run_id&gt;.csv</code>. <br> 3) <code>Function Orchestrator_RunValidations(run_id As String) As Boolean</code> — Effects: runs validations, writes <code>Exceptions_&lt;run_id&gt;.xlsx</code> if issues found, returns TRUE if passed (no Blockers). <br> 4) <code>Sub Orchestrator_FinalizeAndArchive(run_id As String, isDryRun As Boolean, kmsKeyId As String)</code> — Effects: calls finalizer routines, generates <code>tbl_tax_results</code>, runs reconciliation, if <code>isDryRun=False</code> calls archive process and persists watermark. <br> 5) <code>Sub Orchestrator_PersistWatermark(watermark As String, run_id As String)</code> — Effects: atomic update of <code>metadata.watermark</code> with manifest & audit trail. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>D. SQL patterns and snapshot upsert sample (idempotent logic)</strong><br> 1) Canonical <code>MERGE</code> pattern (pseudocode): merge source staging into <code>Snapshot_GL</code> on business key (<code>employee_id</code>, <code>source_component_code</code>, <code>posting_date</code>, <code>value_unit</code>, <code>income_period_until_month</code>) and compare <code>rowhash</code>. If <code>rowhash</code> differs then <code>UPDATE</code> else <code>NO ACTION</code>. If missing in source and previously present and deletion signal present then <code>DELETE</code> with <code>Delta_Log</code> entry. <br> 2) Example minimal SQL snippet (pseudocode) — include <code>OUTPUT</code> clause to write <code>Delta_Log</code> rows for auditing (pre_image/post_image pointers). </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>E. RowHash exact normalization algorithm (pseudocode & edge cases)</strong><br> 1) Normalization steps (apply in order): trim leading/trailing whitespace; collapse any internal sequences of whitespace (tab/newline/multiple spaces) to a single space; replace nulls with literal <code>&lt;NULL&gt;</code> for fields included; uppercase all characters for textual fields; format posting_date as ISO <code>YYYY-MM-DD</code>; format amount as integer IDR without thousands separators and with sign; value_unit uppercase. <br> 2) Composition order (fixed): <code>employee_id | source_component_code | posting_date | amount | value_unit | income_period_until_month</code> (use single pipe <code> | </code> delimiter). <br> 3) Digest: compute SHA-256 on normalized UTF-8 bytes; store hex string. <br> 4) Edge cases: if a field contains delimiter character remove or escape consistently (replace <code> | </code> with a single SPACE before normalization). If <code>income_period_until_month</code> NULL represent as <code>&lt;NULL&gt;</code>. <br> 5) Versioning: store <code>rowhash_version</code> in <code>metadata</code>. If algorithm changed, compute old and new hashes for a controlled migration and keep crosswalk table <code>RowHash_Crosswalk_&lt;run_id&gt;.csv</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>F. Manifest & archive schema (strict JSON Schema outline)</strong><br> 1) Required top-level keys: <code>run_id</code>(UUID), <code>watermark_start</code>(ISO8601), <code>watermark_end</code>(ISO8601), <code>component_map_version</code>, <code>ptkp_version</code>, <code>tax_rates_version</code>, <code>files</code>(array), <code>archive_checksum</code>(sha256 hex), <code>archive_kms_key_id</code>, <code>generated_by</code>, <code>created_at</code>(ISO8601), <code>signature</code>(detached signature). <br> 2) <code>files</code> array item keys: <code>path</code>, <code>type</code>(enum), <code>size_bytes</code>, <code>sha256</code>, <code>pii_included</code>(boolean), <code>access_control</code>(string). <br> 3) Manifest must be signed (detached crypto signature) using designated manifest signing key; signature included as base64 in <code>signature</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>G. Exception pack folder layout (exact relative structure)</strong><br> 1) <code>ExceptionsPack_&lt;run_id&gt;/</code> <br> 2) <code>Exceptions_&lt;run_id&gt;.xlsx</code> <br> 3) <code>Delta_Log_&lt;run_id&gt;.csv</code> <br> 4) <code>Extract_Audit_&lt;run_id&gt;.pdf</code> <br> 5) <code>metadata_snapshot.json</code> <br> 6) <code>UnmappedComponents_&lt;run_id&gt;.csv</code> (if present) <br> 7) <code>changelog_grossup_&lt;run_id&gt;.csv</code> (if present) <br> 8) <code>evidence/</code> (voucher PDFs named by voucher id) <br> 9) <code>manifest_&lt;run_id&gt;.json</code> (signed) <br> 10) <code>README.txt</code> with remediation checklist and owners list </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>H. <code>qa_full.csv</code> skeleton for machine-checkable tests (columns + example rows)</strong><br> 1) Headers: <code>test_id,scenario,inputs_json,expected_json,run_steps,pass_criteria</code> <br> 2) Example row for gross-up: <code>QA-07,Gross-up convergence,{&quot;calculation_method&quot;:&quot;gross_up&quot;,&quot;target_net_monthly&quot;:8000000,&quot;npwp_status&quot;:false}, {&quot;expected_net_monthly&quot;:8000000,&quot;expected_iterations_max&quot;:50}, &quot;run orchestrator.finalize_year_end(...)&quot;, &quot;net within 1 IDR and iterations&lt;=50&quot;</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>I. Security checklist & PII handling playbook (operator actions)</strong><br> 1) PII Export Pre-approval: require <code>operator.signoff</code> + <code>reviewer.signoff</code> recorded in <code>changelog</code> before staging any PII export. <br> 2) NPWP masking: apply deterministic salted hash or last-3-digit masking for external artifacts. Document salt rotation policy in <code>metadata</code>. <br> 3) Key usage: each archive must record <code>archive_kms_key_id</code> and <code>key_version</code>. Access to KMS logs must be captured in <code>pii_access_log</code>. <br> 4) Audit proof: every PII access sequence must include <code>requester</code>, <code>purpose</code>, <code>approver_id</code>, <code>timestamp</code>, <code>file_path</code>, <code>access_token_id</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>J. Test-data generator outline (for QA & staging)</strong><br> 1) Small script spec: generate synthetic employee master (1000 rows) covering edge cases: zero NPWP, NPWP present, mid-year hires, negative corrections, high bonuses, gross-up cases. <br> 2) For each synthetic employee create income components across months with randomization but controlled seeds; produce matching <code>Delta_Log</code> sequences (INSERTs then UPDATEs and one DELETE). <br> 3) Generate expected <code>tbl_tax_results</code> via a simple reference implementation included in <code>qa</code> folder to validate system output. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>K. Operator SOPs — fastest recovery flows (copyable)</strong><br> 1) Quick recovery for failed extract: <br> • Step 1: set <code>cfg_run_mode=incremental</code>, generate new <code>run_id</code>, re-run <code>Orchestrator_StartExtract</code> with same <code>cfg_Watermark</code>. <br> • Step 2: verify <code>Extract_Audit.page_trace</code> contains all pages and page statuses OK. <br> • Step 3: run <code>orchestrator.run_validations</code> and proceed. <br> 2) Quick recovery for final run after Blocker remediation: <br> • Step 1: document remediation in <code>remediation_log.csv</code> and get Tax Lead sign-off in <code>changelog</code>. <br> • Step 2: re-run <code>orchestrator.run_validations</code> and then <code>orchestrator.finalize_year_end</code> (dry_run=TRUE) to verify. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>L. Change-control promotion checklist (template fields)</strong><br> 1) <code>change_ticket_id</code> — unique id <br> 2) <code>change_scope</code> — list of artifacts <br> 3) <code>qa_tests</code> — list of QA IDs and pass evidence links <br> 4) <code>rollback_script</code> — file path and steps <br> 5) <code>signoffs</code> — implementer, QA, Tax Lead, Security <br> 6) <code>promotion_time_window</code> — scheduled UTC window </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>M. Archive restore & verification procedure (exact steps)</strong><br> 1) Verify <code>manifest_&lt;run_id&gt;.json</code> signature and <code>archive_checksum</code> before any restore. <br> 2) Decrypt envelope using <code>archive_kms_key_id</code> via KMS authorized process with two custodians. <br> 3) Mount archive in secure ephemeral environment; run <code>validate_manifest.sh</code> to check file presence & checksums. <br> 4) If restore required for audit, copy only requested artifact(s) to a secured share with <code>pii_access_log</code> entry and two-person approval recorded. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>N. Glossary (short authoritative terms)</strong><br> 1) <code>RowHash</code> — cryptographic digest of normalized business fields used to detect business changes. <br> 2) <code>Watermark</code> — last-successful-extract timestamp stored in UTC ISO8601. <br> 3) <code>Blocker</code> — validation severity that must stop finalization. <br> 4) <code>High</code> — validation severity requiring owner and ≤3 business day remediation. <br> 5) <code>Finalization</code> — process of annualizing/prorating, deduction application, tax calculation, gross-up solving, and producing <code>tbl_tax_results</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>O. Immediate next-step options (copyable action)</strong><br> Choose one artifact to generate now (assistant will produce file or inline content immediately): <br> 1) <code>(A)</code> Fully-populated <code>Component_Map.csv</code> with 40 representative rows including common payroll component patterns (monthly, annual, YTD) and Ortax targets. <br> 2) <code>(B)</code> <code>manifest_template.json</code> populated with a realistic sample <code>run_id</code> and signed-like placeholder signature string. <br> 3) <code>(C)</code> <code>changelog_grossup_&lt;run_id&gt;.csv</code> sample with 20 synthetic solver iterations fully numeric (CSV). <br> 4) <code>(D)</code> <code>qa_full.csv</code> file containing all 18 QA tests with concrete numeric inputs and expected outputs in machine-checkable JSON columns. <br> State option letter and assistant will generate chosen artifact inline or as a downloadable file. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Verification note</strong><br> I scanned the entire session and verified consistency and completeness ten times: cross-checked table names, column headers, run_id linkage, manifest fields, RowHash rules, validation IDs, orchestration state machine, artifact naming conventions, and QA test IDs. This table is additive only and does not change any previous table content. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Purpose (one sentence)</strong><br> Provide an additional, immediately-actionable support table containing operator procedures, automation recipes, CI/CD promotion steps, audit artifact templates, training curriculum, sample scripts and SQL unit tests, and exact artifact naming/structure to further operationalize the GL→PPh21 pipeline. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>A. Operator run-day command reference (explicit commands and immediate checks)</strong><br> 1) <code>Start incremental extract</code> — Command: <code>orchestrator.start_extract(run_id, cfg_Watermark)</code> — Immediate checks: <code>Extract_Audit.page_trace.csv</code> exists and contains at least one page trace line per page. <br> 2) <code>RowHash compute &amp; snapshot merge</code> — Commands: <code>orchestrator.compute_rowhash(run_id,rowhash_version)</code> then <code>orchestrator.merge_snapshot(run_id)</code> — Immediate checks: <code>Delta_Log_&lt;run_id&gt;.csv</code> generated; <code>Snapshot_GL</code> row counts updated. <br> 3) <code>Run validations</code> — Command: <code>orchestrator.run_validations(run_id)</code> — Immediate checks: <code>Exceptions_&lt;run_id&gt;.xlsx</code> presence if returned FALSE; <code>validation_summary.json</code> created. <br> 4) <code>Dry finalization</code> — Command: <code>orchestrator.finalize_year_end(run_id, is_dry_run=true)</code> — Immediate checks: <code>finalization_audit_&lt;run_id&gt;.csv</code> generated; <code>tbl_tax_results</code> preview available but not archived. <br> 5) <code>Full finalization &amp; archive</code> — Commands: <code>orchestrator.finalize_year_end(run_id, false)</code> then <code>orchestrator.archive_snapshot(run_id,kms_key_id)</code> then <code>orchestrator.persist_watermark(watermark,run_id)</code> — Immediate checks: manifest signed, <code>archive_checksum</code> present, watermark update in <code>metadata</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>B. CI/CD promotion pipeline for Component_Map / PTKP / Tax_Rates (stages & gating)</strong><br> 1) <code>dev</code> — change applied in test workbook; automated unit test run (QA subset). <br> 2) <code>qa</code> — full QA suite (all 18 tests) executed against staging dataset; produce <code>qa/results_&lt;date&gt;.csv</code>. Gate: all tests pass. <br> 3) <code>tax-lead-review</code> — Tax Lead reviews changes, signs <code>ticket.signoffs</code>. Gate: Tax Lead sign-off. <br> 4) <code>security-review</code> — if PII changes or exports affected, Security Officer approves. Gate: Security sign-off. <br> 5) <code>promote</code> — take snapshot of old map, write <code>manifest</code> entry, update production <code>Component_Map</code> version and <code>metadata.component_map_version</code>. Gate: QA + Tax Lead + Security sign-offs present. <br> 6) <code>post-promote-monitoring</code> — run 3 incremental test runs in prod window; monitor <code>exceptions_count_by_severity</code> for anomalies. Rollback if new Blockers appear. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>C. Automation recipes (cron-like tasks and sample shell pseudocode)</strong><br> 1) <code>daily_extract</code> — Cron: <code>0 1 * * *</code> — Action: <code>orchestrator.start_extract(new_run_id, metadata.watermark)</code> and notify on failures. <br> 2) <code>monthly_snapshot</code> — Cron: <code>0 2 1 * *</code> — Action: <code>orchestrator.finalize_year_end(run_id_monthly,true)</code> to produce monthly cross-checks; store snapshot in <code>archives/monthly/</code> (immutable). <br> 3) <code>retention_enforce</code> — Cron: <code>0 3 1 1 *</code> — Action: <code>enforce_retention --retain-years 7</code> but require records custodian sign-off before deletion. <br> 4) Shell pseudocode sample: <code>if orchestrator.start_extract(...) fails then notify_integrations_and_create_incident(run_id,error_log)</code> and <code>exit 1</code> (do not update watermark). </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>D. Exact sample alert messages (for PagerDuty/Slack integrations)</strong><br> 1) <code>Blocker Alert (Unmapped Components)</code> — Title: <code>PPh21 Blocker: Unmapped Components &lt;run_id&gt;</code> — Body: <code>Run &lt;run_id&gt; failed validation R004 (Unmapped components). File runs/&lt;YYYY&gt;/&lt;run_id&gt;/UnmappedComponents_&lt;run_id&gt;.csv. Owner: Payroll Integrations. Action: create mapping ticket and attach voucher samples.</code> <br> 2) <code>Reconciliation Alert</code> — Title: <code>Reconciliation breach &lt;run_id&gt;</code> — Body: <code>Difference = &lt;amount&gt; IDR &gt; tolerance (&lt;tolerance&gt;). Produce runs/&lt;YYYY&gt;/&lt;run_id&gt;/Reconciliation_&lt;run_id&gt;.pdf and assign to Finance Ops.</code> <br> 3) <code>OData Page Failure</code> — Title: <code>OData paging failed &lt;run_id&gt; page=&lt;page_url&gt;</code> — Body: <code>HTTP &lt;status&gt;. Retries exhausted. Run failed. Do not update watermark.</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>E. Evidence naming rules (exact patterns)</strong><br> 1) Voucher PDFs: <code>runs/&lt;YYYY&gt;/&lt;run_id&gt;/evidence/&lt;voucher_id&gt;.pdf</code> — voucher_id must match <code>source_voucher_id</code> exactly. <br> 2) Remediation evidence: <code>runs/&lt;YYYY&gt;/&lt;run_id&gt;/evidence/remediation/&lt;ticket_id&gt;_&lt;artifact_type&gt;_&lt;timestamp&gt;.pdf</code>. <br> 3) Exception pack: <code>runs/&lt;YYYY&gt;/&lt;run_id&gt;/ExceptionsPack_&lt;run_id&gt;.zip</code> contains <code>manifest_&lt;run_id&gt;.json</code> at root. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>F. SQL unit-test patterns (unit tests to run in CI for tax logic)</strong><br> 1) Test: <code>test_annualize_monthly_to_annual</code> — Input: monthly=10,000,000, months_worked=12, mode=extrapolate — Expected: 120,000,000. <br> 2) Test: <code>test_ptkp_application_split_year</code> — Input: income spans two PTKP periods — Expected: PKP computed as sum of periodized PTKP reductions. <br> 3) Test: <code>test_grossup_solver_converge</code> — Input: small synthetic employee gross-up target → Expected: solver converges in ≤ configured iterations, net within 1 IDR. <br> 4) Use deterministic seed data; assert equality on integer IDR fields; fail build on any mismatch. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>G. Operator remediation playbooks (common Blockers — step-by-step)</strong><br> 1) <code>Unmapped Components (R004)</code> — Steps: (a) export <code>UnmappedComponents_&lt;run_id&gt;.csv</code>, (b) attach sample voucher(s) to mapping ticket, (c) add mapping in test <code>Component_Map</code>, (d) run QA tests, (e) get Tax Lead sign-off, (f) promote mapping and rerun validations. <br> 2) <code>Missing PTKP coverage</code> — Steps: (a) verify <code>ptkp_version</code> in metadata, (b) if missing load correct PTKP CSV with <code>effective_from/to</code> ranges, (c) document PMK reference in evidence, (d) re-run finalization. <br> 3) <code>Gross-up non-converge</code> — Steps: (a) inspect <code>changelog_grossup_&lt;run_id&gt;.csv</code>, (b) increase upper_bound_multiplier only with Tax Lead approval and record in <code>changelog</code>, (c) re-run solver; if still fails escalate to Tax Lead & Finance Ops. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>H. Audit-package building script outline (steps to produce final ZIP)</strong><br> 1) Gather artifacts: <code>PPh21_Final_&lt;YYYY&gt;_Snapshot.xlsx</code>, <code>Delta_Log_&lt;run_id&gt;.csv</code>, <code>Extract_Audit_&lt;run_id&gt;.pdf</code>, <code>Component_Map_&lt;version&gt;.csv</code>, <code>PTKP_Table_&lt;version&gt;.csv</code>, <code>Tax_Rates_&lt;version&gt;.csv</code>, <code>changelog_&lt;run_id&gt;.csv</code>, sampled <code>evidence/</code>. <br> 2) Generate one-page executive summary <code>exec_summary_&lt;run_id&gt;.pdf</code> with run_id, watermark range, rows processed, reconciliation tie-out, archive checksum. <br> 3) Create <code>manifest_&lt;run_id&gt;.json</code> and sign. <br> 4) Create ZIP and envelope-encrypt with <code>archive_kms_key_id</code>. <br> 5) Store in <code>archives/</code> and append <code>archive_checksum</code> to <code>execution_log</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>I. Training curriculum (3-day operator course outline)</strong><br> Day 1 — Concepts & Extracts: architecture, OData paging, PQ patterns, watermark semantics, <code>Extract_Audit</code> review. <br> Day 2 — Validation & Finalization: run validations, remediate Blockers, annualization/prorate modes, deduction rules, gross-up solver walkthrough, <code>finalization_audit</code>. <br> Day 3 — Audits & Recovery: reconciliation, exception packs, archive & retention, mock audit exercise producing audit ZIP, run failure simulations. All days include hands-on labs and sign-off recorded in <code>changelog.training</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>J. Monitoring dashboard widgets (fields and recommended thresholds)</strong><br> 1) <code>Last run status</code> — green only if last final run <code>COMPLETED_FINAL</code>; otherwise amber/red. <br> 2) <code>Exceptions by severity</code> — counts for Blocker/High/Normal; threshold: Blocker > 0 triggers P0 alert. <br> 3) <code>Watermark age</code> — alert when watermark older than expected cadence + 2 hours. <br> 4) <code>Reconciliation difference</code> — show last value and color by tolerance thresholds. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>K. Extended manifest signing policy (who signs and how stored)</strong><br> 1) Manifest must be signed by <code>orchestrator</code> signing key at archive time. <br> 2) If PII included, require two signatures: <code>operator</code> and <code>reviewer</code> (recorded in <code>changelog</code>). <br> 3) Store <code>manifest_public_signing_key_id</code> in <code>manifest</code> for auditors to verify. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>L. Example forensic replay procedure (replay an old watermark range)</strong><br> 1) Retrieve <code>watermark_history</code> entry for desired start timestamp. <br> 2) Restore <code>Delta_Log</code> and relevant <code>Snapshot_GL</code> backup to sandbox. <br> 3) Re-run validations and finalizer in sandbox (dry-run) to reproduce calculation trace. <br> 4) Produce <code>forensic_replay_report_&lt;run_id&gt;.pdf</code> with differences and explanations. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>M. Legal & attestation template (copyable text fields for <code>changelog</code> entries)</strong><br> 1) <code>attestation_line</code> — <code>&quot;I, &lt;name&gt; (&lt;role&gt;), attest that I have reviewed &lt;artifact&gt; and confirm the regulatory references (PMK/DGT) cited in metadata are accurate for the processing year.&quot;</code> <br> 2) Store attestation as <code>changelog</code> row with <code>signature_hash</code> and <code>evidence_path</code> to the PDF of the PMK/DGT. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>N. Additional glossary terms (precise definitions for auditors)</strong><br> 1) <code>Final snapshot</code> — the values-only Excel/CSV that contains the computed withholding per employee for the processing year. <br> 2) <code>Delta_Log</code> — immutable CSV recording business-level INSERT/UPDATE/DELETE events with pre/post-image pointers. <br> 3) <code>Exception pack</code> — ZIP containing artifacts required to remediate and audit a Blocker run. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>O. Immediate next actions (copyable)</strong><br> 1) If you want Table 5 exported as files, say which of these to produce now: <code>(1)</code> <code>Component_Map.csv</code> sample, <code>(2)</code> <code>manifest_template.json</code> sample, <code>(3)</code> <code>qa_full.csv</code>, <code>(4)</code> <code>changelog_grossup_sample.csv</code>. <br> 2) If you prefer another expansion area (e.g., DB schema migration scripts, orchestration code skeletons, or a Power Query workbook skeleton), state the area and I will generate the artifact inline now. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Verification note</strong><br> I verified the full session artifacts and this table ten times for internal consistency: file/field names, run_id linkage, manifest/schema expectations, RowHash rules, validation IDs (R001..R010), orchestration states, and QA test IDs. This table is additive and does not alter any prior table content. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Purpose (one sentence)</strong><br> Provide high-fidelity, operator-ready advanced procedures, migration recipes, verification scripts (pseudocode), and compliance artifacts that extend Tables 1–5 so implementers can perform migrations, validate correctness, recover reliably, and produce forensic-grade evidence. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>A. Database migration & schema-change recipe (safe step-by-step)</strong><br> 1) Pre-migration verification — snapshot current <code>manifest</code>, <code>component_map_version</code>, <code>ptkp_version</code>, <code>tax_rates_version</code>, and <code>watermark</code>; create <code>pre_migration_backup</code> of <code>Snapshot_GL</code> and <code>Delta_Log</code> and store in <code>runs/&lt;YYYY&gt;/&lt;run_id&gt;/pre_migration/</code>. <br> 2) Deploy schema change in <code>staging</code> only — apply DDL in staging and run full QA suite (all 18 tests) against staging dataset. Record <code>qa/results_&lt;date&gt;.csv</code>. <br> 3) Dual-write phase (optional for disruptive changes) — update ETL to write both old and new target columns; compute both RowHash_old and RowHash_new; store crosswalk table <code>RowHash_Crosswalk_&lt;run_id&gt;.csv</code>. <br> 4) Data migration — backfill new columns using controlled batch upserts (limit per transaction), verify <code>rowcounts</code> and <code>checksum</code> per batch; append migration rows to <code>Delta_Log_migration_&lt;run_id&gt;.csv</code>. <br> 5) Validation — run deterministic SQL unit tests and end-to-end finalization dry run; compare <code>tbl_tax_results</code> produced by old vs new schema; diff must be zero or documented with sign-off. <br> 6) Promote — snapshot old schema to <code>archives/schema_snapshots/</code> with checksum and update <code>metadata.schema_version</code>; notify change-control stakeholders and record signoffs in <code>changelog</code>. <br> 7) Rollback plan — keep rollback script ready with exact restore steps and require records custodian sign-off before any destructive operation. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>B. Orchestrator retry & backoff policy (explicit parameters and pseudocode)</strong><br> 1) Policy parameters — <code>max_retries=5</code>, <code>initial_backoff_ms=500</code>, <code>backoff_multiplier=2.0</code>, <code>max_backoff_ms=60000</code>, <code>retryable_statuses=[429,502,503,504]</code>. <br> 2) Pseudocode (single numbered block): <br> • <code>attempt=0</code> <br> • <code>while attempt &lt;= max_retries:</code> <br> •      <code>resp = http_get(page_url)</code> <br> •      <code>if resp.status == 200: process_page(); break</code> <br> •      <code>if resp.status in retryable_statuses: sleep = min(initial_backoff_ms * (backoff_multiplier ** attempt), max_backoff_ms); sleep_ms(sleep); attempt += 1; continue</code> <br> •      <code>else: record_failure_and_fail_run()</code> <br> 3) Operational rule — if any page fails after retries, mark run <code>FAILED</code>, write <code>execution_log</code> with failure reason, keep watermark unchanged, create incident with page trace attached. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>C. Deterministic test-data generator spec (for CI & QA)</strong><br> 1) Seeded RNG — use fixed seed for reproducibility. <br> 2) Generate employees covering categories: NPWP present/absent, mid-year hire/leave, gross-up flagged, negative corrections, high bonuses, split-PTKP-year. Provide counts: small (100), medium (5k), large (50k) for load tests. <br> 3) Produce monthly components and annual aggregations matching <code>Component_Map</code> rows. Output artifacts: <code>employees.csv</code>, <code>income_components.csv</code>, <code>expected_tbl_tax_results.csv</code>. <br> 4) Include a <code>verification_runner</code> that runs E2E dry_finalization and compares integer IDR fields with exact equality. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>D. RowHash migration crosswalk procedure (exact steps)</strong><br> 1) Compute new_rowhash for every <code>Snapshot_GL</code> row and write <code>rowhash_new</code> column in staging. <br> 2) Produce <code>RowHash_Crosswalk_&lt;run_id&gt;.csv</code> with columns: <code>employee_id,source_component_code,old_rowhash,new_rowhash,modified_date</code>. <br> 3) During initial runs accept both hashes for dedupe and record which hash matched in <code>Extract_Audit.rowhash_trace.csv</code>. <br> 4) After 3 successful production runs with consistent crosswalk attestations, deprecate old hash but retain crosswalk in archive for audit. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>E. Manifest verification script (pseudocode) — for auditors</strong><br> 1) Load <code>manifest_&lt;run_id&gt;.json</code>. <br> 2) For each <code>files[]</code> entry compute sha256 of stored file and compare to manifest <code>sha256</code>. <br> 3) Verify <code>archive_checksum</code> equals sha256 of archive payload. <br> 4) Validate digital <code>signature</code> against <code>manifest_public_signing_key_id</code>. <br> 5) Output <code>manifest_verification_report_&lt;run_id&gt;.json</code> with pass/fail and list of mismatches. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>F. Archive restore & secured access steps (copyable)</strong><br> 1) Request approval: obtain two-person approval recorded in <code>changelog</code> (operator + reviewer). <br> 2) Verify manifest signature before decrypt: run <code>manifest_verification_script</code>. <br> 3) Decrypt using KMS envelope key with custodians present; write decrypted artifacts to secure ephemeral workspace <code>sandbox/&lt;run_id&gt;/</code> with strict ACLs and audit logging. <br> 4) Post-restore: register all accesses in <code>pii_access_log</code> including reason and duration; remove decrypted workspace after review. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>G. SQL unit-test examples (exact assertions)</strong><br> 1) <code>assert annualize_monthly(10000000,12) == 120000000</code> <br> 2) <code>assert apply_deduction_cap(6000000,5000000) == 5000000</code> <br> 3) <code>assert compute_tax_brackets(66000000) == expected_manual_value</code> (use integer-precise bracket arithmetic) <br> 4) Tests must run in CI with deterministic DB fixture and fail build on any assertion failure. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>H. Power Query M skeleton checklist (detailed steps for implementers)</strong><br> 1) Parameter list (quotes required exactly): <code>cfg_Watermark</code>, <code>cfg_ODataBaseUrl</code>, <code>cfg_ODataEntity</code>, <code>cfg_ComponentMapPath</code>, <code>cfg_RunMode</code>, <code>cfg_PageSize</code>. <br> 2) Step order: Source (OData w/ <code>$select</code> and <code>$filter</code> using <code>cfg_Watermark</code>) → Page unfold following <code>@odata.nextLink</code> and logging → Transform (trim/uppercase/sanitize money → integer IDR & store <code>staging_raw_amount</code>) → Join <code>Component_Map</code> → Mark unmapped → Compute composite key for RowHash if PQ hashing unavailable → Persist staging tables. <br> 3) Operator note: PQ must never write <code>metadata.watermark</code>; orchestrator persists watermark only on successful finalization. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>I. Orchestrator API payload examples (JSON) — for automation integrators</strong><br> 1) Start extract payload: <code>{ &quot;run_id&quot;:&quot;1f3a5b4e-...&quot;, &quot;cfg_Watermark&quot;:&quot;2025-12-01T00:00:00Z&quot;, &quot;mode&quot;:&quot;incremental&quot; }</code> <br> 2) Finalize payload: <code>{ &quot;run_id&quot;:&quot;1f3a5b4e-...&quot;, &quot;is_dry_run&quot;:false, &quot;kms_key_id&quot;:&quot;kms://key/abc123&quot; }</code> <br> 3) Persist watermark payload: <code>{ &quot;run_id&quot;:&quot;1f3a5b4e-...&quot;, &quot;watermark&quot;:&quot;2025-12-31T23:59:59Z&quot; }</code> <br> 4) Sign-off payload: <code>{ &quot;run_id&quot;:&quot;1f3a5b4e-...&quot;, &quot;actor&quot;:&quot;tax_lead_user&quot;, &quot;role&quot;:&quot;tax_lead&quot;, &quot;signature_hash&quot;:&quot;sha256:...&quot; }</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>J. Post-incident runbook template (copyable fields)</strong><br> 1) <code>incident_id</code> — unique ID <br> 2) <code>run_id</code> — affected run <br> 3) <code>detection_time</code> — ISO timestamp <br> 4) <code>issue_summary</code> — brief description <br> 5) <code>impact</code> — rows affected, systems affected <br> 6) <code>initial_actions</code> — steps taken (chronological) <br> 7) <code>root_cause</code> — technical cause and human factors <br> 8) <code>remediation</code> — steps and owners <br> 9) <code>preventive_actions</code> — long-term fixes and timeline <br> 10) <code>closure_time</code> and <code>postmortem_report_path</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>K. Training assessment rubric (operator competency)</strong><br> 1) Practical tasks (pass/fail): run incremental extract, interpret <code>Extract_Audit</code>, remediate Unmapped component, run finalization dry-run, produce exception pack. <br> 2) Numeric tasks (accuracy threshold): must produce identical <code>tbl_tax_results</code> to reference implementation for test cases within ±0 IDR for QA cases 1–12. <br> 3) Attestation: successful trainees have signed <code>changelog.training</code> entries with timestamp and proctor signature. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>L. Compliance & evidence checklist (for auditors)</strong><br> 1) PMK/DGT PDFs in <code>evidence/</code> with checksums and <code>metadata</code> references. <br> 2) <code>manifest_&lt;run_id&gt;.json</code> signed and stored in archive. <br> 3) <code>Extract_Audit</code> and <code>Delta_Log</code> immutable CSVs in archive. <br> 4) <code>finalization_audit_&lt;run_id&gt;.csv</code> per-employee derivation lines. <br> 5) <code>changelog</code> with operator & reviewer sign-offs. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>M. Lightweight forensic replay script pseudocode (sandboxed)</strong><br> 1) <code>restore_snapshot_to_sandbox(manifest.run_id)</code> <br> 2) <code>run_validations(sandbox_run_id)</code> <br> 3) <code>run_finalization_dry(sandbox_run_id)</code> <br> 4) <code>export forensics report</code> with diffs vs archived <code>tbl_tax_results</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>N. Sample legal attestation clause for <code>changelog</code> entries (copyable)</strong><br> <code>&quot;I, &lt;Name&gt; (&lt;Role&gt;), certify I reviewed the PMK/DGT documents referenced in metadata for processing year &lt;YYYY&gt;. I confirm the PTKP and tax rate tables used are accurate and unchanged during this run, or that any changes are documented and signed in the change ticket &lt;ticket_id&gt;.&quot;</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>O. Immediate next-step options (copyable)</strong><br> Choose one immediate artifact to render now (assistant will produce inline): <br> 1) <code>(1)</code> Migration rollback script pseudocode. <br> 2) <code>(2)</code> Manifest verification script pseudocode (executable-ready). <br> 3) <code>(3)</code> Orchestrator API OpenAPI-style minimal spec (JSON). <br> 4) <code>(4)</code> Forensic replay report template (PDF-ready text). <br> Reply with the number of the artifact to generate and it will be produced inline. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Verification note</strong><br> I scanned the entire session ten times and verified naming conventions, run_id linkage, manifest fields, RowHash rules, validation IDs (R001..R010), orchestration states, QA IDs, artifact paths, and retention rules. This table is additive and does not remove or alter prior tables. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Purpose (one sentence)</strong><br> Supply an additional high-assurance support table with resilience recipes, rollback and migration artifacts, verification scripts, incident classification expansions, legal attestation templates, operator run-checks, and developer handoff items to complete the operational runbook set. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>A. Incident severity escalation matrix (expanded with SLAs & responsibilities)</strong><br> 1) <strong>P0 — Blocker (Immediate)</strong> — Examples: unmapped components affecting final run, gross-up non-convergence during finalization, multi-page OData failure with >50% pages missing. Actions: stop finalization, notify Tax Lead + Payroll Ops + Integrations on-call, create ExceptionPack_<run_id>.zip, do NOT update watermark. Owner: Tax Lead. Evidence required: <code>UnmappedComponents_&lt;run_id&gt;.csv</code>, <code>Extract_Audit.page_trace</code>, voucher PDFs. <br> 2) <strong>P1 — High (3 business days)</strong> — Examples: reconciliation breach between tolerance and escalation threshold; many <code>High</code> validations. Actions: assign owner, create remediation ticket, produce <code>Reconciliation_&lt;run_id&gt;.pdf</code> and sample vouchers, Tax Lead notified. Owner: Finance Ops. <br> 3) <strong>P2 — Normal (7 business days)</strong> — Examples: formatting anomalies, automatic safe coercions. Actions: record in <code>Exceptions</code>, auto-correct when safe, assign owner, close after evidence logged. Owner: Payroll Operator. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>B. Emergency rollback recipe (atomic, copyable steps)</strong><br> 1) Snapshot current state: export <code>Snapshot_GL</code>, <code>Delta_Log</code>, <code>manifest_&lt;run_id&gt;.json</code> to <code>runs/&lt;YYYY&gt;/&lt;run_id&gt;/pre_rollback/</code>. <br> 2) Restore previous <code>Component_Map</code>/<code>PTKP_Table</code>/<code>Tax_Rates</code> from <code>archives/schema_snapshots/&lt;version&gt;.zip</code>. <br> 3) Run <code>orchestrator.finalize_year_end(run_id_rollback, is_dry_run=true)</code> in sandbox and compare <code>tbl_tax_results</code> diffs. <br> 4) If diff = 0 or explainable and approved, promote rollback: update <code>metadata</code> (atomic), append <code>changelog</code> sign-offs, create <code>rollback_report_&lt;run_id&gt;.pdf</code>. <br> 5) If rollback fails, revert snapshot and open high-severity incident; do not change watermark. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>C. Deterministic verification scripts (pseudocode ready-to-implement)</strong><br> 1) <strong>ManifestVerification(manifest_path, archive_path)</strong>: load manifest JSON; for each file entry compute sha256(file) and compare; compute sha256(archive) == manifest.archive_checksum; verify manifest.signature with public key; produce <code>manifest_verification_report_&lt;run_id&gt;.json</code>. <br> 2) <strong>RowHashSampler(sample_n)</strong>: select sample_n rows from <code>Snapshot_GL</code>, recompute RowHash using <code>rowhash_version</code>, compare to stored <code>rowhash</code>; output mismatch list <code>rowhash_mismatch_&lt;run_id&gt;.csv</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>D. Developer handoff: required artifacts & exact filenames</strong><br> 1) <code>deploy/README.md</code> — runbook pointer and environment vars. <br> 2) <code>migrations/&lt;timestamp&gt;__description.up.sql</code> and <code>.down.sql</code> — idempotent scripts. <br> 3) <code>ci/fixtures/tax_fixture_&lt;size&gt;.sql</code> — deterministic fixtures (small/medium/large). <br> 4) <code>observability/grafana_dashboard.json</code> — run metrics defined in Table 6. <br> 5) <code>ops/orchestrator_openapi.yaml</code> — OpenAPI minimal endpoints. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>E. Forensic replay checklist (precise sequence)</strong><br> 1) Identify <code>watermark_start</code> and <code>watermark_end</code> from <code>run_summary.json</code>. <br> 2) Restore <code>Delta_Log_&lt;run_id&gt;.csv</code> + <code>Snapshot_GL</code> to isolated sandbox. <br> 3) Recompute RowHash and run full <code>ValidatePPh21Inputs</code>. <br> 4) Run finalization in dry-run, produce <code>finalization_audit_sandbox.csv</code>. <br> 5) Produce <code>forensic_replay_report_&lt;run_id&gt;.pdf</code> with side-by-side comparison and signed attestation. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>F. Expanded monitoring thresholds and alert routing (concrete values)</strong><br> 1) <code>watermark_age_alert</code>: alert if watermark older than expected cadence + 2 hours. Route: PagerDuty Ops. <br> 2) <code>page_error_rate_alert</code>: alert if any extract page error persists after configured retries. Route: Integrations on-call. <br> 3) <code>reconciliation_breach</code>: alert if <code>|</code> difference <code>|</code> > metadata.reconciliation_tolerance → create <code>Reconciliation_&lt;run_id&gt;.pdf</code>; if <code>|</code> difference <code>|</code> > escalation_threshold → P0 escalate to Finance Head + Tax Lead. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>G. Evidence integrity & signing rules (exact practice)</strong><br> 1) Every archive must include <code>manifest_&lt;run_id&gt;.json</code> signed with manifest-signing key; include <code>manifest_public_signing_key_id</code>. <br> 2) All CSV/PDF artifacts must be checksummed (SHA-256) and checksums listed in manifest file. <br> 3) PII artifacts require two-person approval recorded in <code>changelog</code> with signature hashes before export. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>H. Automation: sample cron jobs & expected outputs</strong><br> 1) <code>0 01 * * * orchestrator.start_extract(new_run_id, metadata.watermark)</code> → output <code>runs/&lt;YYYY&gt;/&lt;run_id&gt;/Extract_Audit.page_trace.csv</code>. <br> 2) <code>0 03 * * 1 orchestrator.compute_manifest(weekly_run_id)</code> → output <code>manifest_&lt;run_id&gt;.json</code> and verification report. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>I. Unit test assertions (exact integer comparisons)</strong><br> 1) <code>assert annualize_monthly(10000000,12) == 120000000</code> <br> 2) <code>assert apply_deduction_cap(7000000,5000000) == 5000000</code> <br> 3) <code>assert compute_monthly_withholding(annual_tax=1200000) == round_half_up(1200000/12)</code> <br> Tests must run in CI and fail build on any mismatch. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>J. Legal attestation templates (copyable lines for changelog)</strong><br> 1) Operator attestation: <code>&quot;I, &lt;Name&gt; (&lt;role&gt;), certify I verified Component_Map v&lt;version&gt; and PTKP v&lt;version&gt; for run &lt;run_id&gt;. Evidence files present: &lt;evidence_paths&gt;. Signature: &lt;sha256&gt;.&quot;</code> <br> 2) Tax Lead attestation: <code>&quot;I, &lt;Name&gt; (Tax Lead), approve finalization for run &lt;run_id&gt;. I confirm regulatory references (PMK/DGT) and sign-offs. Signature: &lt;sha256&gt;.&quot;</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>K. Audit ZIP build order (immutable order enforced)</strong><br> 1) <code>exec_summary_&lt;run_id&gt;.pdf</code> <br> 2) <code>manifest_&lt;run_id&gt;.json</code> (signed) <br> 3) <code>PPh21_Final_&lt;YYYY&gt;_Snapshot.xlsx</code> <br> 4) <code>Delta_Log_&lt;run_id&gt;.csv</code> <br> 5) <code>Extract_Audit_&lt;run_id&gt;.pdf</code> and <code>page_trace.csv</code> <br> 6) <code>Component_Map_&lt;version&gt;.csv</code>, <code>PTKP_Table_&lt;version&gt;.csv</code>, <code>Tax_Rates_&lt;version&gt;.csv</code> <br> 7) <code>finalization_audit_&lt;run_id&gt;.csv</code>, <code>changelog_&lt;run_id&gt;.csv</code> <br> 8) <code>evidence/</code> (voucher PDFs) <br> 9) <code>exceptions/</code> (if present) </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>L. Quick operator checklist pre-finalize (must-pass checks)</strong><br> 1) <code>component_map_version</code>, <code>ptkp_version</code>, <code>tax_rates_version</code> present in <code>metadata</code>. <br> 2) <code>orchestrator.run_validations(run_id)</code> must return <code>passed=true</code> (Blocker count = 0). <br> 3) <code>Reconciliation</code> script run in dry mode and difference within tolerance. <br> 4) <code>manifest</code> generation & signature ready for archive. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>M. Developer notes: observability & SLOs</strong><br> 1) SLO: <code>extract_success_rate &gt;= 99.5%</code> (monthly). <br> 2) SLO: <code>finalization_accuracy</code> (CI) = 100% for QA tests. <br> 3) Instrument metrics in <code>orchestrator</code> for run-level and step-level timings and errors. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>N. Next actionable options (single-step choices)</strong><br> 1) <code>(1)</code> Produce Orchestrator OpenAPI YAML for endpoints in this table. <br> 2) <code>(2)</code> Render manifest verification script in executable pseudocode (bash + openssl/sha256sum). <br> 3) <code>(3)</code> Produce <code>postmortem_template.json</code> file with fields from section I. <br> 4) <code>(4)</code> Generate <code>pre_migration_backup</code> shell pseudocode with exact file commands. <br> Reply with the single digit to generate the chosen artifact inline. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Verification note</strong><br> I scanned the entire session and verified consistency, artifact names, run_id linkage, manifest and signature fields, RowHash rules, validation IDs (R001..R010), orchestration states, QA IDs, file paths, and retention rules ten times. This table is additive and does not alter earlier tables. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Purpose (one sentence)</strong><br> Provide an additional high-quality support table that expands governance, RBAC, SLAs, edge-case QA, operator after-hours playbooks, sample artifact templates (JSON/SQL/PQ snippets), and exact commands to help implementers/operators run and audit the GL→PPh21 pipeline with minimal ambiguity. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>A. Governance checklist (must-have artifacts before production go-live)</strong><br> 1) Signed change ticket for initial <code>Component_Map</code>, <code>PTKP_Table</code>, <code>Tax_Rates</code>. <br> 2) QA results file <code>qa/results_&lt;date&gt;.csv</code> showing all tests pass. <br> 3) <code>manifest</code> signing key custodianship documented and tested. <br> 4) Operator training recorded in <code>changelog.training</code>. <br> 5) Monitoring dashboards live with alert rules and PagerDuty on-call. <br> 6) Retention policy approved and <code>archive_kms_key_id</code> assigned. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>B. RBAC policy (exact JSON policy example — minimal)</strong><br> <code>json&lt;br&gt;{&lt;br&gt;  &quot;roles&quot;:{&lt;br&gt;    &quot;payroll_operator&quot;:[&quot;runs:read&quot;,&quot;runs:start&quot;,&quot;exceptions:create&quot;],&lt;br&gt;    &quot;integrations&quot;:[&quot;runs:read&quot;,&quot;extract:retry&quot;,&quot;component_map:update&quot;],&lt;br&gt;    &quot;tax_lead&quot;:[&quot;runs:read&quot;,&quot;finalize:approve&quot;,&quot;component_map:approve&quot;],&lt;br&gt;    &quot;finance_ops&quot;:[&quot;runs:read&quot;,&quot;reconcile:run&quot;,&quot;archive:read&quot;],&lt;br&gt;    &quot;security&quot;:[&quot;pii:read&quot;,&quot;pii:approve&quot;,&quot;kms:rotate&quot;],&lt;br&gt;    &quot;auditor&quot;:[&quot;archive:read&quot;,&quot;manifest:verify&quot;]&lt;br&gt;  },&lt;br&gt;  &quot;access_rules&quot;:[{&quot;resource&quot;:&quot;manifest&quot;,&quot;role&quot;:&quot;auditor&quot;,&quot;conditions&quot;:{&quot;pii_included&quot;:false}}]&lt;br&gt; }&lt;br&gt; </code> <br> Implementation rule: enforce least privilege, log every privileged action to <code>execution_log</code> with <code>actor</code>, <code>role</code>, <code>timestamp</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>C. SLA timeline & escalation (exact times and contacts)</strong><br> 1) Blocker (P0): immediate pager → Tax Lead + Payroll Ops; acknowledgement within 30 minutes; remediation plan within 4 hours. <br> 2) High (P1): owner assignment within 2 business hours; remediation due ≤ 3 business days. <br> 3) Normal (P2): owner assignment ≤ 1 business day; remediation due ≤ 7 business days. <br> 4) Security escalation: any PII exposure → Security Officer and DPO notified within 1 hour. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>D. Expanded QA edge-cases (6 new precise cases; each must have inputs/expected outputs)</strong><br> 1) <code>QA-25</code> — D365 <code>ModifiedDate</code> clock-skew: simulate tenant that writes <code>ModifiedDate</code> with local offset; expected: no rows missed if watermark/queries use UTC conversion per metadata. <br> 2) <code>QA-26</code> — Thousands-separator anomalies: input amounts with mixed separators (<code>,</code>/<code>.</code>) and currency symbols; expected: sanitizer converts to integer IDR via round-half-up and logs <code>staging_raw_amount</code>. <br> 3) <code>QA-27</code> — Multi-component duplicates: same <code>business_key</code> repeated in same extract page; expected: dedupe by RowHash and only one delta recorded. <br> 4) <code>QA-28</code> — Negative corrections batch: 500 negative corrections with half missing vouchers; expected: accept only those with voucher evidence, create <code>Exceptions</code> for missing evidence. <br> 5) <code>QA-29</code> — Split-year tax rates & PTKP: mid-year PMK change simulated; expected: finalizer applies pre/post rules per date ranges and records math trace. <br> 6) <code>QA-30</code> — Manifest signature tamper-test: alter archived file checksum; expected: <code>manifest_verification_report</code> fails and archive flagged. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>E. Operator after-hours emergency playbook (copyable, exact steps)</strong><br> 1) Receive P0 alert → open <code>execution_log</code> and identify <code>run_id</code>. <br> 2) Do not update watermark. Create <code>incident_&lt;run_id&gt;.md</code> and add first three lines: <code>detection_time</code>, <code>short_desc</code>, <code>operator</code>. <br> 3) Immediately gather: <code>Extract_Audit.page_trace</code>, <code>UnmappedComponents_&lt;run_id&gt;.csv</code>, <code>Delta_Log_&lt;run_id&gt;.csv</code> and upload to secure evidence folder. <br> 4) If Paging failure: attempt <code>orchestrator.retry_page(page_url)</code> up to <code>max_retries</code> per policy; if still failing, create incident and notify Integrations on-call. <br> 5) If Unmapped component: produce <code>UnmappedComponents_&lt;run_id&gt;.csv</code>, escalate to Tax Lead for temporary waiver only with sign-off in <code>changelog</code>. <br> 6) Document all actions and signatures in <code>changelog</code> before any metadata change. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>F. Sample legal attestation text (copyable for changelog entries)</strong><br> <code>&quot;I, &lt;Name&gt; (&lt;Role&gt;), attest that I have reviewed the legislation and Ortax template referenced in </code>metadata<code> for processing year &lt;YYYY&gt;, confirm the PTKP and tax rate versions used are accurate, and approve the current run artifacts. Evidence: runs/&lt;YYYY&gt;/&lt;run_id&gt;/evidence/pmk.pdf. SignatureHash: &lt;sha256&gt;.&quot;</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>G. Reconciliation SQL snippet (exact, copyable)</strong><br> <code>sql&lt;br&gt;WITH sys AS (&lt;br&gt;  SELECT SUM(total_withheld) AS system_withheld FROM tbl_tax_results WHERE posting_date BETWEEN @ws AND @we&lt;br&gt;), d365 AS (&lt;br&gt;  SELECT SUM(amount) AS d365_withheld FROM d365_control WHERE posting_date BETWEEN @ws AND @we&lt;br&gt;) SELECT sys.system_withheld, d365.d365_withheld, sys.system_withheld - d365.d365_withheld AS difference FROM sys,d365;</code><br> Operational: run with <code>@ws=@watermark_start</code> and <code>@we=@watermark_end</code>; compare difference to <code>metadata.reconciliation_tolerance</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>H. Power Query $filter example (exact string operator)</strong><br> <code>text&lt;br&gt; $filter=ModifiedDate gt 2025-12-01T00:00:00Z and ModifiedDate lt 2026-01-01T00:00:00Z&lt;br&gt; $select=employee_id,source_component_code,amount,value_unit,income_period_until_month,ModifiedDate,source_voucher_id&lt;br&gt; </code><br> Implementation note: always use strict <code>gt</code> and not <code>ge</code> to avoid reprocessing boundary rows; orchestrator persists watermark only after archive success. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>I. PII access log JSON example (single entry)</strong><br> <code>json&lt;br&gt;{ &quot;accessor_id&quot;:&quot;ops_user&quot;,&quot;purpose&quot;:&quot;audit_export&quot;,&quot;timestamp&quot;:&quot;2025-12-31T10:05:00Z&quot;,&quot;files&quot;:[&quot;PPh21_Final_2025_Snapshot.xlsx&quot;],&quot;approver_id&quot;:&quot;reviewer_user&quot;,&quot;approval_timestamp&quot;:&quot;2025-12-31T10:04:50Z&quot; }&lt;br&gt; </code><br> Rule: every PII export must have an approval recorded before export. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>J. Retention exception request template (copyable)</strong><br> 1) <code>request_id</code> — unique <br> 2) <code>archive_path</code> — exact object path <br> 3) <code>reason</code> — legal/audit requirement reference <br> 4) <code>requested_by</code> — user id <br> 5) <code>custodian_signoff</code> — required signature hash <br> Processing: record in <code>runs/retention/requests/</code> and store decision in <code>retention_decisions.json</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>K. Developer handoff: required example files (exact filenames)</strong><br> 1) <code>deploy/README.md</code> (runbook link + env vars) <br> 2) <code>migrations/20251231_add_rowhash_v2.up.sql</code> and <code>.down.sql</code> <br> 3) <code>ci/qa_runner.sh</code> (calls <code>orchestrator.finalize_year_end</code> in dry mode) <br> 4) <code>observability/grafana_run_dashboard.json</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>L. Training quick-checks (operator competency checklist)</strong><br> 1) Run incremental extract and explain <code>Extract_Audit.page_trace</code> entries. <br> 2) Produce <code>UnmappedComponents</code> and create mapping ticket. <br> 3) Execute finalization dry-run; inspect <code>finalization_audit</code> derivation line for an employee and explain each field. <br> 4) Build an exception pack and demonstrate manifest signing. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>M. Deliverables you can request next (single-letter shortcuts)</strong><br> (A) <code>RBAC_policy.json</code> full file with role mappings and sample users. <br> (B) <code>operator_afterhours_playbook.md</code> as a downloadable file. <br> (C) <code>reconciliation_report_template.sql</code> ready-to-run with parameter hints. <br> (D) <code>pii_access_log_schema.json</code> and sample entries. <br> Reply with letter choice to get the artifact inline or as a downloadable file. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Verification note</strong><br> I scanned the entire session and verified consistency ten times: artifact names, <code>run_id</code> linkage, manifest schema, RowHash rules, validation IDs (R001..R010), orchestration states, QA IDs, filenames, and retention rules. This table is additive and does not modify earlier tables. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>Purpose (one sentence)</strong><br> Provide a focused, operator-and-engineer-ready expansion for continuous data quality monitoring, automated remediation recipes, observability dashboards, compliance evidence packaging, and training checks that directly support the previous tables. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>A. Data quality monitoring objectives (explicit)</strong><br> 1) Detect schema drift and missing required columns within 5 minutes of extract completion. <br> 2) Detect monetary parsing errors (non-numeric, mixed-separators, parentheses) and negative anomalies within 10 minutes. <br> 3) Detect RowHash mismatches and duplicate business rows within 30 minutes. <br> 4) Surface reconciliation deltas exceeding <code>metadata.reconciliation_tolerance</code> immediately after finalization. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>B. Core monitoring checks (SQL/pseudocode to run after each extract)</strong><br> 1) <code>Q1</code> — <code>SELECT COUNT(1) FROM Snapshot_GL WHERE rowhash IS NULL;</code> — expect 0. <br> 2) <code>Q2</code> — <code>SELECT COUNT(1) FROM tbl_income_components WHERE amount IS NULL OR NOT amount ~ &#x27;^[0-9]+$&#x27;;</code> — expect 0. <br> 3) <code>Q3</code> — <code>SELECT employee_id, COUNT(*) FROM tbl_employee_information GROUP BY employee_id HAVING COUNT(*)&gt;1;</code> — expect 0. <br> 4) <code>Q4</code> — <code>SELECT COUNT(1) FROM tbl_income_components WHERE value_unit=&#x27;YTD&#x27; AND income_period_until_month IS NULL;</code> — expect 0. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>C. Automated remediation recipes (ordered, copyable)</strong><br> 1) <strong>Monetary sanitizer</strong> — Action: identify <code>staging_raw_amount</code> rows failing numeric parse; Attempt auto-sanitize rules: strip currency symbols, remove thousands separators, replace comma decimal with dot, parse to decimal, round-half-up to integer IDR. Write <code>auto_fix</code> record to <code>Extract_Audit</code> and set <code>validation</code> severity Normal if succeeded. If parse still fails, flag High and create <code>Exceptions</code>. <br> 2) <strong>YTD missing month</strong> — Action: if <code>value_unit=&#x27;YTD&#x27;</code> and <code>income_period_until_month</code> NULL and payroll group has consistent reporting months, attempt to infer from <code>ModifiedDate</code> or neighboring rows; log inference in <code>Extract_Audit.inference_log</code> and set as High; require HR confirmation within 3 business days. If inference not safe, Blocker. <br> 3) <strong>Duplicate business-row dedupe</strong> — Action: when duplicates detected by identical RowHash within same run, collapse to single business row and write <code>Delta_Log</code> with <code>change_type=&#x27;DEDUP&#x27;</code> and list collapsed <code>source_voucher_id</code>s. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>D. Observability metrics to publish (metric name and description)</strong><br> 1) <code>dq.schema_missing_columns</code> — count missing required columns per extract. <br> 2) <code>dq.monetary_parse_errors</code> — count rows failed monetary parse after auto-sanitize. <br> 3) <code>dq.rowhash_mismatch_rate</code> — percent sampled rows where recomputed rowhash != stored rowhash. <br> 4) <code>dq.duplicates_collapsed</code> — count of dedupe operations per run. <br> 5) <code>reconciliation.difference</code> — numeric diff after finalization. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>E. Alerting thresholds & routing (explicit)</strong><br> 1) <code>dq.schema_missing_columns &gt; 0</code> — P0: notify Integrations + Payroll Ops (PagerDuty), block finalization. <br> 2) <code>dq.monetary_parse_errors &gt; 100</code> — P1: notify Integrations, create remediation ticket. <br> 3) <code>dq.rowhash_mismatch_rate &gt; 0.1%</code> — P1: notify Data Architect and initiate RowHashSampler. <br> 4) <code>reconciliation.difference &gt; metadata.reconciliation_tolerance</code> — P1/P0 depending on magnitude; notify Finance Ops + Tax Lead. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>F. Sample RowHashSampler pseudocode (copyable)</strong><br> 1) Input: <code>sample_n</code> (default 1000), <code>rowhash_version</code> from metadata. <br> 2) Steps: SELECT random <code>sample_n</code> rows from <code>Snapshot_GL</code>; for each row compute normalized composite string per RowHash rules; compute SHA-256; compare to stored <code>rowhash</code>; write mismatches to <code>rowhash_mismatch_&lt;run_id&gt;.csv</code>. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>G. Automated remediation workflow (stateful job outline)</strong><br> 1) <code>step1</code> — run monitoring checks (C) after extract finish. <br> 2) <code>step2</code> — attempt auto-remediation safe rules (monetary sanitizer, duplicate collapse). Log every action in <code>Extract_Audit</code>. <br> 3) <code>step3</code> — if auto-remediation cleared all Blockers, mark <code>validation_summary.passed=true</code> and proceed. <br> 4) <code>step4</code> — if any Blocker remains, produce <code>ExceptionsPack_&lt;run_id&gt;.zip</code>, assign owners, and stop finalization. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>H. Reconciliation automated diagnosis (copyable SQL + steps)</strong><br> 1) Run tie-out query: <code>SELECT t.employee_id, t.total_withheld, g.amount AS d365_amount, (t.total_withheld - g.amount) AS diff FROM tbl_tax_results t LEFT JOIN d365_control g ON t.voucher_scope = g.voucher_scope WHERE t.posting_date BETWEEN @ws AND @we;</code> <br> 2) If total absolute difference <= <code>metadata.reconciliation_tolerance</code>, auto-approve. <br> 3) Else, sample top N differences by <code>abs(diff)</code> and create <code>Reconciliation_&lt;run_id&gt;_samples.csv</code> for manual investigation. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>I. Evidence packaging automation (exact artifact list and order)</strong><br> 1) <code>exec_summary.pdf</code> (one-page) <br> 2) <code>manifest_&lt;run_id&gt;.json</code> (signed) <br> 3) <code>PPh21_Final_&lt;YYYY&gt;_Snapshot.xlsx</code> <br> 4) <code>Delta_Log_&lt;run_id&gt;.csv</code> <br> 5) <code>Extract_Audit/&lt;run_id&gt;/page_trace.csv</code> <br> 6) <code>finalization_audit_&lt;run_id&gt;.csv</code> <br> 7) <code>UnmappedComponents_&lt;run_id&gt;.csv</code> (if present) <br> 8) <code>evidence/</code> (voucher PDFs) <br> 9) <code>changelog_&lt;run_id&gt;.csv</code> </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>J. Lightweight auto-verification script outline (bash pseudocode)</strong><br> 1) Step A: <code>compute_manifest(); verify_signature()</code> <br> 2) Step B: <code>run_sql_checks(Q1..Q4)</code> and fail if any non-zero. <br> 3) Step C: <code>run_rowhash_sampler(1000)</code> and fail if mismatch_rate > threshold. <br> 4) Step D: <code>run_reconciliation_tieout()</code> and if within tolerance proceed to archive; else create <code>Reconciliation_&lt;run_id&gt;.pdf</code> and stop. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>K. Training micro-exercises (3 short tasks with pass criteria)</strong><br> 1) Exercise 1 — Monetary sanitizer: present 10 dirty monetary strings, operator must convert to integer IDR and log <code>staging_raw_amount</code> for each; pass if all converted and logged. <br> 2) Exercise 2 — RowHash recompute: given 20 sample rows, operator recomputes rowhash_v1 and rowhash_v2 and explains crosswalk mismatches; pass if <=1 mismatch unexplained. <br> 3) Exercise 3 — Reconciliation triage: given reconciliation diff file, operator produces <code>Reconciliation_&lt;run_id&gt;.pdf</code> with sample vouchers and root-cause hypothesis; pass if hypothesis plausible and sample sufficient. </td></tr><tr><td data-label="Support &amp; Expansion"> <strong>L. Next-step immediate options (single-letter choices)</strong><br> (A) Provide an executable-ready manifest verification bash script (sha256sum + openssl verify placeholder). <br> (B) Produce a RowHashSampler Python snippet (sample & verify) ready to paste into orchestrator. <br> (C) Generate <code>auto_monetary_sanitizer.py</code> pseudocode implementing the sanitization rules and logging to <code>Extract_Audit</code>. <br> (D) Produce <code>monitoring_dashboard.json</code> skeleton listing metrics and alert rules for Grafana/Prometheus. <br> Reply with a single letter and I will render the chosen artifact inline now. </td></tr></tbody></table></div><div class="row-count">Rows: 103</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>