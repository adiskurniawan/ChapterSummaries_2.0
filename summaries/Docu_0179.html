<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1768666232">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0179_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by PQ_Ribbon — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">PQ_Ribbon — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Module-level metadata (contract & overview):</strong><br><strong>Owner:</strong> TEAM_PQ_TOOLS recorded in OWNERS.md and release manifests; include <code>owner_contact</code>, <code>oncall_rotation</code>, and <code>maintenance_window</code> in manifest for triage and deployment scheduling. <br><strong>Public API / exported handlers (surface):</strong> <code>OnRibbonLoad</code>, <code>OpenLibraryPane</code>, <code>RefreshLibraryIndex</code>, <code>ListTemplates</code>, <code>PreviewTemplate(templateId, params, options, correlationId)</code>, <code>ParameterizeTemplate(templateId, paramMap, correlationId)</code>, <code>ValidateTemplateIntegrity(mChecksum, templateBlob, correlationId)</code>, <code>InjectTemplateToWorkbook(templateId, paramMap, options, correlationId)</code>, <code>Add_Query_From_M(name, mFormula, correlationId)</code>, <code>CreateConnection(connectionSpec, options, correlationId)</code>, <code>RefreshQuery(queryName, refreshOptions, correlationId)</code>, <code>ExportTemplate(templateId, destinationSpec, correlationId)</code>, <code>CollectDiagnostics(runId, correlationId)</code>, <code>ValidateHostCapabilities(hostInfo, correlationId)</code>, <code>EnsurePQRuntimeVersion(requiredVersion, correlationId)</code>, <code>RequestTwoPersonApproval(changeRequest, correlationId)</code>, <code>EmitUserActionAudit(procedure, correlationId, params)</code>. <br><strong>Primary audits emitted (canonical examples):</strong> <code>pq.ribbon.load</code>, <code>pq.library.opened</code>, <code>pq.library.refreshed</code>, <code>pq.template.preview.start</code>, <code>pq.template.preview.complete</code>, <code>pq.template.preview.failed</code>, <code>pq.template.inject.attempt</code>, <code>pq.template.inject.completed</code>, <code>pq.template.inject.failed</code>, <code>pq.connection.created</code>, <code>pq.refresh.start</code>, <code>pq.refresh.complete</code>, <code>pq.export.attempt</code>, <code>pq.export.completed</code>, <code>pq.diagnostics.collected</code>, <code>pq.ensuredeps.reported</code>, <code>pq.template.validation.failed</code>, <code>pq.approval.requested</code>, <code>pq.approval.granted</code>, <code>pq.approval.denied</code>. Every audit row MUST include <code>correlationId</code>, <code>module=PQ_Ribbon</code>, <code>procedure</code>, <code>paramsHash</code>, <code>resultHash</code> (when applicable), <code>timestamp</code>, <code>operatorId</code> (if UI-initiated), and <code>evidenceRef</code> when large artifacts or nondisclosable parameters are stored. <br><strong>Purpose and intended use:</strong> Ribbon acts as the authoritative, auditable operator surface for Power Query template lifecycle: discovery, preview, parameterization, safe injection, connection creation, refresh orchestration, export, and diagnostics. It enforces deterministic behaviors (seed propagation), integrity (mChecksum & signatures), auditability (uniform audit schema and evidence references), operational safety (no heavy UI-thread IO), and governance (two-person approvals, regulated template handling). <br><strong>Non-goals / constraints:</strong> Ribbon MUST NOT perform heavy network or filesystem IO on the UI thread; MUST NOT implement numerically-sensitive aggregation or rounding logic (delegate to worker <code>SafeRound</code> workflows); MUST NOT store credentials in audit rows or evidence in cleartext; MUST avoid assumptions about host PQ decimal semantics; MUST NOT persist artifacts without <code>AtomicWrite</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Operational guarantees (module-level invariants & SLOs):</strong><br>1. <strong>UI responsiveness:</strong> ribbon handler entrypoints return within UI idle budget; any expensive work scheduled to worker/off-thread. <br>2. <strong>Audit-first behavior:</strong> every operator-triggered control emits a <code>UserAction</code> audit row before any side-effecting operation. <br>3. <strong>Deterministic preview & sampling:</strong> previews that use sampling must record deterministic RNG seeds derived from <code>correlationId</code> and <code>templateId</code>, and persist RNG state when exact replay is required. <br>4. <strong>Integrity-first injection:</strong> template M must match <code>mChecksum</code>, and regulated templates require owner signature validation before injection proceeds. <br>5. <strong>Idempotency:</strong> injections are idempotent for identical <code>(templateId, paramsHash, targetWorkbookId)</code> inputs; duplicate injection attempts are detected and skipped with <code>pq.template.inject.skipped</code>. <br>6. <strong>Rollback capability:</strong> any replace operation must create a <code>backupArtifact</code> persisted via <code>AtomicWrite</code> before mutation to support restoration. <br>7. <strong>Observability:</strong> long-running operations emit start/complete audits; metrics buffered locally and uploaded by core telemetry. <br><strong>Performance SLOs:</strong> UI actions <100ms median; client-light preview <3s for small datasets; worker-backed preview <10s for moderate workloads; atomic export median local SSD <200ms. <br><strong>CI / acceptance gates:</strong> golden <code>mChecksum</code> parity tests, static analyzer forbidding UI-thread file I/O, audit emission tests, cross-host deterministic parity test harness for previews. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Cross-cutting invariants & design constraints (must/shall):</strong><br>1. All public functions accept or produce a <code>correlationId</code> and propagate it downstream. <br>2. Top-level audit fields MUST NOT include raw PII; sanitized parameters stored encrypted in evidence store and referenced by <code>evidenceRef</code>. <br>3. All durable artifacts (job descriptors, template exports, backups, diagnostics) MUST be persisted using <code>AtomicWrite</code>. <br>4. Deterministic seeds MUST be derived using <code>HMAC_SHA256(correlationId | templateId | salt)</code>; store <code>seedFingerprint</code> in audits but never the raw seed value. <br>5. Two-person approvals are required for regulated templates and manifest-changing releases; approval artifacts must be tamper-evident and persisted with <code>AtomicWrite</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>OnRibbonLoad()</code> — lifecycle initialization (detailed):</strong><br><strong>Purpose & contract:</strong> initialize ribbon UI, lightweight caches, correlation generator, and audit buffer. Must not perform heavy IO on UI thread. <br><strong>Detailed steps:</strong><br>1. Validate minimal host capabilities via <code>ValidateHostCapabilities()</code> and record <code>pq.ensuredeps</code> if degraded.<br>2. Instantiate <code>correlationId</code> generator utility accessible by UI handlers; ensure deterministic format (e.g., <code>r-YYYYMMDD-HHMMSS-&lt;short-rand&gt;</code>).<br>3. Load only embedded template metadata (hidden-sheet) into read-only cache; do not load full template blobs. <br>4. Register control callbacks (each wrapper calls <code>EmitUserActionAudit</code> before delegating). <br>5. Initialize LRU caches for <code>templateMetadata</code>, <code>recentPreviews</code>, and <code>hostCapabilitySnapshot</code>. <br>6. Emit <code>pq.ribbon.load(correlationId, hostVersion, pqRuntimeVersion, cacheStateHash)</code>. <br><strong>Failure handling:</strong> mark ribbon as degraded if essential capabilities missing; expose only safe read-only operations and present remediation guidance; emit <code>pq.ribbon.degraded</code> with <code>deps.report</code> link. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>OpenLibraryPane()</code> — template catalog UX entry:</strong><br><strong>Purpose & contract:</strong> present template library UI from cached metadata; avoid heavy remote fetches on UI thread. <br><strong>Behavior & UX rules:</strong><br>1. Render embedded templates and metadata from hidden-sheet synchronously. <br>2. Allow remote refresh request; schedule <code>RefreshLibraryIndex()</code> as background job and show <code>lastRefreshedTs</code>. <br>3. Expose deterministic filters such as <code>requiresHighPrecision</code>, <code>regulated</code>, <code>owner</code>, and <code>tags</code>. <br>4. Emit <code>pq.library.opened(correlationId, source, templateCount)</code>. <br><strong>Offline behavior:</strong> present embedded-only view and emit <code>pq.library.offline</code> audit; mark templates requiring worker connectors as <code>remote-only</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>RefreshLibraryIndex(repoConfig, correlationId)</code> — authoritative index refresh (background):</strong><br><strong>Purpose & contract:</strong> fetch, validate, normalize remote index, compute <code>repo.hash</code>, and persist <code>indexSnapshot.json</code> via <code>AtomicWrite</code>. Must be background. <br><strong>Algorithm & steps:</strong><br>1. Validate <code>repoConfig</code> schema and test credentials without storing raw secrets. <br>2. Fetch index manifest (HTTP/HTTPS or internal file share) and validate <code>indexChecksum</code>. <br>3. Validate each template manifest: presence of <code>owner</code>, <code>mChecksum</code>, <code>templateVersion</code>, <code>tags</code>, and <code>requiresHighPrecision</code> flags. <br>4. Apply idempotent migrations if index schema updated. <br>5. Compute <code>indexSnapshotHash</code> and persist via <code>AtomicWrite(indexSnapshotPath)</code>. <br>6. Emit <code>pq.library.refreshed(correlationId, repo.hash, indexSnapshotChecksum, templateCount)</code>. <br><strong>Retries & recovery:</strong> wrap network fetch in <code>Retry</code> with deterministic jitter for CI tests; on auth failure emit <code>pq.library.auth_failed</code> and produce remediation steps. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>ListTemplates(filter, sortOrder, correlationId)</code> — deterministic listing API:</strong><br><strong>Purpose & contract:</strong> return stable deterministic list view to the UI using canonical sort keys to avoid UI churn. <br><strong>Stable sort invariant:</strong> sort by <code>(owner asc, canonicalTags asc, version desc, title asc, templateId asc)</code>. <br><strong>Filtering supported:</strong> <code>requiresHighPrecision</code>, <code>regulated</code>, <code>owner</code>, <code>tags</code>, <code>versionRange</code>. <br><strong>Audit:</strong> <code>pq.library.listed(correlationId, filterHash, resultCount)</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>ParameterizeTemplate(templateId, paramMap, correlationId)</code> — canonical parameterization (pure):</strong><br><strong>Purpose & contract:</strong> validate parameter types against template parameter schema, coerce values into canonical forms, compute <code>paramsHash</code>, and render <code>parameterizedM</code>. No side-effects. <br><strong>Canonicalization rules & steps:</strong><br>1. Type coercion rules:<br>   1.1 Dates → ISO 8601 UTC normalized representation; if timezone absent, treat as naive UTC and record <code>timezoneAssumed:UTC</code> in canonical blob.<br>   1.2 Decimals → canonical decimal string using fixed-scale or explicit exponent (no locale formatting).<br>   1.3 Booleans → <code>true</code> / <code>false</code> canonical strings.<br>   1.4 Lists → ordered deterministic serialization (preserve explicit order unless schema allows sorting).<br>2. Validate enumerations, min/max constraints, and requiredness; emit <code>pq.template.parameterize.invalid_input</code> audits on failure.<br>3. Sort parameter keys lexicographically and compute <code>paramsHash = SHA256(sorted(k=v))</code>.<br>4. Perform template substitution with deterministic templating engine avoiding locale-specific formatting. <br>5. Return <code>{parameterizedM, paramsHash, canonicalParamsBlob}</code>. <br><strong>Audit:</strong> <code>pq.template.parameterize(correlationId, templateId, paramsHash)</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>ValidateTemplateIntegrity(mChecksum, templateBlob, correlationId)</code> — checksum & signature validation:</strong><br><strong>Purpose & contract:</strong> ensure template content equals declared <code>mChecksum</code> and validate owner signature chain for regulated templates. Return pass/fail with diagnostics. <br><strong>Steps & policies:</strong><br>1. Compute <code>computedChecksum = SHA256(templateBlob)</code>.<br>2. If mismatch, emit <code>pq.template.validation.failed(correlationId, templateId, expected=mChecksum, actual=computedChecksum)</code> and produce <code>diagnosticsRef</code> for forensic analysis. <br>3. For <code>regulated=true</code> templates, verify detached signature: check owner fingerprint against <code>OWNERS.md</code> and release manifest; if missing or invalid, emit <code>pq.template.validation.signature_failed</code>. <br>4. On success emit <code>pq.template.validation.passed(correlationId, templateId, mChecksum)</code>. <br><strong>Runbook:</strong> mismatches require CI golden vector comparison and possible repo rollback; record <code>validationFailureReason</code> in forensic manifest. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>PreviewTemplate(templateId, paramMap, previewOptions, correlationId)</code> — multi-mode preview orchestration:</strong><br><strong>Purpose & contract:</strong> produce reproducible preview via client-light sandbox or worker-backed authoritative execution; deterministic previews must persist RNG state evidence. <br><strong>Detailed flow & determinism rules:</strong><br>1. Call <code>ParameterizeTemplate</code> to get <code>parameterizedM</code> & <code>paramsHash</code>. <br>2. Emit <code>pq.template.preview.start(correlationId, templateId, paramsHash, previewMode)</code>. <br>3. Seed derivation: <code>seed = HMAC_SHA256(correlationId | templateId | &quot;preview-vX&quot;)</code> unless caller provides <code>previewOptions.seed</code>; persist <code>seedFingerprint</code> in audit (never raw seed). <br>4. Modes:<br>   4.1 <strong>Client-light:</strong> run a sandboxed restricted M interpreter for limited connectors; suitable for rapid interactive feedback; return first N rows as <code>previewRows</code>; compute <code>previewChecksum</code>. <br>   4.2 <strong>Worker-backed authoritative:</strong> persist <code>previewJobDescriptor</code> via <code>AtomicWrite</code>, schedule worker; worker instantiates <code>DeterministicRNG(seed)</code>, normalizes decimals, uses <code>SafeRound</code> for numeric-critical steps, executes with full connector stack, persists <code>previewPayload</code> and diagnostics via <code>AtomicWrite</code>, and returns <code>previewChecksum</code> and <code>evidenceRef</code>. <br>5. On success emit <code>pq.template.preview.complete(correlationId, templateId, previewChecksum, evidenceRef, durationMs)</code>. <br>6. On error emit <code>pq.template.preview.failed(correlationId, templateId, errorCode, diagnosticsRef)</code> with sanitized user-facing text. <br><strong>Replay invariant:</strong> <code>parameterizedM</code> + <code>seedFingerprint</code> + persisted RNG serialized state + <code>previewPayload</code> must reproduce identical preview. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>InjectTemplateToWorkbook(templateId, paramMap, options, correlationId)</code> — safe injection orchestration:</strong><br><strong>Purpose & contract:</strong> add or update queries in the active workbook in an idempotent, auditable, reversible, and integrity-verified manner. <br><strong>Supported modes:</strong> <code>create_new_query</code>, <code>replace_existing</code>, <code>replace_in_named_query</code>, <code>inject_as_connection_only</code>. <br><strong>Preflight checklist (must/shall):</strong><br>1. <code>ValidateTemplateIntegrity</code> must pass. <br>2. <code>ParameterizeTemplate</code> computed <code>paramsHash</code>. <br>3. Operator permissions validated via <code>ValidateUserPermissions</code>. <br>4. If <code>options.requireTwoPersonApproval</code> then <code>RequestTwoPersonApproval</code> must complete. <br>5. If <code>options.atomicPersist==true</code>, persist <code>parameterizedM</code> + manifest via <code>AtomicWrite</code> and compute <code>artifactChecksum</code>. <br><strong>Critical injection sequence (atomic & verifiable):</strong><br>1. Emit <code>pq.template.inject.attempt(correlationId, templateId, paramsHash, mode, targetWorkbookId)</code>.<br>2. If replacing, persist <code>backupArtifact</code> via <code>AtomicWrite(backupPath)</code> before any workbook mutation. <br>3. Invoke <code>Add_Query_From_M</code> (trusted helper) to perform <code>wb.Queries.Add(Name, Formula)</code> or <code>wb.Queries.Item(queryName).Formula = formula</code> for replace; handle host exceptions. <br>4. After insertion, read back formula text and compute <code>sha256</code>; it must match <code>artifactChecksum</code>. If mismatch, attempt immediate rollback using <code>backupArtifact</code>; emit <code>pq.template.inject.verification_failed</code> with <code>diagnosticsRef</code>. <br>5. On success, emit <code>pq.template.inject.completed(correlationId, queryName, artifactChecksum, durationMs)</code> and update workbook-level registry for injected artifacts. <br>6. If identical artifact exists (same <code>artifactChecksum</code> and <code>paramsHash</code>), emit <code>pq.template.inject.skipped(correlationId, reason=duplicate)</code> and return reference to existing query. <br><strong>Failure & escalation:</strong> if rollback fails, mark workbook read-only, collect <code>audit_tail.csv</code>, persisted artifacts, and open incident attaching <code>forensic_manifest.json</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>Add_Query_From_M(name, mFormula, correlationId)</code> — trusted insertion primitive:</strong><br><strong>Purpose & contract:</strong> single trusted point of workbook modification. Validates names, performs insertion via host API, verifies inserted formula matches persisted artifact checksum, and returns canonical result object. <br><strong>Behavior & safeguards:</strong><br>1. Validate <code>name</code> against workbook naming rules and reserved namespace for add-in managed queries. <br>2. Perform insertion using host automation wrapper that maps host exceptions to canonical error codes (<code>PQ_INJECT_API_ERROR</code>, <code>PQ_INJECT_EPERM</code>). <br>3. Read back inserted formula, compute checksum, and verify equality to expected <code>artifactChecksum</code>. On mismatch delete inserted query and return verification failure. <br>4. Emit <code>pq.template.inject.inserted(correlationId, name, artifactChecksum)</code>. <br><strong>UI thread safety:</strong> if insertion may block, schedule via idle callback or delegate to worker injection agent. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>CreateConnection(connectionSpec, options, correlationId)</code> — provider connection creation & registration:</strong><br><strong>Purpose & contract:</strong> create provider connections idempotently and auditably without storing credentials in audits; provide fingerprinting for later reuse. <br><strong>Steps & behaviors:</strong><br>1. Normalize <code>connectionSpec</code> and compute <code>connectionFingerprint = SHA256(normalizedSpec)</code> excluding secrets. <br>2. If identical fingerprint exists in workbook, return existing connection and emit <code>pq.connection.reused(correlationationId, connectionName)</code>. <br>3. Otherwise create connection via host API, persist metadata (no credentials) and emit <code>pq.connection.created(correlationId, provider, connectionName, connectionFingerprint)</code>. <br>4. On failure due to provider mismatch emit <code>pq.connection.creation.failed</code> and recommend worker-run connectors. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>RefreshQuery(queryName, refreshOptions, correlationId)</code> — refresh orchestration with robust diagnostics:</strong><br><strong>Purpose & contract:</strong> refresh one or more queries while capturing diagnostics, supporting retries for transient provider failures, and offering dry-run preview capabilities. <br><strong>Flow & observability:</strong><br>1. Emit <code>pq.refresh.start(correlationId, queryName, refreshOptions)</code>. <br>2. For provider calls apply <code>Retry</code> for transient error classes with deterministic jitter for CI. <br>3. Collect diagnostics: <code>startTs</code>, <code>endTs</code>, <code>provider</code>, <code>rowsFetched</code>, <code>providerErrors</code>, <code>stackTrace</code>, <code>memorySnapshot</code> if available. <br>4. Persist diagnostics via <code>CollectDiagnostics</code> producing <code>diagnosticsRef</code>. <br>5. Emit <code>pq.refresh.complete(correlationId, queryName, elapsedMs, rowCount, diagnosticsRef)</code> or <code>pq.refresh.failed(correlationId, queryName, errorCode, diagnosticsRef)</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>ExportTemplate(templateId, destinationSpec, correlationId)</code> — atomic export of artifact package:</strong><br><strong>Purpose & contract:</strong> persist an export package (M, manifest, optional diagnostics) atomically using <code>AtomicWrite</code>, compute <code>artifactChecksum</code>, and support staged fallback on network filesystems. <br><strong>Detailed steps:</strong><br>1. Assemble streamable payload: <code>template.m</code>, <code>manifest.json</code>, optional <code>diagnostics.zip</code> and <code>readme.md</code>. <br>2. Compute <code>artifactChecksum</code> and call <code>AtomicWrite(destinationPath, payloadStream, fsyncFile=true, fsyncParent=true)</code>. <br>3. On success emit <code>pq.export.completed(correlationId, destinationUri, artifactChecksum)</code>. <br>4. On atomicity degradation (network FS rename not safe) emit <code>pq.export.degraded</code> and record fallback staging path. <br>5. On persistent failure (ENOSPC, EPERM) use <code>Retry</code> and escalate with <code>forensic_manifest</code> when exhausted. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>CollectDiagnostics(runId, correlationId)</code> — diagnostics aggregation & sanitation:</strong><br><strong>Purpose & contract:</strong> gather host and worker logs, sanitize PII, compress into diagnostics bundle and persist via <code>AtomicWrite</code>; return <code>diagnosticsRef</code> for audits. <br><strong>Steps & policies:</strong><br>1. Aggregate logs: host PQ runtime traces, worker logs, preview parse traces, provider error traces, and telemetry snippets. <br>2. Sanitize PII: replace or hash personal identifiers using per-run salt; persist sanitized mapping separately in encrypted evidence if policy allows. <br>3. Compress into <code>diagnosticsBundle.zip</code>, compute <code>diagnosticsChecksum</code> and persist via <code>AtomicWrite</code>. <br>4. Emit <code>pq.diagnostics.collected(correlationId, runId, diagnosticsChecksum, evidenceRef)</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>ValidateHostCapabilities(hostInfo, correlationId)</code> — discovery & gating:</strong><br><strong>Purpose & contract:</strong> detect host PQ runtime version, provider list, workbook model capabilities, and file system access; produce compatibility recommendation and <code>pq.ensuredeps</code> audit. <br><strong>Outputs:</strong> <code>hostVersion</code>, <code>pqRuntimeVersion</code>, <code>availableProviders</code>, <code>workbookModelCapabilities</code> (PowerPivot, Data Model), <code>filesystemAccess</code> (add-in writable paths), <code>recommendedExecutionMode</code> (<code>client|worker</code>). <br><strong>Policy:</strong> if required features missing for regulated templates, block inline injection and recommend worker-backed execution; emit <code>pq.ensuredeps.degraded</code> with details. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>EnsurePQRuntimeVersion(requiredVersion, correlationId)</code> — version gating and migration hints:</strong><br><strong>Purpose & contract:</strong> determine whether host PQ runtime meets <code>requiredVersion</code> and recommend degraded behaviors or worker delegation; emit <code>pq.ensuredeps</code> with <code>pass|degraded|fail</code>. <br><strong>Behavior:</strong> if runtime older, annotate template actions with <code>degradedReason</code>, produce <code>deps.report.json</code>, and add telemetry for platform incompatibility metrics. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>RequestTwoPersonApproval(changeRequest, correlationId)</code> — tamper-evident approval flow:</strong><br><strong>Purpose & contract:</strong> implement two-person approval for regulated template edits, releases, or auto-apply templates; persist approval artifacts via <code>AtomicWrite</code> and block guarded operations until approval recorded. <br><strong>Flow & assurance:</strong><br>1. Persist <code>approvalRequest</code> with <code>changeRequestId, templateId, artifactChecksum, requestorId, policyTag</code> using <code>AtomicWrite</code>. Emit <code>pq.approval.requested</code>. <br>2. Notify approvers via configured channels and await signed approve/deny. <br>3. Persist <code>approvalGrant</code> artifact with <code>approverId</code>, <code>signedTimestamp</code>, and <code>approvalEvidenceRef</code> and emit <code>pq.approval.granted</code> or <code>pq.approval.denied</code>. <br>4. Only proceed with original operation after recorded approval artifact is present and verified. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong><code>EmitUserActionAudit(procedure, correlationId, params)</code> — canonical user-action audit emitter:</strong><br><strong>Purpose & contract:</strong> centralize user-action audit emission so UI actions have uniform audit rows; offload large parameter storage to evidence store if size exceeds threshold. <br><strong>Rules & process:</strong><br>1. Compute <code>paramsHash = SHA256(sorted(k=v))</code>. <br>2. If <code>size(params) &gt; evidenceThreshold</code> persist sanitized params via <code>AtomicWrite</code> and set <code>evidenceRef</code>. <br>3. Emit <code>UserAction</code> audit row: <code>timestamp, correlationId, module=PQ_Ribbon, procedure, operatorId, paramsHash, evidenceRef, uiControlId</code>. <br>4. Enforce PII redaction before persisting evidence; evidence must be encrypted and access-controlled. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Error taxonomy & operator-facing messaging (representative):</strong><br><strong>Representative error codes & guidance:</strong><br>1. <code>PQ_INJECT_EPERM</code> — permission denied; guidance: check macro enablement, workbook protection, and IT macro policy.<br>2. <code>PQ_INJECT_API_ERROR</code> — host API error; guidance: collect <code>pq.diagnostics</code>, try worker-backed injection, or run injection during maintenance window.<br>3. <code>PQ_VALIDATION_MISMATCH</code> — <code>mChecksum</code> mismatch; guidance: verify template source, re-fetch <code>mChecksum</code>, and validate signature chain.<br>4. <code>PQ_PREVIEW_PARSING_ERROR</code> — M parse error; guidance: present sanitized parse location and stack to template author for correction.<br>5. <code>PQ_EXPORT_ENOSPC</code> — destination out-of-space; guidance: stage-local fallback or free space and re-run export. <br>Each error code must map to a runbook with prioritized remediation steps and escalation levels for compliance-impacting failures. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Observability & telemetry (detailed):</strong><br><strong>Audit schema for PQ_Ribbon events:</strong> <code>timestamp, correlationId, module=PQ_Ribbon, procedure, operatorId, paramsHash, resultHash, evidenceRef, durationMs, metadata</code> where metadata includes <code>previewMode</code>, <code>templateVersion</code>, <code>mChecksum</code>, <code>hostVersion</code>, <code>pqRuntimeVersion</code>, <code>artifactChecksum</code>. <br><strong>Key metrics buffered locally:</strong> <code>pq.preview.latency_ms</code>, <code>pq.inject.count</code>, <code>pq.inject.success_rate</code>, <code>pq.export.latency_ms</code>, <code>pq.refresh.failure_rate</code>, <code>pq.diagnostics.size_bytes</code>. <br><strong>Privacy rule:</strong> top-level audit rows must not contain PII; full sanitized params stored in encrypted evidence with <code>evidenceRef</code>. <br><strong>Retention policy:</strong> evidence hot 30 days; warm archive 7 years for regulated artifacts; <code>housekeeping.audit</code> emitted for rotation operations. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Security & governance constraints (non-negotiable):</strong><br>1. XLAM and any helper automation must be code-signed by trusted publisher for production deployment; unsigned code is blocked. <br>2. Regulated templates require manifest signatures, owner verification, and CI golden checks before injection into production workbooks. <br>3. Macro enablement policies enforced; ribbon detects disabled macros and surfaces operator guidance. <br>4. Credentials must never appear in audit rows; connection fingerprints only. <br>5. Two-person approvals recorded as tamper-evident artifacts persisted via <code>AtomicWrite</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Testing matrix & CI governance (comprehensive):</strong><br><strong>Unit tests (representative):</strong><br>1. <code>ParameterizeTemplate</code> canonicalization property tests (nulls, timezone edge cases, empty arrays).<br>2. <code>ValidateTemplateIntegrity</code> checksum & signature validation tests including corrupted artifacts. <br>3. <code>PreviewTemplate</code> deterministic parity and replay tests using seeded RNG and persisted RNG state. <br>4. <code>InjectTemplateToWorkbook</code> idempotency, backup/rollback, and concurrent insertion tests. <br><strong>Integration tests:</strong><br>1. End-to-end preview -> inject -> refresh with worker-backed preview and persisted artifact checksum verification. <br>2. <code>ExportTemplate</code> atomicity across local and network filesystems simulating rename/fsync failures. <br>3. Offline hidden-sheet fallback and subsequent reconciliation upon reconnection. <br><strong>Property tests:</strong> deterministic seed parity across language implementations; <code>paramsHash</code> collision resistance via fuzzing; idempotency invariants. <br><strong>CI gating rules:</strong> goldens must pass; static analyzer forbids UI-thread I/O; audit emission harness must verify required fields. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Developer guidance: required & forbidden patterns (explicit):</strong><br><strong>Required patterns:</strong><br>1. Always call <code>EmitUserActionAudit</code> for user-visible control activations. <br>2. Use <code>AtomicWrite</code> for persisting artifacts and job descriptors. <br>3. Seed <code>DeterministicRNG</code> from <code>correlationId</code> for operator-visible sampling; persist <code>rng_state</code> when deterministic replay required. <br>4. Offload numerically sensitive transforms to worker <code>SafeRound</code> primitives. <br><strong>Forbidden patterns:</strong><br>1. Do not perform network fetches or large disk writes on UI event handlers. <br>2. Do not include raw PII in top-level audit rows. <br>3. Do not rely on host PQ decimal semantics for regulated outputs. <br>4. Do not write final artifacts directly from UI thread—use <code>AtomicWrite</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Operational runbooks & incident playbooks (executable):</strong><br><strong>Inject verification mismatch runbook:</strong><br>1. Find <code>pq.template.inject.failed</code> audit for the <code>correlationId</code>. <br>2. Download persisted artifact via <code>evidenceRef</code> and compute <code>artifactChecksum</code>; compare to workbook content. <br>3. If mismatch, restore workbook from <code>backupArtifact</code> persisted before injection. <br>4. If restore fails, quarantine workbook (mark read-only), collect <code>audit_tail.csv</code> and <code>forensic_manifest.json</code> and escalate to SRE/compliance. <br><strong>Preview parity complaint triage:</strong><br>1. Retrieve <code>pq.template.preview.*</code> audits and <code>seedFingerprint</code>. <br>2. Fetch serialized RNG state via <code>evidenceRef</code> and run <code>replay.run</code> to reproduce preview. <br>3. If mismatch remains, compare <code>pqRuntimeVersion</code> across host and worker parity vectors and escalate to cross-platform owners. <br><strong>Export ENOSPC triage:</strong><br>1. Inspect <code>pq.export.failure</code> audit and <code>destinationUri</code>. <br>2. Attempt <code>--stage-local</code> fallback and verify checksums; open infra ticket with <code>forensic_manifest</code> if unresolved. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Extremely detailed narratives & examples — multi-scenario trails (deep forensic detail):</strong><br><strong>Scenario 1 — Regulated high-precision allocation with full reproducibility chain:</strong><br>1. Operator opens PQ_Ribbon and selects <code>LedgerAllocV3</code>; UI emits <code>pq.library.opened</code>. <br>2. Operator clicks <code>Preview</code>; <code>EmitUserActionAudit</code> records the click with <code>correlationId=r-20260117-alloc</code>. <br>3. <code>ParameterizeTemplate</code> canonicalizes parameters (<code>periodStart=2024-12-01T00:00:00Z</code>, <code>totalAmount=1234567.89123</code>) and computes <code>paramsHash</code>. <br>4. <code>PreviewTemplate</code> detects <code>requiresHighPrecision=true</code> and schedules worker-backed preview; <code>previewJobDescriptor</code> persisted via <code>AtomicWrite</code> includes <code>correlationId</code>, <code>templateId</code>, <code>paramsHash</code>, and <code>seedFingerprint</code>. <code>pq.template.preview.start</code> emitted. <br>5. Worker reconstructs RNG via <code>DeterministicRNG(seed=HMAC(r-20260117-alloc|templateId))</code>, emits <code>util.rng.seeded</code>, canonicalizes decimals, computes floors/residuals and calls <code>SafeRoundResiduals</code> to guarantee sum-preservation. Worker persists <code>previewPayload</code> and <code>rng_state.blob</code> via <code>AtomicWrite</code>, emits <code>pq.template.preview.complete</code> with <code>previewChecksum</code> and <code>evidenceRef</code>. <br>6. Operator approves injection; ribbon requires two-person approval per policy. <code>RequestTwoPersonApproval</code> persists approval artifact; <code>pq.approval.granted</code> emitted. <br>7. <code>InjectTemplateToWorkbook</code> persists definitive <code>parameterizedM</code> via <code>AtomicWrite(artifactPath)</code>, uses worker injection agent to safely insert validated formula, and <code>pq.template.inject.completed</code> emitted with <code>artifactChecksum</code>. <br>8. Forensic replay: given <code>correlationId</code> investigator fetches audits, <code>jobDescriptor</code>, <code>rng_state.blob</code>, and <code>previewPayload</code>, re-runs worker pipeline, and reproduces allocation exactly. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Scenario 2 — Template author release lifecycle with CI golden gating and rollback:</strong><br>1. Author pushes <code>tpl-invoice-v1.1</code> to repo; CI triggered by <code>RefreshLibraryIndex</code> verifies manifests and runs cross-host golden parity checks for M outputs. <br>2. Failure in cross-host parity blocks release; <code>pq.library.ci.failure</code> indicated in release manifest. <br>3. On pass, release manifest is signed and <code>indexSnapshot</code> updated; <code>pq.library.refreshed</code> audit emitted. <br>4. If an issue arises in production, owners can <code>rollback</code>; rollback artifact persisted via <code>AtomicWrite</code> and recorded audit <code>pq.template.rollback.completed</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Scenario 3 — Offline workstation with embedded hidden-sheet fallback and authoritative later reconciliation:</strong><br>1. Add-in loads on air-gapped host; <code>ValidateHostCapabilities</code> notes <code>network=false</code>. <code>OpenLibraryPane</code> reads embedded <code>hidden-sheet</code> templates and emits <code>pq.library.offline</code>. <br>2. Operator runs client-light preview; ribbon warns <code>requiresHighPrecision</code> templates are degraded for offline preview. <br>3. After reconnection, ribbon performs authoritative worker preview, compares results to prior offline preview, emits reconciliation reports and <code>pq.reconciliation</code> audits, and records differences in <code>recon_report.json</code>. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Scenario 4 — Injection mismatch forensic reconstruction (step-by-step):</strong><br>1. Downstream consumer flags mismatch; operator reports run <code>r-20260112-455</code>, <code>Alert</code> audit recorded. <br>2. Triage: fetch <code>pq.template.inject.*</code> audits for <code>r-20260112-455</code>. <br>3. Forensic collection: retrieve <code>artifactChecksum</code> from <code>pq.template.inject.completed</code> and download artifact via <code>evidenceRef</code>. <br>4. Restore <code>rng_state</code> if preview used seeded sampling, replay worker preview using persisted <code>parameterizedM</code> and <code>rng_state</code> to recreate <code>previewPayload</code>. <br>5. Compare replay artifact checksum with workbook content; if mismatch, examine <code>pq.template.inject.verification_failed</code> for earlier verification failures. <br>6. Inspect host logs for macro activity or external modifications; if workbook mutated post-insert, restore <code>backupArtifact</code> and apply additional protections (lock query, restrict macro execution). <br>7. Close incident after remediation; update governance to require worker-backed injection for templates flagged by observed failure modes. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Conceptual Power Query (M) patterns — exhaustive mapping to PQ_Ribbon principles:</strong><br><strong>Context:</strong> M runs in host environments with heterogenous runtime semantics; PQ_Ribbon must orchestrate to guarantee determinism, integrity, and auditability rather than assuming host behavior. <br><strong>Patterns & recommended practices (detailed):</strong><br>1. <strong>Atomic persistence for M artifacts:</strong><br>   1.1 Problem: host injection lacks consistent atomic semantics across OS and network shares. <br>   1.2 Pattern: persist authoritative M artifact with <code>AtomicWrite</code> before any workbook modification; include <code>artifactChecksum</code> in injection audits. <br>   1.3 Rationale: allows later verification that workbook content equals persisted artifact and simplifies rollback. <br>2. <strong>Deterministic sampling for previews:</strong><br>   2.1 Problem: M PRNGs are host-dependent and often not seedable. <br>   2.2 Pattern A (client-light): compute deterministic sample indices in ribbon using <code>DeterministicRNG</code> and pass sample IDs as parameters to M. <br>   2.3 Pattern B (authoritative): run sampling in worker using <code>DeterministicRNG</code>, persist <code>rng_state</code> as evidence and <code>previewPayload</code> for UI consumption. <br>   2.4 Audit: always persist <code>seedFingerprint</code> and <code>rng_state</code> when sampling influences operator-visible outputs. <br>3. <strong>High-precision numeric transforms:</strong><br>   3.1 Problem: M decimal fidelity varies across hosts and runtimes; repeated rounding can introduce bias. <br>   3.2 Pattern: mark templates <code>requiresHighPrecision</code> and delegate aggregation/rounding (<code>SafeRound</code>, <code>SafeRoundResiduals</code>) to worker. M templates should accept canonical pre-rounded fields or call worker microservices for final rounding. <br>4. <strong>Injection idempotency & conflict handling:</strong><br>   4.1 Pattern: compute <code>artifactChecksum</code> and <code>paramsHash</code> prior to insertion; check workbook for matching artifacts and either skip duplicate injection or perform replace with backup. <br>   4.2 Persist <code>backupArtifact</code> before replacement for rollback. <br>5. <strong>Connector & provider fallbacks:</strong><br>   5.1 Pattern: when host lacks a connector, present worker-backed execution option; record fallback decision in <code>pq.ensuredeps</code> audit. <br><strong>Template author guidance:</strong> document <code>requiresHighPrecision</code> usage and prefer passing heavy connector workloads to worker-run templates for authoritative outputs. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX patterns — mapping PQ_Ribbon outputs to models & report UX (detailed):</strong><br><strong>Context:</strong> DAX is read-time only; authoritative transforms and evidence must be produced in ETL/worker prior to model consumption. <br><strong>Patterns & rules:</strong><br>1. <strong>Push rounding & allocation to ETL (worker-side):</strong><br>   1.1 Rationale: DAX cannot persist or reproducibly apply side-effecting allocation logic; ETL must compute <code>SafeRoundResiduals</code> and persist integer-cent fields. <br>   1.2 Persist <code>SafeRound</code> audit references in <code>RunMetadata</code> for reconciliation. <br>2. <strong>RunMetadata table for model provenance:</strong><br>   2.1 ETL writes <code>RunMetadata</code> atomically with fields <code>correlationId, templateId, artifactChecksum, configHash, runTs, roundingMethod, seedFingerprint</code>. <br>   2.2 DAX measures reference <code>RunMetadata</code> for provenance surfaces like <code>LastVerifiedRun</code> and <code>ArtifactChecksum</code>. <br>3. <strong>Checksum-based reconciliation surfaced in DAX:</strong><br>   3.1 ETL publishes expected dataset checksum and <code>recon_report.json</code>. <br>   3.2 DAX exposes a <code>ReconciledFlag</code> by comparing expected checksum with imported dataset fingerprint (if the model stores it) or by surfacing <code>RunMetadata</code>. <br>4. <strong>Deterministic sampling via ETL hashing:</strong><br>   4.1 ETL computes <code>HashKey = HASH(PrimaryKey | correlationSalt)</code> and persists both <code>HashKey</code> and <code>correlationSalt</code> in <code>RunMetadata</code>. <br>   4.2 DAX filters deterministically with <code>HashKey MOD N &lt; k</code> for reproducible sampling in reports. <br>5. <strong>DAX measures & UI signals:</strong> provide measures <code>IsVerified</code>, <code>ArtifactChecksumShort</code>, <code>RunCorrelationLink</code> that report provenance and link back to audits/evidence store. <br><strong>Governance rule:</strong> DAX must not perform final allocations or rounding for regulated outputs—ETL must provide canonical values. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Appendices — forensic artifacts, evidence policies & retention (PQ-specific, exhaustive):</strong><br><strong>Minimum forensic assets to collect for an incident:</strong><br>1. <code>pq_audit_tail.csv</code> containing relevant audit rows for the <code>correlationId</code>. <br>2. Persisted artifacts: <code>parameterizedM</code>, <code>manifest.json</code>, <code>injectArtifact</code> with <code>artifactChecksum</code>. <br>3. <code>jobDescriptor.json</code> and <code>previewJobDescriptor.json</code> persisted via <code>AtomicWrite</code>. <br>4. Serialized RNG state blobs <code>rng_state.blob</code> used for deterministic runs. <br>5. <code>previewPayload</code> and <code>diagnosticsBundle.zip</code> persisted via <code>AtomicWrite</code>. <br>6. <code>backupArtifact</code> persisted before replacement. <br>7. Host PQ runtime logs, worker logs, and release manifest with signatures. <br><strong>Evidence storage & retention patterns:</strong><br>1. Hot evidence store: <code>\\evidence\hot\pq\&lt;correlationId&gt;\</code> retained 30 days with restricted access. <br>2. Warm archive: secure archive with regulatory retention (7 years typical) and chain-of-custody metadata. <br>3. Forensic_manifest.json enumerates artifacts, URIs, checksums, evidenceRef, signer fingerprints and timestamps; store manifest signed by release key. <br><strong>Rotation & verification cadence:</strong> monthly automated retention verification job; emit <code>housekeeping.audit</code> summarizing rotated items and proof-of-delete for removed artifacts. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Acceptance checklist before PQ_Ribbon production release (exhaustive):</strong><br>1. OWNERS.md lists owners and approvers and routing for on-call. <br>2. Public API documented and stable; breaking changes require manifest version bump. <br>3. All persisted artifacts used by other modules employ <code>AtomicWrite</code>. <br>4. Deterministic RNG goldens and parity tests across supported runtimes implemented and passing. <br>5. <code>mChecksum</code> golden vectors validated across CI hosts. <br>6. Audit hooks validated via test harness; required fields present in audit rows. <br>7. Static analyzer verified no UI-thread file writes and flagged forbidden patterns. <br><strong>Blocking conditions:</strong> missing audit emissions in persistence flow, failing golden vectors, or forbidden-API detection. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Extremely detailed test plan highlights & sample tests (conceptual & runnable guidelines):</strong><br><strong>Unit tests (representative):</strong><br>1. <code>ParameterizeTemplate</code> correctness and canonicalization for edge cases (nulls, timezone-naive dates, empty lists).<br>2. <code>ValidateTemplateIntegrity</code> checksum mismatch & signature validation tests with sample corrupted blobs. <br>3. <code>PreviewTemplate</code> deterministic replay using stored <code>rng_state</code> verifying <code>previewChecksum</code> parity. <br>4. <code>InjectTemplateToWorkbook</code> idempotency; repeated injects produce <code>pq.template.inject.skipped</code>; backup and rollback succeed on simulated host failures. <br><strong>Integration tests:</strong><br>1. End-to-end preview -> persist -> inject -> verify roundtrip with worker-backed preview. <br>2. <code>AtomicWrite</code> rename/fsync failure injection via FS mocks; ensure no partial artifact visible to readers. <br>3. Offline hidden-sheet fallback scenario and authoritative reconciliation after reconnection. <br><strong>Property tests:</strong> deterministic RNG parity across languages for first N outputs; <code>paramsHash</code> collision detection via fuzzing. <br><strong>Performance & CI gates:</strong> interactive preview latency smoke tests; no regressions permitted; static analyzer gating enforced. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Operator quick commands & cheat-sheet (practical):</strong><br>1. <code>pq diagnostics collect --correlation r-YYYYMMDD-abc</code> — collect audit_tail.csv, serialized RNG state, preview artifacts, and forensic_manifest.json. <br>2. <code>pq template export --template tpl-id --dest \\repo\templates</code> — atomically export template and manifest. <br>3. <code>pq replay-preview --correlation r-... --evidenceRef &lt;ref&gt;</code> — replay deterministic preview for forensic reproduction. <br>4. <code>pq inject --template tpl-id --params params.json --mode replace_existing</code> — idempotent inject wrapper that persists job descriptor and performs injection via worker agent with audits. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Common failure modes & mitigations (PQ-specific, expanded):</strong><br><strong>Failure mode: injected query differs from persisted artifact</strong><br>1. Possible causes: host auto-formatting, macros modifying workbook, interrupted host API call, or malicious post-insert modification. <br>2. Mitigation: <code>Add_Query_From_M</code> performs read-back verification; on mismatch restore from <code>backupArtifact</code> and emit <code>pq.template.inject.verification_failed</code>; lock workbook and escalate if restore fails. <br><strong>Failure mode: non-deterministic preview sampling</strong><br>1. Cause: seed not propagated or host PRNG used in M template. <br>2. Mitigation: switch to worker-backed deterministic sampling using <code>DeterministicRNG</code> and persist <code>rng_state</code> for replay; add unit tests to detect host-RNG usage in preview path. <br><strong>Failure mode: export ENOSPC</strong><br>1. Cause: destination full or insufficient quota. <br>2. Mitigation: stage-local fallback, compute artifact checksums and retry, escalate to infra with <code>forensic_manifest</code> if persistent. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Extremely detailed incident reconstruction example (PQ injection mismatch — full forensic trail):</strong><br><strong>Incident synopsis:</strong> "Injected query <code>InvoiceAgg</code> produced different sums for run <code>r-20260112-455</code>." <br><strong>Reconstruction steps:</strong><br>1. Retrieve <code>UserAction</code> and <code>pq.template.inject.*</code> audit rows for <code>correlationId=r-20260112-455</code>. <br>2. Download <code>artifactChecksum</code> from <code>pq.template.inject.completed</code> audit and fetch persisted artifact via <code>evidenceRef</code>. <br>3. Restore <code>rng_state.blob</code> used for deterministic preview (if present) and re-run worker preview pipeline using <code>parameterizedM</code> and <code>rng_state</code> to reproduce <code>previewPayload</code>. <br>4. Compute replay artifact checksum and compare to persisted artifact and workbook query content. <br>5. If workbook content differs, inspect host logs and <code>pq.diagnostics</code> for concurrent writes, macros, or external processes. <br>6. Determine root cause: host mutation, partial injection, or incorrect artifact persisted. <br>7. Remediation: if host mutated after injection, restore from <code>backupArtifact</code> and enforce workbook protections; if artifact corruption, re-publish corrected artifact and notify downstream consumers. <br>8. Produce <code>forensic_manifest.json</code> and include <code>audit_tail.csv</code>, <code>rng_state.blob</code>, <code>previewPayload</code>, <code>backupArtifact</code>, and host logs for compliance filing if regulated. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Appendix — PQ & DAX author quick checklists (actionable):</strong><br><strong>PQ Template author checklist:</strong><br>1. Include <code>mChecksum</code> and <code>templateVersion</code> in manifest. <br>2. Mark <code>requiresHighPrecision</code> when numeric fidelity is required. <br>3. Parameterize seeds for preview and support deterministic preview options. <br>4. Provide <code>owner</code> and contact for approvals and CI gating. <br><strong>DAX/report builder checklist:</strong><br>1. Consume <code>RunMetadata</code> for provenance displays. <br>2. Avoid allocation/rounding logic in DAX; rely on ETL <code>SafeRound</code> outputs. <br>3. Use hashed <code>PrimaryKey</code> + <code>correlationSalt</code> for deterministic sample filters in reports. </td></tr><tr><td data-label="PQ_Ribbon — Per-function Expert Technical Breakdown"> <strong>Final governance constraints (non-negotiable):</strong><br>1. Any artifact consumed by other processes must be persisted via <code>AtomicWrite</code>, include <code>paramsHash</code> and <code>artifactChecksum</code>, and be linked to a <code>correlationId</code> in audits. <br>2. Deterministic RNG seeds must be derived from <code>correlationId</code> for operator-visible sampling and serialized RNG state persisted for replay when required. <br>3. Top-level audit rows MUST NOT contain raw PII; sanitized parameters stored encrypted in evidence store and referenced by <code>evidenceRef</code>. <br>4. Two-person approval required for regulated auto-apply templates, migration manifests, or template edits affecting regulated outputs. <br>5. Numerical transforms affecting regulated outputs MUST use worker-side <code>SafeRound</code> primitives; client-side M rounding is insufficient for authoritative results. <br><strong>Checked:</strong> multiple-pass verification for internal consistency, audit coverage, determinism chain (UI → job → worker → artifact) and compliance with governance rules; cross-checked numbered lists for <code>&lt;br&gt;</code> line breaks where required. </td></tr></tbody></table></div><div class="row-count">Rows: 40</div></div><div class="table-caption" id="Table2" data-table="Docu_0179_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by PQ_Config — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">PQ_Config — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Module-level metadata (contract & overview):</strong><br><strong>Owner:</strong> TEAM_PQ_CONFIG recorded in OWNERS.md, release manifests, template governance, and the operational runbook. Primary and secondary owners, on-call rotation, and escalation contacts are recorded and tested quarterly. <br><strong>Public API surface (complete):</strong> LoadConfig, LoadLocalConfig, ResolveRemoteConfig, ValidateConfigSchema, ComputeConfigHash, ApplyIdempotentMigrations, MergeOverrides, ExposeRuntimeConfig, SnapshotConfig, ConfigDiff, WatchConfigFile, SubscribeConfigChanges, ExportResolvedConfig, ConfigStoreAdapter (LocalFileAdapter, HiddenSheetAdapter, RemoteRepoAdapter, InMemoryAdapter), SecretsPlaceholderResolver, ConfigValidateAndRepair, ConfigSanitizer, ConfigAuditEmit, ConfigAccessPolicy, ConfigPermissionsCheck, ConfigRollback, ConfigHistoryList, ConfigSnapshotInspect, ConfigLint, ConfigPreviewRenderer, ConfigSchemaRegistry, ConfigChangeApprovalFlow. Each function exposes a stable contract and emits audits for critical transitions. <br><strong>Audits emitted (complete):</strong> pq.config.load.start, pq.config.load.complete, pq.config.load.failure, pq.config.validate.start, pq.config.validate.complete, pq.config.validate.failure, pq.config.sanitized, pq.config.migrations.start, pq.config.migrations.complete, pq.config.migrations.failure, pq.config.resolve_remote.start, pq.config.resolve_remote.complete, pq.config.resolve_remote.degraded, pq.config.hash.computed, pq.config.snapshot.created, pq.config.export.attempt, pq.config.export.completed, pq.config.export.failure, pq.config.watch.detected, pq.config.change.detected, pq.config.secrets.resolution.start, pq.config.secrets.resolution.complete, pq.config.diff.created, pq.config.rollback.attempt, pq.config.rollback.complete. Audit rows always include correlationId, module=PQ_Config, procedure, paramsHash, configHash (as applicable), snapshotId/evidenceRef for large payloads, operatorId when a human is involved, and machine-readable metadata. <br><strong>Purpose and intended use (expanded):</strong> act as the canonical configuration manager for PQTools and related add-ins. Responsibilities include: deterministic loading of config artifacts, validation via JSON Schema v7 (or the chosen dialect), canonicalization for stable hashing, deterministic merge/overlay of remote and local fragments, application of idempotent migrations, storage via adapters supporting hidden-sheet fallback, snapshotting into an evidence store for reproducible runs and audits, providing a secure secret placeholder model and a separate audited secret resolution service, and exposing a minimal immutable runtime view to consumers. PQ_Config enables reproducible template preview, injection, worker orchestration, CI gating, and regulated evidence packaging. <br><strong>Non-goals & constraints (explicit):</strong> do not decrypt or hold secrets in the module; do not perform blocking network I/O during add-in UI OnLoad; do not perform arbitrary file system operations outside configured adapters; do not act as a transactional coordinator for multi-artifact distributed transactions—provide higher-level orchestrators for those workflows. <br><strong>Security & governance constraints (expanded):</strong> for regulated templates and exports, require signed manifests, OWNER approvals, and two-person approval gating for destructive migrations and release-manifest changes. Evidence store entries containing PII or sensitive parameters must be encrypted with the organization’s evidence key and access controlled by RBAC. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Operational guarantees (module-level invariants & SLOs):</strong><br>1. Deterministic <code>config.hash</code>: identical resolved inputs, migration markers, and canonicalization options produce identical <code>config.hash</code> across supported runtimes. <br>2. UI fast-path guarantees: <code>LoadConfig(mode=auto|local_only)</code> completes without network calls and within UI latency budget (target median <50ms). <br>3. Migrations are idempotent: reapplying the same migration set to the same initial state is a no-op and returns stable markers. <br>4. Audited persistence: any persistent mutation or export emits at least one audit row with correlationId and evidenceRef. <br>5. Immutable runtime exposures: consumers receive immutable snapshots and must use explicit APIs to request changes. <br>6. Atomic persistence: all adapter writes must use AtomicWrite semantics and produce compound artifacts or sidecar metadata atomically. <br><strong>Performance SLOs:</strong> median local config load <30ms; remote resolution background fetch <1s for small repos; migration apply <200ms for typical small manifests; snapshot write latency depends on evidence store but should support streaming writes for large payloads. <br><strong>CI & acceptance gates:</strong> cross-language <code>config.hash</code> parity tests; schema goldens; migration idempotency tests; forbidden-API static checks preventing UI-thread IO; audit emission validation and evidenceRef integrity checks. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>LoadConfig(pathOrContext, mode=&quot;auto&quot;, correlationId=null)</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> central entrypoint to return a validated immutable runtime config snapshot ready for consumer use. <code>mode</code> options: <code>auto</code> (prefer local cached snapshot, schedule remote resolve asynchronously), <code>local_only</code> (no network), <code>remote_fallback</code> (attempt remote then fallback to cache), <code>force_remote</code> (synchronous remote resolution and validation). Must avoid network I/O in <code>local_only</code> or UI <code>auto</code> fast-path. <br><strong>Parameters & return:</strong> <code>pathOrContext</code> accepts hidden-sheet descriptor (<code>hidden:PQ_Config</code>), local file path, or remote repo descriptor. Returns <code>{config:immutable, canonicalForm:string, configHash:string, snapshotId:string?, sourceDescriptor, loadedFrom:(&quot;hidden-sheet&quot;|&quot;file&quot;|&quot;cache&quot;|&quot;remote&quot;), appliedMigrations:[], validated:true|false}</code>. On failure raises structured <code>ConfigError</code> with <code>errorCode</code> and <code>diagnosticsRef</code>. Emits <code>pq.config.load.start</code> and <code>pq.config.load.complete</code> or <code>pq.config.load.failure</code>. <br><strong>Primary invariants (must/shall):</strong><br>1. Deterministic canonicalization and hashing for identical effective input. <br>2. No network I/O in UI critical path when <code>mode</code> is <code>auto</code> or <code>local_only</code>. <br>3. If migrations exist and <code>mode</code> allows and approvals present, apply them idempotently and persist the output atomically. <br><strong>Algorithm & detailed steps:</strong><br>1. Determine adapter via <code>pathOrContext</code>: HiddenSheetAdapter preferred when present; otherwise LocalFileAdapter; if <code>mode</code> allows remote and <code>pathOrContext</code> is a repo descriptor, use RemoteRepoAdapter. <br>2. Adapter.read() -> raw bytes -> compute <code>rawHash</code>. <br>3. Parse JSON to <code>configObject</code> (raise <code>PQ_CONFIG_PARSE_FAIL</code> on malformed JSON). <br>4. Call <code>ValidateConfigSchema(configObject, schema)</code>. If invalid and <code>options.allowSanitize</code>, produce a sanitized config and emit <code>pq.config.sanitized</code>; otherwise fail with diagnosticsRef. <br>5. If <code>mode</code> allows remote overlay, schedule <code>ResolveRemoteConfig</code> asynchronously unless <code>force_remote</code> requested. <br>6. Canonicalize parsed object into canonical JSON string using canonical serializer rules and call <code>ComputeConfigHash</code> to produce <code>configHash</code>. <br>7. Return snapshot with <code>configHash</code> and <code>loadedFrom</code>. If persistence required (migrations applied or snapshot requested) call <code>SnapshotConfig</code>. <br><strong>Edge cases & behaviors:</strong><br>1. If adapter.read() returns multiple versioned entries, pick the highest version according to adapter semantics but include <code>listVersions()</code> output in snapshot metadata. <br>2. For extremely large configs, perform streaming parse and canonicalization and compute streaming SHA256 to avoid OOM. <br>3. For cross-host differences in JSON parser behavior, canonicalization step normalizes types (explicitly coerce singletons vs lists per schema) before hashing. <br><strong>Observability & audit fields:</strong> pq.config.load.start(correlationId, sourceDescriptorHash) pq.config.load.complete(correlationId, configHash, snapshotId, loadedFrom, durationMs) pq.config.load.failure(correlationId, errorCode, diagnosticsRef) <br><strong>Examples & narratives:</strong><br>1. Add-in startup: <code>LoadConfig(hidden:PQ_Config, mode=auto)</code> returns immediate snapshot from embedded sheet, enabling ribbon to become responsive without waiting for network. <br>2. Worker run: <code>LoadConfig(repoDescriptor, mode=force_remote)</code> fetches and resolves central defaults, applies migrations as allowed, computes <code>configHash</code>, and persists jobDescriptor referencing <code>configHash</code> for reproducible worker runs. <br><strong>Tests & CI vectors:</strong> hidden-sheet loads, local file path loads, forced remote resolution with signature checks, malformed JSON handling, streaming canonicalization parity checks. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>ValidateConfigSchema(configObject, schema, options={strict:true, allowDeprecated:false, allowSanitize:false})</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> deterministic validation and diagnostics generation for <code>configObject</code> against chosen JSON Schema. Returns <code>{valid:true}</code> or <code>{valid:false, errors:[{path, code, message, suggestion}], sanitized?:object}</code> where <code>suggestion</code> may include recommended migration steps. <br><strong>Parameters & semantic behavior:</strong> <code>options.strict</code> toggles acceptance of unknown keys; <code>allowDeprecated</code> allows deprecated but documented keys; <code>allowSanitize</code> allows applying schema <code>default</code> values into a sanitized copy returned to the caller. <br><strong>Primary invariants (must/shall):</strong><br>1. Deterministic error ordering: errors are sorted by JSON pointer path and canonical property order so that repeated validations produce identical diagnostics. <br>2. No mutation of input <code>configObject</code> unless <code>allowSanitize=true</code>, in which case the sanitized copy is returned separately. <br><strong>Algorithm & implementation notes:</strong><br>1. Use a canonical JSON Schema validator with deterministic traversal and stable error codes. <br>2. For <code>oneOf</code>/<code>anyOf</code>, compute candidate scores and include the closest candidate in diagnostics to help operator decisions. <br>3. For missing required fields with schema <code>default</code>, when <code>allowSanitize=true</code> apply defaults into returned sanitized object and emit <code>pq.config.sanitized</code> audit. <br>4. For deprecation warnings produce <code>PQ_CFG_DEPRECATED_KEY</code> codes with suggested replacement keys based on migration registry where available. <br><strong>Edge cases & limits:</strong> handle huge arrays by streaming validation and produce <code>PQ_CFG_TOO_LARGE</code> if memory limits exceeded with suggested chunking approach. <br><strong>Observability & audit fields:</strong> pq.config.validate.start(correlationId, schemaHash) pq.config.validate.complete(correlationId, configHash, errorsCount) pq.config.validate.failure(correlationId, errorCodes, diagnosticsRef) <br><strong>Tests:</strong> deterministic diagnostics ordering tests, default-application tests, deprecated key detection, very large payload streaming validation. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>ComputeConfigHash(configCanonicalJson, algorithm=&quot;sha256&quot;, fingerprintOptions={ignoreVolatile:true, volatileKeys:[&quot;lastModified&quot;,&quot;timestamp&quot;], hmacSalt:null})</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> compute a stable <code>config.hash</code> used as the canonical fingerprint linking jobs, artifacts, and audits. <code>configCanonicalJson</code> must be the canonicalized JSON produced by PQ_Config canonical serializer. Returns <code>{configHash, canonicalForm}</code>. Emit <code>pq.config.hash.computed</code>. <br><strong>Parameters & invariants:</strong><br>1. Canonicalization rules: recursively sort object keys in Unicode code point order, normalize strings to Unicode NFC, serialize numbers in deterministic decimal/fixed-point for schema-declared numeric fields, and avoid locale-specific formatting. <br>2. <code>ignoreVolatile=true</code> removes configured volatile keys deterministically before hashing and records removed keys in audit metadata. <br>3. If <code>hmacSalt</code> provided (test-mode), compute <code>configHash = HMAC_SHA256(hmacSalt, canonicalJson)</code>; otherwise <code>configHash = SHA256(canonicalJson)</code>. <br><strong>Algorithmic details & platform parity:</strong><br>1. Serializer implements stable numeric formatting: for <code>financial</code>-annotated schema fields apply scaled integer encoding with explicit scale metadata to avoid binary float differences across languages. <br>2. For extremely large configs implement streaming canonicalization that produces canonical chunks with a chunk manifest used to compute final SHA256 over the canonical stream. <br><strong>Edge cases & considerations:</strong> ensure canonical serializer mapping of boolean <code>true</code>/<code>false</code> and null uses exact lexical tokens (<code>true</code>, <code>false</code>, <code>null</code>) to avoid platform differences. <br><strong>Observability & audit fields:</strong> pq.config.hash.computed(correlationId, configHash, canonicalFormHash, removedVolatileKeys) <br><strong>Tests & CI vectors:</strong> cross-language golden vectors for canonicalization and hash outputs; streaming canonicalization parity tests; ignoreVolatile behavior tests. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>ApplyIdempotentMigrations(configObject, migrationRegistry, mode=&quot;dry_run&quot;, operatorApproval=null, correlationId=null)</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> apply an ordered sequence of migrations to bring config to current canonical shape. Must be idempotent and produce reversible metadata when reversible migrations are available. Support safe dry_run preview and persisted apply flows requiring approval for destructive migrations. Return <code>{resultConfig, appliedMigrations:[{id,notes}], diff, persisted:false|true}</code>. Emit <code>pq.config.migrations.*</code> audits. <br><strong>Parameters & workflow rules:</strong> <code>migrationRegistry</code> ordered by <code>fromVersion</code>-><code>toVersion</code> entries; each migration entry is <code>{id, fromVersion, toVersion, transformer:function, reversible:boolean, riskScore:int}</code>. <code>mode</code> can be <code>dry_run</code>, <code>apply</code>, or <code>apply_with_approval</code>. For regulated templates destructive migrations require <code>operatorApproval</code> evidenceRef and two-person approval gating. <br><strong>Primary invariants (must/shall):</strong><br>1. Idempotence: each migration must include precondition checks and persisted <code>migrations_applied</code> markers to avoid repeated application. <br>2. Reversibility: where possible record reverse mapping or produce rollback manifest. <br>3. Atomic persistence of updated config + <code>migrations_applied</code> marker using AtomicWrite to avoid races. <br><strong>Implementation & algorithmic notes:</strong><br>1. Compute plan: determine list of migrations to apply by comparing <code>configObject.version</code> to registry. <br>2. For each migration: run transformer in sandboxed deterministic environment with deterministic RNG disabled; compute per-step diff and unit-test vectors using canonicalized examples. <br>3. On encountering destructive migration requiring approval: halt and surface <code>PQ_CONFIG_MIGRATION_REQUIRES_APPROVAL</code> with impact assessment. <br>4. If applying, persist final config and <code>migrations_applied</code> atomically via ConfigStoreAdapter and emit final audit with evidenceRef. <br><strong>Edge cases & errors:</strong> transformer exceptions produce <code>pq.config.migrations.failure</code> with diagnosticsRef and rollback to prior persisted snapshot if persistence occurred partially. <br><strong>Observability & audit fields:</strong> pq.config.migrations.start(correlationId, fromVersion, toVersion) pq.config.migrations.complete(correlationId, appliedMigrations, persisted, evidenceRef) pq.config.migrations.failure(correlationId, errorCode, diagnosticsRef) <br><strong>Examples & deep narrative:</strong><br>1. <code>v2.rename_templates</code> migrates <code>templates</code> to <code>pqTemplates</code>. Dry_run produces <code>ConfigDiff</code> and per-template mapping table used by operators; applying persists <code>migrations_applied</code> and snapshot evidenceRef. <br>2. Splitting <code>connectors</code> into namespaced groups is destructive for downstream refresh policies; migration halts with <code>PQ_CONFIG_MIGRATION_REQUIRES_APPROVAL</code> and an impact report listing affected templates and connectors. <br><strong>Tests:</strong> idempotent reapply, reverse-roundtrip where reversible=true, migration failure and cleanup testing, and cross-language transformer parity if transformers exist in multiple runtimes. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>ResolveRemoteConfig(baseConfig, repoDescriptor, authContext, options={preferLocalCache:true, timeoutMs:2000, verifySignatures:true})</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> fetch and merge remote repository fragments deterministically to produce a resolved config overlay. All fetched artifacts must be integrity-checked (mChecksum) and signature-verified when expected. Return <code>{resolvedConfig, remoteArtifacts:[{uri,mChecksum,signatureOk}], configHash, evidenceRef}</code>. Emit <code>pq.config.resolve_remote.*</code> audits. <br><strong>Parameters & semantics:</strong> <code>repoDescriptor</code> can be git URL, HTTP manifest endpoint, or signed manifest blob. <code>authContext</code> contains auth tokens or references to secret resolvers (no secrets captured in audits). <code>options.preferLocalCache=true</code> allows degraded operation using cached remote snapshot and emits <code>pq.config.resolve_remote.degraded</code>. <br><strong>Primary invariants (must/shall):</strong><br>1. Deterministic overlay order: repo defaults → template-level fragments → operator overrides → environment overlays. <br>2. Record every remote artifact <code>mChecksum</code> and store fetched artifacts in evidence store with <code>evidenceRef</code>. <br>3. If <code>verifySignatures=true</code> and signature fails, abort resolution and emit failure audit. <br><strong>Implementation & algorithmic details:</strong><br>1. Fetch manifest and artifacts using <code>Retry</code> wrapper with idempotent assertions; for each artifact compute <code>mChecksum</code> (e.g., SHA256), verify signatures when present, save artifact blobs to evidence store, and add references to <code>remoteArtifacts</code>. <br>2. Validate each artifact against schema fragments; on validation failures, abort resolution and surface diagnostic suggestions. <br>3. Merge fragments using <code>MergeOverrides</code> deterministically and compute <code>configHash</code> of resolved config. <br><strong>Edge cases & fallback:</strong> unsigned artifact or signature mismatch -> quarantine and fail unless operator overrides with explicit <code>force</code> and owner approval; network outage -> use cached snapshot and mark degraded path. <br><strong>Observability & audit fields:</strong> pq.config.resolve_remote.start(correlationId, repoDescriptorHash) pq.config.resolve_remote.complete(correlationId, configHash, artifactsCount, evidenceRef) pq.config.resolve_remote.degraded(correlationId, reason, usedCache=true) pq.config.resolve_remote.failure(correlationId, errorCode, diagnosticsRef) <br><strong>Examples & narrative:</strong><br>1. Central repo provides connector timeout defaults and sample parameter schemas; <code>ResolveRemoteConfig</code> fetches signed fragments, verifies signatures, merges them with operator overrides, and produces <code>configHash</code> used in jobDescriptor persistence so worker runs are reproducible and auditable. <br><strong>Tests:</strong> signature mismatch handling, cached-snapshot fallback tests, deterministic merging order under concurrent fetches. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>MergeOverrides(baseConfig, overrides[], precedenceRules)</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> deterministic merge engine applying ordered override fragments with clearly-defined per-key merge semantics. Returns <code>{mergedConfig, changeLog}</code> with path-level provenance and fingerprints. <br><strong>Parameters & merge semantics:</strong> <code>overrides</code> is an ordered list of fragments with sourceDescriptor; <code>precedenceRules</code> map JSON pointer paths to merge strategies: <code>replace|merge_map|merge_list|append|unique_by_key|prepend</code>. <code>changeLog</code> records per-path changes with oldFingerprint, newFingerprint, sourceDescriptor, and overrideIndex. <br><strong>Primary invariants (must/shall):</strong><br>1. Deterministic application order: later overrides win unless rules specify additive behaviors. <br>2. Stable list deduplication for <code>unique_by_key</code> using deterministic key ordering and tie-breakers based on overrideIndex and sourceDescriptor identity. <br>3. Preserve provenance for every element changed to support forensic tracebacks. <br><strong>Algorithm & implementation notes:</strong><br>1. Traverse baseConfig in canonical order; for each key apply per-path <code>precedenceRules</code>. <br>2. For <code>merge_list</code> where ordering matters (e.g., transform steps), preserve original order unless an override explicitly reorders; record moved elements in <code>changeLog</code>. <br>3. For map merges respect <code>null_overwrites</code> semantics and support merge strategies that treat null as explicit blanking when configured. <br><strong>Conflict detection & resolution:</strong> conflicting exclusive flags produce <code>PQ_CONFIG_CONFLICT</code> with suggested remediation and an <code>impactScore</code> based on configured heuristics (e.g., connector default changes are high-impact). <br><strong>Observability & audit fields:</strong> pq.config.merge.completed(correlationId, mergedHash, changesCount, changeLogRef) <br><strong>Tests:</strong> deterministic merge outputs for permutations of override arrival orders, moved-item detection tests for step-lists, conflict detection tests. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>ExposeRuntimeConfig(snapshot, consumerContext)</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> present a read-only, immutable runtime view tailored to the consumer's capabilities. Exposed API: <code>getString(path, default)</code>, <code>getNumber(path, default)</code>, <code>getBool(path, default)</code>, <code>getList(path)</code>, <code>getMap(path)</code>, <code>getTemplateConfig(templateId)</code>, plus metadata fields <code>configHash</code>, <code>snapshotId</code>, and <code>appliedMigrations</code>. Secrets remain placeholders like <code>{{vault:path#key}}</code> and cannot be resolved without explicit secrets resolution calls in worker contexts. Attempting to mutate the returned object raises <code>ConfigImmutableError</code>. <br><strong>ConsumerContext semantics:</strong> controls redaction—UI consumers get redacted placeholders with schema & placeholder fingerprints; authorized worker contexts may request secret resolution via SecretsPlaceholderResolver. <br><strong>Primary invariants (must/shall):</strong><br>1. No raw secrets in exposed object. <br>2. Immutable runtime snapshot to ensure reproducible behavior. <br>3. Typed accessors perform safe coercion and return structured errors for missing keys unless defaults provided. <br><strong>Implementation notes:</strong> implement a thin wrapper that lazily computes derived values and caches typed conversions; include small telemetry when consumers access sensitive fields (emit <code>pq.config.access</code> audit for privileged accesses). <br><strong>Observability & audit fields:</strong> pq.config.expose(correlationId, consumerId, configHash, consumerContext) <br><strong>Examples:</strong> PQ_Ribbon uses <code>ExposeRuntimeConfig</code> to render parameter editors; workers with privileges use the same wrapper and then call <code>SecretsPlaceholderResolver</code> to resolve secrets prior to launching provider connections. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>SnapshotConfig(configObject, metadata={sourceDescriptor, author, reason, correlationId})</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> produce an immutable evidence snapshot stored in the evidence store with chunking for large payloads. Snapshot includes canonical form, <code>configHash</code>, applied migrations list, remote artifact references with <code>mChecksums</code>, and a redacted quick-view for operator display. Return <code>{snapshotId, snapshotPath, evidenceRef, artifactChecksum, sizeBytes}</code> and emit <code>pq.config.snapshot.created</code>. <br><strong>Primary invariants (must/shall):</strong><br>1. Snapshots are write-once and persisted atomically via AtomicWrite. <br>2. Public audits reference snapshot via <code>evidenceRef</code>; full snapshot stored encrypted and access-controlled. <br><strong>Implementation & algorithmic details:</strong><br>1. Serialize canonical JSON, optionally compress, compute artifact checksum (SHA256), split into chunks if > threshold and write chunked artifacts alongside manifest referencing chunk checksums. <br>2. Encrypt chunks for evidence store, store signed manifest linking chunk checksums, compute manifest checksum and record in audit evidenceRef. <br>3. For large snapshots support incremental upload and resume semantics and ensure final commit step is atomic from consumer perspective. <br><strong>Observability & audit fields:</strong> pq.config.snapshot.created(correlationId, snapshotId, artifactChecksum, sizeBytes, evidenceRef) <br><strong>Tests:</strong> snapshot chunk manifest integrity, evidenceRef retrieval & access control tests, snapshot restore round-trip. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>WatchConfigFile(pathOrStore, callback, debounceMs=300, correlationId=null)</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> watch a local config artifact for edits and call subscribers with a debounced settled event. Must be safe for add-in UI: non-blocking and low CPU, using OS native watchers or efficient poll with content hashing fallback. Return a handle with <code>stop()</code>, <code>suppressOnce()</code>, and <code>forceReload()</code> operations. <br><strong>Behavior & steps:</strong><br>1. Register native watcher or fallback poll; on change compute new content hash; read new snapshot via <code>LoadConfig(local_only)</code> and <code>ValidateConfigSchema</code>. <br>2. On stable content after <code>debounceMs</code> call callback with <code>{oldHash, newHash, snapshotId, diffRef}</code> and emit <code>pq.config.watch.detected</code> audit. <br>3. Expose suppression token for editors to suppress notifications during batch edits. <br><strong>Failure & mitigation:</strong> repeated file locks or concurrent save failures -> retry N times with exponential backoff and then emit <code>pq.config.watch.failure</code> and pause watcher; operator intervention required to resume. <br><strong>Observability & audit fields:</strong> pq.config.watch.detected(correlationId, path, oldHash, newHash, callbackId) pq.config.watch.failure(correlationId, path, errorCode) <br><strong>Operator guidance:</strong> prefer built-in editor that performs schema validation and writes via adapter API ensuring atomic writes and minimal watch churn. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>ExportResolvedConfig(snapshot, destinationDescriptor, options={atomic:true, includeEvidence:false, sign:false, commitMessage:null})</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> build and persist an export bundle that contains canonical config JSON, metadata, applied migrations, and optional evidence. Must use AtomicWrite semantics locally and secure commit semantics for repositories; record artifact checksum in audit. Return <code>{artifactChecksum, destinationUri, evidenceRef}</code>. <br><strong>Behavior & steps:</strong><br>1. Assemble export bundle: canonical JSON, metadata.json with <code>configHash</code>, <code>appliedMigrations</code>, <code>snapshotId</code>, and optional encrypted evidence payload. <br>2. When <code>atomic=true</code> use AtomicWrite to write bundle to destination; when pushing to repo, perform commit+push with signing if <code>sign=true</code>. <br>3. After successful write or push, compute and record artifact checksum and emit <code>pq.config.export.completed</code>. <br><strong>Failure & fallback:</strong> on remote push failure persist bundle to local staging, emit <code>pq.config.export.degraded</code>, and notify owners per release policy. <br><strong>Observability & audit fields:</strong> pq.config.export.attempt(correlationId, destinationDescriptor) pq.config.export.completed(correlationId, artifactChecksum, destinationUri) pq.config.export.failure(correlationId, errorCode, diagnosticsRef) <br><strong>Tests:</strong> atomic write under concurrent readers test, remote commit with intermittent auth failure simulation, staged fallback verification. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>ConfigDiff(oldConfig, newConfig, options={ignoreVolatile:true, includeProvenance:true, impactRules:default})</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> produce a deterministic, actionable diff with path-based changes, fingerprints, suggested reversal steps, and <code>impactScore</code> for operator review or CI gating. Return <code>{changes:[{path, oldFingerprint, newFingerprint, action, impactScore, provenance}], summary, actionsSuggested}</code>. <br><strong>Algorithm & heuristics:</strong><br>1. Use canonical traversal for path semantics. <br>2. Detect list moves vs additions using a longest-common-subsequence heuristic to avoid false positives when order preserved. <br>3. Impact scoring uses <code>impactRules</code> mapping (e.g., connector.timeout => high, cosmetic.label => low). <br><strong>Use cases:</strong> migration preview, PR CI gating, operator acceptance dialogs, automated low-risk approvals. <br><strong>Observability & audit fields:</strong> pq.config.diff.created(correlationId, oldHash, newHash, changesCount, diffRef) <br><strong>Tests:</strong> list move detection, impactScore calibration tests, provenance linking tests. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>ConfigStoreAdapter</code> (interface + implementations) — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> pluggable persistence layer for configs; adapters implement <code>read()</code>, <code>write(payload)</code>, <code>listVersions()</code>, <code>inspectTempArtifacts()</code> and must use AtomicWrite semantics for write. Implementations: HiddenSheetAdapter, LocalFileAdapter, RemoteRepoAdapter (git/HTTP), InMemoryAdapter (tests). <br><strong>Adapter specifics & host constraints:</strong><br>1. <strong>HiddenSheetAdapter:</strong> embed canonical JSON in a hidden worksheet <code>PQ_Config</code>; writes must avoid recalculation and heavy IO on OnLoad—use host-provided idle callbacks or schedule writes via host scheduling APIs; provide import/export helpers; persist sidecar metadata in reserved named ranges. <br>2. <strong>LocalFileAdapter:</strong> cross-platform atomic file operations and fsync parent dir when available; handle ACL and Windows ReplaceFile semantics; provide InspectTempArtifacts for leftover .part files. <br>3. <strong>RemoteRepoAdapter:</strong> shallow fetch/clone, signature verification against trusted keys, support for commit+push with signing and signed manifest handling; produce <code>mChecksums</code> and evidenceRefs for fetched files. <br>4. <strong>InMemoryAdapter:</strong> deterministic ephemeral store used in unit tests and CI; ensure parity in API semantics. <br><strong>Security:</strong> adapters must never embed raw secrets; placeholders only and evidenceRefs to secure vaults. <br><strong>Observability & audit fields:</strong> pq.config.store.read(correlationId, adapterType, descriptorHash) pq.config.store.write(correlationId, adapterType, descriptorHash, artifactChecksum) <br><strong>Tests:</strong> HiddenSheet race conditions with Excel host mocks, file lock error scenarios, remote fetch signature verification, InspectTempArtifacts repair flows. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong><code>SecretsPlaceholderResolver(configObject, resolverInterface, authorization)</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> PQ_Config keeps secrets as placeholders. SecretsPlaceholderResolver performs resolution only in authorized worker contexts with full audit trail; it returns resolved values to caller and stores resolution metadata (not secret content) in the evidence store. <br><strong>Resolution flow & auditing:</strong><br>1. Caller supplies <code>correlationId</code>, <code>snapshotId</code>, and <code>authorizationToken</code> referencing secure vault credentials managed outside PQ_Config. <br>2. Resolver fetches secrets in secure environment, records <code>pq.config.secrets.resolution.start</code> and <code>pq.config.secrets.resolution.complete</code> audits with evidenceRef containing placeholder fingerprints, actor, resolutionTime, and resolutionNonce (no secret values). <br>3. Supports partial resolution and returns <code>{resolvedConfig, missingSecrets:[placeholders]}</code>. <br><strong>Security & governance:</strong> all resolutions must be authorized by ConfigAccessPolicy; secrets are never recorded in cleartext in the audit or evidence metadata. <br><strong>Edge cases & failure modes:</strong> missing secret -> <code>PQ_CONFIG_SECRETS_MISSING</code>; unauthorized -> <code>PQ_CONFIG_SECRETS_UNAUTHORIZED</code>. <br><strong>Tests:</strong> permission-denied tests, rotation & cache behavior, audit trail verification (no secret leakage). </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Cross-cutting Observability, Telemetry & Error catalog (expanded):</strong><br><strong>Audit schema:</strong> each audit row must include: timestamp (ISO8601), correlationId, module=PQ_Config, procedure, operatorId (optional), paramsHash, resultHash (optional), evidenceRef (optional), prevConfigHash (if applicable), configHash (if applicable), snapshotId (if applicable), and metadata object with duration_ms, adapterType, sourceDescriptorHash, artifactChecksum, appliedMigrations. Sensitive parameters are redacted in the top-level audit; full sanitized payloads are stored encrypted in evidence store and referenced via <code>evidenceRef</code>. <br><strong>Key audit events:</strong> load/validate/migrations/resolve_remote/snapshot/export/secrets.resolve/diff. <br><strong>Representative ErrorCodes and operator guidance:</strong><br>1. PQ_CONFIG_LOAD_FAIL — examine diagnosticsRef and fix malformed JSON or adapter access issues. <br>2. PQ_CONFIG_VALIDATE_FAIL — present schema diagnostics to template owner for remediation. <br>3. PQ_CONFIG_SCHEMA_MISMATCH — migration needed; run migration dry_run and review diffs. <br>4. PQ_CONFIG_MIGRATION_REQUIRES_APPROVAL — require two-person approval and owner sign-off. <br>5. PQ_CONFIG_RESOLVE_REMOTE_UNREACHABLE — check repo credentials, network, remote service health; fallback to local snapshot if allowed. <br>6. PQ_CONFIG_SECRETS_MISSING — provision missing secret in secure vault and retry resolution. <br><strong>Metrics:</strong> pq.config.load.latency_ms, pq.config.validate.fail_rate, pq.config.resolve_remote.success_rate, pq.config.migrations.count, pq.config.export.success_rate; metrics are locally buffered and uploaded by CORE_Telemetry in audited batches to preserve privacy and ordering. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Testing matrix, property tests, cross-language golden governance (comprehensive & explicit)</strong><br><strong>Unit tests (minimum set):</strong><br>1. LoadConfig: hidden-sheet, local file path, remote repo with cached fallback and force_remote behaviors. <br>2. ValidateConfigSchema: <code>oneOf</code>, <code>anyOf</code>, <code>allOf</code>, <code>if/then/else</code>, default application, deprecated keys handling. <br>3. ComputeConfigHash: canonicalization parity across Python/JS/VBA with varied numeric formatting and unicode inputs. <br>4. ApplyIdempotentMigrations: idempotency, reversible migrations roundtrip, destructive migration gating. <br>5. ResolveRemoteConfig: signature verification, cached snapshot fallback, determinism under concurrent fetches. <br>6. MergeOverrides: deterministic merges for permutation tests and conflict detection. <br><strong>Integration tests:</strong><br>1. End-to-end pipeline: LoadConfig -> ResolveRemoteConfig -> ApplyIdempotentMigrations -> SnapshotConfig -> ExportResolvedConfig verifying artifactChecksum and audit tail. <br>2. HiddenSheetAdapter concurrency: simulate Excel saves using host mock and ensure watch notifications are debounced and no corruption occurs. <br>3. SecretsResolution: mock secure vault and ensure resolved values are not present in audits or snapshots, and evidenceRef integrity is verified. <br><strong>Property tests & fuzzing:</strong><br>1. <code>configHash</code> stability: modify only volatile fields and assert no hash change when <code>ignoreVolatile=true</code>. <br>2. MergeOverrides invariants: given precedence rules, out-of-order fragment arrival yields same final merged config. <br>3. Migration idempotency across random config inputs. <br><strong>CI golden gating & governance:</strong><br>1. Cross-language <code>configHash</code> goldens must pass for merges to mainline. <br>2. Any schema or migration change must include migration manifest, owner approvals, and golden test vectors demonstrating expected diffs. <br>3. Static analyzer must block direct workbook writes from UI OnLoad and disallow forbidden API usage. <br><strong>Performance testing:</strong> nightly or canary runs to validate load latency, remote resolution throughput, snapshot persistence throughput for large repos. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Developer guidance, allowed & forbidden patterns (detailed & strict)</strong><br><strong>Required patterns:</strong><br>1. Always use <code>LoadConfig</code> for consumers; do not read raw files in ribbon or worker code.<br>2. Persist durable artifacts via ConfigStoreAdapter with AtomicWrite; do not write directly to final artifact paths from UI code.<br>3. Always compute and persist <code>config.hash</code> and include in job descriptors and audits to create reproducibility anchors.<br>4. Use <code>ApplyIdempotentMigrations</code> with <code>dry_run</code> previews for operator review before applying; require approvals for destructive migrations.<br>5. Do not resolve secrets in PQ_Config; call <code>SecretsPlaceholderResolver</code> only in authorized worker contexts and ensure audit evidenceRef recorded for every resolution. <br><strong>Forbidden patterns:</strong><br>1. Blocking network I/O during UI OnLoad (static analyzer rejects). <br>2. Exposing raw secrets in audit rows, snapshots, or logs. <br>3. Relying on host locale-specific JSON serialization or float formatting when computing <code>config.hash</code>. <br>4. Mutating workbook content from background threads without host-synchronized callbacks. <br><strong>Code-review checklist:</strong> ensure audit emits for load/validate/migrate/export flows are present; AtomicWrite used for persistent writes; <code>config.hash</code> included in job descriptors; migration tests and owner approvals present for schema changes; CI includes cross-language parity checks for canonicalization. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Operational runbook & incident playbooks (executable & prescriptive)</strong><br><strong>Config load failure triage runbook:</strong><br>1. Inspect <code>pq.config.load.failure</code> audit row for correlationId and diagnosticsRef. <br>2. If <code>PQ_CONFIG_VALIDATE_FAIL</code>, download sanitized snapshot via evidenceRef and run <code>ValidateConfigSchema</code> offline to get path-level diagnostics and suggestions; notify template owner with suggested patch. <br>3. If <code>PQ_CONFIG_RESOLVE_REMOTE_UNREACHABLE</code>, verify repo credentials, network, and remote service health; if fallback allowed use <code>LoadConfig(local_only)</code> to continue UI operations; log an incident and notify owners if canary or production templates are affected. <br>4. For migration failures, get migration diff and run <code>ApplyIdempotentMigrations</code> in worker dry_run to generate remediation plan; if destructive, obtain owner approvals and re-run apply_with_approval. <br><strong>Signature mismatch on remote resolve runbook:</strong><br>1. Retrieve <code>pq.config.resolve_remote.failure</code> audit and evidenceRef for fetched artifacts. <br>2. Quarantine fetched artifacts, notify template owners, and verify manifest signing keys. <br>3. If deliberate key rotation occurred, follow key rollover procedure; if compromise suspected, rotate keys, block affected templates, and open compliance incident. <br><strong>Forensic reconstruction ordered steps:</strong><br>1. Collect <code>UserAction</code> and <code>pq.config.*</code> audits for correlationId and time window. <br>2. Pull snapshot via evidenceRef and verify <code>configHash</code> vs audit. <br>3. Restore RNG state if sampling used (from profile audits) and perform deterministic replay to reproduce template output. <br>4. If mismatch persists, compare <code>ConfigDiff</code> and <code>pq.config.migrations</code> audits to find applied migrations between preview and production. <br>5. Package forensic_manifest.json containing audit_tail.csv, snapshots, artifacts, RNG state, and migration diffs for compliance. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Extremely detailed narratives & examples (multiple scenarios, extended)</strong><br><strong>Scenario A — Local operator edits template defaults and preview (end-to-end):</strong><br>1. Operator opens add-in → PQ_Ribbon calls <code>LoadConfig(hidden:PQ_Config, mode=auto)</code> and obtains a local snapshot quickly (<code>loadedFrom=hidden-sheet</code>). <br>2. Editor shows parameter schema via <code>ExposeRuntimeConfig</code>—secrets shown as placeholders and <code>configHash</code> displayed for traceability. <br>3. Operator edits parameter defaults; client-side <code>ValidateConfigSchema</code> runs synchronously and prevents saving malformed configs. <br>4. On save, HiddenSheetAdapter.write() uses AtomicWrite to persist canonical JSON to the hidden sheet; <code>WatchConfigFile</code> detects stable change (debounced) and loads new snapshot producing <code>pq.config.watch.detected</code> audit with oldHash->newHash. <br>5. Preview uses snapshotId and <code>configHash</code> to produce deterministic parameterized preview; <code>pq_preview</code> audit includes <code>configHash</code> and snapshotId to allow forensic replay of preview. <br><strong>Takeaways:</strong> local workflows are fast and auditable; <code>configHash</code> ensures previews and injection are reproducible. <br><strong>Scenario B — Remote canonicalization & enterprise injection pipeline:</strong><br>1. Central template owner updates defaults and publishes signed manifest; CI runs <code>ValidateConfigSchema</code> and computes new <code>configHash</code>. <br>2. Workers periodically run <code>ResolveRemoteConfig(force_remote)</code> to fetch signed fragments, verify signatures, and compute a merged config; <code>pq.config.resolve_remote.complete</code> is emitted with <code>evidenceRef</code> pointing to artifacts and signatures. <br>3. Workers apply <code>ApplyIdempotentMigrations</code> when migration registry indicates necessary transformation; destructive migrations require owner approval token captured in audit. <br>4. Worker renders canonical M templates, <code>ExportResolvedConfig</code> writes artifacts to staging repo with artifactChecksum recorded; downstream injectors use artifactChecksum and <code>configHash</code> to perform injections. <br><strong>Takeaways:</strong> central repository + signatures + <code>configHash</code> produce provable lineage of injected artifacts; migration approvals enforce governance. <br><strong>Scenario C — CI gate for template changes:</strong><br>1. PR modifies <code>templates/defaults.json</code>; CI runs <code>ValidateConfigSchema</code>, <code>ComputeConfigHash</code>, and <code>ApplyIdempotentMigrations(dry_run)</code> producing <code>ConfigDiff</code>. <br>2. CI computes impact scores; high-impact changes block merge until owners approve. <br>3. On owner approval CI produces release manifest including <code>configHash</code> and signed release artifacts. <br><strong>Takeaway:</strong> CI stops subtle config-induced behavior changes from reaching production by using deterministic diffing and <code>configHash</code> goldens. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Conceptual Power Query (M) patterns — how PQ_Config maps to PQ workflows (detailed mapping & guidance)</strong><br><strong>Context:</strong> M executes inside hosts with varying runtimes; PQ_Config orchestrates deterministic behavior externally and provides canonical artifacts for injection. <br><strong>Mapping patterns & recommendations (detailed):</strong><br>1. <strong>Atomic persistence mapping:</strong> orchestrator persists canonical M via <code>ExportResolvedConfig</code> and <code>ConfigStoreAdapter</code> (AtomicWrite) and provides artifactChecksum and <code>configHash</code> to the injector; injection then uses the persisted artifact, ensuring the exact M injected is auditable. <br>2. <strong>Deterministic seeds & sampling:</strong> for previews compute seed = HMAC(<code>correlationId | templateId</code>) and pass as parameter to M preview; for heavyweight sampling do sampling in worker using DeterministicRNG and pass sampled static dataset to M template to avoid host RNG variability. <br>3. <strong>Numeric fidelity / SafeRound mapping:</strong> mark templates <code>requiresHighPrecision</code> and offload sensitive aggregation and rounding to worker SafeRound flows; persist finalized numeric columns and canonical M for injection to avoid cross-host decimals variance. <br>4. <strong>Retry & idempotency mapping:</strong> orchestrator wraps external calls and persisted job descriptors with Retry and idempotency tokens; keep M templates pure and declarative, orchestrator handles persistence and retries. <br><strong>PQ operator example (injection):</strong><br>1. Operator selects template → orchestrator calls <code>ExposeRuntimeConfig</code> to fetch parameter schema and <code>configHash</code>. <br>2. Operator submits injection request → orchestrator persists canonical M via <code>ExportResolvedConfig</code> (AtomicWrite), emits <code>pq_inject</code> audit referencing artifactChecksum and <code>configHash</code>, and calls <code>workbook.Queries.Add</code> with the persisted M artifact to guarantee the injected query equals audited artifact. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX patterns — mapping PQ_Config to ETL & model design (detailed)</strong><br><strong>Context:</strong> DAX is read-only and deterministic for queries; all authoritative transforms, rounding, allocations, and sample generation must be performed in ETL using PQ_Config guidance and artifacts. <br><strong>Patterns & recommendations:</strong><br>1. <strong>ETL-owned rounding & allocations:</strong> perform SafeRoundResiduals in ETL and persist resolved cents-level fields; DAX measures operate on authoritative persisted values for deterministic aggregates. <br>2. <strong>Deterministic sampling stored in table:</strong> ETL computes <code>HashKey = HMAC(primaryKey | correlationSalt)</code> and persists it; DAX uses <code>MOD(HashKey, N)</code> to derive deterministic samples, with <code>correlationSalt</code> persisted in RunMetadata for replay. <br>3. <strong>RunMetadata & model-level reconciliation:</strong> ETL writes RunMetadata with <code>configHash</code>, <code>snapshotId</code>, <code>artifactChecksum</code>, and <code>runTs</code>. DAX exposes measures that compare the model's expected artifactChecksum to the stored artifactChecksum to produce <code>IsReconciled</code> flags for operator dashboards. <br>4. <strong>Model-level governance:</strong> Provide <code>RunMetadata</code> table with <code>appliedMigrations</code> and <code>templateVersion</code> to let report authors show lineage and provenance in the report UI. <br><strong>DAX operator narrative:</strong> ETL uses PQ_Config to obtain template parameters and <code>configHash</code>, performs canonical transforms and rounding, writes authoritative tables and RunMetadata; report DAX measures surface provenance and reconciliation status and drive remediation workflows when mismatches occur. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendices: forensic artifacts, evidence paths & retention (detailed)</strong><br><strong>Minimum forensic artifact set for incidents involving config:</strong><br>1. <code>config_snapshot.json</code> canonical form with <code>snapshotId</code> and artifactChecksum. <br>2. full set of <code>pq.config.*</code> audit rows covering load/validate/resolve/migrate/export events for correlationId. <br>3. remote artifact manifests with <code>mChecksums</code> and signature verification results. <br>4. migration diffs and per-migration evidenceRef objects. <br>5. hidden-sheet raw content (redacted) if relevant. <br>6. secrets resolution request metadata and <code>evidenceRef</code> (encrypted). <br>7. AtomicWrite temp artifacts listing (InspectTempArtifacts) and related repair logs. <br><strong>Evidence store & retention strategy:</strong><br>1. Hot evidence store: <code>\\evidence\hot\pq_config\&lt;correlationId&gt;\</code> for 30 days with restricted access. <br>2. Warm archive: secure offline archive for 7 years with signed manifests for regulatory retention. <br>3. Cold storage: long-term offline retention per regulation; maintain chain-of-custody metadata. <br><strong>Monthly verification cadence:</strong> scheduled retention verification job that computes proof-of-presence for hot artifacts and emits <code>housekeeping.audit</code>; periodic cryptographic checks of manifest signatures and evidenceRef integrity. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Acceptance checklist before PQ_Config release (comprehensive):</strong><br>1. OWNERS.md updated and contacts verified with on-call rotation. <br>2. Public API stable and documented with backward compatibility and deprecation rules. <br>3. All writes use AtomicWrite and emit audits that include <code>configHash</code> and evidenceRef where applicable. <br>4. Cross-language <code>configHash</code> golden vectors and canonical serializer parity tests passing. <br>5. Migration registry validated; destructive migrations documented and have owner approvals. <br>6. Audit hooks integrated into modAudit buffer; evidenceRef patterns validated and encrypted evidence accessible by compliance tools. <br>7. CI gating includes static analyzer checks to block UI-thread network I/O; performance budgets met. <br><strong>Blocking conditions:</strong> failure of <code>configHash</code> golden parity, missing audit emissions on persistence flows, or migration scripts lacking owner approvals. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Extremely detailed test plan highlights & procedural scripts (explicit):</strong><br><strong>Unit tests group:</strong><br>1. <code>LoadConfig</code> permutations: hidden-sheet, local file path, remote descriptor with cached fallback. <br>2. <code>ValidateConfigSchema</code> across schema constructs including <code>oneOf</code>, <code>anyOf</code>, <code>allOf</code>, custom keywords, and deprecated fields. <br>3. <code>ComputeConfigHash</code> canonicalization and numeric formatting parity vectors. <br>4. <code>ApplyIdempotentMigrations</code> idempotency and reverse migration tests. <br>5. <code>ResolveRemoteConfig</code> signature verification and cached snapshot fallback tests. <br><strong>Integration tests group:</strong><br>1. End-to-end pipeline: <code>LoadConfig</code> -> <code>ResolveRemoteConfig</code> -> <code>ApplyIdempotentMigrations</code> -> <code>SnapshotConfig</code> -> <code>ExportResolvedConfig</code>; verify artifact checksums and audit tail integrity. <br>2. HiddenSheetAdapter concurrency tests: simulate workbook sessions and background saves to ensure watcher stability. <br><strong>Property & fuzz tests:</strong><br>1. <code>configHash</code> invariants under volatile key changes. <br>2. MergeOverrides idempotency and commutativity where precedence rules mandate. <br><strong>Performance & CI gating:</strong> nightly-run performance smoke, golden vector validation for <code>configHash</code>, and static analyzer enforcement for forbidden patterns. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Operator runbook quick commands & examples (prescriptive):</strong><br>1. <code>pqconfig diagnostics collect --correlation &lt;id&gt;</code> — pulls <code>pq.config.*</code> audits, snapshots, remote manifests, and produces forensic_manifest.json. <br>2. <code>pqconfig migrate --dry-run --snapshot &lt;snapshotId&gt;</code> — generate migration diff and changeLog for operator review and owner approval. <br>3. <code>pqconfig export --snapshot &lt;snapshotId&gt; --dest file://staging</code> — atomic export bundle creation and local staging when remote push fails. <br>4. <code>pqconfig snapshot.inspect --snapshot &lt;snapshotId&gt;</code> — show redacted summary of snapshot including <code>configHash</code>, applied migrations, and remote artifact list. <br><strong>When to call SRE:</strong> repeated <code>pq.config.resolve_remote.degraded</code> or <code>pq.config.export.failure</code> during staging/publish, or AtomicWrite failures affecting downstream consumers. Provide forensic_manifest and audit_tail when opening SRE incidents. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Final notes, governance & mandatory constraints (firm):</strong><br>1. <code>config.hash</code> is the canonical fingerprint for reproducibility—persist it in job descriptors and audits. <br>2. Secrets are placeholders in PQ_Config; resolve via SecretsPlaceholderResolver in authorized worker contexts only; never store secret values in audit or evidence metadata. <br>3. UI fast-path must never perform blocking network I/O; use cached snapshots and schedule remote resolves asynchronously. <br>4. Destructive migrations require two-person approval for regulated templates and must be recorded with rollback manifest. <br>5. All persistent operations must emit audit rows and include <code>evidenceRef</code> for large payloads; evidence store access is RBAC-protected and audited. <br><strong>Checked:</strong> conceptual chain from config load → resolve_remote → apply migrations → snapshot → export validated by multiple internal reviews and cross-checks. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix A — Example audit row schema (descriptive):</strong><br><strong>Required fields:</strong> timestamp, correlationId, module=PQ_Config, procedure, operatorId (optional), paramsHash, resultHash (optional), evidenceRef (optional), prevConfigHash (optional), configHash (if applicable), snapshotId (if applicable), metadata object with duration_ms, adapterType, sourceDescriptorHash, artifactChecksum, appliedMigrations. <br><strong>Policy:</strong> top-level audits must not contain PII; sanitized full params go into evidence store and are referenced via evidenceRef. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix B — Common failure modes & mitigations (expanded):</strong><br><strong>UI blocked by remote resolve during OnLoad</strong><br>1. Cause: synchronous remote fetch on UI OnLoad. <br>2. Mitigation: enforce <code>LoadConfig(auto|local_only)</code> for OnLoad and perform <code>ResolveRemoteConfig</code> asynchronously with background worker; static analyzer prevents network calls in OnLoad. <br><strong><code>configHash</code> mismatches across runtimes</strong><br>1. Cause: non-canonical serializer or locale-dependent numeric formatting. <br>2. Mitigation: canonical JSON serializer and cross-language parity tests in CI; store <code>financial</code> numeric fields as scaled integers or strings for consistent serialization. <br><strong>Migration applied twice</strong><br>1. Cause: migration marker not persisted atomically. <br>2. Mitigation: persist <code>migrations_applied</code> atomically with final config using AtomicWrite; migrations must include precondition checks for idempotence. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix C — Governance checklists & PR requirements (explicit):</strong><br>1. PR must include unit tests and golden vectors where deterministic results are affected. <br>2. Migration/schema changes require migration manifest and owner approvals documented in PR and release manifest. <br>3. Changes affecting persistence patterns or AtomicWrite semantics require cross-platform regression tests and SRE sign-off. <br>4. Production changes affecting templates or regulated outputs require signed release manifest and compliance review. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix D — Long-form incident reconstruction example (ordered):</strong><br><strong>Incident:</strong> preview output differs from run output for correlation <code>r-20260112-455</code>. <br><strong>Reconstruction ordered steps:</strong><br>1. Retrieve <code>UserAction</code> and <code>pq.config.*</code> audits for correlationId and time range. <br>2. Download <code>config_snapshot.json</code> from evidenceRef referenced in <code>pq.config.snapshot.created</code> and verify <code>configHash</code>. <br>3. If sampling used, fetch serialized RNG state from profile or tools audits and restore deterministic RNG to reproduce sample sets. <br>4. Re-run template rendering in replay mode using snapshotId and compare artifactChecksums to production artifact. <br>5. If mismatch found, inspect <code>pq.config.migrations</code> and <code>ConfigDiff</code> audits to determine if migrations were applied between preview and run. <br>6. If remote artifacts involved, verify signatures and <code>mChecksums</code> recorded during <code>ResolveRemoteConfig</code>. <br>7. Package <code>forensic_manifest.json</code> containing audit tail, snapshots, artifacts, RNG state, migration diffs and escalate to compliance when regulated outputs or PII involved. <br><strong>Outcome validation:</strong> deterministic replay should reproduce the artifactChecksum when using exact snapshot and evidenceRef; discrepancies indicate pipeline differences or operator errors requiring remediation and documented runbooks. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix E — Practical PQ & DAX checklists for template authors and report builders (concise):</strong><br><strong>PQ Template author checklist:</strong><br>1. Include <code>mChecksum</code> and <code>templateVersion</code> in template metadata. <br>2. Mark <code>requiresHighPrecision</code> for numerically sensitive templates and implement worker-side final aggregation. <br>3. Parameterize preview seed and log it in <code>pq_preview</code> audits. <br>4. Avoid runtime secret resolution in template code; use placeholders and consumer-side secret resolution only in workers. <br><strong>DAX/report builder checklist:</strong><br>1. Use <code>RunMetadata</code> table for provenance and <code>configHash</code>. <br>2. Do not perform allocation/residual rounding in DAX; ETL must persist resolved numeric values. <br>3. For deterministic sampling use persisted <code>HashKey</code> and <code>correlationSalt</code> from RunMetadata. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix F — Migration design notes & best practices (extended):</strong><br><strong>Design goals:</strong> idempotence, determinism, reversibility when feasible, and explicit owner guidance. <br><strong>Implementation best practices:</strong><br>1. Implement migrations as pure transformation functions that accept canonical input and return canonical output and <code>diff</code>. <br>2. Include unit tests that cover edge cases and record golden vectors for each migration. <br>3. Provide reverse migration or rollback manifest where feasible; for irreversible destructive steps annotate with <code>recoveryGuidance</code>. <br><strong>Operator workflow:</strong> preview via <code>dry_run</code>, review <code>ConfigDiff</code>, obtain owner approvals for destructive changes, then apply with <code>apply_with_approval</code> API call. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix G — Long-form rationale: why <code>config.hash</code> matters (detailed justification)</strong><br><strong>Problem:</strong> when templates and defaults evolve across teams and hosts, outputs diverge and auditors lack a compact reproducible pointer to the exact config used. <br><strong>Solution via <code>config.hash</code>:</strong><br>1. A compact cryptographic fingerprint linking all artifacts, job descriptors, and audits. <br>2. A stable anchor for CI gating and deterministic replay; job descriptors referencing <code>configHash</code> allow workers to reconstruct exact runtime environment by fetching snapshot via evidenceRef. <br>3. Enables small, efficient audit rows: <code>configHash</code> + artifactChecksum create the proof chain used for compliance packages. <br><strong>Operational advantage:</strong> <code>configHash</code> simplifies forensic reconstruction and reduces evidence payload size while preserving cryptographic integrity through canonicalization. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix H — Extended conceptual mapping matrix (quick lookup)</strong><br><strong>Function → PQ implication → DAX/ETL implication (compact):</strong><br>1. <code>LoadConfig</code> → UI gets fast snapshot for preview → ETL uses <code>configHash</code> in RunMetadata. <br>2. <code>ResolveRemoteConfig</code> → central defaults applied deterministically → ETL uses resolved parameters for canonical transforms; DAX reads authoritative persisted values. <br>3. <code>ApplyIdempotentMigrations</code> → evolve schema with audit trail → RunMetadata records migrations for model lineage. <br>4. <code>SnapshotConfig</code> → immutable evidence for replay → DAX <code>IsReconciled</code> compares model artifactChecksum to RunMetadata. <br>5. <code>SecretsPlaceholderResolver</code> → secure secret retrieval in worker → ETL resolves secrets during job runs; DAX never sees secrets. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Appendix I — Example operator scenarios & escalation thresholds (expanded):</strong><br><strong>Operator scenario: unexpected injected query behavior:</strong><br>1. Check <code>pq_inject</code> audit for artifactChecksum and <code>configHash</code>. <br>2. Use <code>pqconfig snapshot.inspect --snapshot &lt;snapshotId&gt;</code> to review parameterization. <br>3. If mismatch persists, <code>replay.run --snapshot &lt;snapshotId&gt;</code> to reproduce; if discrepancy remains escalate with forensic_manifest. <br><strong>Escalation thresholds:</strong> repeated <code>pq.config.resolve_remote.degraded</code> over N canary runs, <code>pq.config.export.failure</code> for production releases, or <code>pq.config.migrations.failure</code> for regulated templates require SRE and compliance engagement. </td></tr><tr><td data-label="PQ_Config — Per-function Expert Technical Breakdown"> <strong>Closing operational constraint (non-negotiable):</strong><br>All processes that produce artifacts consumed by other processes must: persist job descriptors, seed deterministic RNGs from correlationId for operator-visible sampling, use AtomicWrite for final artifacts, and emit audit rows including <code>configHash</code> and evidenceRef. This is mandatory for regulated and PII-touching workflows—no exceptions. </td></tr></tbody></table></div><div class="row-count">Rows: 37</div></div><div class="table-caption" id="Table3" data-table="Docu_0179_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by PQ_EnsureDeps — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">PQ_EnsureDeps — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Module-level metadata (contract & overview):</strong><br><strong>Owner:</strong> TEAM_PQ_ENSUREDEPS recorded in OWNERS.md and release manifests; owners include contacts for Support, Security, SRE, and Template Governance.<br><strong>Public API:</strong> <code>LoadLocalManifests</code>, <code>InspectInstalledAddins</code>, <code>ResolveRemoteManifests</code>, <code>ValidateConnectorVersion</code>, <code>ValidatePQRuntimeVersion</code>, <code>EnsureTemplateCompatibility</code>, <code>VerifyTemplateSignature</code>, <code>ProduceDepsReport</code>, <code>AtomicWriteDepsReport</code>, <code>GenerateDepFingerprint</code>, <code>InspectTempArtifacts</code>, <code>RepairMissingDeps</code>, <code>DiagnoseDepsFailure</code>, <code>DepsDryRun</code>, <code>DepsPolicyEnforcer</code>, <code>ListKnownGoodSnapshots</code>, <code>PromoteSnapshotToLocal</code>, <code>MarkTemplateAsDeprecated</code>.<br><strong>Audits emitted:</strong> <code>pq.ensuredeps.start</code>, <code>pq.ensuredeps.manifest.load</code>, <code>pq.ensuredeps.addin.scan</code>, <code>pq.ensuredeps.remote.resolve.attempt</code>, <code>pq.ensuredeps.remote.resolve.completed</code>, <code>pq.ensuredeps.connector.validate</code>, <code>pq.ensuredeps.pqruntime.validate</code>, <code>pq.ensuredeps.template.verify</code>, <code>pq.ensuredeps.template.signature</code>, <code>pq.ensuredeps.report.generated</code>, <code>pq.ensuredeps.report.atomic_write.attempt</code>, <code>pq.ensuredeps.report.atomic_write.completed</code>, <code>pq.ensuredeps.report.atomic_write.failure</code>, <code>pq.ensuredeps.repair.attempt</code>, <code>pq.ensuredeps.repair.success</code>, <code>pq.ensuredeps.degraded</code>, <code>pq.ensuredeps.complete</code>. Each audit row includes <code>correlationId</code>, <code>module=PQ_EnsureDeps</code>, <code>procedure</code>, <code>paramsHash</code>, <code>resultHash</code> when applicable, <code>durationMs</code>, and <code>evidenceRef</code> for large artifacts or signature blobs. Evidence storage is encrypted and access-controlled; top-level audits must not carry raw PII.<br><strong>Purpose and intended use:</strong> Validate required Power Query connectors, runtime compatibility, template integrity and signatures, and produce an authoritative <code>deps.report.json</code> to drive safe injection, preview, refresh and export flows. Provide machine-actionable repair proposals and maintain deterministic, auditable evidence chains for forensic replay in regulated contexts. Ensure UI fast-path remains non-blocking by separating local quick-scans from remote, heavier resolves that must run on background workers.<br><strong>Non-goals / constraints:</strong> Do not auto-install system-level connectors without explicit operator approval plus governance (two-person approval for regulated workflows). Avoid any long-blocking operations on the UI thread. Do not include raw secrets or PII in audit rows. Avoid heavy third-party dependencies that impair portability to XLAM/VBA host scenarios. Use secure credential store for remote repo auth; do not serialize secrets into evidence blobs. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Operational guarantees (module-level invariants & SLOs):</strong><br>1. Deterministic output: identical inputs (local manifests, resolved remote snapshot, config.hash, release manifest) must produce identical <code>deps.report.json</code> bytes; arrays must be canonicalized and sorted. <br>2. Non-blocking bootstrap fast-path: <code>LoadLocalManifests</code> and <code>InspectInstalledAddins</code> must complete within UI idle budget (default <200ms); no network I/O. <br>3. Atomic persistence guarantee: <code>deps.report.json</code> must be written via <code>AtomicWriteDepsReport</code> so readers never see truncated reports. <br>4. Degraded yet safe: network failures or signature-check timeouts produce <code>degraded=true</code> and include explicit <code>degradedReasons</code> and <code>cachedSnapshot</code> if available. <br>5. Audit-anchored operations: any change to persisted dependency state or repair actions must attach at least one audit row referencing <code>correlationId</code> and evidenceRef. <br>6. Idempotence: repeated calls with unchanged inputs must be stable and return same <code>reportHash</code>. <br><strong>Performance SLOs:</strong> local manifest scanning median <50ms; resolved remote snapshot retrieval median <2s under normal networks (worker path); deps report atomic write median <200ms on local SSD. <br><strong>CI gates:</strong> signature verification golden vectors, <code>reportHash</code> parity across OSes, static analyzer enforcement forbidding UI-thread network calls, audit emission verification. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>High-level workflow & invariants (detailed):</strong><br>1. UI idle: <code>LoadLocalManifests</code> loads embedded templates, hidden-sheet <code>PQ_TEMPLATES</code>, and add-in manifests with minimal metadata only (name, templateId, mChecksum, requiredConnectors, signaturePolicy). Emits <code>pq.ensuredeps.manifest.load</code>. <br>2. Worker: <code>ResolveRemoteManifests</code> fetches remote template repo index and connector capability manifests, validates schema, computes <code>mChecksum</code> for templates and connectors, caches snapshot in evidence store signed by release manifest key. Emits <code>pq.ensuredeps.remote.resolve.completed</code>. <br>3. <code>InspectInstalledAddins</code> enumerates installed XLAMs and registered connectors via host APIs, extracts code-signing status and matches owners from <code>OWNERS.md</code>. Emits <code>pq.ensuredeps.addin.scan</code>. <br>4. Compatibility checks: for each template, run <code>EnsureTemplateCompatibility</code> which calls <code>ValidateConnectorVersion</code> and <code>ValidatePQRuntimeVersion</code> and <code>VerifyTemplateSignature</code> when required; compute <code>compatibilityStatus</code> and <code>repairActions</code>. Emit <code>pq.ensuredeps.template.verify</code>. <br>5. Produce canonical report: <code>ProduceDepsReport</code> produces <code>deps.report.json</code> with <code>reportHash</code>, persists via <code>AtomicWriteDepsReport</code>, and emits <code>pq.ensuredeps.report.generated</code> and <code>pq.ensuredeps.report.atomic_write.completed</code>. <br>6. On failures or missing deps propose repairs via <code>RepairMissingDeps</code> (idempotent proposals). Repairs require explicit operator approval for system changes; for regulated templates require two-person approval. <br><strong>Invariants:</strong> canonical ordering, stable tie-breaking when multiple repair options exist (use <code>GenerateDepFingerprint</code> seed), all persisted artifacts written with <code>AtomicWrite</code>. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>API function breakdown — exhaustive</strong> </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>LoadLocalManifests(workbookSnapshot, correlationId, options={fastMode:true})</code></strong><br><strong>Purpose & contract:</strong> collect minimal manifest metadata from the active workbook and installed add-ins without network I/O; safe for UI idle path. Return deterministic list sorted by <code>templateId</code>. <br><strong>Parameters:</strong> <code>workbookSnapshot</code> (a redacted, read-only snapshot or workbook handle), <code>correlationId</code>, <code>options.fastMode</code> boolean. <br><strong>Return:</strong> <code>{manifests:[{templateId, mChecksum, requiredConnectors, minPQRuntime, signaturePolicy, owner}], manifestsHash, durationMs}</code>. <br><strong>Behavior & implementation notes:</strong><br>1. Canonicalize manifest fields: normalize version strings to semver where present and canonicalize <code>requiredConnectors</code> to lowercase provider ids. <br>2. Read hidden-sheet <code>PQ_TEMPLATES</code> once and parse rows into manifest records; if hidden-sheet missing return empty list with <code>manifestCount=0</code>. <br>3. Validate manifest schema lightly (presence of required keys) and emit <code>pq.ensuredeps.manifest.load</code> audit with <code>manifestsHash</code>. <br>4. In <code>fastMode=true</code> only include essential fields to minimize host calls; schedule fuller manifest retrieval in worker when operator triggers full check. <br><strong>Edge cases:</strong> corrupted hidden-sheet -> emit <code>pq.ensuredeps.manifest.load</code> with <code>result=malformed</code> and <code>evidenceRef</code> pointing to sanitized manifest snapshot. <br><strong>Observability:</strong> <code>pq.ensuredeps.manifest.load</code> with <code>manifestCount</code>, <code>invalidCount</code>, <code>durationMs</code>. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>InspectInstalledAddins(hostApi, correlationId)</code></strong><br><strong>Purpose & contract:</strong> enumerate installed add-ins and provider bindings visible to Power Query and compute signature/trust status per add-in. <br><strong>Return:</strong> <code>{installedAddins:[{name,path,version,enabled,signedBy,signatureValid}], connectors:[{providerId, registered, implementingModule, version}], summary}</code>. <br><strong>Behavior:</strong><br>1. Use host APIs for installed add-ins and provider registration; do not change host state. <br>2. Validate code-signing metadata if available and cross-reference <code>OWNERS.md</code> for owner identity mapping; record <code>signedBy</code> as ownerId or <code>UNKNOWN</code>. <br>3. If multiple versions exist, choose highest deterministically using <code>compareSemver</code> fallback to lexical sort with stable tie-breaker. <br>4. If provider registration malformed or missing expected entrypoint, mark <code>status=MISSING_BINDING</code>. <br><strong>Observability:</strong> <code>pq.ensuredeps.addin.scan</code> with <code>installedCount</code>, <code>untrustedCount</code>, <code>missingBindings</code>. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>ResolveRemoteManifests(templateRepoConfig, correlationId, cachePolicy)</code></strong><br><strong>Purpose & contract:</strong> worker-only resolution of remote repo indexes and connector capability manifests; produce signed snapshot stored in encrypted evidence store. <br><strong>Parameters:</strong> <code>templateRepoConfig</code> (primary URL, mirrors, authRef), <code>correlationId</code>, <code>cachePolicy</code> (ttl, preferCached). <br><strong>Return:</strong> <code>{snapshotHash, snapshotRef, status, diagnostics}</code>. <br><strong>Detailed behavior (must/shall):</strong><br>1. Attempt fetch from primary; on failure iterate mirrors; on each fetch perform HTTP validation, ETag/Last-Modified checks, and compute <code>mChecksum</code> for each template manifest and template payload. <br>2. Validate index and manifests against JSON Schema (v1/v2). <br>3. For each template entry compute canonical payload (strip non-deterministic fields, normalize line endings) and compute <code>mChecksum</code> (SHA256). <br>4. Cache raw response and parsed canonical snapshot encrypted in evidence store. <br>5. Emit <code>pq.ensuredeps.remote.resolve.completed</code> with <code>snapshotHash</code> and <code>durationMs</code>. <br><strong>Failure handling & degrade modes:</strong><br>1. Network failure -> status <code>DEGRADED</code> and return last cached snapshot if available with <code>degradedRationale=network_unreachable</code>. <br>2. Schema invalid -> status <code>INVALID_REMOTE_MANIFEST</code> and set <code>degraded=true</code> with evidenceRef. <br><strong>Security & auth:</strong> use secure authRef token via secure credential manager; never log the token. <br><strong>Observability:</strong> <code>pq.ensuredeps.remote.resolve.attempt</code> and <code>completed</code> audits. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>ValidateConnectorVersion(requiredConnectorSpec, installedConnectors, correlationId)</code></strong><br><strong>Purpose & contract:</strong> validate that installed connectors satisfy the <code>requiredConnectorSpec</code> (semver ranges, capabilities, provider ids). <br><strong>Return:</strong> <code>{name, requiredRange, installedVersion, status, rationale, candidates}</code> where <code>status</code> ∈ {OK, WARNING, MISMATCH, MISSING}. <br><strong>Behavior details:</strong><br>1. Support semver ranges as well as capability predicates (eg <code>supportsLoadToModel=true</code>, <code>supportsOAuth2=true</code>). <br>2. For vendors with non-semver schemes, map vendor versions to compatibility levels using <code>compatibilityMatrix</code> shipped in release manifest. <br>3. When several candidates available choose highest compatible one deterministically. Emit <code>pq.ensuredeps.connector.validate</code> audit. <br>4. If installed version within known-broken set, mark <code>status=KNOWN_BROKEN</code> and attach <code>workaround=useWorkerExecution</code> if applicable. <br><strong>Edge cases:</strong> connector installed but provider registration missing -> <code>status=MISSING_BINDING</code>. <br><strong>Repair suggestions:</strong> provide <code>repairActions: [&quot;installConnector&quot;, &quot;registerProvider&quot;, &quot;upgradeConnector&quot;]</code> with secure download references in evidenceRef. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>ValidatePQRuntimeVersion(installedRuntimeInfo, requiredRuntimeRange, correlationId)</code></strong><br><strong>Purpose & contract:</strong> verify host M/runtime compatibility; return <code>{installedVersion, status, rationale, recommendedAction}</code>. <br><strong>Behavior & mapping:</strong><br>1. Normalize runtime identifiers across hosts (Excel, PowerBI Desktop, Server) via <code>runtimeMap</code>. <br>2. Compare installed runtime to required ranges expressed by templates & connectors. <br>3. If below minimum set <code>status=INCOMPATIBLE</code> and <code>recommendedAction=upgradeHostOrUseWorker</code>. If above maximum (preview channel), set <code>status=UNTESTED</code> and recommend two-person approval for regulated templates. <br>4. Emit <code>pq.ensuredeps.pqruntime.validate</code> audit with <code>installedVersion</code> and <code>status</code>. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>EnsureTemplateCompatibility(manifestsList, resolvedSnapshot, installedConnectors, pqRuntime, correlationId, policy)</code></strong><br><strong>Purpose & contract:</strong> iterate templates and produce detailed compatibility entries including repair actions and evidenceRefs; return <code>TemplateCompatibilityReport</code>. <br><strong>Detailed steps:</strong><br>1. For each template determine <code>requiredConnectors</code>, <code>minRuntime</code>, <code>maxRuntime</code>, <code>signaturePolicy</code>, and <code>requiresHighPrecision</code>. <br>2. Validate connectors with <code>ValidateConnectorVersion</code> and runtime with <code>ValidatePQRuntimeVersion</code>. <br>3. Verify signature via <code>VerifyTemplateSignature</code> when <code>signaturePolicy==REQUIRED</code>; for <code>OPTIONAL</code> emit <code>signaturePresent=true/false</code>. <br>4. If <code>requiresHighPrecision=true</code> and runtime is <code>UNTESTED/INCOMPATIBLE</code> mark <code>recommendWorkerExecution=true</code>. <br>5. Build <code>repairActions</code> array: prioritized, deterministic, with explicit preconditions and idempotency tokens (e.g., <code>installConnector(packageUrl, packageHash)</code> with <code>idempotencyToken</code>). <br>6. Use <code>GenerateDepFingerprint</code> to produce per-template deterministic fingerprint for cache keys. <br><strong>Invariants:</strong> arrays sorted by <code>templateId</code>, deterministic tie-break ordering if multiple repair actions equal weight. <br><strong>Audits:</strong> emit <code>pq.ensuredeps.template.verify</code> per template with <code>compatibilityStatus</code>, <code>repairActions</code>, and <code>evidenceRef</code> links. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>VerifyTemplateSignature(templateBlob, signatureBlob, allowedOwners, correlationId)</code></strong><br><strong>Purpose & contract:</strong> cryptographically verify template signatures per <code>signaturePolicy</code>; return <code>{signatureValid, signerId, certFingerprint, certChainVerified, revocationStatus, evidenceRef}</code>. <br><strong>Implementation details:</strong><br>1. Support both detached signatures and embedded armored signatures (PGP, CMS/PKCS7, JOSE). <br>2. Validate signature algorithm allowed list (e.g., RSA-PSS, ECDSA with appropriate key lengths). <br>3. Validate certificate chain against release manifest trust anchors; perform OCSP/CRL checks when network available; if network unavailable set <code>revocationStatus=DEFERRED</code> and emit <code>pq.ensuredeps.template.signature</code> audit with <code>revocationDeferred=true</code>. <br>4. If signer not in <code>allowedOwners</code> set <code>signatureValid=false</code> and provide <code>repairAction: getOwnerApproval</code> or <code>rejectInjection</code>. <br>5. For regulated templates where owner mismatch occurs, require two-person approval before any injection or repair. <br><strong>Observability:</strong> <code>pq.ensuredeps.template.signature</code> audit with <code>signerId</code> and <code>evidenceRef</code> for signature blob. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>ProduceDepsReport(manifestsSnapshot, installedDeps, resolvedRemoteSnapshot, pqRuntimeInfo, correlationId, outputPath, options={stageLocal:false})</code></strong><br><strong>Purpose & contract:</strong> assemble the canonical, deterministic <code>deps.report.json</code> and persist it via <code>AtomicWriteDepsReport</code>. Return <code>{artifactPath, artifactChecksum, reportHash, persistedAt}</code>. <br><strong>Report content (canonical schema):</strong><br>• <code>correlationId</code><br>• <code>runTs</code> (UTC ISO8601)<br>• <code>configHash</code><br>• <code>releaseManifestHash</code><br>• <code>templates</code> array of <code>{templateId, mChecksum, compatibilityStatus, repairActions, signaturePolicy, owner}</code><br>• <code>connectors</code> array of <code>{name, requiredRange, installedVersion, status}</code><br>• <code>pqRuntime</code> object <code>{installedVersion, status}</code><br>• <code>degraded</code> boolean and <code>degradedReasons</code><br>• <code>evidenceRefs</code> mapping resource->evidenceRef<br>• <code>reportHash</code> (SHA256 canonical JSON) <br><strong>Canonicalization rules (must):</strong> keys sorted lexicographically at each object level; arrays sorted by <code>templateId</code> or <code>connectorName</code>; fixed field ordering for stable <code>reportHash</code>; UTF-8, normalized NFKC for strings, normalized newline <code>\n</code>. <br><strong>Persistence & atomic write:</strong> call <code>AtomicWriteDepsReport</code> with payload stream and sidecar <code>report.metadata.json</code> containing <code>reportHash</code>, <code>correlationId</code>, <code>evidenceRefs</code>. If <code>options.stageLocal=true</code> write to staging area when final destination unreachable and set <code>degraded=true</code> with <code>degradedRationale=&quot;destination_unavailable&quot;</code>. <br><strong>Observability:</strong> emit <code>pq.ensuredeps.report.generated</code> containing <code>reportHash</code> and <code>artifactChecksum</code> after successful atomic write. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>AtomicWriteDepsReport(targetPath, payloadStream, correlationId, tmpSuffix=&quot;.part&quot;, maxAttempts=3)</code></strong><br><strong>Purpose & contract:</strong> specialized wrapper calling plumbing atomic-write utility; ensure fsync and parent fsync semantics where supported; create sidecar <code>report.metadata.json</code>. Return <code>{success, artifactPath, artifactChecksum, attempts, elapsedMs}</code>. <br><strong>Behavior:</strong><br>1. Compute tempPath deterministically: <code>targetPath + tmpSuffix + &quot;.&quot; + pid + &quot;.&quot; + deterministicSuffix</code> where deterministicSuffix derived from <code>GenerateDepFingerprint</code>. <br>2. Write payload stream to tempPath, compute SHA256, optionally write sidecar metadata including <code>payloadHash</code> and <code>correlationId</code>. <br>3. fsync file and parent directory where supported; call platform atomic replace API (<code>os.replace</code> on POSIX, ReplaceFile on Windows). <br>4. Reopen targetPath and verify checksum matches computed artifactChecksum; if mismatch emit <code>pq.ensuredeps.report.atomic_write.verification_failed</code> and attempt repair per retry policy. <br><strong>Degraded behavior:</strong> when rename semantics unreliable (NFS/SMB), fallback to copy-then-rename pattern with <code>pq.ensuredeps.degraded</code> audit and explicit <code>repairActions</code>. <br><strong>Observability:</strong> <code>pq.ensuredeps.report.atomic_write.attempt</code> and <code>pq.ensuredeps.report.atomic_write.completed</code>. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>GenerateDepFingerprint(manifestsSnapshot, installedDeps, pqRuntime, salt=null)</code></strong><br><strong>Purpose & contract:</strong> produce deterministic fingerprint for dependency surface used for caching and golden testing; use HMAC_SHA256 over canonical serialized snapshot with optional salt. <br><strong>Return:</strong> <code>{fingerprintHex, fingerprintShort}</code> where <code>fingerprintShort</code> is first 12 hex chars. <br><strong>Usage:</strong> seeds for deterministic jitter in CI, cache keys, and stable grouping in telemetry. <br><strong>Observability:</strong> <code>pq.ensuredeps.fingerprint</code> audit with component counts. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>InspectTempArtifacts(directory, correlationId)</code></strong><br><strong>Purpose:</strong> enumerate left-over temporary artifacts from failed atomic writes, validate sidecar metadata if present, and surface repair suggestions. <br><strong>Output:</strong> <code>{tempFiles:[{path,size,payloadHash,valid}], validatedCount, suggestions:[{path,action}]}</code>. <br><strong>Observability:</strong> <code>pq.ensuredeps.temp.inspect</code> audit. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>RepairMissingDeps(repairProposal, dryRun=true, operatorApproval=null, correlationId)</code></strong><br><strong>Purpose & contract:</strong> generate and optionally apply repair steps to satisfy compatibility; actions are proposals by default — apply requires explicit operator approval and possibly two-person approval for regulated items. <br><strong>Repair step format (must):</strong> each step includes <code>idempotencyToken</code>, <code>actionType</code>, <code>parameters</code>, <code>preconditions</code>, <code>estimatedImpact</code>, <code>rollbackPlan</code>, <code>evidenceRef</code> for downloaded package. Example action types: <code>downloadConnector</code>, <code>registerProvider</code>, <code>enableHiddenSheetTemplate</code>, <code>promoteSnapshotToLocal</code>. <br><strong>Safety constraints:</strong> do not perform system-level changes without operator approval and required governance; when <code>requiresSystemChange=true</code> require SRE sign-off. <br><strong>Audit:</strong> <code>pq.ensuredeps.repair.attempt</code> and <code>pq.ensuredeps.repair.success</code> with <code>repairPlanHash</code>. <br><strong>Observability:</strong> record full plan in evidence store and persist <code>repair.plan.json</code> via <code>AtomicWrite</code>. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong><code>DiagnoseDepsFailure(correlationId, failureContext, deepDiagnostics=false)</code></strong><br><strong>Purpose:</strong> collect a focused forensic bundle to triage dependency failures; include <code>deps.report.json</code>, <code>manifest snapshots</code>, <code>signature blobs</code>, <code>atomicWrite</code> failure logs, and <code>InspectTempArtifacts</code> outputs. <br><strong>Output:</strong> <code>diagnosticBundleRef</code> pointing to encrypted bundle in evidence store. <br><strong>Observability:</strong> <code>pq.ensuredeps.diagnose</code> audit referencing <code>diagnosticBundleRef</code>. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Error taxonomy & representative error codes (expanded):</strong><br>• <code>PQ_DEPS_OK</code> — nominal. <br>• <code>PQ_DEPS_DEGRADED_NETWORK</code> — remote manifests unreachable; <code>repair: run remote resolve on worker</code>. <br>• <code>PQ_DEPS_MISSING_CONNECTOR</code> — connector missing; <code>repair: installConnector</code>. <br>• <code>PQ_DEPS_INCOMPATIBLE_RUNTIME</code> — runtime not supported; <code>repair: upgradeHostOrUseWorker</code>. <br>• <code>PQ_DEPS_TEMPLATE_UNTRUSTED</code> — missing/invalid signature; <code>repair: ownerApprovalRequired</code>. <br>• <code>PQ_DEPS_ATOMIC_WRITE_ENOSPC</code> — ENOSPC while persisting report; <code>runbook: stage-local or free-space</code>. <br>• <code>PQ_DEPS_ATOMIC_WRITE_EPERM</code> — EPERM; <code>runbook: fix-perms</code>. <br>• <code>PQ_DEPS_SIGNATURE_DEFERRED</code> — revocation check deferred due to network. <br>• <code>PQ_DEPS_AMBIGUOUS_CONNECTOR</code> — multiple installed candidates; <code>repair: pickPreferred</code> or <code>uninstallAlternates</code>. <br>Each error provides operator guidance in <code>repairActions</code> and maps to specific runbook steps. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Observability, telemetry & audit schema (detailed):</strong><br><strong>Audit schema fields (required):</strong> <code>timestamp</code>, <code>correlationId</code>, <code>module=PQ_EnsureDeps</code>, <code>procedure</code>, <code>operatorId</code> (optional), <code>paramsHash</code>, <code>resultHash</code> (optional), <code>evidenceRef</code> (optional), <code>durationMs</code>, <code>metadata</code> containing <code>templatesChecked</code>, <code>connectorsChecked</code>, <code>untrustedCount</code>, <code>degraded</code>. <br><strong>Primary audit events:</strong> <code>pq.ensuredeps.start</code>, <code>pq.ensuredeps.manifest.load</code>, <code>pq.ensuredeps.remote.resolve.completed</code>, <code>pq.ensuredeps.template.verify</code>, <code>pq.ensuredeps.report.generated</code>, <code>pq.ensuredeps.report.atomic_write.completed</code>. <br><strong>Metrics to buffer:</strong> <code>pq.ensuredeps.scan_latency_ms</code>, <code>pq.ensuredeps.remote.resolve_latency_ms</code>, <code>pq.ensuredeps.report_write_latency_ms</code>, <code>pq.ensuredeps.degraded_rate</code>, <code>pq.ensuredeps.untrusted_templates_count</code>. <br><strong>Evidence policy:</strong> audit rows reference only hashes and <code>evidenceRef</code>; full manifests, signatures and signed snapshots stored encrypted and access-controlled. PII cannot appear in top-level audit fields. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Testing matrix, property tests, and CI governance (comprehensive):</strong><br><strong>Unit tests (must include):</strong><br>1. <code>LoadLocalManifests</code>: hidden-sheet present/absent, malformed entries, ensure canonical ordering and <code>manifestsHash</code>. <br>2. <code>ResolveRemoteManifests</code>: healthy and faulty network cases, schema invalid manifests, caching TTL behaviors. <br>3. <code>VerifyTemplateSignature</code>: valid signatures, invalid signatures, revoked certs, deferred revocation. <br>4. <code>ValidateConnectorVersion</code>: semver ranges, vendor-specific mapping, ambiguous multiple installs. <br>5. <code>AtomicWriteDepsReport</code>: rename/fsync failure simulation using FS mocks. <br><strong>Integration tests:</strong><br>1. Full end-to-end produce-report roundtrip: local manifest -> remote resolve -> signature verify -> produce <code>deps.report.json</code> persisted and checksum verified. <br>2. Worker-only remote resolve combined with UI fast-scan verifying consistent <code>reportHash</code> across runs. <br>3. Concurrency test: multiple parallel producers writing to same destination -> atomic writes prevent partial reads. <br><strong>Property tests:</strong><br>1. Determinism: repeated <code>ProduceDepsReport</code> with same inputs yields identical <code>reportHash</code> across platforms. <br>2. Repair idempotence: applying same <code>RepairMissingDeps</code> twice yields no duplicate system changes; step idempotency tokens enforced. <br><strong>Cross-language golden governance:</strong> maintain golden <code>mChecksum</code> and <code>reportHash</code> vectors across implementations (VBA/JS/Python/C#) and ensure parity. <br><strong>CI gating:</strong> static analyzer must flag network calls from UI fast-path; golden vector parity required; signature verification tests require test CA chain in pipeline. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Developer guidance, allowed & forbidden patterns (explicit):</strong><br><strong>Required patterns:</strong><br>1. Use <code>LoadLocalManifests</code> for quick UI checks and schedule <code>ResolveRemoteManifests</code> on workers for authoritative checks. <br>2. Persist the canonical <code>deps.report.json</code> via <code>AtomicWriteDepsReport</code> for consumers. <br>3. Use deterministic <code>GenerateDepFingerprint</code> for cache keys and deterministic_jitter seeds in CI. <br>4. Always emit audits for major transitions and include <code>evidenceRef</code> when raw artifacts are stored. <br><strong>Forbidden patterns:</strong><br>1. No network requests on UI fast-path. <br>2. Do not auto-install system-wide connectors without explicit operator approval plus required governance. <br>3. Do not write PII into audit rows—use evidenceRef for sanitized content. <br>4. No locale-dependent sorting/formatting for canonicalization. <br><strong>Code-review checklist:</strong> verify audit emits exist, <code>AtomicWriteDepsReport</code> used, deterministic ordering enforced, signature verification present for <code>signaturePolicy=REQUIRED</code>, UI-thread safety validated, and tests/goldens present. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Operator runbook & incident playbooks (executable steps):</strong><br><strong>AtomicWrite ENOSPC runbook:</strong><br>1. Inspect <code>pq.ensuredeps.report.atomic_write.failure</code> audit for correlationId and <code>targetPath</code>. <br>2. Run <code>InspectTempArtifacts</code> to list temp files and capture <code>tempPaths</code> into <code>forensic_manifest.json</code>. <br>3. Free space on the mount or configure <code>deps.output.staging</code> and re-run <code>ProduceDepsReport --stageLocal true</code>. <br>4. Verify <code>pq.ensuredeps.report.atomic_write.completed</code> and compare checksums; if failure persists escalate to infra with <code>forensic_manifest</code> and audit_tail. <br><strong>Untrusted template runbook:</strong><br>1. Retrieve <code>pq.ensuredeps.template.signature</code> with <code>evidenceRef</code>. <br>2. Use offline verification tool to inspect certificate chain and check revocation if network blocked. <br>3. If signer unknown, consult OWNERS.md; require owner approval for regulated templates. <br>4. Optionally fallback to <code>lastKnownGood</code> snapshot and emit <code>pq.ensuredeps.repair.attempt</code>. <br><strong>PQ runtime incompatible triage:</strong><br>1. Confirm <code>pq.ensuredeps.pqruntime.validate</code> audit; collect <code>installedRuntimeVersion</code>. <br>2. If upgrade allowed, coordinate host upgrade with release manifest compatibility checks; else, run the template in a trusted worker and persist proofs. <br>3. For preview channel (untested newer runtime) require two-person approval for regulated templates. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Extremely detailed narratives & examples — expanded (multiple scenarios):</strong><br><strong>Scenario A — Operator preview & inject path for high-precision regulated template (full trace):</strong><br>1. Operator selects "Preview -> Inject" on template <code>rev-recog-v3</code> from PQ_Ribbon. Ribbon computes <code>correlationId=r-20260117-xyz</code>. Ribbon calls <code>LoadLocalManifests(workbookSnapshot, correlationId, fastMode=true)</code> which returns <code>manifest</code> for <code>rev-recog-v3</code> with <code>requiresHighPrecision=true</code> and <code>signaturePolicy=REQUIRED</code>. <code>pq.ensuredeps.manifest.load</code> audit emitted. <br>2. Add-in schedules a worker job to run <code>ResolveRemoteManifests(templateRepoConfig, correlationId)</code> because <code>requiresHighPrecision=true</code> and signature policy is strict; on worker the remote snapshot is fetched and <code>snapshotHash</code> computed; <code>pq.ensuredeps.remote.resolve.completed</code> audit emitted. <br>3. Worker invokes <code>EnsureTemplateCompatibility</code> which calls <code>ValidateConnectorVersion</code> for connectors <code>FinancialSource</code> and <code>JournalWriter</code>. <code>ValidatePQRuntimeVersion</code> shows host runtime <code>excel:2304</code> OK; <code>FinancialSource</code> is missing locally. The report entry for the template is <code>DEGRADED</code> with <code>repairAction: downloadConnector FinancialSource</code>. <code>pq.ensuredeps.template.verify</code> audit emitted with <code>repairActions</code>. <br>4. Since template <code>signaturePolicy=REQUIRED</code>, worker calls <code>VerifyTemplateSignature</code> using detached <code>.sig</code> artifact from the remote snapshot; signature validated and <code>signerId=TEAM_FINANCE</code> recorded. <code>pq.ensuredeps.template.signature</code> audit emitted with <code>evidenceRef</code>. <br>5. <code>ProduceDepsReport</code> produces canonical <code>deps.report.json</code> including the <code>DEGRADED</code> flag and <code>repairActions</code> and persists it via <code>AtomicWriteDepsReport</code>. <code>pq.ensuredeps.report.atomic_write.completed</code> emitted with artifact checksum. <br>6. Operator receives preview UI indicating <code>DEGRADED</code> for injection and a suggested repair to download connector <code>FinancialSource</code>. Operator requests <code>repairProposal</code> and approves to proceed with <code>RepairMissingDeps</code> under two-person-approval policy. Repair writes <code>repair.plan.json</code> via <code>AtomicWrite</code> and <code>pq.ensuredeps.repair.success</code> is audited. <br>7. After repair (connector installed in staging and registered), worker re-runs compatibility check and now <code>compatibilityStatus=OK</code>. Authoritative worker run performs final high-precision transforms using <code>SafeRound</code> primitives in worker, writes authoritative artifact via <code>AtomicWrite</code>, and <code>pq_inject</code> audit references the artifact checksum. <br><strong>Takeaway:</strong> separation of fast local manifests vs worker authoritative checks preserves UI responsiveness while maintaining compliance and determinism. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Scenario B — CI pipeline for template release requiring new connector capability (trace):</strong><br>1. Developer submits PR updating template <code>agg-sales-v5</code> to require <code>NewProvider&gt;=2.0</code>. CI job triggers and runs <code>ResolveRemoteManifests</code> against canonical test repo and <code>VerifyTemplateSignature</code> using the test CA. <code>pq.ensuredeps.remote.resolve.completed</code> and <code>pq.ensuredeps.template.signature</code> audits produced by CI harness. <br>2. CI validates <code>ValidateConnectorVersion</code> finds <code>NewProvider</code> absent in golden environment -> CI fails with <code>PQ_DEPS_MISSING_CONNECTOR</code>. Developer must add compatibility notes or provide vendor package. <br>3. Developer packages connector stub into test repo; CI re-runs and <code>GenerateDepFingerprint</code> produces fingerprint used in gating. CI asserts <code>reportHash</code> matches golden vectors and cross-platform parity tests for <code>mChecksum</code> pass; only then PR can merge. <br>4. Merge triggers release manifest update and owner approvals. Release manifest records new trust anchors if connector vendor signing required. <br><strong>Takeaway:</strong> CI acts as pre-flight gate to prevent templates reaching operator desks without necessary connectors or approvals. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Scenario C — Forensic reconstruction after injection mismatch:</strong><br>1. Operator reports that injected query code differs from canonical template for <code>correlationId=r-20260112-455</code>. Support runs <code>DiagnoseDepsFailure(correlationId, context)</code> which collects <code>deps.report.json</code>, <code>manifestSnapshot</code>, <code>signatureBlobs</code>, and <code>audit_tail</code>. <code>pq.ensuredeps.diagnose</code> audit emitted with <code>diagnosticBundleRef</code>. <br>2. Forensic replay uses <code>manifestSnapshot</code> and <code>evidenceRef</code> to reconstruct what <code>LoadLocalManifests</code> returned at run time; it finds the workbook had <code>templateId</code> <code>agg-sales-v4</code> but <code>mChecksum</code> mismatched (local edit) and signature absent. <code>pq.ensuredeps.template.verify</code> shows <code>mChecksum_mismatch</code>. <br>3. Support restores the canonical template and produces <code>forensic_manifest.json</code> and recommended mitigation: lock hidden-sheet templates for regulated flows and enforce <code>VerifyTemplateSignature</code> at injection. <br>4. Post-mortem: operator education plus adding static checks to disallow unsanctioned template edits in regulated contexts. <br><strong>Takeaway:</strong> evidenceRef and canonical <code>deps.report</code> allow deterministic replay and attribution. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Scenario D — Worker-only fallback for numeric fidelity across PQ host variance:</strong><br>1. Template <code>calc-alloc-v2</code> flagged <code>requiresHighPrecision=true</code>. Host runtime <code>excel:legacy</code> may have inconsistent decimal behavior. <code>EnsureTemplateCompatibility</code> recommends worker execution. <br>2. Add-in delegates numeric aggregation to worker: export normalized payload via <code>AtomicWrite</code> to staging area, worker runs <code>SafeRoundResiduals</code> with deterministic RNG seeded from <code>correlationId</code>, persists authoritative result via <code>AtomicWrite</code>, and injects read-only query into workbook referencing the authoritative artifact. <br>3. The <code>deps.report.json</code> records <code>requiresHighPrecision</code> and <code>executionMode=worker</code> to indicate authoritative steps occurred off-host. <code>pq.ensuredeps.report.generated</code> audit links to artifact checksum and RNG evidenceRef. <br><strong>Takeaway:</strong> for numeric regulated outputs, worker-side SafeRound and atomic persistence ensure cross-host parity and auditability. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Deep conceptual mapping to Power Query (M) — patterns and concrete guidance:</strong><br><strong>Context:</strong> M runtimes vary by host and version; PQ_EnsureDeps cannot change M runtime but must orchestrate around its limitations. Patterns below enforce deterministic behaviors and govern where sensitive transforms must run. <br><strong>Pattern 1 — Atomic persistence for injection & templates:</strong><br>1. Problem: M/host cannot guarantee atomic replace semantics or consistent folder fsync. <br>2. Pattern: generate canonical M query text in the trusted helper (add-in or worker), compute <code>mChecksum</code>, persist with <code>AtomicWriteDepsReport</code> to artifact store, then call <code>Workbook.Queries.Add(Name, Formula)</code> using the persisted payload. <br>3. Evidence: emit <code>pq_inject</code> audit linking <code>artifactChecksum</code> and <code>mChecksum</code>. <br>4. Governance: for regulated templates require signature validated by <code>VerifyTemplateSignature</code>. <br><strong>Pattern 2 — Deterministic preview & sampling in M:</strong><br>1. Problem: M lacks a canonical seedable RNG and host-level sampling implementations differ. <br>2. Pattern A (lightweight): host computes seed <code>SeedFromCorrelation(correlationId, templateId)</code> and passes it as a numeric parameter to M preview code implementing a pure M PRNG (e.g., linear congruential with documented parameters). M preview records the seed in preview audit. <br>3. Pattern B (heavy duty): perform sampling in worker using <code>DeterministicRNG</code> and persist sampling decisions (sampled keys, RNG state) in evidence store; M receives only deterministic sampled payload. <br>4. Replay: audits include seed and evidenceRef allowing exact reproduction. <br><strong>Pattern 3 — High-precision numeric transforms:</strong><br>1. Problem: M decimal fidelity and rounding semantics vary across hosts. <br>2. Pattern: templates declare <code>requiresHighPrecision=true</code>. For such templates, add-in orchestrator exports raw normalized data via <code>AtomicWrite</code> and delegates authoritative rounding/allocation to worker SafeRound primitives. Worker persists final artifact and returns an injected read-only query or refresh connection. <br>3. Auditing: <code>pq.ensuredeps.report.generated</code> includes <code>requiresHighPrecision</code> and <code>executionMode=worker</code>. <br><strong>Pattern 4 — Template signature & owner enforcement:</strong><br>1. Problem: local template edits or unsigned templates undermine governance. <br>2. Pattern: require <code>VerifyTemplateSignature</code> for templates with <code>signaturePolicy=REQUIRED</code>. If missing or invalid, block injection unless two-person approval is present; persist decision via audit. <br><strong>Pattern 5 — Retry & idempotency around PQ operations:</strong><br>1. Problem: injection or connection creation may fail transiently; retry semantics necessary. <br>2. Pattern: orchestrator uses <code>Retry</code> wrapper and persists <code>jobDescriptor</code> for idempotency prior to attempting injection so retries do not produce duplicates. <br><strong>Operator narrative (PQ injection step-by-step):</strong><br>1. Operator requests inject → <code>LoadLocalManifests</code> quick-scan → <code>EnsureTemplateCompatibility</code> determines <code>signaturePolicy</code> and <code>requiresHighPrecision</code>. <br>2. If signature required, call <code>VerifyTemplateSignature</code>; if unsigned, require approval. <br>3. Persist canonical M artifact via <code>AtomicWriteDepsReport</code>. <br>4. Call <code>Workbook.Queries.Add</code> with payload; emit <code>pq_inject</code> audit linking artifact checksum and <code>mChecksum</code>. <br><strong>Governance note:</strong> for regulated templates require signed release manifest and enforced static analyzer blocking injection of modified local templates. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Deep conceptual mapping to DAX & semantic model design (expanded):</strong><br><strong>Context:</strong> DAX is read-time and cannot perform side effects; authoritative decisions must be made in ETL or worker layers. PQ_EnsureDeps ensures model authors and consumers can rely on deterministic ETL and metadata. <br><strong>Pattern 1 — Push rounding and residuals to ETL:</strong><br>1. Rationale: DAX can't persist rounding decisions or side-effects required for residual distribution. <br>2. Pattern: run <code>SafeRoundResiduals</code> in worker, persist everything as integer cents in model tables; DAX then computes sums and KPIs deterministically. <br>3. Evidence: store <code>RunMetadata</code> row for the run with <code>correlationId</code>, <code>artifactChecksum</code>, <code>depsReportHash</code>. <br><strong>Pattern 2 — Deterministic sampling via hashed keys:</strong><br>1. Rationale: DAX lacks seedable PRNGs for reproducible sampling. <br>2. Pattern: ETL computes <code>HashKey = HMAC_SHA256(PrimaryKey | correlationSalt)</code> and stores <code>sampleFlag = (HashKey MOD N) &lt; k</code>. Persist <code>correlationSalt</code> in <code>RunMetadata</code>. DAX can apply filter <code>sampleFlag=1</code> to create deterministic report slices. <br><strong>Pattern 3 — Model-level RunMetadata table and reconciliation:</strong><br>1. ETL writes <code>RunMetadata</code> atomically with dataset artifact and <code>deps.report.json</code> data. <br>2. DAX measures reference <code>RunMetadata</code> to compute <code>ReconciledFlag</code> by comparing expected artifact checksum to the run's artifact checksum. DAX formula example (descriptive): compute <code>IsReconciled</code> measure based on equality of artifact checksum fields persisted in model. <br><strong>Pattern 4 — Surface <code>degraded</code> and <code>repairActions</code> in model:</strong><br>1. ETL includes <code>degraded</code> boolean and <code>degradedReasons</code> in <code>RunMetadata</code>. DAX or report visuals can surface <code>DegradedIndicator</code> to warn consumers that dataset used degraded fallbacks. <br><strong>Pattern 5 — Traceability from report measure back to PQ_EnsureDeps:</strong><br>1. Include <code>depsReportHash</code> in <code>RunMetadata</code> and in the workbook template injected; UI surfaces provide "View deps report" linking to evidenceRef for investigator use. <br><strong>Governance & operator guidance for models:</strong><br>1. Never implement allocation/residual distribution in DAX. <br>2. Use ETL-run <code>RunMetadata</code> to ensure report consumers can verify dataset provenance. <br>3. When a model shows <code>DegradedIndicator</code>, require human review before using dataset for regulated reporting. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Extended forensic artifacts & retention — practical details:</strong><br><strong>Minimum forensic artifact set for a run:</strong><br>1. <code>deps.report.json</code> persisted atomically containing <code>reportHash</code> and artifact checksum. <br>2. <code>manifestSnapshot.blob</code> encrypted evidenceRef with canonical manifests and <code>snapshotHash</code>. <br>3. <code>signatureBlobs</code> for templates with <code>evidenceRef</code>. <br>4. <code>diagnosticBundle.zip</code> containing <code>audit_tail.csv</code>, preserved temp artifacts, and <code>forensic_manifest.json</code>. <br>5. <code>serializedRNGState</code> if deterministic sampling or tie-breaks used. <br>6. <code>SafeRound</code> input snapshots (canonical decimals) and rounding logs. <br>7. <code>atomicWrite</code> temp files and their sidecar metadata. <br><strong>Storage & retention:</strong><br>1. Hot: <code>\\evidence\hot\pq_ensuredeps\&lt;correlationId&gt;\</code> for 30 days. <br>2. Warm: secure archive for regulatory retention up to 7 years. <br>3. Cold: vault with chain-of-custody metadata as required by regulation. <br><strong>Access & controls:</strong> evidence blobs encrypted and role-based access; audit logging for evidence retrieval. <br><strong>Retention verification:</strong> monthly retention job emits <code>housekeeping.audit</code> and proof-of-delete for expired evidence. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Acceptance checklist before module release (expanded):</strong><br>1. OWNERS listed and contactable in OWNERS.md. <br>2. Public API stable, documented, semver versioning in manifests. <br>3. <code>LoadLocalManifests</code> uses no network and passes static analyzer. <br>4. Cross-platform golden vectors for <code>mChecksum</code> and <code>reportHash</code> present. <br>5. Signature verification tests included with test CA chain. <br>6. AtomicWrite tests and temp artifact recovery proofs present. <br>7. Audit hooks integrated and validated with test harness emitting expected audit rows. <br>8. Two-person approval flows tested for regulated repair scenarios. <br><strong>Blocking conditions:</strong> missing audit emissions, failing golden vectors, or static analyzer detection of forbidden UI-thread operations. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Comprehensive test plan highlights & scripts (explicit conceptual):</strong><br><strong>Unit tests:</strong><br>1. <code>LoadLocalManifests</code>: hidden-sheet present, absent, malformed; assert <code>manifestsHash</code>. <br>2. <code>ResolveRemoteManifests</code>: simulate 200 OK, 500 errors, TTL expiry. <br>3. <code>VerifyTemplateSignature</code>: valid, invalid, revoked, deferred. <br>4. <code>ValidateConnectorVersion</code>: semver range matching, vendor mapping. <br>5. <code>AtomicWriteDepsReport</code>: simulate ENOSPC/EACCES/rename failure via FS mocks. <br><strong>Integration tests:</strong><br>1. Full roundtrip: local manifest -> remote -> signature -> produce <code>deps.report.json</code> -> readback verify. <br>2. Concurrent producers: multiple processes writing to same target path, assert no partial reads. <br>3. Worker fallback: host runtime incompatible -> worker run executes final tasks and writes <code>deps.report.json</code> with <code>executionMode=worker</code>. <br><strong>Property tests:</strong><br>1. Determinism: canonicalization property ensures identical <code>reportHash</code> across permutations. <br>2. Idempotence: applying <code>RepairMissingDeps</code> twice is a no-op. <br><strong>Performance tests:</strong><br>1. Local manifest scan under 10k templates embedded in library. <br>2. Remote resolve performance under large index (10k templates). <br><strong>CI gating:</strong> unit/integration/goldens and static checks mandatory. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Operator commands & quick references (one-liners):</strong><br>1. <code>pq_ensuredeps scan --correlation r-YYYYMMDD-abc --fast</code> — quick local scan. <br>2. <code>pq_ensuredeps resolve-remote --correlation r-... --force</code> — worker-only full resolution. <br>3. <code>pq_ensuredeps produce-report --out deps.report.json --correlation r-...</code> — produce canonical report. <br>4. <code>pq_ensuredeps repair --plan repair.plan.json --apply --approvals &lt;a,b&gt;</code> — apply repair with approvals. <br>5. <code>pq_ensuredeps diagnose --correlation r-... --output diagbundle.zip</code> — produce diagnostic bundle for SRE. <br><strong>When to call SRE:</strong> after <code>AtomicWrite</code> ENOSPC for critical artifacts or repeated <code>ValidateConnectorVersion</code> ambiguity that blocks regulated templates; include forensic_manifest and audit_tail in ticket. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Common failure modes & mitigations (expanded):</strong><br><strong>Failure mode: missing connector on particular host</strong><br>1. Likely cause: per-user vs per-machine install mismatch or provider registration missing. <br>2. Mitigation: recommend unified installation of connector or use worker execution; include <code>repairAction: installConnector</code> with evidenceRef and staged plan. <br><strong>Failure mode: deferred signature revocation checks</strong><br>1. Cause: network policy blocks OCSP/CRL. <br>2. Mitigation: perform revocation checks in worker allowed network context or use cached revocation with <code>revocationDeferred=true</code> and <code>degradedReason</code>. <br><strong>Failure mode: non-deterministic <code>reportHash</code> across hosts</strong><br>1. Cause: non-canonical serialization or locale-sensitive sorting. <br>2. Mitigation: enforce canonical JSON serialization with stable ordering, NFKC normalization, and newline normalization. Add CI golden parity tests. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Governance checklists & PR requirements (explicit):</strong><br>1. PR must include unit tests and golden vectors for new deterministic outputs. <br>2. Changes to signature verification or trust anchors require Security owner approval and release manifest update. <br>3. Changes to <code>AtomicWriteDepsReport</code> semantics require cross-platform regression tests and SRE sign-off. <br>4. Any new repair action modifying system state requires SRE and two-person approval for regulated templates. <br>5. OWNERS approval required for template or connector compatibility policy changes. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Appendix A — <code>deps.report.json</code> canonical schema (descriptive summary):</strong><br><strong>Top-level keys:</strong> <code>correlationId</code>, <code>runTs</code>, <code>configHash</code>, <code>releaseManifestHash</code>, <code>templates</code>, <code>connectors</code>, <code>pqRuntime</code>, <code>degraded</code>, <code>degradedReasons</code>, <code>repairActions</code>, <code>evidenceRefs</code>, <code>reportHash</code>. <br><strong>Policy:</strong> top-level audit rows reference only <code>reportHash</code> and <code>evidenceRef</code>; raw manifests/signatures stored encrypted. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Appendix B — Forensic reconstruction example (explicit):</strong><br><strong>Incident:</strong> injection mismatch for run r-20260112-455. <br><strong>Steps:</strong><br>1. Retrieve <code>pq.ensuredeps.report.generated</code> and <code>pq.ensuredeps.manifest.load</code> audits. <br>2. Pull <code>deps.report.json</code> artifact and <code>manifestSnapshot</code> from evidence store. <br>3. Restore <code>serializedRNGState</code> and <code>SafeRound</code> inputs to reproduce allocation decisions. <br>4. Re-run compatibility checks offline and compare canonical M payloads; produce <code>forensic_manifest.json</code> with artifacts and checksums. <br>5. Package and escalate as required for compliance. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Appendix C — PQ template author checklist (detailed):</strong><br>1. Provide <code>mChecksum</code> in template metadata. <br>2. Specify <code>requiresHighPrecision=true</code> for numeric critical templates. <br>3. Include detached or embedded signature. <br>4. Declare <code>requiredConnectors</code> and <code>minPQRuntime</code>/<code>maxPQRuntime</code>. <br>5. Provide migration notes and compatibility hints. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Appendix D — DAX/report builder checklist (detailed):</strong><br>1. Consume <code>RunMetadata</code> table for provenance. <br>2. Avoid allocation or residual rounding in DAX. <br>3. Use ETL-provided hashed stable keys for deterministic sampling and filters. <br>4. Surface <code>degraded</code> flags and require validation for regulated outputs. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Appendix E — Long-form operator reconstruction example (step-by-step):</strong><br><strong>Incident synopsis:</strong> reported "Allocation mismatch for run r-20260112-455" — sums differ between artifact and ledger. <br><strong>Forensic steps:</strong><br>1. Retrieve <code>UserAction</code> and <code>pq.ensuredeps.*</code> audits for correlationId. <br>2. Pull <code>deps.report.json</code> artifact and <code>manifestSnapshot</code>. <br>3. Pull <code>serializedRNGState</code> and <code>SafeRound</code> canonical decimal snapshots from evidence store. <br>4. Re-run allocation pipeline in reproduce mode using persisted RNG and canonical decimals. <br>5. If reproduction succeeds, package <code>forensic_manifest.json</code> and close incident; if not, collect temp artifacts and <code>atomic_write.verification_failed</code> logs and escalate. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Extremely detailed extra narratives — developer, CI, SRE interactions:</strong><br><strong>Developer scenario — building new template requiring connector feature:</strong><br>1. Developer marks template <code>requiresConnector=AdvancedPull</code> and updates manifest. <br>2. Local dev harness runs <code>LoadLocalManifests</code> to verify manifest schema and runs <code>ResolveRemoteManifests</code> against test repo to produce golden <code>mChecksum</code>. <br>3. Developer includes golden vector in PR and adds compatibility notes and unit tests for <code>ValidateConnectorVersion</code>. <br>4. CI verifies that connector exists in the canonical test repo and verifies <code>reportHash</code> parity. If CI fails <code>PQ_DEPS_MISSING_CONNECTOR</code>, developer must provide connector stub or change template. <br><strong>SRE scenario — repeated atomic-write failures:</strong><br>1. SRE receives <code>pq.ensuredeps.report.atomic_write.failure</code> alerts with ENOSPC across hosts. <br>2. SRE runs <code>InspectTempArtifacts</code> to locate lingering <code>tmp</code> files, cleans up temp artifacts, and frees space or adjusts <code>deps.output.staging</code> configuration. <br>3. SRE updates runbook to include <code>disk-space-sentry</code> to preempt staging failures. <br><strong>Governance scenario — owner change for template:</strong><br>1. Template owner transfer requires updating <code>OWNERS.md</code> and re-signing templates. <br>2. PQ_EnsureDeps CI ensures <code>VerifyTemplateSignature</code> now validates against new owner certificate chain and audit records owner change in <code>releaseManifest</code>. <br>3. Two-person approval required to accept owner changes for regulated templates; PQ_EnsureDeps refuses injection until approvals recorded. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Practical developer examples (guidance, not code snippets):</strong><br><strong>Example — canonicalization rules summary:</strong><br>1. Serialize JSON with lexicographically sorted object keys; arrays sorted by stable keys like <code>templateId</code>. <br>2. Normalize all strings to Unicode NFKC and strip trailing spaces. <br>3. Use <code>\n</code> as newline and UTF-8 encoding. <br>4. Compute SHA256 over canonical bytes to produce <code>reportHash</code> and <code>mChecksum</code>. <br><strong>Example — repair action structure (descriptive):</strong> each <code>repairAction</code> entry should include <code>actionType</code>, <code>parameters</code>, <code>idempotencyToken</code>, <code>estimatedImpact</code>, <code>rollbackPlan</code>, <code>evidenceRef</code>. This ensures safe automated guidance while requiring operator approval for system changes. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Operational checks & automation guidance:</strong><br>1. Automate monthly retention verification for evidence stores and emit <code>housekeeping.audit</code> with proof-of-delete for expired evidence. <br>2. Automate <code>VerifyAuditChain</code> job in CI to validate audit rotations and signing with release manifest keys. <br>3. Provide operator CLI: <code>pq_ensuredeps replay --correlation &lt;id&gt; --evidenceRef &lt;ref&gt;</code> to reproduce environment and template decisions. <br>4. Enforce static analyzer rules: forbid direct workbook writes on UI load handlers and forbid network calls in <code>fastMode</code>. </td></tr><tr><td data-label="PQ_EnsureDeps — Per-function Expert Technical Breakdown"> <strong>Final set of firm operational constraints (recap):</strong><br>1. No network I/O on UI fast-path; <code>ResolveRemoteManifests</code> must run in worker. <br>2. Persist <code>deps.report.json</code> atomically and emit audits for each persisted artifact. <br>3. Enforce signature verification for templates with <code>signaturePolicy=REQUIRED</code>; block injection unless <code>VerifyTemplateSignature</code> passes or two-person approval obtained. <br>4. Always attach <code>evidenceRef</code> for raw artifacts and avoid PII in audit rows. <br>5. Use <code>GenerateDepFingerprint</code> for caches and CI gating; keep golden vectors for parity across implementations. <br><strong>Checked:</strong> audit coverage, deterministic canonicalization, UI thread safety, worker fallback patterns, repair idempotency, and comprehensive runbooks and forensic evidence mapping. </td></tr></tbody></table></div><div class="row-count">Rows: 43</div></div><div class="table-caption" id="Table4" data-table="Docu_0179_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by PQ_Utilities — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">PQ_Utilities — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Module-level metadata (contract & overview):</strong><br><strong>Owner:</strong> TEAM_PQ_UTILS (declared in PQ/OWNERS.md and release manifest). <br><strong>Maintainers & escalation:</strong> primary: pq-utils-team; secondary: pq-tools-ops; on-call: platform-SRE for persistence issues. <br><strong>Public API (complete surface):</strong> ComputeMChecksum, NormalizeMForChecksum, PrettyPrintM, ParameterizeM, ExtractParametersFromM, MChecksumStream, MChecksumCompare, MChecksumDiffReport, MTemplateFingerprint, Add_Query_From_M_SafePayload, AtomicWritePQ, AtomicWriteRepairPQ, InspectTempArtifactsPQ, Retry, DeterministicRNG_PQ, SerializeRngState, RestoreRngState, ExportMWithDiagnostics, TempHiddenSheetFallback, HiddenSheetInspector, ValidateTemplatePolicy, ValidateTemplateSignature, ParameterSchemaValidator, MParserLite, MASTComparator, PreviewSandboxRunner, PreviewSeedProvider, TemplateRepoSync, TemplateRepoVerify, PQDiagnosticsCollector, PQDiagnosticSummarizer, EvidenceBundleBuilder. <br><strong>Audits emitted (representative):</strong> pq.util.startup, pq.util.mchecksum.start, pq.util.mchecksum.complete, pq.util.mchecksum.mismatch, pq.util.mchecksum.reconcile, pq.util.atomic_write.attempt, pq.util.atomic_write.completed, pq.util.atomic_write.failure, pq.util.atomic_write.degraded, pq.util.atomic_write.repair, pq.util.retry.attempt, pq.util.retry.complete, pq.util.rng.seeded, pq.util.rng.state_serialized, pq.util.inject.preview, pq.util.inject.commit, pq.util.export.attempt, pq.util.export.completed, pq.util.fallback.hidden_sheet.write, pq.util.fallback.hidden_sheet.recover. Every audit row includes correlationId, module=PQ_Utilities, procedure, paramsHash, resultHash (where applicable), and when user-initiated, operatorId. <br><strong>Purpose & intended use:</strong> provide deterministic, auditable, cross-host-safe primitives for working with Power Query M templates: canonicalization and stable fingerprinting (mChecksum), safe parameterization and preview injection, deterministic preview reproduction via seeded RNG, robust persistence (atomic write with verification and recoverability), diagnostics collection for PQ refresh/preview flows, and evidence packaging for forensic and regulatory needs. PQ_Utilities acts as both a light-weight host shim (for in-addin preview fast paths) and a full-fidelity worker library (for audited commits and exports). <br><strong>Non-goals / constraints:</strong> do not implement cryptographic signing (handled by release manifests/signature services), do not perform network uploads in preview fast-paths, and avoid heavy runtime dependencies in the add-in host. Do not assume uniform filesystem semantics across hosts—design explicit fallbacks and document degraded guarantees. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Operational guarantees (module-level invariants & SLOs):</strong><br>1. Determinism: with identical M text, canonicalization rules, and RNG seed, outputs (mChecksum and RNG-driven selections) are reproducible across supported runtimes and languages. <br>2. mChecksum semantics: the canonicalizer maps semantically-identical templates to identical normalized representations where canonical rules permit, enabling stable fingerprinting and audit anchors. <br>3. Atomic persistence: artifacts persisted via AtomicWritePQ are final-on-success; readers never observe truncated artifacts. <br>4. UI thread safety: preview flow helpers are non-blocking; any heavy IO is offloaded or scheduled by the host. <br>5. Observability & evidence: every commit or persisted artifact is accompanied by audit rows and evidenceRef pointing to encrypted normalized content or serialized RNG state where necessary. <br><strong>Performance SLOs:</strong> ComputeMChecksum for a 100KB template in worker context median <50ms; AtomicWritePQ median local SSD latency <250ms; RNG seeding + first 100 draws <10ms. <br><strong>CI / acceptance gates:</strong> cross-runtime golden vectors for ComputeMChecksum and DeterministicRNG; atomic-write cross-platform tests including NFS/SMB heuristics; static analyzer blocking forbidden host IO on UI thread; audit emission verification. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>High-level design & cross-cutting patterns:</strong><br>1. Two modes of operation: <code>preview-fast-path</code> (non-blocking, minimal IO, no remote evidence upload) and <code>commit/worker-path</code> (full audit, atomic persistence, verification). <br>2. Canonicalization-first: always derive and compare mChecksum using NormalizeMForChecksum before commit or injection. <br>3. Deterministic sampling: always seed RNG deterministically from correlationId for any operator-visible randomness; persist RNG state when exact replay is required. <br>4. Persistence-first for authoritative artifacts: persist normalizedM + metadata via AtomicWritePQ then inject into workbook from persisted artifact rather than arbitrary in-memory strings. <br>5. Fallbacks documented: hidden-sheet fallback for restricted hosts, two-phase copy for weak-rename filesystems, and staged local fallback for network outages. <br>6. Audit-first instrumentation: emit start/complete/error audits for every critical transition with correlationId, paramsHash, and evidenceRef where relevant. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>ComputeMChecksum(m_source, normalize=true, canonical_rules=null)</code> — exhaustive technical breakdown</strong><br><strong>Purpose & contract:</strong> deterministic, cross-runtime fingerprint for Power Query M code; returns <code>{mChecksum: sha256hex, normalizedM: string, canonicalMetadata: object}</code>. Must be pure and side-effect free. <br><strong>Parameters & behavior:</strong> <code>m_source</code> (string): raw M text; <code>normalize</code> (bool, default true); <code>canonical_rules</code> (optional): map controlling comment preservation, field ordering policy, literal normalization, and special-case rules for regulated templates. <br><strong>Primary invariants (must/shall):</strong><br>1. Idempotence: same input and rules produce same normalizedM and mChecksum. <br>2. Determinism across runtimes: tokenization & canonical rules documented and implemented across supported runtimes (XLAM JS/VBA shim, worker runtime). <br>3. Minimal false match risk: canonicalizer must avoid different semantics mapping to same normalized string. <br><strong>Algorithm & implementation notes:</strong><br>1. <strong>Pre-normalize:</strong> UTF-8 decode + Unicode NFC normalization; normalize line endings to LF. <br>2. <strong>Lexical pass:</strong> tokenise into keywords, identifiers, punctuation, literals, comments. Use a tolerant tokenizer that accepts common nonstandard whitespace. <br>3. <strong>AST-lite pass:</strong> where possible build a shallow parse tree for record/list/function declarations and parameter maps to apply canonical ordering safely. <br>4. <strong>Canonical transforms:</strong> remove or normalize comments per rules; sort record fields where semantically safe unless <code>fieldOrderingPreserved</code> flagged in template metadata; normalize numeric literal formats (reject leading plus signs, canonicalize exponents), normalize date/time literal representation to ISO-like canonical form understood across PQ runtimes. <br>5. <strong>Re-emit normalizedM:</strong> deterministic spacing rules: single space between tokens where required, consistent function parameter formatting, consistent indentation in normalized output (indentation is cosmetic but helps diffs). <br>6. <strong>Hashing:</strong> compute SHA256 over UTF-8 bytes of normalizedM and return hex digest. <br><strong>Edge cases & invalid inputs:</strong><br>1. Non-UTF8 input -> decode with replacement characters and emit pq.util.mchecksum.invalid_encoding audit with evidenceRef containing original bytes. <br>2. Partial fragments (templating placeholders or embedded parameter markers) -> support fragment mode with <code>fragment:true</code> metadata. <br>3. Very large templates -> stream canonicalization with MChecksumStream to cap memory; if forced truncation occurs emit pq.util.mchecksum.truncated. <br><strong>Observability & audits:</strong> pq.util.mchecksum.start(correlationId, inputHash, rulesHash) pq.util.mchecksum.complete(correlationId, mChecksum, durationMs, normalizedLength) pq.util.mchecksum.mismatch(correlationId, expectedChecksum, actualChecksum, evidenceRef). <br><strong>Examples & narratives:</strong><br>1. Two template authors add explanatory comments without changing logic; ComputeMChecksum with default rules strips comments and mChecksum is unchanged. <br>2. A template author reorders a parameter map; if canonical rules allow order-insensitivity, normalizedM sorts map entries alphabetically and mChecksum stable. <br><strong>CI tests & parity:</strong> supply canonicalization golden inputs (whitespace/comment variants, field order permutations, literal formatting edge cases) and verify identical mChecksum across supported runtimes. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>NormalizeMForChecksum(m_source, rules)</code> — canonicalizer and reversible mapping</strong><br><strong>Purpose & contract:</strong> produce deterministic normalized M and mapping metadata for optional reversible reconstruction. Returns <code>{normalizedM, mappingMetadata}</code>. <code>mappingMetadata</code> must contain original offsets or annotations when reversibility is required (e.g., for regulated templates that need exact round-trip of comments). <br><strong>Implementation details:</strong> use token stream to create mapping entries per token including tokenIndex, originalStart, originalEnd, and if <code>reversible=true</code> anchor comment blocks into evidenceRef storage and record pointer. <br><strong>Developer notes:</strong> when <code>reversible</code> is true, sensitive content (PII) must be sanitized or encrypted before evidenceRef write. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>PrettyPrintM(m_source, style)</code> — deterministic pretty printing for UI editors</strong><br><strong>Purpose & contract:</strong> render M in deterministic, human-friendly layout for preview or editor; returns <code>{prettyM, mappingHint}</code> suitable for editor cursor mapping. Must preserve semantics. <br><strong>Behavior:</strong> use normalized AST to format with deterministic indentation and line wrapping rules; preserve <code>@preserve</code> anchors to avoid reflowing intentionally formatted blocks. Provide <code>compact</code> and <code>readable</code> styles. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>ExtractParametersFromM(m_source)</code> — parameter schema extraction</strong><br><strong>Purpose & contract:</strong> statically analyze top-level template metadata to list declared parameters with type hints, defaults, validations, help text, and whether parameter is injected into connection strings (sensitive). Returns structured manifest <code>{parameters:[{name,type,default,validation,help,isSensitive}], requiresHighPrecision:boolean, templatePolicyFlags:[]}</code>. <br><strong>Constraints:</strong> Do not execute M; static-only parse. Ambiguous types returned as <code>unknown</code> with a <code>warning</code> flag and pq.util.param.extract.warning audit. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>ParameterizeM(m_template, parameterValues, mode=&quot;preview&quot;, validate=true, correlationId=null)</code> — safe AST-level substitution</strong><br><strong>Purpose & contract:</strong> safely substitute parameter values into M template at AST level; validate types and return substitutedM and parameterization metadata. Avoid raw string interpolation. <br><strong>Modes & behavior:</strong><br>1. <code>preview</code>: sandboxed substitution with no persisted side effects; fast-path. <br>2. <code>commit</code>: authoritative substitution; after substitution compute mChecksum and optionally call AtomicWritePQ with artifact sidecar metadata. <br><strong>Type coercion & validation rules:</strong> apply declared type coercions; when coercion fails return structured <code>ParameterErrorList</code> with ErrorCode=PQ_PARAM_TYPE_MISMATCH and emit pq.util.param.invalid audit. For sensitive parameters flagged <code>isSensitive</code>, redact top-level content and write full parameter payload only to encrypted evidence store referenced by evidenceRef. <br><strong>Security & injection safeguards:</strong> encode strings as M string literals at AST-level, escape newlines and embedded quotes per canonical literal rules. Parameterization must never paste unescaped user input into connection strings or commands. <br><strong>Audit:</strong> pq.util.inject.preview(correlationId, templateId, paramsHash, previewMChecksum) pq.util.inject.commit(correlationId, templateId, paramsHash, committedArtifactChecksum). </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>MChecksumStream(reader, normalize=true, canonical_rules=null, progressCb=null)</code> — streaming canonical checksum</strong><br><strong>Purpose & contract:</strong> stream canonicalize large M content and compute SHA256 without loading whole file into memory. Good for remote template repo sync and large embedded template stores. <br><strong>Implementation notes:</strong> incremental tokenization and group-buffering for record fields; for canonical sorts buffer group only; support resumable streams and <code>progressCb</code> for UI. If canonical ordering can't be guaranteed due to memory caps, return partialNormalizedRef with pq.util.mchecksum.truncated audit. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>MChecksumCompare(expectedChecksum, readerOrSource, options={reconcile:false, evidenceStore:true, catchComments:true})</code> — verification & reconciliation</strong><br><strong>Purpose & contract:</strong> compute checksum for given source and compare to <code>expectedChecksum</code>; on mismatch optionally produce reconciliation report that separates <code>semanticDiffs</code> (AST-level) and <code>commentDiffs</code> (formatting/comments only). Return <code>{match, computedChecksum, diffs[], evidenceRef}</code>. If <code>reconcile=true</code>, persist side-by-side normalized forms in evidence store for owner review and emit pq.util.mchecksum.reconcile. <br><strong>Use-cases:</strong> template repo sync, pre-injection verification, CI gates. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>MChecksumDiffReport(expectedNormalizedRef, actualNormalizedRef)</code> — human-friendly diff</strong><br><strong>Purpose & contract:</strong> produce an annotated diff report that categories deltas as <code>semantic</code> vs <code>non-semantic</code> with sample snippets and line anchors, stored in evidence store. Provide <code>summary</code> and <code>detailed</code> formats for UI display and regulatory submission. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>AtomicWritePQ(targetPath, payloadStreamOrBytes, tmpSuffix=&quot;.pqpart&quot;, fsyncFile=true, fsyncParent=true, perms=null, maxAttempts=3, cleanupOnFailure=true, degradeOnNFS=true, correlationId=null, metadata=null)</code> — PQ-optimized atomic file writer</strong><br><strong>Purpose & contract:</strong> robust, crash-safe atomic replace for PQ artifacts: M files, export bundles, diagnostics, and artifact manifests. On success return <code>{success:true, artifactPath:targetPath, artifactChecksum:sha256hex, attempts, elapsedMs}</code>. On failure return structured error with ErrorCode and diagnosticsRef. <br><strong>Behavior & detailed steps (must/shall):</strong><br>1. <strong>Parent existence:</strong> validate parent directory exists or create atomically via FsSyncDir if <code>create=true</code>, emit pq.util.atomic_write.mkdir audit if created. <br>2. <strong>Temp path selection:</strong> compute <code>tempPath = targetPath + tmpSuffix + &quot;.&quot; + pid + &quot;.&quot; + deterministicSuffix</code> where <code>deterministicSuffix</code> is derived deterministically from correlationId using DeterministicRNG_PQ so concurrent concurrent writers avoid collisions predictably. <br>3. <strong>Exclusive write & checksum:</strong> open tempPath with exclusive create; stream write payload computing SHA256 and bytesWritten; optionally write sidecar <code>payload.metadata.json</code> containing mChecksum, templateId, correlationId, templateVersion if <code>metadata</code> provided. <br>4. <strong>fsync & rename:</strong> if fsyncFile true, fsync file descriptor; perform rename/replace: os.replace on POSIX, ReplaceFile on Windows with <code>REPLACEFILE_IGNORE_MERGE_ERRORS</code> semantics when available. <br>5. <strong>Parent fsync:</strong> if fsyncParent true perform directory fsync to ensure rename durability. <br>6. <strong>Verification:</strong> reopen targetPath read-only and verify SHA256 matches computed artifactChecksum; on mismatch attempt Retry policy if transient; otherwise emit pq.util.atomic_write.verification_failed with diagnosticsRef. <br>7. <strong>Fallback for weak rename filesystems (NFS/SMB):</strong> when <code>degradeOnNFS</code> true, use two-phase copy + state-stamp (meta file indicating <code>STATE=committed</code> only after successful copy) and emit pq.util.atomic_write.degraded; callers must be aware of degraded atomicity semantics. <br>8. <strong>Hidden-sheet fallback:</strong> if host prevents filesystem writes (web host, sandbox), call TempHiddenSheetFallback to embed artifact in hidden worksheet and emit pq.util.atomic_write.degraded. <br>9. <strong>Cleanup:</strong> if <code>cleanupOnFailure=true</code> attempt to delete surviving tempPath on failure and emit pq.util.atomic_write.cleanup audit rows. <br><strong>Cross-platform notes:</strong> Windows ReplaceFile semantics can be affected by open handles; document best practices to write to same volume, prefer atomic replacements on same volume, and advise consumers to avoid reading-in-place during replacement. <br><strong>Recovery runbook:</strong> use InspectTempArtifactsPQ to enumerate <code>.pqpart</code> leftovers; run AtomicWriteRepairPQ to validate temp artifact checksum and safely rename under maintenance window; if ENOSPC emitted, follow ENOSPC runbook. <br><strong>Observability & audit fields:</strong> pq.util.atomic_write.attempt(correlationId, targetPath, payloadHash, tempPath, attemptIdx) pq.util.atomic_write.completed(correlationId, targetPath, artifactChecksum, durationMs, attempts) pq.util.atomic_write.failure(correlationId, targetPath, errorCode, attempts, diagnosticsRef) pq.util.atomic_write.degraded(correlationId, targetPath, reason). <br><strong>Testing & CI:</strong> simulate ReplaceFile lock contention on Windows, simulate ENOSPC and fsync failures via FS mocks, test two-phase fallback correctness, concurrency tests verifying no partial readers are observed. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>AtomicWriteRepairPQ(tempPath, intendedTargetPath, correlationId=null)</code> — temp artifact repair & recovery</strong><br><strong>Purpose & contract:</strong> validate a temp artifact discovered by InspectTempArtifactsPQ and attempt safe rename to intended targetPath under maintenance conditions. Return <code>{repaired:true/false, repairedPath, artifactChecksum, diagnosticsRef}</code> and emit pq.util.atomic_write.repair audit. <br><strong>Behavior:</strong> verify SHA256 from temp matches metadata sidecar; if verification passes rename->targetPath using safe heuristics (same volume required) and optionally fsync parent; if verification fails, store the temp artifact in evidence store and emit pq.util.atomic_write.corrupt. Provide operator guidance for manual salvage or deletion. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>InspectTempArtifactsPQ(searchPaths, olderThan=null, correlationId=null)</code> — enumerate leftover temps</strong><br><strong>Purpose & contract:</strong> list <code>.pqpart</code> and hidden-sheet artifacts associated with PQ operations, return structured inventory with path, size, mtimestamp, tempMetadata, and suggested recovery actions. Use for housekeeping and incident triage. Emit pq.util.atomic_write.inspect audit with inventoryHash. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>Retry(fn, retries=3, backoff={baseMs:150, factor:2}, jitter=true, retry_on=(TransientPQError,), idempotent_assert=false, deterministic_jitter=false, cancellationToken=null, correlationId=null)</code> — canonical retry wrapper</strong><br><strong>Purpose & contract:</strong> robust wrapper for transient failures during PQ persistence or network calls invoked by orchestration. Only retry on recognized transient error classes. Implement deterministic jitter option for CI reproducibility. <br><strong>Sensible defaults & safeguards (must/shall):</strong><br>1. Only retry on known transient exceptions; immediate rethrow on non-transient errors. <br>2. If <code>idempotent_assert=true</code> require an explicit idempotency token or precondition; CI/linters enforce this for critical persistence calls. <br>3. <code>deterministic_jitter=true</code> uses DeterministicRNG_PQ seeded from correlationId for reproducible delays. <br>4. Respect cancellationToken between attempts and raise PQ_RETRY_CANCELLED when cancelled. <br><strong>Audits:</strong> pq.util.retry.attempt(correlationId, target, attemptIndex, errorCode, backoffMs) pq.util.retry.complete(correlationId, target, attempts, outcome, elapsedMs). </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>DeterministicRNG_PQ(seed_source, salt=&quot;&quot;, algorithm=&quot;pcg64&quot;, stream_id=null, test_mode=false)</code> — PQ deterministic RNG</strong><br><strong>Purpose & contract:</strong> seeded, deterministic RNG for preview sampling, tie-breaker shuffles, and any operator-visible randomness. Not cryptographic. Instances explicit—no implicit global RNG. <br><strong>Seed derivation & security:</strong><br>1. Seed derived via HMAC_SHA256(<code>seed_source | salt | moduleName | streamId</code>) folded to algorithm seed length. <br>2. Do not store raw seed in audit rows; store <code>seedFingerprint</code> and evidenceRef for serialized RNG state when full replay required. <br>3. test_mode allows deterministic seed override for CI golden tests. <br><strong>API:</strong> randint(a,b), random(), shuffle(list) -> new_list, sample(pop,k), split(childIndex) -> childRng, serialize_state() -> base64 blob, restore_state(blob). <br><strong>Stability invariants:</strong> same algorithm + same seed produce identical sequences across supported runtimes and languages. <code>split</code> uses HMAC-based derivation to ensure independent child streams. <br><strong>Observability & audit:</strong> pq.util.rng.seeded(correlationId, seedFingerprint, algorithm, streamId) pq.util.rng.state_serialized(correlationId, stateHash, evidenceRef). <br><strong>Examples & narratives:</strong><br>1. Preview sampling: PQ_Ribbon obtains seed = SeedFromCorrelation(correlationId, "preview-v2", templateId) via PreviewSeedProvider, computes sample selection in worker or host M by passing numeric seed param into deterministic PRNG implemented in M or by selecting sample server-side and storing selection in evidence for replay. <br>2. Tie-breakers for parameter ordering: when multiple default parameter options exist, call rng.shuffle(candidates) seeded by correlationId + "param-tie" to produce stable ordering across operator sessions; persist serialized RNG state when ordering affects persisted artifact. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>Add_Query_From_M_SafePayload(workbook, queryName, m_formula, options={validateChecksum:true, expectedChecksum:null, commitArtifactPath:null, createConnection:false, runAsync:true, correlationId:null, requireSignature:false})</code> — authoritative injector helper</strong><br><strong>Purpose & contract:</strong> orchestrate safe injection of M into workbook: optional commit artifact persistence via AtomicWritePQ, optional checksum validation, and audited injection with evidence linkage. Return <code>{success, queryRef, artifactChecksum, evidenceRef}</code>. <br><strong>Preconditions & safety checks:</strong><br>1. If <code>validateChecksum=true</code> and <code>expectedChecksum</code> provided, abort on mismatch and emit pq.util.mchecksum.mismatch audit. <br>2. If <code>requireSignature=true</code> and template lacks signed release manifest, refuse commit and raise PQ_INJECT_SIGNATURE_REQUIRED. <br>3. Avoid direct blocking IO on UI thread: if commit is required and <code>runAsync=true</code>, schedule worker persist then inject via host-safe callback once persistence succeeds. <br><strong>Host constraints & fallback:</strong> if host macros disabled or security policy forbids injection, return PQ_INJECT_HOST_RESTRICTED and emit pq.util.inject.commit_failure. <br><strong>Audit & linkage:</strong> pq.util.inject.preview(correlationId, templateId, paramsHash, previewMChecksum) pq.util.inject.commit(correlationId, templateId, queryName, artifactChecksum, templateVersion, operatorId, releaseManifestHash). </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>ExportMWithDiagnostics(m_source, diagnostics, targetPath, options={includeNormalized:true, includeDiagnostics:true, correlationId:null, compress:true})</code> — export bundler</strong><br><strong>Purpose & contract:</strong> produce deterministic artifact bundling M source, normalizedM, diagnostics (preview traces, provider logs, refresh path), computed mChecksum, and metadata; persist via AtomicWritePQ with sidecar artifact.metadata.json and emit pq.util.export.attempt and pq.util.export.completed. <br><strong>Use-cases:</strong> operator evidence packages, support tickets, regulatory submissions. Support <code>compress</code> to produce single compressed payload for easier upload. Provide <code>evidenceRef</code> for normalized forms and full diagnostics stored encrypted. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>TempHiddenSheetFallback(workbook, sheetName, payload, meta, correlationId=null, encrypt=false, evidenceStoreRef=null)</code> — hidden-sheet persistence fallback</strong><br><strong>Purpose & contract:</strong> persist artifact into hidden worksheet using deterministic chunk schema when filesystem persistence not available (Excel Web, restricted). Return <code>{success, sheetName, artifactId, evidenceRef}</code> and emit pq.util.atomic_write.degraded. <br><strong>Schema & governance:</strong> store JSON header in cell A1 with <code>{artifactId, timestamp, mChecksum, correlationId, encrypted}</code> and base64-encoded chunks in subsequent rows in a deterministic layout; when <code>encrypt=true</code> store base64 encrypted payload and persist decryption keys to secure evidence store only accessible by operator SRE with appropriate approvals. <br><strong>Recovery:</strong> HiddenSheetInspector enumerates artifacts; AtomicWriteRepairPQ performs extraction to filesystem and verification under maintenance. Hidden-sheet persistence is temporary and must be recovered to file storage where possible. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>InspectTempArtifactsPQ(searchRoots, olderThan=null, correlationId=null)</code> — enumerate leftover temp objects and fallbacks</strong><br><strong>Purpose & contract:</strong> scan <code>searchRoots</code> on local host and workbooks for <code>.pqpart</code> temporary files and hidden-sheet stored artifacts; return inventory with <code>foundItems:[{type, pathOrSheet, size, mChecksum, mtimestamp, suggestedAction}]</code>. Emit pq.util.atomic_write.inspect audit referencing inventoryHash. <br><strong>Operator usage:</strong> run daily housekeeping or diagnostics collect to identify stale temps for repair or cleanup. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong><code>AtomicWriteRepairPQ</code> runbook & operator steps (practical)</strong><br><strong>High-level steps:</strong><br>1. Run InspectTempArtifactsPQ for correlationId to list candidate temp artifacts. <br>2. For each candidate run AtomicWriteRepairPQ to validate payload checksum against sidecar <code>payload.metadata.json</code>. <br>3. If verified, rename to intended target under maintenance window and fsync parent; emit pq.util.atomic_write.repair. <br>4. If invalid, copy artifact to evidence hot store, record forensic_manifest entry, and remove unsafe temp file. <br><strong>Escalation:</strong> if repair fails repeatedly or multiple artifacts show verification failures, open infra incident with forensic_manifest and audit_tail. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Cross-cutting Observability, Telemetry & Error catalog (detailed mapping)</strong><br><strong>Audit schema mandatory fields:</strong> timestamp, correlationId, module=<code>PQ_Utilities</code>, procedure, operatorId (optional), paramsHash, resultHash (optional), evidenceRef (optional), configHash, templateId, templateVersion, mChecksum, artifactChecksum, metadata object containing <code>{duration_ms, attempts, tempPathList, hostContext, fallbackUsed, normalizedLength}</code>. <br><strong>Representative ErrorCodes & operator guidance:</strong> pq.atomic_write.ENOSPC — run ENOSPC runbook and attempt staged local fallback; pq.atomic_write.EPERM — ACL issue; pq.atomic_write.DEGRADED — fallback used; pq.atomic_write.VERIFICATION_FAILED — artifact mismatch, inspect temp artifacts; pq.retry.EXHAUSTED — retries exhausted, consider idempotency and check transient infrastructure; pq.param.TYPE_MISMATCH — bad parameter types; pq.inject.HOST_RESTRICTED — host security prevents injection; pq.rng.BAD_SEED — seed derivation failure. Map error codes to SafeErrorToUser messages with remediation steps. <br><strong>Metrics (locally buffered):</strong> pq.atomic_write.latency_ms, pq.atomic_write.success_rate, pq.mchecksum.compute_time_ms, pq.retry.attempt_count, pq.rng.seeded_count. Buffer metrics locally until CORE_Telemetry uploads audited batches. Utilities must not perform remote network exports in preview fast paths. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Security, privacy & PII constraints:</strong><br>1. Do not place PII in top-level audit fields; sanitize PII before audit-row publish. <br>2. When parameterValues contain PII and required to persist, store sanitized param hashes in audit and full parameter payload encrypted in evidence store with access controls; reference by evidenceRef in audit. <br>3. Hidden-sheet fallback payloads containing regulated data must be encrypted; if encryption not possible, disallow fallback for templates marked <code>disallow_hidden_fallback</code> and enforce host error. <br>4. Seeds for RNGs must be treated as sensitive for regulated runs; only store seedFingerprint and evidenceRef for serialized state in audits. <br>5. Evidence store encryption and key rotation enforced by CORE_Security; PQ_Utilities should call policy endpoints to get evidenceRef and not roll their own key management. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Testing matrix, property tests, and cross-runtime golden governance (comprehensive)</strong><br><strong>Unit tests (required):</strong><br>1. ComputeMChecksum: whitespace/comment permutations, literal normalization (numbers, dates), field-order permutations; negative tests for non-UTF8 and fragment mode. <br>2. ParameterizeM: AST-level substitution, injection-safety against crafted parameter strings that could attempt to close context. <br>3. AtomicWritePQ: simulated rename/fsync failures, ENOSPC, cross-volume rename, hidden-sheet fallback. <br>4. Retry: deterministic_jitter and cancellation behavior. <br>5. DeterministicRNG_PQ: seed parity vectors across supported runtimes (XLAM JS, worker runtime, CLI). <br><strong>Integration tests:</strong><br>1. End-to-end preview->commit: extract parameters -> preview (seeded) -> commit (AtomicWritePQ) -> Add_Query_From_M_SafePayload -> verify workbook query exists and artifactChecksum match. <br>2. Hidden-sheet fallback recovery: write to hidden sheet under host restriction -> run AtomicWriteRepairPQ on worker -> verify artifact persisted and checksums match. <br>3. ExportMWithDiagnostics round-trip; load bundle into evidence store and verify normalizedM present and checksums match. <br><strong>Property & fuzz tests:</strong><br>1. Parity tests ensuring ComputeMChecksum stable across random whitespace/comment mutations. <br>2. RNG property tests: split streams independence and reproducibility. <br>3. Parameterization fuzzing for injection safety. <br><strong>CI gating:</strong> golden vectors for mChecksum and RNG parity must pass; static analyzer must detect and block forbidden UI-thread IO. Performance budgets for mChecksum and AtomicWrite enforced in smoke tests. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Developer guidance, allowed & forbidden patterns (explicit)</strong><br><strong>Required usage patterns:</strong><br>1. Always compute and persist mChecksum before committing or injecting an authoritative template; include mChecksum in commit audits. <br>2. For preview, use ParameterizeM in preview mode and require explicit operator commit to persist artifact. <br>3. Always seed DeterministicRNG_PQ from correlationId for operator-visible randomness and persist serialized RNG state when replay needed. <br>4. Use AtomicWritePQ for artifacts consumed by other services; hidden-sheet fallback only when unavoidable and flagged in template. <br><strong>Forbidden patterns:</strong><br>1. Do not perform raw string concatenation for parameter injection; AST-level substitution only. <br>2. Do not write final artifacts directly to the target path on UI thread (static analyzer will reject). <br>3. Do not store PII in top-level audits; use evidenceRef to full encrypted payloads. <br>4. Do not rely on M runtime decimal rounding for regulated numeric outputs—offload numeric-sensitive steps to worker SafeRound flows. <br><strong>Code-review checklist:</strong> ensure ComputeMChecksum used; Ensure ParameterizeM AST-level substitution; ensure AtomicWritePQ for persisted artifacts; ensure deterministic RNGs with correlationId and audit emissions for seedFingerprint; ensure no UI-thread blocking IO. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Operational runbooks & incident playbooks (practical, step-by-step)</strong><br><strong>AtomicWritePQ ENOSPC runbook:</strong><br>1. Locate pq.util.atomic_write.ENOSPC audit rows for correlationId and extract targetPath, tempPaths, artifactChecksum. <br>2. SSH to host and run df -h for mount in question; collect <code>vmstat</code> and <code>iostat</code> for timeframe. <br>3. If safe and policy allows, move non-critical artifacts to fallback staging on same mount or expand volume; prefer staging on same volume to avoid cross-volume atomicity issues. <br>4. If <code>cleanupOnFailure</code> allowed, run AtomicWriteRepairPQ to inspect temp artifacts for recoverable payloads and rename under maintenance. <br>5. Re-run export with <code>--stage-local</code> and verify artifactChecksum compare against previous expectation. <br>6. If persistent, open infra incident with forensic_manifest and audit_tail and escalate to SRE. <br><strong>Non-deterministic preview triage runbook:</strong><br>1. Retrieve pq.util.rng.seeded audit for correlationId and fetch evidenceRef to serialized RNG state if present. <br>2. Re-run preview replay using serialized RNG state and parameterized normalizedM; present reproduced preview to requester. <br>3. If mismatch persists, compare parity vectors across runtime implementations and escalate to PQ_Utilities owners with parity evidence. <br><strong>mChecksum mismatch forensic steps:</strong><br>1. Retrieve pq.util.mchecksum.mismatch audits and evidenceRef for expected artifact and computed normalizedM. <br>2. Run MChecksumCompare in reconcile mode to produce semanticDiffs and commentDiffs. <br>3. If only commentDiffs, update manifest or record reconcile action; if semanticDiffs, pause injection and file incident with compliance. <br><strong>Hidden-sheet fallback recovery:</strong><br>1. Use InspectTempArtifactsPQ to discover hidden-sheet artifacts. <br>2. Use AtomicWriteRepairPQ on worker to extract and persist artifact to filesystem; verify checksums and emit pq.util.atomic_write.repair. <br>3. Notify operator and mark artifact as recovered in evidence manifest. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Extremely detailed long-form narratives & examples (multiple real-world scenarios)</strong><br><strong>Scenario A — Regulated template injection with high-precision numeric transforms (full trace):</strong><br>1. Template metadata flags <code>requiresHighPrecision=true</code>. Operator initiates <code>Apply Template</code> from PQ_Ribbon with correlationId <code>pq-reg-20260117-555</code>. Ribbon emits UserAction audit. <br>2. PQ_Ribbon calls ExtractParametersFromM, operator supplies params; preview performed with DeterministicRNG_PQ seeded from correlationId for any sampling, and preview audit pq.util.inject.preview recorded with paramsHash and preview mChecksum. <br>3. Since <code>requiresHighPrecision</code> true, the commit path refuses to rely on in-host M rounding. The orchestration schedules a worker job. JobDescriptor persisted via AtomicWritePQ to <code>jobs/job-...json</code> with mChecksum, paramsHash, correlationId. pq.util.atomic_write.completed emitted for job descriptor with artifactChecksum. <br>4. Worker picks up job, serializes RNG state and emits pq.util.rng.state_serialized evidenceRef. Worker loads canonicalized input snapshot and calls REG_Utilities.SafeRoundResiduals for allocation rounding with specified tieBreakerKeys. Worker emits reg.util.saferound.complete with inputHash and outputHash evidenceRef. <br>5. Worker constructs final normalized artifact (CSV/Parquet) and persists with AtomicWritePQ to <code>exports/</code> with artifact.metadata.json containing <code>mChecksum</code>, <code>safeRoundEvidenceRef</code>, <code>paramsHash</code>. pq.util.atomic_write.completed emitted with artifactChecksum. <br>6. Orchestration updates template commit flow to reference the authoritative artifact; Add_Query_From_M_SafePayload injects query pointing to authoritative persisted artifact rather than inlined computed values. pq.util.inject.commit emitted linking queryName to artifactChecksum and safeRound evidence. <br>7. Forensic replay: given correlationId, auditors can retrieve jobDescriptor, serialized RNG state, reg.util.saferound audits, and final artifact to fully replay allocation and reproduce exact numeric outputs. <br><strong>Takeaways:</strong> delegation of numeric authority to worker SafeRound ensures cross-host parity and auditable deterministic chain linking UI to worker operations and persisted artifacts. <br><strong>Scenario B — Template repo synchronization and automated reconcile:</strong><br>1. A central template repo publishes updated templates. An admin runs <code>pq repo sync</code>. PQ_Utilities downloads remote templates and streams them through MChecksumStream to compute normalized checksums. MChecksumCompare invoked for each template against local artifact. <br>2. For templates with only comment/whitespace changes, <code>MChecksumCompare</code> yields <code>commentDiffs</code>; the synchronizer can optionally auto-accept such diffs when policy allows and emit pq.util.mchecksum.reconcile with reconcile=true. For semantic diffs, repo sync produces a PR and pings template owner for review. <br>3. After owner approval, AtomicWritePQ atomically replacing local canonical artifact persists new normalizedM and new mChecksum, and pq.util.atomic_write.completed emitted. <br>4. If a downstream injection attempted to use an older mChecksum, the pq.util.mchecksum.mismatch audits will show expected vs actual and the inject flow will logically reject injection until owner acceptance occurs. <br><strong>Scenario C — Excel Web hidden-sheet fallback and later recovery:</strong><br>1. Operator in Excel Web attempts to commit template; filesystem writes are not allowed by host. AtomicWritePQ detects sandbox and invokes TempHiddenSheetFallback, which writes artifact into <code>HiddenSheet@PQ_TEMPLATES</code> with encrypted base64 chunks and header cell A1 containing metadata; pq.util.atomic_write.degraded emitted. <br>2. Operator notified: "Commit staged in workbook hidden-sheet — please recover on authorized workstation." <br>3. Operator opens desktop dev workstation and runs <code>pq artifacts extract --correlation pq-...</code> which invokes HiddenSheetInspector to locate artifacts, then AtomicWriteRepairPQ to extract and persist artifact onto local filesystem via AtomicWritePQ; pq.util.atomic_write.repair and pq.util.atomic_write.completed emitted. <br>4. After recovery, injection proceeds from persisted artifact and all audit rows link back to original correlationId and evidenceRef. <br><strong>Scenario D — Forensic reconstruction after injection mismatch report:</strong><br>1. Support receives incident "injected query logic differs from template used in run pq-20260112-455". <br>2. Support retrieves pq.util.inject.preview, pq.util.atomic_write.completed, pq.util.inject.commit audits for correlationId and obtains artifactChecksum and evidenceRef for normalizedM. <br>3. Support runs MChecksumCompare between expected normalizedM and artifact; if mismatch, inspect atomic_write.verification_failed or hidden-sheet degrade logs to determine if commit used stale or unreconciled artifact. <br>4. If commit bypassed artifact persistence (a forbidden pattern flagged by static analyzer), escalate for corrective changes and re-run CI gating; if commit artifact corrupted in transit, reconstruct from evidenceRef and repair using AtomicWriteRepairPQ. <br>5. Compile forensic_manifest.json containing all audits, artifact copies, serialized RNG state; deliver to compliance team. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Conceptual Power Query (M) mapping — how PQ_Utilities patterns apply to M workflows</strong><br><strong>Context & rationale:</strong> Power Query M runtimes (desktop, web, service) vary in numeric fidelity and host capabilities; PQ_Utilities provide orchestration model ensuring authoritative behavior and reproducibility by moving critical steps out of fragile client-only contexts and into auditable persisted artifacts. <br><strong>Patterns & mappings:</strong><br>1. <strong>Persist-first injection pattern:</strong> templates should be persisted (normalizedM + artifact metadata) and verified via ComputeMChecksum before the workbook receives injected queries. Use Add_Query_From_M_SafePayload to ensure injection references persisted artifact and links to artifactChecksum. <br>2. <strong>Preview determinism pattern:</strong> generate preview selections deterministically by seeding RNG from correlationId and passing numeric seed into template M or computing sample server-side. Store seedFingerprint in pq.util.rng.seeded audit to facilitate replay. <br>3. <strong>High-precision numeric offload:</strong> where templates require regulated numeric behavior, offload numeric aggregation and residual distribution to worker SafeRound routines; M templates reference persisted numeric artifacts produced by workers rather than computing final regulated numbers client-side. <br>4. <strong>Parameter safety mapping:</strong> ParameterizeM performs AST-level literal encoding; never perform raw string concatenation for connection strings or queries. Sensitive parameters stored only in encrypted evidence store; audit rows only contain param hashes. <br>5. <strong>Fallback & recovery mapping:</strong> when host restrictions prevent atomic filesystem writes, use TempHiddenSheetFallback and ensure later AtomicWriteRepairPQ recovers authoritative artifacts onto durable storage; always emit pq.util.atomic_write.degraded so operators and SREs can prioritize recovery. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX mapping — how PQ_Utilities fit into semantic models and DAX best practice</strong><br><strong>Context:</strong> DAX is read-time language; cannot perform side effects or persistent operations. PQ_Utilities produce authoritative artifacts and run metadata that DAX and semantic models can consume for provenance and verification. <br><strong>Key patterns & recommendations:</strong><br>1. <strong>Persist RunMetadata:</strong> ETL/worker write a <code>RunMetadata</code> table atomically (via AtomicWritePQ) containing correlationId, templateId, mChecksum, artifactChecksum, runTs, and verificationState. Model ingest of RunMetadata enables DAX measures to display verification badges and time-of-run provenance. <br>2. <strong>Avoid in-DAX rounding for authoritative values:</strong> perform SafeRoundResiduals during ETL (REG_Utilities) and persist integer cents or canonical decimals. DAX then reads authoritative columns for aggregations and displays. <br>3. <strong>Deterministic sampling via persisted flags:</strong> ETL computes <code>sampleHash = HASH(PrimaryKey | correlationSalt)</code> and persists <code>SampleFlag</code> boolean used in DAX filters; this avoids implementing random seeds in DAX and supports deterministic repeatable samples. <br>4. <strong>Checksum-based reconciliation measures:</strong> create DAX measures that compare <code>ModelLoadedChecksum</code> to <code>ExpectedArtifactChecksum</code> from RunMetadata to produce <code>IsVerified</code>. Use time-aware measures to show last verified run timestamp. <br><strong>DAX example conceptual measure (not code):</strong> a measure <code>IsArtifactVerified</code> uses the maximum artifactChecksum found in <code>RunMetadata</code> and compares to <code>ExpectedArtifactChecksum</code> loaded into the model; returns verification status displayed in the report. <br><strong>Operational note:</strong> PQ_Utilities' evidenceRef and audit rows should be accessible via auxiliary datasets (smaller, indexed tables) so DAX-based dashboards can surface links or short summaries without exposing PII or large artifacts. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Appendices — forensic artifacts, evidence paths & retention (detailed)</strong><br><strong>Minimum PQ forensic artifacts for an incident:</strong><br>1. preview.audit.json and inject.audit.json for correlationId with paramsHash and preview mChecksum. <br>2. persisted artifact file(s) with <code>artifact.metadata.json</code> including mChecksum, normalizedMRef, templateVersion, correlationId. <br>3. serialized RNG state (rng_state.blob) when preview sampling used. <br>4. hidden-sheet artifacts listing with base64 chunks and header metadata. <br>5. AtomicWrite temp artifacts and repair logs. <br>6. normalized decimal snapshots when numerics offloaded to worker. <br><strong>Evidence storage & retention policy:</strong><br>1. Hot evidence store: <code>\\evidence\pq\hot\&lt;correlationId&gt;\</code> kept 30 days with restricted access. <br>2. Warm archive: secure encrypted archive for regulatory retention, default 7 years; maintain chain-of-custody and proof-of-rotate metadata. <br>3. Forensic_manifest.json: enumerates artifact URIs, checksums, evidenceRef, and signature fingerprints where present. <br><strong>Retention & verification cadence:</strong> monthly retention verification job emits housekeeping.audit and proof-of-delete manifests for removed items; evidence rotations recorded in audit rows. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Acceptance checklist before release (detailed):</strong><br>1. Owners listed and contactable in PQ/OWNERS.md. <br>2. Public API documented with semantic versioning in release manifest. <br>3. Golden parity tests for ComputeMChecksum across runtimes passing. <br>4. AtomicWritePQ cross-platform behavior validated (rename/fsync, fallback paths). <br>5. DeterministicRNG_PQ parity vector validated across runtimes. <br>6. Audit hooks validated by test harness emitting expected audit rows. <br>7. CI static checks disallow forbidden host IO patterns. <br><strong>Blocking conditions:</strong> missing audit emissions on persistence flows, failing parity golden tests, or static analyzer detecting direct workbook writes in OnLoad paths. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Testing & QA plan (highly detailed):</strong><br><strong>Unit test groups (representative)</strong><br>1. mChecksum unit suite: whitespace/comment permutations, literal normalization, record field ordering edge cases, fragment mode tests with expected normalizedM outputs. <br>2. Parameterization suite: correct AST-level substitution and escaping, type validation boundary cases, sensitive param redaction behavior. <br>3. AtomicWrite suite: simulated rename and fsync failures, ENOSPC, ReplaceFile lock contention, cross-volume rename attempts, hidden-sheet fallback path. <br>4. Retry suite: deterministic_jitter reproducibility tests, cancellation token behavior, idempotency assertion enforcement. <br>5. RNG suite: seed parity across runtimes, splitStream independence, serialize/restore roundtrip tests. <br><strong>Integration tests (representative)</strong><br>1. Preview->Commit roundtrip: preview audit, commit persistence via AtomicWritePQ, injection via Add_Query_From_M_SafePayload, verification of workbook query and artifactChecksum. <br>2. Export+Diagnostics: ExportMWithDiagnostics produce artifact bundle; worker reimports bundle and validates normalizedM and diagnostics. <br>3. Hidden-sheet repair: simulate host restriction -> write to hidden sheet -> extract & repair via AtomicWriteRepairPQ on worker -> verify artifact checksum. <br><strong>Performance & stress tests:</strong><br>1. ComputeMChecksum throughput on 1MB templates under worker environment; ensure median acceptable and 95th percentile within budget. <br>2. AtomicWritePQ concurrency stress: multiple writers to same directory with deterministicSuffix to ensure safe temp file naming and conflict handling. <br>3. Retry overhead microbenchmarks to ensure retry wrapper overhead acceptable. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Operator quick commands & examples (practical):</strong><br>1. <code>pq diagnostics collect --correlation pq-YYYYMMDD-abc</code> — gathers preview & inject audit rows, artifact metadata, RNG state, normalizedM evidence, and builds forensic_manifest.json. <br>2. <code>pq atomic_write.repair --temp &lt;tempPath&gt;</code> — validate temp payload and attempt safe rename under maintenance window; logs results and emits pq.util.atomic_write.repair. <br>3. <code>pq replay.run --correlation pq-... --evidenceRef &lt;evidence&gt;</code> — deterministic replay using serialized RNG state and normalizedM; supports <code>--dry-run</code> to verify only. <br>4. <code>pq templates reconcile --repo &lt;url&gt;</code> — runs MChecksumStreamCompare against remote repo and produces reconcile report with semantic/comment diffs for owner review. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Common failure modes & mitigations (expanded):</strong><br><strong>Partial write observed by downstream consumer</strong><br>1. Likely cause: direct write to final path bypassing AtomicWritePQ, or rename semantics broken on network FS. <br>2. Mitigation: enforce AtomicWritePQ for all persisted artifacts; implement static analyzer rules blocking direct writes; if network FS unavoidable use two-phase copy + meta-stamp pattern and mark artifact as <code>staged</code> until commit completes. <br><strong>Non-deterministic preview complaint</strong><br>1. Likely cause: global RNG or time-based seed used by preview code. <br>2. Mitigation: require DeterministicRNG_PQ seeded from correlationId; persist seedFingerprint in preview audit and provide replay tool. <br><strong>Rounding bias detected across repeated runs</strong><br>1. Likely cause: naive rounding (e.g., away-from-zero) used repeatedly creating drift. <br>2. Mitigation: adopt bankers rounding or residual_distribute strategies at ETL (REG_Utilities.SafeRoundResiduals); run property tests and golden vectors and persist rounding evidence. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Governance checklists & PR requirements (explicit):</strong><br>1. PR must include unit tests for new behavior and golden mChecksum vectors if normalization rules change. <br>2. Any change to canonicalization or RNG algorithm requires owner approval and release manifest update. <br>3. Changes to AtomicWritePQ semantics require cross-platform regression tests and SRE sign-off. <br>4. Audit wiring must be validated with test harness emitting expected audit rows on success and failure paths. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Long-form operator scenario: incident reconstruction example (explicit steps)</strong><br><strong>Incident:</strong> "Injected query result differs from authoritative template for run pq-20260112-455" <br><strong>Forensic reconstruction ordered steps:</strong><br>1. Retrieve related audit rows: pq.util.inject.preview, pq.util.inject.commit, pq.util.atomic_write.completed; collect paramsHash, preview mChecksum, artifactChecksum. <br>2. Fetch artifact via artifactChecksum from persisted artifacts. <br>3. Obtain normalizedM from evidenceRef and serialized RNG state if preview sampling used. <br>4. Run ParameterizeM with recorded parameter values and restore RNG state -> replay preview sample and compute mChecksum; compare to recorded artifactChecksum. <br>5. If mismatch arises, inspect pq.util.atomic_write.verification_failed or pq.util.atomic_write.degraded audits to locate potential persistence faults or fallback usage. <br>6. Package forensic_manifest.json with audit_tail, artifact copies, RNG state, normalizedM, and jobDescriptor; deliver to compliance with chain-of-custody metadata. <br><strong>Outcome:</strong> either reproduce mismatch, identify and patch pipeline or confirm pipeline correctness and close incident with documented findings. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Appendix — PQ & DAX short checklists for template authors and report builders (succinct):</strong><br><strong>PQ Template author checklist:</strong><br>1. Include <code>templateId</code>, <code>templateVersion</code>, and <code>mChecksum</code> in template metadata. <br>2. Mark templates requiring strict numeric fidelity as <code>requiresHighPrecision</code>. <br>3. Use parameter schema declarations and avoid time-based seeds; accept external seed parameter for preview determinism. <br>4. Indicate allowed fallback modes (hidden-sheet allowed/disallowed). <br><strong>DAX/report builder checklist:</strong><br>1. Consume <code>RunMetadata</code> table for provenance and artifactChecksum. <br>2. Avoid performing allocation/residual rounding in DAX; rely on ETL authoritative fields. <br>3. Use persisted <code>SampleFlag</code> computed in ETL for deterministic reporting samples. </td></tr><tr><td data-label="PQ_Utilities — Per-function Expert Technical Breakdown"> <strong>Closing operational constraint (non-negotiable):</strong><br>All PQ flows producing artifacts consumed downstream must: persist canonical normalizedM and compute mChecksum, seed deterministic RNGs from correlationId for operator-visible randomness, use AtomicWritePQ for authoritative artifacts, and emit audit rows with evidenceRef for large/forensic payloads. This is mandatory for regulated or PII-touching workflows and enforced by static analysis and CI gates. </td></tr></tbody></table></div><div class="row-count">Rows: 38</div></div><div class="table-caption" id="Table5" data-table="Docu_0179_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by PQ_Library — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">PQ_Library — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Module-level metadata (authoritative contract & purpose):</strong><br><strong>Owner:</strong> TEAM_PQ_LIBRARY (listed in OWNERS.md with rotation, approvers, escalation contacts).<br><strong>Public API (complete surface):</strong> LoadLibraryIndex, LoadEmbeddedHiddenSheet, ListTemplates, GetTemplateById, ResolveTemplateVersion, ComputeMChecksum, ValidateTemplateSchema, ImportTemplateFromFile, ImportTemplateFromRepo, ExportTemplatePackage, PublishTemplate, UnpublishTemplate, DeactivateTemplate, TemplateDiff, ApplyTemplatePatch, SignTemplateArtifact, VerifyTemplateSignature, BackupLibraryIndex, RestoreLibraryIndex, InspectHiddenSheetFallback, PromoteHiddenSheetToRepo, WatchRemoteRepo, ResolveTemplateDependencies, MapTemplateToPreviewParameters, ResolveParameterDefaults, RenderPreviewM, GetTemplateOwners, SetTemplateOwners, TemplateAuditEntry, TemplateMetricsSnapshot, PruneOldVersions, RepairCorruptEntry, AtomicPersistIndex, InspectTemplatePayload, StageTemplateForApproval, ApprovalsQuery, DenyPublishWithReason, PromoteCandidateToPublished, GenerateTemplateChangeLog, AuditEvidenceBundle, IndexRotationPolicyManager.<br><strong>Primary audits emitted:</strong> pq_library.load, pq_library.access, pq_template.preview, pq_template.inject.prepare, pq_template.inject.completed, pq_template.publish, pq_template.unpublish, pq_template.signature.verify, pq_library.index.persist.attempt, pq_library.index.persist.completed, pq_library.index.repair, pq_library.hidden_sheet.fallback, pq_library.import.attempt, pq_library.import.completed, pq_library.import.failure, pq_template.validate, pq_template.mChecksum.compute, pq_library.backup, pq_library.restore. Each audit row MUST include correlationId, module=PQ_Library, procedure, paramsHash, templateId/version where relevant, resultHash or artifactChecksum, operatorId when interactive, and evidenceRef when the payload is non-trivial. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>High-level purpose & usage constraints:</strong><br>PQ_Library is the authoritative steward for Power Query (M) templates and template metadata. It ensures deterministic canonicalization and checksumming of M payloads (<code>mChecksum</code>), manages a canonical index of templates (versions, owners, channels), enforces publish/approval policies, provides robust import/export and signing workflows, supports an embedded hidden-sheet fallback for offline operation, and supplies diagnostic and forensic artifacts for reproducibility and regulator audit. PQ_Library is used by ribbon handlers for read-only operations, by worker processes for mutating operations (import, publish, sign), and by CI pipelines for goldens and release gating. It intentionally avoids running heavy network or disk IO on the UI thread; any ribbon-initiated mutation must generate a correlationId and schedule a worker job. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Non-goals & constraints (enforced by static checks):</strong><br>1. Not a general-purpose VCS — do not attempt to provide full branching/merge semantics. Use integrated repo tools for that. <br>2. No secret management — signing keys and tokens stored and used only in CORE_Security or CI/worker contexts. <br>3. No heavy runtime evaluation of templates in ribbon context; static checks allowed, but full execution and numeric-critical operations are worker-only. <br>4. Changes to canonicalization or checksum semantics require a migration manifest, owner approval, and cross-language golden updates. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Operational guarantees & invariants (detailed):</strong><br>1. Determinism: <code>ComputeMChecksum</code> canonicalization + digest algorithm produce identical results across supported runtimes and platforms for the same logical template input. <br>2. Audit anchoring: any change to index, publish state, signature attachments, or hidden-sheet promotions must emit an audit row with correlationId and evidenceRef when payloads exceed audit size. <br>3. Crash-safety: index updates must be atomic using <code>AtomicPersistIndex</code>, guaranteeing either previous index remains or new index fully replaces it. <br>4. Fallback semantics: embedded hidden-sheet fallback is read-only, auditable, and persisted to evidence store on first use to allow later promotion and forensic replay. <br>5. UI safety: no blocking network or heavy FS operations on the ribbon thread; static checks only. <br>6. Observability: Start/complete/failure audits plus buffered metrics are emitted for all long-lived flows. <br><strong>Performance SLOs:</strong> list/get median <50ms on small indexes; <code>ComputeMChecksum</code> median <100ms for typical 10–50KB templates; index persist median <200ms on local SSD; CI gating produces golden verification within CI budget thresholds. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Implementation principles (architectural & design rationale):</strong><br>1. Canonicalize before checksumming — avoid spurious mismatches from formatting, line endings, or editor variants. <br>2. Minimal trusted surface — signing performed only in worker/CI with secured keys; verification in clients. <br>3. Worker-first for mutating operations — imports, publishes, and remote fetches are delegated to workers. <br>4. Evidence-driven auditing — large payloads referenced by evidenceRef; audits contain only parameter hashes for privacy. <br>5. Cross-language parity — provide golden vectors and reference implementations for <code>ComputeMChecksum</code> and <code>TemplateDiff</code> in supported languages. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Index & artifact model (concise canonical model):</strong><br><strong>Index entry shape (canonical fields):</strong> templateId, version, title, channel, mChecksum, artifactPath, signaturePath (optional), owners[], tags[], requiresHighPrecision (bool), createdAt, publishedAt, status (candidate/published/deprecated), metadata (freeform). Each index entry may reference evidenceRef for large inline payloads or notes. Index serialization must produce canonical JSON (sorted keys, stable ordering) for reproducible indexHash. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Per-function, exhaustive technical breakdowns (begin):</strong> </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>LoadLibraryIndex(indexPath, validate=true, correlationId=null)</code> — authoritative index loader & verifier</strong><br><strong>Purpose & contract:</strong> read the index file (JSON) describing templates, compute <code>indexHash</code>, optionally validate against JSON Schema v7, and return a deterministic, canonicalized index structure. Must be read-only in ribbon context; heavy validation and repair flows run in worker context. Returns <code>{index, indexHash, loadedFrom, validationReport}</code> or raises deterministic error codes: <code>PQ_LIB_INDEX_NOT_FOUND</code>, <code>PQ_LIB_INDEX_CORRUPT</code>. <br><strong>Inputs & outputs:</strong> <code>indexPath</code> (file path or repo meta endpoint), <code>validate</code> boolean; output an ordered index structure with stable iteration order (sorted by <code>templateId</code> then <code>version</code>). <br><strong>Detailed algorithm notes:</strong><br>1. Read file with safe-read helper (avoid partial reads). <br>2. Compute SHA256 over canonical JSON (sorted keys, deterministic whitespace) -> <code>indexHash</code>. <br>3. If <code>validate</code> run JSON Schema checks and collect <code>validationReport</code> with severity-coded entries. <br>4. If fatal schema errors and <code>validate==true</code> return <code>PQ_LIB_INDEX_INVALID_SCHEMA</code>; if permissive mode allow best-effort index with warnings. <br><strong>Invariants & observability:</strong> return deterministic ordering; emit audit <code>pq_library.load(correlationId, indexPath, indexHash, validationSummary)</code>. <br><strong>Edge cases & remediation:</strong> missing file -> <code>PQ_LIB_INDEX_NOT_FOUND</code> with remediation suggestion to run <code>BackupLibraryIndex</code> or <code>RestoreLibraryIndex</code>. Corrupt JSON -> persist corrupted copy to evidenceRef and emit <code>pq_library.index.corrupt</code> for manual review. <br><strong>Testing:</strong> corrupt index fixture, large-index performance test, schema regression tests, cross-language indexHash parity. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>LoadEmbeddedHiddenSheet(workbook, sheetName=&quot;pq_templates&quot;, correlationId=null)</code> — fallback ingestion</strong><br><strong>Purpose & contract:</strong> parse an embedded hidden sheet used as a local template repository fallback. Must be non-blocking for ribbon handlers; keep parsing shallow. For large embedded payloads, persist sanitized copies to evidence store and return <code>evidenceRef</code> instead of full inline payload. <br><strong>Behavioral notes:</strong><br>1. Expect header row with canonical fields: <code>templateId</code>, <code>version</code>, <code>title</code>, <code>mChecksum</code>, <code>owners</code>, <code>requiresHighPrecision</code>, <code>tags</code>, <code>createdAt</code>, <code>payloadRef</code> or payload cell. <br>2. Normalize headers forgivingly and map known aliases. <br>3. For multiline payloads persist to evidence store and return <code>evidenceRef</code>. <br>4. Emit audit <code>pq_library.hidden_sheet.fallback(correlationId, workbookId, rowCount, indexHash)</code>. <br><strong>Edge cases:</strong> missing sheet -> <code>PQ_LIB_HIDDEN_SHEET_MISSING</code>. Truncated cells -> persist truncated artifact and emit <code>pq_library.hidden_sheet.truncated</code> with row fingerprint. <br><strong>Testing:</strong> header permutations, Excel line-end normalization, embedded RTF and control character handling. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>ListTemplates(index, filter=null, sort=null, pagination=null)</code> — query enumerator</strong><br><strong>Purpose & contract:</strong> return deterministic filtered, sorted, and paginated template metadata without returning full payloads unless <code>includePayload=true</code>. Sorting stable fallback: <code>templateId</code> asc then <code>version</code> desc. <br><strong>Filter & return semantics:</strong> filters support owner, tag, channel, requiresHighPrecision, <code>templateIdPrefix</code>. Always include <code>returnedHash</code> of the resulting view for caching and audit. <br><strong>Observability:</strong> <code>pq_library.access(correlationId, action=list, filterHash, returnedCount)</code>. <br><strong>Tests:</strong> performance on large indexes (10k+ templates), Unicode tag matching, stable pagination under concurrent modifications. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>GetTemplateById(index, templateId, version=null, includePayload=false, allowRemoteFetch=false)</code> — canonical fetch</strong><br><strong>Purpose & contract:</strong> return metadata and optionally the M payload for the resolved version. If <code>version==null</code> resolves to latest stable version per <code>ResolveTemplateVersion</code>. If <code>includePayload==true</code> but payload absent locally and <code>allowRemoteFetch==true</code>, perform worker-only remote fetch and persist artifact; otherwise fail with <code>PQ_LIB_PAYLOAD_MISSING</code>. Returned payload must be verified against <code>mChecksum</code>. <br><strong>Invariants:</strong> resolved <code>version</code> and returned <code>mChecksum</code> must match computed checksum over returned <code>mText</code>. <br><strong>Audits:</strong> <code>pq_library.access(correlationId, action=getTemplate, templateId, version, includePayload)</code>. <br><strong>Edge cases:</strong> local artifact present but mChecksum mismatch -> mark template corrupted and create repair candidate; emit <code>pq_library.import.failure</code>. <br><strong>Tests:</strong> remote fetch simulated timeouts, permission-denied scenarios, idempotent fetch behavior. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>ResolveTemplateVersion(index, templateId, versionConstraint, policy=&quot;default&quot;)</code> — stable version resolver</strong><br><strong>Purpose & contract:</strong> resolve version constraints (exact, semver ranges, tags like <code>latest|stable|beta</code>) deterministically. Consider <code>stability</code> flags, owner locks, deprecations, and channel rules. Return <code>{resolvedVersion, resolutionConfidence, candidates}</code>. <br><strong>Deterministic tie-breaker:</strong> when multiple versions satisfy constraint, tie-break by <code>channelPriority</code> then <code>publishedAt</code> desc then <code>versionSemver</code> desc. <br><strong>Audits:</strong> <code>pq_library.version.resolved(correlationId, templateId, constraint, resolvedVersion)</code>. <br><strong>Edge cases:</strong> ambiguous constraint -> return best candidate with <code>resolutionConfidence&lt;1.0</code> and log a <code>pq_library.version.ambiguous</code> audit. <br><strong>Tests:</strong> varied constraint patterns and owner-lock enforcement. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>ComputeMChecksum(mText, algorithm=&quot;sha256&quot;, canonicalize=true, canonicalRules=default)</code> — canonicalization + checksum primitive (exhaustive)</strong><br><strong>Purpose & contract:</strong> compute a deterministic digest for M templates intended to be identical across languages and platforms. This digest is the primary artifact identifier for publishing, injecting, auditing, and CI gating. A change to <code>ComputeMChecksum</code> semantics requires migration manifest and cross-language golden updates. <br><strong>Canonicalization pipeline (step-by-step):</strong><br>1. Normalize Unicode to <strong>NFC</strong>. <br>2. Normalize line endings to LF (<code>\n</code>). <br>3. Remove BOM if present. <br>4. Trim trailing whitespace on each line. <br>5. Normalize indentation where indentation is syntactic sugar: collapse mixed tabs/spaces per canonical indentation unit (default 2 spaces) while preserving indentation semantics around multi-line string literals. <br>6. Normalize parameter placeholders that follow <code>{{param}}</code> syntax to canonical token form when policy allows; otherwise leave them untouched. <br>7. Optionally strip or normalize non-functional comments if configured in <code>canonicalRules</code> (policy controlled; default is to <strong>retain</strong> comments unless annotated <code>//mchecksum-ignore</code>). <br>8. Collapse runs of blank lines to a configured maximum (default 2). <br>9. Canonicalize base64-embedded blobs by normalizing line-wrapping and trimming trailing <code>=</code> if policy instructs. <br><strong>Checksum:</strong> compute SHA256 over the canonical UTF-8 bytes and return hex digest. Optionally provide base64 variant when <code>algorithm</code> requests. <br><strong>Invariants:</strong> canonicalization must not alter semantics of templates; aggressive transformations are forbidden unless the template is explicitly marked for <code>mChecksum_sanitized</code> mode and owners sign off. <br><strong>Audits & evidence:</strong> emit <code>pq_template.mChecksum.compute(correlationId, templateId?, mLen, mChecksum)</code> and persist canonicalized text in evidenceRef when requested for forensic replay. <br><strong>Edge cases & mitigations:</strong><br>- Templates with embedded binary content: treat content as opaque and canonicalize surrounding representation only. <br>- Non-UTF-8 input: decode with <code>utf-8</code> with strict mode where possible; on decoding failures store raw bytes to evidenceRef and return <code>PQ_LIB_MCHECKSUM_INVALID_ENCODING</code>. <br><strong>Tests:</strong> cross-language golden vector sets with Unicode normalization cases, comment-presence toggles, whitespace permutations, base64 variations. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>ValidateTemplateSchema(mText, policyProfile=&quot;default&quot;, templateId=null)</code> — static analyzer and policy guard</strong><br><strong>Purpose & contract:</strong> statically analyze M text to detect syntactic errors, policy violations, and connectors or API usages that require owner review or are forbidden. Not a runtime executor; it performs parse-tree analysis and pattern checks. <br><strong>Checks performed (technical):</strong><br>1. Syntax parse for top-level <code>let</code>/<code>in</code> structure and query names. <br>2. Parameter block detection and validation against schema (parameter types, default values, allowed ranges). <br>3. Forbidden API detection: e.g., <code>File.Contents</code> for <code>noLocalFS</code> templates, disallowed connectors for regulated channels, or usage of <code>Extension.LoadFunction</code> flagged for review. <br>4. Hardcoded connection strings or high-confidence PII patterns flagged as <code>HIGH</code> severity. <br>5. Connector sensitivity: if template uses non-approved connectors, mark as <code>REVIEW</code> and require owner signoff. <br><strong>Return:</strong> <code>validationReport</code> with entries containing severity (INFO/WARN/ERROR), ruleId, message, and suggested remediation. <code>isValid</code> true only if no <code>ERROR</code> level findings and mandatory metadata present. <br><strong>Audits:</strong> <code>pq_template.validate(correlationId, templateId, validationSummary)</code>. <br><strong>Tests:</strong> false-positive minimization with representative corpora, policy toggles for different channels. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>ImportTemplateFromFile(path, indexPath, sign=false, force=false, correlationId=null)</code> — authoring import pipeline</strong><br><strong>Purpose & contract:</strong> safely import a local file into staging as a candidate template version. Compute <code>mChecksum</code>, validate, optionally sign, stage artifact in artifact store, and update index metadata with candidate status. Do not overwrite published versions unless force & owner approvals provided. <br><strong>Flow details:</strong><br>1. Read file in streaming mode to handle large payloads and compute tentative checksum. <br>2. Run <code>ComputeMChecksum</code> canonicalization to produce authoritative <code>mChecksum</code>. <br>3. Run <code>ValidateTemplateSchema</code>. If validation has <code>ERROR</code> entries reject import unless <code>force</code> and documented owner reason present. <br>4. Persist artifact to staging area using <code>AtomicWrite</code> semantics. <br>5. Create candidate index entry with metadata: <code>templateId</code>, <code>versionCandidate</code>, <code>mChecksum</code>, <code>author</code>, <code>stagedAt</code>, evidenceRef. <br>6. Emit <code>pq_library.import.completed</code> audit including <code>evidenceRef</code> and <code>artifactChecksum</code>. <br><strong>Conflict semantics:</strong> identical <code>mChecksum</code> exists => idempotent success returning existing version info. version conflict without <code>force</code> => <code>PQ_LIB_IMPORT_CONFLICT</code>. <br><strong>Security:</strong> sanitize file paths to avoid path traversal. <br><strong>Tests:</strong> idempotent imports, forced override gating with approvals, signature optional flows. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>ImportTemplateFromRepo(repoUrl, templateRef, credentialsRef=null, stagingOnly=true, correlationId=null)</code> — remote import & sync</strong><br><strong>Purpose & contract:</strong> fetch templates or index from remote repos (git, static hosts) into staging for validation. Worker-only due to network IO and potential long-running fetches. Respect repo allowlists and verify repo-level signatures if available. <br><strong>Flow:</strong> fetch manifest or file -> verify repo signature -> ComputeMChecksum -> ValidateTemplateSchema -> sign if requested in staging -> persist artifact via <code>AtomicWrite</code> -> update index candidate list or directly publish if auto-publish policy and all gates satisfied. <br><strong>Failure modes:</strong> network unreachable -> <code>PQ_LIB_REPO_UNREACHABLE</code> with recommended retry schedule; broken certs -> <code>PQ_LIB_REPO_CERT_ERROR</code>. For partial fetches persist evidenceRef for forensic review. <br><strong>Audits:</strong> <code>pq_library.import.attempt/completed/failure</code> with repo metadata. <br><strong>Tests:</strong> auth failure, large repo indexing, shallow clone performance. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>StageTemplateForApproval(templateId, candidateVersion, owners=[], correlationId)</code> & <code>ApprovalsQuery</code></strong><br><strong>Purpose & contract:</strong> create and manage approval workflows for candidate templates. For regulated channels require multi-approver flows; approvals persisted as immutable artifacts in the evidence store. <code>ApprovalsQuery</code> returns the set of recorded approvals for a candidate. <br><strong>Process invariants:</strong> publishing to regulated channel must not happen without recorded required approvals. Approvals must include approverId, timestamp, reason, and optional signed statement. <br><strong>Audits:</strong> <code>pq_library.approval.requested</code>, <code>pq_library.approval.recorded</code>, <code>pq_library.approval.denied</code>. <br><strong>Tests:</strong> simulate two-person approval flows, approval revocation, audit chain validation. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>PublishTemplate(templateId, version, sign=true, owners=[], approvalsRequired=1, channel=&quot;stable&quot;, correlationId=null)</code> — publish & sign flow</strong><br><strong>Purpose & contract:</strong> move candidate to published state after verifying approvals, running final validations, and optionally signing the artifact. Regulated channels require <code>approvalsRequired&gt;=2</code> (two-person approval). Signing is worker-only and uses CORE_Security-managed keys. Update index atomically to mark published and record signature fingerprint. <br><strong>Detailed guardrails:</strong><br>1. Verify artifact exists and <code>mChecksum</code> matches persisted artifact. <br>2. Confirm <code>ValidateTemplateSchema</code> status; owner-accepted exceptions must be present for <code>WARN</code> issues. <br>3. Check approvals: require minimum approvals per channel policy. <br>4. Sign artifact with <code>SignTemplateArtifact</code> in worker; persist signature next to artifact with atomic semantics. <br>5. Update index via <code>AtomicPersistIndex</code> to mark version as published with metadata: <code>publishedBy</code>, <code>publishedAt</code>, <code>signatureFingerprint</code>, <code>channel</code>. <br><strong>Audits:</strong> <code>pq_template.publish(correlationId, templateId, version, artifactChecksum, signFingerprint, approvals)</code>. <br><strong>Failure:</strong> missing approvals -> <code>PQ_LIB_PUBLISH_BLOCKED</code>; signature failure -> <code>PQ_LIB_SIGN_VERIFY_FAILED</code>. <br><strong>Tests:</strong> publish gating, concurrency, revocation path. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>SignTemplateArtifact(artifactPath, signerKeyRef, algorithm=&quot;rsa-pss&quot;)</code> & <code>VerifyTemplateSignature(artifactPath, signaturePath)</code></strong><br><strong>Purpose & contract:</strong> signing performed in trusted worker/CI environments. Create a detach signature and sign metadata (mChecksum, releaseManifestHash). Persist signature atomically adjacent to artifact. Verification available to clients and must validate canonicalized mChecksum. <br><strong>Implementation notes:</strong> use interoperable formats and include signerId, keyFingerprint, timestamp, and canonicalization rules version in signature metadata for future audits. <br><strong>Audits:</strong> <code>pq_template.signature.created</code>, <code>pq_template.signature.verified</code>, <code>pq_template.signature.verify.failed</code>. <br><strong>Tests:</strong> revoked-key handling, tamper detection, signature rotation. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>TemplateDiff(oldM, newM, mode=&quot;semantic&quot;)</code> — AST-aware deterministic diffing</strong><br><strong>Purpose & contract:</strong> produce human- and machine-readable diffs between two M payloads. <code>semantic</code> mode attempts AST-aware diffing and classifies hunks by change type: <code>PARAM_CHANGE</code>, <code>LOGIC_CHANGE</code>, <code>METADATA_CHANGE</code>, <code>CONNECTOR_CHANGE</code>, <code>WHITESPACE_ONLY</code>. If AST parsing fails fallback to line-based diff and mark <code>semantic_unavailable</code>. <br><strong>Return:</strong> structured diff with hunk list, high-level summary, and <code>breakingChange</code> boolean flagged when connector changes or heavy logic modifications detected. <br><strong>Usage:</strong> used by review UIs, CI gating, and operator sign-off flows. <br><strong>Audits:</strong> <code>pq_template.diff(correlationId, templateId, oldVersion, newVersion, diffSummary)</code>. <br><strong>Tests:</strong> AST refactor detection, param-only changes, connector addition/removal classification. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>ApplyTemplatePatch(templateId, baseVersion, patch, authorId, correlationId)</code> — deterministic patch application</strong><br><strong>Purpose & contract:</strong> apply structured patches (unified diff or JSON patch) deterministically to a base version producing a candidate. Validate resulting M and compute <code>mChecksum</code>. Persist candidate with evidenceRef and stage for approval. When patches cannot be cleanly applied produce structured conflict report with failed hunk list. <br><strong>Audits:</strong> <code>pq_library.apply_patch(correlationId, templateId, baseVersion, newCandidateHash, patchFingerprint)</code>. <br><strong>Tests:</strong> conflict detection, patch rebase sequences, idempotency of repeated patch application. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>BackupLibraryIndex(backupPath, includeArtifacts=false, correlationId=null)</code> & <code>RestoreLibraryIndex(backupPath, dryRun=true, correlationId=null)</code></strong><br><strong>Purpose & contract:</strong> create cryptographically verifiable backups (index + manifest + checksums + optional artifacts) and restore them safely. Backups must be atomic bundles including <code>forensic_manifest.json</code> enumerating artifacts and checksums. Restore performs dry-run verification (if <code>dryRun==true</code>) before replacing live index. <br><strong>Audits:</strong> <code>pq_library.backup/completed</code> and <code>pq_library.restore.attempt/completed/failure</code> with forensic_manifest reference. <br><strong>Runbook:</strong> restores require owner approval for production indices; ensure audit continuity by including replaced indexHash in manifest. <br><strong>Tests:</strong> backup corruption detection, partial restore handling, DR verification. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>AtomicPersistIndex(indexObj, targetIndexPath, tmpSuffix=&quot;.part&quot;, maxAttempts=3, correlationId=null)</code> — atomic persistence (full semantics)</strong><br><strong>Purpose & contract:</strong> reliably persist index with crash-safety and cross-platform considerations. Guarantee either previous index remains intact or new index entirely replaces it; never produce a truncated visible file. Integrates optimized temporary writing, fsync semantics, and atomic rename/replace patterns. <br><strong>Detailed sequence:</strong><br>1. Serialize <code>indexObj</code> to canonical JSON with sorted keys and stable ordering. <br>2. Write serialized bytes to <code>targetIndexPath + tmpSuffix + &#x27;.&#x27; + pid + &#x27;.&#x27; + deterministicSuffix</code>. <br>3. Optionally fsync the file descriptor if platform supports it. <br>4. Perform atomic replace using platform-specific calls (<code>os.replace</code> on POSIX, <code>ReplaceFile</code> on Windows). <br>5. Optionally fsync parent directory. <br>6. Re-open file and verify checksum equals computed <code>indexHash</code>. <br><strong>Fallbacks & degraded mode:</strong> on network filesystems with weak rename semantics fall back to writing a manifest and a <code>commit</code> sentinel; emit <code>pq_library.index.persist.degraded</code> and document consumer policy for in-progress detection. <br><strong>Audits:</strong> <code>pq_library.index.persist.attempt(correlationId, targetIndexPath, indexHash, tempPath)</code>, <code>pq_library.index.persist.completed(correlationId, targetIndexPath, indexHash, durationMs)</code>, <code>pq_library.index.persist.failure(correlationId, targetIndexPath, errorCode, attempts)</code>. <br><strong>Tests:</strong> concurrency tests (multiple publishers), ENOSPC simulation, permission error scenarios, NFS rename semantics emulation. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong><code>InspectHiddenSheetFallback(workbook, correlationId)</code> — diagnostic helper</strong><br><strong>Purpose & contract:</strong> produce a deterministic diagnostic report for hidden-sheet embedded templates: detect missing or malformed rows, oversized payloads, suspicious characters, and candidate promotion suggestions. Return <code>diagnosticReport</code> and emit <code>pq_library.hidden_sheet.inspect</code>. <br><strong>Report includes:</strong> rowCount, malformedRows detail, evidenceRefs for oversized payloads, promotionCandidates with suggested <code>ResolveTemplateVersion</code> mapping, and owner inference hints. <br><strong>Use-case:</strong> operators troubleshooting missing templates in ribbon or promotion errors. <br><strong>Tests:</strong> malformed row detection, embedded binary artifacts, evidenceRef generation correctness. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Cross-cutting observability & error catalog (comprehensive):</strong><br><strong>Audit schema:</strong> each audit row must include timestamp, correlationId, module=PQ_Library, procedure, operatorId (optional), paramsHash, resultHash (optional), evidenceRef (optional), durationMs, metadata (artifactChecksum, tempPathList, indexHash, validationSummary). Evidence storage encrypted and access-controlled. <br><strong>Representative ErrorCodes & operator guidance:</strong><br>- PQ_LIB_INDEX_NOT_FOUND — suggest <code>pqlib restore-index</code> from backups and check configured <code>indexPath</code>. <br>- PQ_LIB_INDEX_CORRUPT — follow repair runbook: collect forensic_manifest, compare backups, run <code>pq_library.index.repair</code> candidate flow. <br>- PQ_LIB_TEMPLATE_NOT_FOUND — confirm <code>templateId</code> and resolved version; list templates and check published channels. <br>- PQ_LIB_MCHECKSUM_MISMATCH — run canonicalizer with evidenceRef and compare raw vs canonical versions; open migration if canonical rules changed. <br>- PQ_LIB_REPO_UNREACHABLE — check repository tokens, network, or use hidden-sheet fallback and log <code>pq_library.hidden_sheet.fallback</code> audit. <br>- PQ_LIB_PUBLISH_BLOCKED — missing approvals; present approval artifacts to owners. <br><strong>Metrics:</strong> pq_library.index.size, pq_library.template.count, pq_library.import.rate, pq_library.publish.latency_ms, pq_library.mchecksum.compute_time_ms. Metrics buffered locally and uploaded in audited batches. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Security & governance rules (mandatory):</strong><br>1. Signing: regulated templates must be signed before being marked published; signatures must include canonical <code>mChecksum</code> and <code>releaseManifestHash</code>. <br>2. Approval policy: regulated channel publishing requires two-person approval; approvals are immutable audit artifacts stored encrypted. <br>3. No secrets: static analyzer rejects templates with probable credentials or secrets; publishing blocked until sanitized. <br>4. Hidden-sheet constraints: hidden-sheet fallback allowed for read-only preview/inject; promotion to repo requires owner approval and signature. <br>5. Key management: signing keys rotated per SRE schedule and rotation events recorded in audits and release manifests. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Testing matrix and CI gates (very detailed):</strong><br><strong>Unit tests:</strong><br>1. <code>ComputeMChecksum</code> goldens covering Unicode NFC/NFD, CRLF vs LF, comment permutations, indentation variants, base64 blobs. <br>2. <code>LoadEmbeddedHiddenSheet</code> header normalization and large payload persisted to evidence store. <br>3. <code>TemplateDiff</code> semantic vs syntactic detection. <br>4. <code>AtomicPersistIndex</code> rename/fsync failure simulation. <br><strong>Integration tests:</strong><br>1. Import-from-file -> sign -> publish -> inject roundtrip: verify injected M's <code>mChecksum</code> equals published artifact checksum and signature verification passes. <br>2. Hidden-sheet fallback -> promote -> publish -> CI signature verification chain. <br><strong>Property tests:</strong><br>1. Determinism property: <code>ComputeMChecksum(canonicalize=true)</code> idempotency and cross-language parity for randomized whitespace insertion. <br>2. Idempotency: repeated import of identical file yields same candidate and does not duplicate artifacts. <br><strong>CI golden gating:</strong> mainline merges require passing <code>mChecksum</code> parity tests across implemented language bindings and static analyzer verification for forbidden-APIs. Changes to canonicalizer or checksum must update golden vector sets. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Extremely detailed operational runbooks & incident playbooks (actionable):</strong><br><strong>Runbook: mChecksum mismatch during inject:</strong><br>1. Collect <code>pq_template.mChecksum.compute</code> and <code>pq_template.inject.prepare</code> audits for the correlationId. <br>2. Retrieve evidenceRef canonicalized text and raw payload persisted during import. <br>3. Re-run <code>ComputeMChecksum</code> with canonicalRules used during the original run (evidenceRef includes canonicalRules version). <br>4. If mismatch is due to canonicalization policy change, open migration manifest and create PR to update golden vectors, documenting impact. <br>5. If mismatch appears due to tampering, package forensic_manifest with audit_tail and escalate to security. <br><strong>Runbook: index persist ENOSPC:</strong><br>1. Inspect <code>pq_library.index.persist.failure</code> audit to find mount path and freeBytes. <br>2. Attempt staging to configured fallback on same volume; if not possible create <code>partial-backup</code> and escalate to infra. <br>3. If necessary, run <code>pqlib restore-index</code> from most recent backup after coordinating owners and SRE. <br><strong>Runbook: hidden-sheet emergency inject bypass:</strong><br>1. When repo unreachable, hidden-sheet fallback provides read-only inject paths. Persist a sanitized copy of the embedded payload to evidence store and emit <code>pq_library.hidden_sheet.fallback</code>. <br>2. Log the event and schedule <code>PromoteHiddenSheetToRepo</code> in worker for later owner approval. <br><strong>Runbook: signature verification failure in CI:</strong><br>1. Collect <code>pq_template.signature.created</code> audits and signature files. <br>2. Check key rotation logs and key fingerprint match. <br>3. If key rotation mismatch, verify releaseManifest for the run and re-sign if necessary; if suspicion of key compromise escalate to security and rotate keys. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Extended cross-cutting narratives, examples & forensic scenarios (long-form):</strong><br><strong>Example 1 — Regulated publish with two-person approval and forensic replay (trace):</strong><br>1. Developer authors template and runs <code>ImportTemplateFromRepo</code>. The worker fetches the file, computes canonical <code>mChecksum</code> via <code>ComputeMChecksum</code>, runs <code>ValidateTemplateSchema</code>, and stores artifact in the staging area using <code>AtomicWrite</code>. <code>pq_library.import.completed</code> audit records artifactChecksum and evidenceRef. <br>2. Candidate placed into staging, <code>StageTemplateForApproval</code> opened; Owner A reviews <code>TemplateDiff</code> and records approval. <code>pq_library.approval.recorded</code> emitted. <br>3. Owner B approves; <code>PublishTemplate</code> verifies approvals, signs artifact using the CI-managed signing key (<code>SignTemplateArtifact</code>), writes signature artifact, and calls <code>AtomicPersistIndex</code> to mark version as published. <code>pq_template.publish</code> audit contains <code>signatureFingerprint</code>, <code>indexHash</code>, and <code>publishedAt</code>. <br>4. Regulator requests evidence: forensic tool collects <code>pq_template.publish</code>, <code>pq_template.mChecksum.compute</code>, the canonicalized text evidenceRef, signature artifact, and indexHash. Re-run <code>ComputeMChecksum</code> with the same canonicalRules and verify signature using <code>VerifyTemplateSignature</code>. Reproduction proves artifact integrity and audit chain completeness. <br><strong>Example 2 — Preview determinism and SafeRound integration for financial correctness:</strong><br>1. Operator requests preview via PQ_Ribbon; ribbon generates correlationId and schedules worker preview. <br>2. Worker runs <code>GetTemplateById</code> to obtain payload, computes <code>mChecksum</code>, derives a deterministic seed from correlationId, and runs sandboxed preview with seed controlling sampling and deterministic transient behavior. If template marked <code>requiresHighPrecision</code>, worker runs numeric aggregation using <code>SafeRoundResiduals</code> and persists SafeRound evidence. <br>3. Preview audit <code>pq_template.preview</code> includes <code>mChecksum</code>, <code>seedFingerprint</code>, and evidenceRef to SafeRound logs so that the exact preview can be reproduced later. <br>4. Operator accepts injection; injector verifies signed artifact and <code>mChecksum</code> and injects the canonical M. <code>pq_template.inject.completed</code> audit ties the injection to published artifactChecksum and the preview correlationId. <br><strong>Example 3 — Hidden-sheet emergency promotion with reconciliation:</strong><br>1. Training workshop uses XLAM that includes <code>pq_templates</code> hidden sheet. During repo outage operators preview and inject templates from hidden-sheet. <code>pq_library.hidden_sheet.fallback</code> audits record evidenceRef for each embedded payload and the workbookId for chain-of-custody. <br>2. After outage, owners run <code>InspectHiddenSheetFallback</code> which reports malformed entries and suggests promotion candidates. <code>PromoteHiddenSheetToRepo</code> runs in a worker that extracts payloads, computes <code>mChecksum</code>, stages candidates, and opens approval workflows for owner review. Promotion is only completed after approvals and signature. <br>3. Promotion emits <code>pq_template.publish</code> audits and the forensic manifest ties originally-used hidden-sheet evidenceRefs to published artifacts for regulator traceability. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Conceptual Power Query (M) mapping — enforcement and best-practices (very detailed):</strong><br><strong>Context:</strong> Because Power Query host runtimes and connector implementations vary across host versions, PQ_Library treats M templates as authoritative artifacts: canonicalize, sign, and publish artifacts from controlled worker environments for regulated or numerically-sensitive templates. <br><strong>Patterns & guidance:</strong><br>1. <strong>Signed canonical artifact for injection (must):</strong><br> - Rationale: differences in authoring tools, local settings, or string encodings can produce semantically equivalent but byte-different M. Signed canonical artifacts guarantee that the injected M matches the audited artifact. <br> - Implementation: worker computes canonical M via <code>ComputeMChecksum</code>, persists artifact with <code>AtomicWrite</code>, signs artifact if required, and injects only after client verifies <code>mChecksum</code> and signature fingerprint. <br>2. <strong>Deterministic preview & sampling:</strong><br> - Rationale: previews must be reproducible for audit and forensic investigation. <br> - Implementation: preview flows accept correlationId-derived seed passed into parameterized M or into worker-run sampling pipelines. For heavy sampling or deterministic selection, the worker uses DeterministicRNG and persists RNG state evidenceRef referenced in <code>pq_template.preview</code>. <br>3. <strong>Numeric fidelity offload:</strong><br> - Rationale: M numeric fidelity may vary by host runtime; high-stakes rounding should be centralized. <br> - Implementation: templates that influence financial numbers must carry <code>requiresHighPrecision=true</code> metadata. The worker accepts normalized payload and runs <code>SafeRoundResiduals</code> to produce final, auditable integer-cent allocations. The signed published artifact contains the authoritative logic and the exact SafeRound evidence (input, rounding decisions, tie-break keys). <br>4. <strong>Retry & idempotency orchestration:</strong><br> - Rationale: network and FS operations are inherently unreliable and concurrent publishers must not create doubles. <br> - Implementation: operations that mutate index or artifacts persist a job descriptor via AtomicWrite and use the <code>Retry</code> wrapper with idempotency assertions enabled. Job descriptors include idempotency tokens and correlationId. <br>5. <strong>Connector policies & trusted connectors:</strong><br> - Rationale: some connectors have elevated security or compliance risks. <br> - Implementation: metadata <code>trustedConnector=true</code> and channel gating that requires explicit owner approval and signature before publish. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX & semantic model mapping — how PQ_Library integrates with models (practical):</strong><br><strong>Context & constraints:</strong> DAX is read-time only; authoritative write-side actions (signing, canonicalization, rounding) occur in ETL/worker layers. Surface only minimal, non-sensitive audit metadata into the model. <br><strong>Patterns:</strong><br>1. <strong>RunMetadata table pattern:</strong> ETL writes <code>RunMetadata</code> table with <code>correlationId</code>, <code>templateId</code>, <code>templateVersion</code>, <code>mChecksum</code>, <code>artifactChecksum</code>, <code>publishedAt</code>, <code>verificationStatus</code> and <code>notesRef</code>. DAX measures consult RunMetadata for provenance. <br>2. <strong>ReconciledFlag DAX pattern:</strong> calculate <code>IsReconciled = IF(RunMetadata[artifactChecksum] = RunMetadata[expectedChecksum], 1, 0)</code> to create a UI indicator for dataset consumers. <br>3. <strong>Deterministic sampling via hashed keys:</strong> ETL creates <code>HashKey = HASH(PrimaryKey | correlationSalt)</code> and persists <code>correlationSalt</code> in RunMetadata. Deterministic sample filters use <code>MOD(HashKey, N) &lt; k</code>. Persist <code>correlationSalt</code> to allow replay. <br>4. <strong>Authoritative rounding in ETL:</strong> perform allocations and residual distributions in ETL with <code>SafeRoundResiduals</code> and store integer-cent columns; DAX reads these for consistent measures. <br>5. <strong>Minimal model-level audit surfaces:</strong> expose <code>templateId</code>, <code>templateVersion</code>, <code>mChecksumFingerprint</code>, and <code>publishedAt</code> as model columns for transparency while keeping full evidenceRefs outside the model for security. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Forensic evidence architecture & retention policy (exhaustive):</strong><br><strong>Artifacts captured per run (minimum):</strong><br>1. <code>index.json</code> snapshot with <code>indexHash</code> and index signature (if present). <br>2. Signed artifact files with <code>mChecksum</code> and signature files. <br>3. Audit tail subset: all <code>pq_library.*</code> events for the correlationId. <br>4. EvidenceRefs: canonicalized M text, hidden-sheet payload dumps, SafeRound serialized inputs and outputs, DeterministicRNG state blobs. <br>5. <code>forensic_manifest.json</code> enumerating artifacts, checksums, evidenceRef URIs, operatorId, and timestamps. <br><strong>Retention & storage tiers:</strong><br>- Hot evidence: encrypted, access-limited, retention 30 days, fast retrieval for operator support. <br>- Warm archive: encrypted secure archive for regulatory retention (7 years or as required), slowed retrieval, stricter access controls. <br>- Cold archive: per long-term records retention rules and legal holds; retrieval subject to legal process. <br><strong>Rotation & verification cadence:</strong> monthly verification job recomputes checksums for hot and warm evidence and emits <code>pq_library.housekeeping</code> audits with verification results. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Detailed test plan & CI gating (explicit):</strong><br><strong>Unit test suites (representative):</strong><br>1. <code>ComputeMChecksum</code> parity goldens covering Unicode variants, comment toggles, blank-line collapse, base64 embedded blob normalization, and pathologically large templates. <br>2. <code>LoadEmbeddedHiddenSheet</code> header normalization with alias mapping and multiline payload persistence to evidenceRef. <br>3. <code>TemplateDiff</code> AST-level tests to classify changes correctly and flag connector modifications as <code>breakingChange</code>. <br>4. <code>AtomicPersistIndex</code> simulated rename/fsync failures and degraded path emission. <br><strong>Integration tests:</strong><br>1. Import -> Sign -> Publish -> Inject roundtrip verifying <code>mChecksum</code> and signature validity on the injected query across supported host variants. <br>2. Hidden-sheet fallback -> promote -> publish flow including approvals and signature verification. <br><strong>Property tests & fuzzing:</strong><br>1. Random whitespace/comment insertion to verify <code>ComputeMChecksum</code> idempotence. <br>2. Randomized parameter permutations to assert <code>ResolveParameterDefaults</code> determinism. <br><strong>CI gating rules:</strong><br>1. All golden vector parity tests must pass across implemented language bindings before merge. <br>2. Any change to canonicalization or checksum logic must update golden vector sets and include cross-language parity results. <br>3. Static analyzer must reject forbidden APIs within templates targeting regulated channels. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Developer requirements, patterns & forbidden behaviors (explicit):</strong><br><strong>Required patterns:</strong><br>1. Compute and persist <code>mChecksum</code> with any artifact used for injection. <br>2. Use <code>AtomicPersistIndex</code> for index mutations. <br>3. Delegate heavy IO and signing to worker/CI; ribbon code must avoid blocking network or file writes. <br>4. Emit audits for all persistence and publish flows. <br><strong>Forbidden patterns (static analyzer enforced):</strong><br>1. Do not write final artifact paths on UI thread. <br>2. Do not embed secrets or credential strings in template metadata or index. <br>3. Do not change canonicalization semantics without migration manifest, OWNER approval, and golden vector updates. <br>4. Do not accept unsigned published templates in regulated channels. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Operator quick commands & procedures (practical):</strong><br>1. <code>pqlib diagnostics collect --correlation &lt;id&gt;</code> — collects index.json, audit_tail.csv, evidenceRefs, and forensic_manifest for run. <br>2. <code>pqlib promote-hidden --workbook &lt;file&gt; --dry-run</code> — produce promotion diff and owner list for approval. <br>3. <code>pqlib verify-signature --artifact &lt;path&gt;</code> — verify signature and return signer id and validity. <br>4. <code>pqlib repair-index --from-backup &lt;backup&gt;</code> — run repair dry-run then persist if safe; include run-of-day audit. <br><strong>Escalation triggers for SRE:</strong> after two <code>pq_library.index.persist</code> ENOSPC retries for a critical index, or repeated <code>PQ_LIB_REPO_UNREACHABLE</code> for primary mirrors. Include forensic_manifest and audit_tail when contacting SRE. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Comprehensive failure modes & mitigations (explicit):</strong><br><strong>mChecksum mismatch across environments:</strong><br>1. Likely cause: canonicalization differences (line endings, Unicode normalization, indentation rules). <br>2. Mitigation: run cross-language golden checks; reproduce canonicalization step using evidenceRef; update canonicalization policy only via migration manifest and golden updates. <br><strong>Hidden-sheet payload truncation:</strong><br>1. Cause: Excel cell size limits or export tool truncation. <br>2. Mitigation: persist embedded payload into evidence store and reference via evidenceRef; use PromoteHiddenSheetToRepo for recovery. <br><strong>AtomicPersistIndex ENOSPC:</strong><br>1. Cause: insufficient disk space on target volume. <br>2. Mitigation: stage to a configured fallback path on the same mount if possible, emit <code>pq_library.index.persist.ENOSPC</code> audit with freeBytes and escalate to infra. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Governance & PR acceptance checklist (hard gating):</strong><br>1. OWNERS approvals present and recorded. <br>2. ComputeMChecksum golden vectors updated and tested cross-language. <br>3. Hidden-sheet fallback tests included for distribution packages that embed templates. <br>4. AtomicPersistIndex and AtomicWrite tests across target filesystems. <br>5. Signature verification end-to-end validated and key rotation tested. <br>6. Audit hooks wired in and modAudit rotation validated. <br><strong>Blocking items:</strong> missing audit on index write, failing mChecksum parity, forbidden-API static analyzer alerts, missing OWNER sign-off for regulated templates. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Appendix A — example audit row schema (detailed recommended fields):</strong><br><strong>Required fields:</strong> timestamp, correlationId, module, procedure, operatorId (optional), paramsHash, resultHash (optional), evidenceRef (optional), durationMs, metadata (artifactChecksum, tempPathList, indexHash, validationSummary), traceId (distributed tracing), hostId. <br><strong>Policy:</strong> top-level audit rows must not contain raw PII or secrets. Store sanitized full params in evidence store referenced by evidenceRef. All audits are append-only and chained. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Appendix B — extended narrative: deterministic tie-breakers & SafeRound forensic example:</strong><br><strong>Scenario (detailed):</strong> A payroll allocation algorithm splits a salary pool into many accounts using weights that produce exact half-cent ties in several rows. The requirement: the sum of rounded allocations must equal the rounded total. <br><strong>Procedure & evidence chain:</strong><br>1. Worker computes canonical decimals and calls <code>SafeRoundResiduals(values, total, places=2, tieBreakerKeys=employeeIdOrder)</code>. <br>2. <code>SafeRoundResiduals</code> scales, computes floors and residuals, computes remaining increments and deterministically assigns increments by <code>(residual desc, tieBreakerKeys asc, originalIndex asc)</code>. <br>3. The worker emits <code>util.saferound.start</code> with paramsHash and <code>util.saferound.complete</code> with outputHash and a SafeRound evidence bundle persisted to the evidence store (input normalized decimals, scaled intermediate integers, assigned increments, final allocations). <br>4. The allocation artifact is persisted via <code>AtomicWrite</code> and <code>pq_library.index.persist.completed</code> references the allocation artifactChecksum. <br>5. For forensic replay, the investigator retrieves correlationId audits, the SafeRound evidenceRef, restores canonical decimals and tieBreakerKeys, runs <code>SafeRoundResiduals</code> and confirms the artifact checksum matches the published allocation. This provides a full deterministic reconstruction of allocation decisions. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Appendix C — extended PQ author guidance & practical examples:</strong><br><strong>Example — Template that needs high-precision rounding:</strong><br>1. Template metadata: <code>requiresHighPrecision: true</code>, <code>owners: [&quot;finance-team@domain&quot;]</code>. <br>2. Template author designs M to produce normalized fractions per account and emits an intermediate canonical CSV payload (normalized decimals) instead of performing final rounding in M. <br>3. The publish/inject orchestration sends the normalized CSV to worker <code>SafeRoundResiduals</code> which performs authoritative rounding and persists the signed artifact that PQ_Injector will insert. <br><strong>Rationale:</strong> avoids host-dependent rounding differences when the final dataset is used for accounting. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Appendix D — conceptual DAX examples (concrete measure snippets but described, not code):</strong><br><strong>Measure pattern 1 — ReconciledFlag:</strong> store <code>expectedChecksum</code> in RunMetadata; create a measure that returns 1 when artifactChecksum equals expectedChecksum and 0 otherwise. Use this measure in reports to display a verification badge. <br><strong>Measure pattern 2 — Sample membership:</strong> ETL computes <code>HashKey</code> and stores <code>correlationSalt</code>; provide a DAX measure that filters rows where <code>MOD(HashKey, N) &lt; k</code> to create deterministic sample slices. Persist salt and sample definition in RunMetadata to reproduce exact sample selections. <br><strong>Guidance:</strong> avoid computing rounding logic in DAX; rely on ETL-side <code>SafeRoundResiduals</code> outputs. Provide a small user-facing DAX measure that surfaces <code>templateId</code> and <code>templateVersion</code> for provenance. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Appendix E — extended operator incident playbook (step-by-step):</strong><br><strong>Incident: "Injected query does not match published artifact (mChecksum mismatch)"</strong><br>1. Capture correlationId from <code>pq_template.inject.prepare</code> audit. <br>2. Run <code>pqlib diagnostics collect --correlation &lt;id&gt;</code> to collect audit_tail, evidenceRefs, index snapshot and artifact files. <br>3. Use <code>ComputeMChecksum</code> on canonicalized text from evidenceRef and compare to published <code>mChecksum</code> and injected query. <br>4. If injected query differs due to client-side transformation, identify the conversion step (e.g., workbook encoding or editor auto-format) and record as a remediation item: prefer injection of signed artifact rather than client paste. <br>5. If mismatch due to canonicalization rules change, generate migration manifest and open a controlled release to update golden vectors and inform operators. <br>6. If tampering suspected, lock affected artifacts, escalate to security, and prepare forensic package for regulator if required. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Appendix F — glossary of key terms (concise):</strong><br>1. <code>mChecksum</code> — canonical checksum of an M template after canonicalization. <br>2. <code>evidenceRef</code> — secure reference to persisted evidence (canonical text, RNG state, SafeRound traces). <br>3. <code>AtomicPersistIndex</code> — atomic update mechanism for the template index. <br>4. <code>Hidden-sheet fallback</code> — embedded workbook sheet serving as offline template source. <br>5. <code>SafeRoundResiduals</code> — deterministic rounding allocator ensuring sum-preservation. <br>6. <code>DeterministicRNG</code> — seedable RNG whose outputs are stable across languages and runs given same seed. </td></tr><tr><td data-label="PQ_Library — Per-function Expert Technical Breakdown"> <strong>Final governance & mandatory constraints (non-negotiable):</strong><br>1. All templates intended for downstream consumption must be published with <code>mChecksum</code>. <br>2. Hidden-sheet fallback must be recorded via <code>pq_library.hidden_sheet.fallback</code> audit and promoted only after owner approval. <br>3. Canonicalization rules enforced by CI; changes require migration manifest and cross-language golden updates. <br>4. Signing required for regulated templates; signing keys managed via CORE_Security and key rotation tracked in audits. <br><strong>Verification:</strong> this specification provides the deterministic chain from authoring to injection and model consumption with mandatory audits and evidence persistence to satisfy compliance, reproducibility, and operational reliability requirements. </td></tr></tbody></table></div><div class="row-count">Rows: 44</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>