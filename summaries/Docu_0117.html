<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1767518008">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0117_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Executive Summary — Short</strong><br>Root cause is almost certainly deterministic within <strong>convert.py</strong>: caption metadata is present in inputs used by TableViewer (TV) but is either not recognized, stripped, overwritten, or not forwarded when P2T runs convert.py. TV’s successful rendering isolates the failure to the preprocess/parse/fragment-construction stages unique to P2T. Restoring caption requires targeted fixes in metadata extraction, normalization, and fragment construction paths inside convert.py plus a defensive test/instrumentation suite.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td></tr><tr><td data-label="Technical Breakdown"> <strong>Scope & Observables</strong><br>• Symptom: final HTML produced by P2T contains no caption where TV shows one. <br>• Confirmed: core_renderer and downstream shared modules are functional — they emit captions when <code>fragment.caption</code> is non-empty. <br>• Unique component: convert.py does parsing and builds the fragment object fed to renderer. <br>• Therefore: the failure surface is limited to convert.py and its interactions with parsing libraries and TableFragment constructors.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td></tr><tr><td data-label="Technical Breakdown"> <strong>Single-Sentence Root Hypothesis</strong><br>convert.py either fails to extract caption metadata from one or more input syntaxes or removes/overwrites the caption during normalization or fallback reconstruction, resulting in <code>fragment.caption</code> being empty at render time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-Confidence Failure Vectors (ranked)</strong><br>1. <strong>Metadata whitelist filtering</strong> — convert.py applies a metadata allowlist that omits <code>caption</code>, so extracted captions are discarded during cleaning. <br>2. <strong>Parser blind spot</strong> — the markdown/CSV parser in convert.py doesn’t detect caption forms (above/below, HTML <code>&lt;caption&gt;</code>, YAML frontmatter, mail-merged CSV caption column). <br>3. <strong>Normalization collapse</strong> — node merging or AST flattening removes sidecar caption nodes when collapsing adjacent nodes into a single table node. <br>4. <strong>Fragment constructor omission</strong> — TableFragment or equivalent is invoked with no caption argument or with default <code>&quot;&quot;</code> due to a refactor or signature mismatch. <br>5. <strong>Sanitizer stripping</strong> — a sanitization routine flags the caption string as unsafe (HTML sanitizer or strip-html step) and nulls it out. <br>6. <strong>Late fallback overwrite</strong> — a fallback rebuild (CSV→table normalize) constructs a new fragment and forgets to copy caption metadata.                                                                                                                                                                                                                                                                                                                                                                        </td></tr><tr><td data-label="Technical Breakdown"> <strong>Concrete Evidence to Collect Immediately (instrumentation points)</strong><br>Insert structured debug logs (or assertions in dev builds) at these exact locations in convert.py: <br>• Immediately after raw parse: <code>logger.debug(&quot;parse: metadata=%s&quot;, metadata)</code> — dump full metadata dict. <br>• After caption extraction: <code>logger.debug(&quot;caption-extracted: %r&quot;, caption)</code> — show <code>None</code>/<code>&quot;&quot;</code> or string. <br>• Before normalization/merge: <code>logger.debug(&quot;pre-normalize nodes: %s&quot;, repr(nodes_summary))</code> — include node types and whether a <code>caption</code> node exists. <br>• After normalization/merge: <code>logger.debug(&quot;post-normalize nodes: %s&quot;, repr(nodes_summary))</code>.<br>• Right before TableFragment creation: <code>logger.debug(&quot;Constructing TableFragment caption=%r, meta=%s&quot;, caption_arg, fragment_meta)</code>.<br>• Immediately before handing to renderer: <code>logger.debug(&quot;Fragment to render: %s&quot;, fragment.to_dict())</code>.<br>Add correlation IDs to logs for a single request to follow the flow. Add an assertion: <code>assert not (original_input_contains_caption and fragment.caption in (None, &quot;&quot;)), &quot;caption lost in convert.py&quot;</code> in development.                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="Technical Breakdown"> <strong>Exact Code Areas to Inspect (file-level)</strong><br>• <code>metadata_extractor</code> functions (markdown frontmatter, inline metadata, HTML caption, CSV header mapping).<br>• <code>sanitize()</code> / <code>cleanup()</code> / <code>strip_unsafe()</code> functions — look for regexes that drop HTML tags or keys.<br>• AST walker/merger — functions that collapse adjacent nodes (look for code that merges paragraph nodes into table nodes or removes sibling nodes).<br>• TableFragment (or equivalent) constructor call sites — confirm signature and argument ordering; search for <code>TableFragment(</code>, <code>new TableFragment(</code>, or factory functions like <code>build_fragment(...)</code>.<br>• Fallback conversion code paths (CSV fallback, forced-normalize) which rebuild fragments from raw cells — they may skip metadata.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </td></tr><tr><td data-label="Technical Breakdown"> <strong>Common Mistakes Found in Similar Projects</strong><br>• Allowlist/denylist drift during refactor: <code>caption</code> removed from <code>ALLOWED_META</code> when tightening acceptable keys. <br>• Name mismatch: parsers put caption under <code>title</code>/<code>desc</code> but fragment expects <code>caption</code>. <br>• Normalization merges <code>&lt;caption&gt;</code> element into table body then discards it. <br>• Sanitizer configured to strip top-level HTML tags, inadvertently deleting entire caption when it contains markup. <br>• Multiple parse backends (markdown vs CSV) produce inconsistent key names; convert.py fails to canonicalize.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </td></tr><tr><td data-label="Technical Breakdown"> <strong>Canonical Fix Strategy (ordered, actionable)</strong><br>1. <strong>Trace & Assert</strong>: add the debug logging and a dev-only assertion described above; reproduce one or two failing inputs. <br>2. <strong>Canonical metadata key</strong>: choose a single internal key name (e.g., <code>caption</code>) and add an explicit canonicalization step that maps all parser outputs (<code>title</code>, <code>caption_text</code>, <code>meta.caption</code>, <code>frontmatter.caption</code>, etc.) into <code>meta[&#x27;caption&#x27;]</code>. <br>3. <strong>Whitelist update</strong>: ensure any metadata allowlist includes <code>caption</code>. <br>4. <strong>Preserve through normalize</strong>: update normalizer/merger to explicitly hoist caption nodes out of table-body merges. Pattern: if a <code>caption</code> sibling/node exists, keep it as a dedicated property on the table node during merges instead of dropping. <br>5. <strong>Fragment constructor contract</strong>: inspect all TableFragment construction points and enforce passing <code>caption=meta.get(&#x27;caption&#x27;)</code> (or passing the <code>meta</code> dict intact). Add signature checks or use a builder/factory to centralize construction. <br>6. <strong>Sanitizer adjustment</strong>: run caption strings through the sanitizer but maintain them; if stripping is required, keep a sanitized fallback (e.g., <code>caption_html</code> and <code>caption_text</code>) rather than nulling the key. <br>7. <strong>Fallback copy</strong>: in any fallback path that rebuilds a fragment, copy <code>meta[&#x27;caption&#x27;]</code> into the rebuilt fragment. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Minimal Patch (pseudo-code)</strong><br>```py                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td></tr></tbody></table></div><div class="row-count">Rows: 9</div></div><div class="table-caption" id="Table2" data-table="Docu_0117_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Session Purpose & Outcome</strong><br>Goal: identify why PasteToTable (P2T) drops captions while TableViewer (TV 2.1) renders them correctly. Conclusion: caption loss occurs only in <strong>convert.py</strong>, the sole module unique to P2T’s pipeline. All shared downstream modules are confirmed correct. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Architecture Comparison</strong><br>TV path: fragment → renderer → HTML → UI.<br>P2T path: raw text → <strong>convert.py</strong> → fragment → renderer → HTML → UI.<br>Only convert.py differs, so the caption must be removed there. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Eliminated Modules (Verified Good)</strong><br><code>core_renderer</code>: proven good because TV injects captions.<br><code>core_table</code>: structural logic only.<br><code>core_fragments</code>: stores metadata but does not strip it.<br>No shared module can produce a failure affecting only P2T. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Root Cause: convert.py</strong><br>convert.py performs parsing, normalization, sanitization, node merging, and fragment construction. Any of these can drop caption metadata.<br>Likely caption loss vectors:<br>• Missing metadata key in whitelist<br>• Caption parsed but overwritten<br>• Caption never extracted<br>• Caption removed during normalization<br>• Caption not passed into fragment constructor </td></tr><tr><td data-label="Technical Breakdown"> <strong>Symptom → Inference</strong><br>Final HTML contains no caption → renderer received <code>caption=&quot;&quot;</code> or <code>None</code>.<br>Renderer works in TV → caption missing <strong>before</strong> renderer → convert.py is responsible. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-Probability Failure Zones in convert.py</strong><br>1. Metadata whitelist filtering: caption excluded.<br>2. Parser blind spot: caption syntax unrecognized.<br>3. Node collapse/merge: caption node discarded during normalization.<br>4. Reconstruction omission: TableFragment constructed without caption.<br>5. Sanitization step: caption removed as “unsafe.”<br>6. Late overwrite: fallback “normalize table” resets caption to empty. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Exact Code Areas to Inspect</strong><br>• metadata extractors<br>• sanitize/cleanup routines<br>• both pipe-table and CSV parsers<br>• AST flatteners and node mergers<br>• TableFragment and related constructors<br>• normalization and fallback table rebuild paths </td></tr><tr><td data-label="Technical Breakdown"> <strong>Verification Procedure</strong><br>1. Print metadata before sanitize.<br>2. Print caption right before constructing TableFragment.<br>3. Compare TV vs P2T fragment objects before rendering.<br>4. Add assertion: caption must not be empty when present in user input. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Renderer Cross-Validation</strong><br>Renderer always emits caption when fragment.caption is non-empty.<br>TV demonstrates correct behavior; thus renderer cannot be the cause of selective caption loss. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Structural Risks in convert.py</strong><br>• overly aggressive metadata filtering<br>• normalization that discards sidecar nodes<br>• fallback rebuilt fragments that omit caption keys<br>• inconsistent caption propagation across markdown/CSV modes </td></tr><tr><td data-label="Technical Breakdown"> <strong>Fix Approach</strong><br>• include “caption” in allowed metadata keys<br>• ensure each parser extracts caption<br>• preserve caption during normalization<br>• guarantee caption is forwarded to fragment constructor<br>• prevent overwrite during fallback conversions </td></tr><tr><td data-label="Technical Breakdown"> <strong>Testing Matrix</strong><br>• caption above table<br>• caption below table<br>• HTML <code>&lt;caption&gt;</code> inside table<br>• markdown metadata caption<br>• mixed HTML + markdown<br>• CSV tables with caption field </td></tr><tr><td data-label="Technical Breakdown"> <strong>Final Consolidation</strong><br>TV proves core_renderer is correct.<br>P2T fails because convert.py preprocesses input.<br>Therefore caption loss is deterministic inside convert.py.<br>Correcting metadata extraction/propagation in convert.py will restore caption injection with no changes to core_renderer. </td></tr></tbody></table></div><div class="row-count">Rows: 13</div></div><div class="table-caption" id="Table3" data-table="Docu_0117_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Executive Technical Thesis</strong>: Caption rendering succeeds only when the fragment model includes a valid, canonical, correctly propagated caption field. TableViewer (TV 2.1) produces such fragments directly and therefore renders captions flawlessly. PasteToTable (P2T) creates fragments only through <code>convert.py</code>, which transforms raw input into structured fragments. Since TV bypasses convert.py entirely, and since all downstream modules (core_renderer, core_fragments, core_table, HTML builder) are shared and empirically validated by TV’s correct output, the only possible subsystem capable of deleting, suppressing, or failing to propagate caption metadata is convert.py. The entire failure is therefore caused by convert.py’s parsing, normalization, filtration, flattening, remapping, or sanitization logic removing or mis-mapping caption data before core_renderer receives the fragment. Only convert.py can produce this asymmetry. Fixing caption propagation inside convert.py fully restores caption injection within P2T. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Architectural Control-Flow Isolation (Deterministic Conclusion)</strong>: TV path = fragment model → core_renderer → HTML. P2T path = user input → convert.py → fragment model → core_renderer → HTML. The fragment model is the pivot point. TV constructs it correctly; P2T constructs it incorrectly. Shared modules after fragment construction cannot selectively malfunction only for P2T. This is a classic upstream-only fault. convert.py is the sole upstream transformer. Therefore convert.py is exclusively responsible. No alternate model fits all observable evidence. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Observed Runtime Behavior Across All Reported Tests</strong>: P2T: captions omitted in final HTML; fragment model shows no caption field or an empty caption. TV: captions present in final HTML; fragment model includes valid caption. When identical table structures are passed to TV, caption appears; when identical data is passed through convert.py, caption disappears. No downstream pathway ever adds captions—caption presence depends entirely on convert.py. Renderer never fabricates caption data; it only outputs what exists. If convert.py outputs a fragment without caption, renderer cannot compensate. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Deep Internal Failure Modes in convert.py (Expanded, Ranked Analysis)</strong>: (1) <strong>Metadata filtering/allowlisting inconsistency</strong>: convert.py likely enforces strict attribute schemas via lists such as allowed_keys or valid_meta. If “caption” is missing, it is silently dropped. This is the highest-probability mechanism because it perfectly matches the symptom: caption appears in TV but disappears in P2T. (2) <strong>Caption stored under a deprecated or mismatched key</strong>: convert.py may store captions under names like “title”, “label”, or “note”, while core_renderer expects “caption”. If conversion logic never canonicalizes keys, core_renderer receives an empty caption. (3) <strong>Node flattening and structural normalization</strong>: convert.py includes logic that collapses multi-node structures, merges text, and discards nodes classified as non-essential. Captions may be misclassified as pre-table stray blocks and removed. (4) <strong>HTML/Markdown sanitization stage</strong>: Sanitizers may classify caption text as unsafe if containing backticks, pipes, or inline markup. Sanitizer may blank caption completely. (5) <strong>Incorrect parsing-path selection</strong>: convert.py may use alternative parse paths for CSV, Markdown pipe tables, or mixed HTML; some of these paths likely lack caption extraction entirely. The presence of multiple parsing entry points increases the chance of inconsistent caption handling. (6) <strong>Incomplete constructor propagation</strong>: convert.py may parse caption and store it in meta but not pass it into TableFragment, losing caption at object-level even if meta contains it. (7) <strong>Fallback parser overrides metadata</strong>: Some fallback routines may regenerate minimal table fragments without including caption, overriding previously extracted metadata. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>High-Resolution Internal Indicators of Each Failure Class</strong>: (1) If caption appears in early parsing logs but disappears in fragment.meta, filtering occurred. (2) If caption appears in meta but not in fragment.caption, TableFragment constructor path is faulty. (3) If caption appears before a normalization pass but disappears after, flattening or sanitization is at fault. (4) If caption appears only when input follows a particular format (e.g., HTML-based captions but not markdown captions), multiple parser-path inconsistencies exist. (5) If captions containing punctuation fail while plain ASCII captions succeed, sanitizer overreach is occurring. (6) If captions vanish only when table appears after another block (e.g., before/after text), block-boundary heuristics may be stripping associated metadata. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Expanded Convert.py Behavioral Audit (Target Regions to Inspect Carefully)</strong>: (A) <strong>Metadata schema definitions</strong>: Global dictionaries or sets establishing which metadata keys survive extraction; caption must be enumerated consistently across all schemas. (B) <strong>Normalization routines</strong>: Functions such as normalize_meta, normalize_table, process_markdown_block, or clean_attributes. These often re-map key names or remove unknown keys. (C) <strong>Parsing states and tokenizers</strong>: Markdown pipe-table parser, CSV parser, and HTML table parser. Each path must produce consistent metadata fields. Captions may appear only in HTML parsing code and absent in markdown or CSV mapping. (D) <strong>Block-level detectors</strong>: convert.py likely groups blocks (paragraph, table, code, caption). If caption is misidentified as stray text instead of table-level metadata, it is discarded. (E) <strong>Child-node attachment</strong>: When tables are parsed as structures containing header, body, and caption nodes, convert.py must attach caption nodes to their parent. Missing attachment results in lost caption. (F) <strong>Rewrite layers</strong>: After parsing, convert.py may rebuild a normalized representation; rewriting often drops non-row elements. This can silently remove captions. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Systematic Full Trace of Caption Lifecycles</strong>: A caption’s lifetime within P2T should follow this sequence: (1) raw detection (markdown or HTML) → (2) extraction into a temporary structure → (3) mapping into canonical meta keys → (4) normalization/sanitization while preserving keys → (5) TableFragment construction with caption → (6) output to core_renderer. If any stage omits caption, final output is empty. Current behavior implies interruption at either stage (3), (4), or (5). TV’s correct output proves stage (6) is correct. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Edge Case Matrix convert.py Must Support (Exhaustive)</strong>: (a) Captions on a dedicated preceding or trailing line. (b) Captions encoded using colon prefix/suffix metadata syntax. (c) Captions embedded in HTML <code>&lt;caption&gt;</code> tags. (d) Captions containing tables, pipes, or escaped characters. (e) Captions using unicode combining characters. (f) Captions that include inline code spans. (g) Captions extracted from CSV-based metadata. (h) Captions that coexist with footnotes, labels, IDs, or CSS classes. (i) Captions in compact one-line markdown tables. (j) Captions adjacent to fenced code blocks. convert.py must treat captions as first-class metadata independent of syntactic form or context. Any edge case incorrectly handled can produce selective caption loss. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Reliability Requirements convert.py Must Uphold</strong>: Captions must not be dropped in any branches, must be mapped to a single canonical field recognized by core_renderer, must survive text normalization and HTML sanitization, must remain attached to the table fragment object, and must maintain consistent typing (string, never None or False). Metadata logic must be deterministic so identical inputs always produce identical fragment.caption values. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Comparative Analysis with TV (Definitive Proof)</strong>: TV constructs fragments through a dedicated internal mechanism that treats caption as a stable field. Because TV outputs correct captions, all downstream rendering logic is validated. If core_renderer had any caption bug (e.g., HTML template omission, empty-string guard, conditional ordering logic), TV would exhibit identical failures. It does not. Therefore the renderer is unequivocally correct. Any alternative hypothesis contradicts observed behavior. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Final Logical Deduction Chain (Irrefutable)</strong>: (1) Captions missing in P2T. (2) Captions present in TV. (3) Renderer is shared. (4) Fragments are constructed differently. (5) Only convert.py constructs fragments for P2T. (6) convert.py must be producing incorrect fragments. (7) Therefore convert.py contains the fault. No downstream module can cause this asymmetry. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Pre-Fix Validation Checklist</strong>: Confirm the following before applying any changes: caption absent in convert.py output; caption present in raw input; no blocking logic in renderer; no caption content visible in sanitized HTML; same input produces correct caption in TV. These confirm upstream-only failure. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Post-Fix Validation Requirements</strong>: After modifying convert.py, P2T must produce fragment.caption matching TV’s output for identical data. HTML output must contain <code>&lt;caption&gt;</code> with exact text. All metadata and style attributes must remain unaffected. Multiple table formats must pass tests. Regression tests must confirm no caption loss in any branch. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Operational Impact Assessment</strong>: Fixing convert.py restores consistent metadata propagation. No behavior changes required in renderer. Risk is concentrated in metadata sanitization and mapping logic. If caption propagation is implemented properly and metadata are canonicalized consistently, the system becomes stable. Failing to patch convert.py keeps P2T fundamentally unreliable for caption-bearing tables. </td></tr><tr><td data-label="Technical Review — Ultra-Detailed, Fully Consolidated Diagnostic (one column, no snippets, no extra blank lines)"> <strong>Final Consolidated Statement</strong>: The only technically valid root cause of the caption injection failure is convert.py’s failure to preserve, canonically map, or correctly attach caption metadata during parsing or normalization. TV proves all downstream logic is correct; therefore convert.py must be audited and updated to ensure captions survive all preprocessing stages. Addressing caption propagation inside convert.py completely resolves the P2T caption injection failure. </td></tr></tbody></table></div><div class="row-count">Rows: 15</div></div><div class="table-caption" id="Table4" data-table="Docu_0117_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Aspect"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Aspect</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Details"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Details</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Aspect"> <strong>Purpose of <code>script.list.js</code></strong>      </td><td data-label="Details"> Render the UI for file/group selection and metadata loading.<br> <em>No caption injection or copy button handling inside this script.</em>                                                                                                                                                                                                                                </td></tr><tr><td data-label="Aspect"> <strong>Labels Files</strong>                     </td><td data-label="Details"> - <code>labels.json</code>: used by the list form (frontend) for displaying basic labels.<br>- <code>labels_injected.json</code>: used by the core_renderer (server-side or client-side renderer) for caption injection and rendering metadata.                                                                                                                                          </td></tr><tr><td data-label="Aspect"> <strong>Role of <code>server.py</code></strong>              </td><td data-label="Details"> - Reads <code>labels.json</code> (or raw label data) to generate <code>labels_injected.json</code> by injecting or augmenting captions.<br>- Supplies <code>labels_injected.json</code> to the core_renderer or rendering pipeline.<br>- Coordinates with frontend (script.list.js) only via metadata, never raw captions or injection.                                                             </td></tr><tr><td data-label="Aspect"> <strong>Frontend Flow (<code>script.list.js</code>)</strong> </td><td data-label="Details"> - Load file/group metadata and display list with basic label info only.<br>- Send metadata about active group on load.<br>- No direct handling or injection of captions — done downstream by the renderer after server-side preparation.<br>- No copy button logic required here anymore.                                                                          </td></tr><tr><td data-label="Aspect"> <strong>Server-side Label Injection</strong>      </td><td data-label="Details"> - <code>server.py</code> must incorporate logic to parse and transform <code>labels.json</code> into <code>labels_injected.json</code>.<br>- Ensure caption data is sanitized and properly formatted for renderer consumption.<br>- Keep <code>labels_injected.json</code> updated when <code>labels.json</code> or files change.<br>- Provide API endpoint or static asset access for renderer to fetch injected labels. </td></tr><tr><td data-label="Aspect"> <strong>Integration Points</strong>               </td><td data-label="Details"> - <code>script.list.js</code> fetches group and file metadata, including basic labels.<br>- Upon load, sends group metadata to server (e.g., <code>/api/group/load</code>) for tracking or other server logic.<br>- Renderer uses <code>labels_injected.json</code> to enrich rendering output with injected captions.                                                                              </td></tr></tbody></table></div><div class="row-count">Rows: 6</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>