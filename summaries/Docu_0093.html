<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1765644791">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      // Delegate addEventListener/removeEventListener to visible button
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      // Delegate onclick assignments
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      // Delegate focus/blur
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
      // If legacy code used direct addEventListener earlier than this script, listeners would already exist
      // on alias element; attempt to re-dispatch those by cloning them to visible button is non-trivial.
      // This approach covers the common case where legacy scripts query the alias and bind after DOM ready.
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li>
<li class="toc-item"><a class="toc-link" href="#Table6">Table 6</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0093_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1 • Single-column Markdown table that uses &lt;details&gt; and &lt;summary&gt;</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown for Table Optimization**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown for Table Optimization</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown for Table Optimization"> <details><summary><strong>1️⃣ Prioritized File Checks</strong></summary><br><strong>1. assets/script.table.js</strong> — Handles caption insertion, ID assignment, copy delegation, and table-specific post-processing. Ensure <code>TableN</code> IDs are stable. Check for destructive operations (<code>table.id = ...</code>, <code>caption.id = ...</code>) and confirm captions respect existing IDs.<br><br><strong>2. assets/script.core.js</strong> — Main conversion and render lifecycle. Converts marked-up text to HTML tables, triggers caption-applier events <strong>after DOM is rendered</strong>, and must avoid destructive operations (<code>innerHTML</code> or <code>replaceChildren</code>). Add logging before/after these operations.<br><br><strong>3. render/core_table.py, render/convert.py, html_renderer.py, server.py</strong> — Server-side scripts for deterministic ID generation and caption rendering. Confirm server-generated captions match client-side selectors. Consider per-table hash for consistency.<br><br><strong>4. assets/script.toc.js</strong> — Builds TOC, normalizes IDs, anchors navigation. Ensure it does not overwrite table/caption IDs and listens to <code>ptt:render-complete</code> to avoid firing too early.<br><br><strong>5. assets/script.save.js</strong> — Handles post-render DOM operations and caching. Wrap DOM replacements with logging, temporarily disable destructive operations for diagnostics, ensure changes occur <strong>after captions are applied</strong>.</details> </td></tr><tr><td data-label="Technical Breakdown for Table Optimization"> <details><summary><strong>2️⃣ Likely Failure Modes</strong></summary><br><strong>1. Client overwrites server captions:</strong> Container replacements (<code>innerHTML</code>) may erase captions. Add logging and comment out destructive code temporarily.<br><br><strong>2. Race condition:</strong> Applier may run before DOM exists. Use:<br><code>try { window.dispatchEvent(new CustomEvent(&#x27;ptt:render-complete&#x27;)); } catch(e){}</code><br>Also listen for <code>ptt:group-loaded</code> if tables load asynchronously.<br><br><strong>3. Selector mismatch:</strong> Renderer may emit <code>&lt;caption&gt;</code> or <code>&lt;h3&gt;</code> instead of <code>.table-caption</code>. Standardize selectors, normalize IDs, strip <code>&lt;br&gt;</code> tags.<br><br><strong>4. Performance bottlenecks:</strong> Large tables (~290k nodes) freeze browser with synchronous DOM updates. Use chunked updates or IntersectionObserver + batched updates (50–200 nodes per batch).<br><br><strong>5. Mixed server-client DOM:</strong> Differences in server-generated captions vs client DOM may misalign tables. Introduce per-table hash verification.</details> </td></tr><tr><td data-label="Technical Breakdown for Table Optimization"> <details><summary><strong>3️⃣ Quick Diagnostic Snippet</strong></summary><br>``<code>javascript&lt;br&gt;(function(){&lt;br&gt;  var caps = Array.isArray(window.__ptt_runtime_captions)? window.__ptt_runtime_captions.slice(0,200):[];&lt;br&gt;  var nodes = Array.from(document.querySelectorAll(&#x27;.table-caption, caption, h1,h2,h3&#x27;)).slice(0,200);&lt;br&gt;  console.log(&#x27;captions.length&#x27;, caps.length, &#x27;nodes.length&#x27;, nodes.length);&lt;br&gt;  for(var i=0;i&lt;Math.max(caps.length, nodes.length, 50); i++){&lt;br&gt;    console.log(i+1,&#x27;caption-&gt;&#x27;,caps[i],&#x27;&lt;empty&gt;&#x27;,&#x27;node-&gt;&#x27;,nodes[i]? (nodes[i].tagName+&#x27;:&#x27; + (nodes[i].id) + &#x27;:&#x27; + nodes[i].textContent.slice(0,40)) : &#x27;&lt;no-node&gt;&#x27;);&lt;br&gt;  }&lt;br&gt;})();&lt;br&gt;</code>``<br>Compare captions vs DOM nodes. Look for mismatched IDs or missing captions.</details> </td></tr><tr><td data-label="Technical Breakdown for Table Optimization"> <details><summary><strong>4️⃣ Immediate Safe Fix Options</strong></summary><br><strong>1. Defensive caption-applier</strong> — Listen to <code>ptt:render-complete</code>, apply captions in batches via <code>requestIdleCallback</code> or <code>setTimeout</code> (50–200 nodes).<br><br><strong>2. Patch destructive renders</strong> — Prevent full container <code>innerHTML</code> replacement post-caption insertion. Target only rows/cells.<br><br><strong>3. Logging instrumentation</strong> — Log before/after render and caption insertion:<br><code>console.log(&#x27;Before container update:&#x27;, container.id);</code><br><code>console.log(&#x27;After update:&#x27;, container.id);</code><br><br><strong>4. Selector normalization</strong> — Use <code>.table-caption, caption, h1,h2,h3</code> consistently.<br><br><strong>5. Performance safeguards</strong> — Use IntersectionObserver + batching.<br><br><strong>6. Unit test small tables</strong> — Validate applier logic incrementally.<br><br><strong>7. Auto-retry missing captions</strong> — Retry injection after timeout.</details> </td></tr><tr><td data-label="Technical Breakdown for Table Optimization"> <details><summary><strong>5️⃣ Stepwise Implementation Plan</strong></summary><br>1. Add console logging around all DOM mutations.<br>2. Normalize selectors (<code>.table-caption, caption, h1,h2,h3</code>).<br>3. Dispatch <code>ptt:render-complete</code> after DOM render.<br>4. Apply captions in async chunks (idle callback or timeout).<br>5. Disable destructive <code>innerHTML</code> updates temporarily.<br>6. Run diagnostic snippet and verify caption mapping.<br>7. Introduce IntersectionObserver batching.<br>8. Tune batch size and idle timeout.<br>9. Monitor main-thread performance.<br>10. Re-enable safe updates after stability confirmed.<br>11. Test across browsers and payload sizes.<br>12. Add regression suite.<br>13. Integrate diff snapshots for QA.<br>14. Implement retry and logging queue.</details> </td></tr><tr><td data-label="Technical Breakdown for Table Optimization"> <details><summary><strong>6️⃣ Advanced IntersectionObserver Pattern</strong></summary><br>``<code>javascript&lt;br&gt;const observer = new IntersectionObserver((entries)=&gt;{&lt;br&gt;  entries.forEach(entry=&gt;{&lt;br&gt;    if(entry.isIntersecting){&lt;br&gt;      applyCaptions(entry.target);&lt;br&gt;      observer.unobserve(entry.target);&lt;br&gt;    }&lt;br&gt;  });&lt;br&gt;},{ root:null, rootMargin:&#x27;100px&#x27;, threshold:0.1 });&lt;br&gt;document.querySelectorAll(&#x27;.table-container&#x27;).forEach(tbl=&gt;observer.observe(tbl));&lt;br&gt;</code>``<br>Ensures captions load only for visible or soon-visible tables.</details> </td></tr><tr><td data-label="Technical Breakdown for Table Optimization"> <details><summary><strong>7️⃣ Verification and Recovery</strong></summary><br>1. Capture server captions snapshot before DOM injection.<br>2. Compare with client-injected captions.<br>3. Log missing or mismatched captions.<br>4. Retry missing ones in batches.<br>5. Track with performance metrics (<code>ptt.tables.injected</code>).<br>6. Confirm consistency between TOC and table IDs.<br>7. Escalate only after 3 failed retries per table.</details> </td></tr><tr><td data-label="Technical Breakdown for Table Optimization"> <details><summary><strong>8️⃣ Next Revision Target</strong></summary><br>Next file to revise: <strong>assets/script.table.js</strong> (focus: async caption applier, IntersectionObserver batching, precomputed caption support).<br><br>After that: <strong>assets/script.list.js</strong> to avoid double-render interference.</details> </td></tr></tbody></table></div><div class="row-count">Rows: 8</div></div><div class="table-caption" id="Table2" data-table="Docu_0093_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2 • Technical Breakdown</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Prioritized File Checks</strong> <br><br><strong>assets/script.table.js</strong> — Handles caption insertion, ID assignment, copy delegation, and table-specific post-processing. It is critical to ensure that <code>TableN</code> IDs are stable, especially when multiple tables are rendered in succession or when tables are dynamically updated via the <code>convert</code> or <code>paste</code> actions. Confirm that caption insertion functions do not overwrite pre-existing IDs or merge different tables unintentionally. Inspect for patterns like <code>table.id = ...</code> or <code>caption.id = ...</code> that might be invoked after every render cycle. <br><br><strong>assets/script.core.js</strong> — The main conversion and render lifecycle engine. It converts marked-up text to HTML tables, invokes caption insertion routines, and triggers any post-processing events. Check whether <code>convert</code> is invoked with combined marked text from multiple table sources, and confirm that it triggers caption-applier events <strong>after</strong> the DOM is fully rendered. Watch for destructive DOM operations such as replacing <code>container.innerHTML</code>, <code>container.replaceChildren()</code>, or wholesale table removal and re-creation. These can easily erase server-generated captions. Ensure that event hooks exist to notify other modules once conversion is complete. <br><br><strong>render/core_table.py, render/convert.py, html_renderer.py, server.py</strong> — These server-side scripts are responsible for deterministic ID generation, caption rendering, and HTML preparation. Confirm that server-generated captions match the client-side selectors used by the caption-applier. Differences between server and client rendering (e.g., <code>&lt;h1&gt;</code> vs <code>&lt;caption&gt;</code> vs <code>.table-caption</code>) can cause misalignment. Check that Python scripts emit predictable IDs, especially when table order or groupings vary between sessions. Consider adding a checksum or hash per table to verify consistency between server output and client DOM. <br><br><strong>assets/script.toc.js</strong> — Responsible for building the Table of Contents (TOC) based on headings, normalizing IDs, and enabling anchor navigation. Ensure it does not overwrite table or caption IDs, alter heading nodes in ways that break the caption-applier, or introduce race conditions with dynamically loaded tables. Confirm that it listens to lifecycle events like <code>ptt:render-complete</code> to avoid firing too early. <br><br><strong>assets/script.save.js</strong> — Handles post-render DOM operations such as saving table state or updating cache. Identify any operations that replace table containers or captions, especially full DOM replacements triggered by <code>innerHTML</code> assignments. Introduce logging around these operations to detect destructive replacements and verify that the DOM modifications occur <strong>after</strong> all captions are applied. Consider temporarily disabling save logic for diagnostics. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Likely Failure Modes</strong> <br><br><strong>1. Client overwrites server captions:</strong> Client-side code may replace containers (<code>container.innerHTML = ...</code>) after server captions are applied. This is a leading cause of lost captions. Implement logging before and after all DOM replacements to detect this. Temporarily comment out destructive operations to confirm the cause. <br><br><strong>2. Race condition:</strong> Caption-applier may execute before DOM nodes exist. Ensure the applier only runs <strong>after</strong> the renderer has completed. Use a custom event, e.g., <code>ptt:render-complete</code>:<br><code>try { window.dispatchEvent(new CustomEvent(&#x27;ptt:render-complete&#x27;)); } catch(e){}</code><br>Attach caption-applier logic to this event. Additionally, if tables are grouped and loaded asynchronously, listen for <code>ptt:group-loaded</code>. <br><br><strong>3. Selector mismatch:</strong> Renderer may emit <code>&lt;caption&gt;</code> or <code>&lt;h3&gt;</code> elements instead of <code>.table-caption</code>. Standardize selectors for the applier: <code>.table-caption, caption, h1,h2,h3</code>. This ensures all captions are detected. Normalize IDs and strip HTML noise such as <code>&lt;br&gt;</code> or nested tags. <br><br><strong>4. Performance bottlenecks:</strong> Extremely large tables (~290k nodes) can freeze the browser during synchronous DOM updates. Use chunked updates or a "visible-first" strategy, combining <code>IntersectionObserver</code> with batched updates. Only visible rows are updated first, and offscreen rows are updated asynchronously to prevent UI lock-ups. Consider <code>requestIdleCallback</code> for deferred work. <br><br><strong>5. Mixed server-client DOM models:</strong> Differences between server-generated captions and client DOM may lead to mismatches, especially when table groups are dynamically reordered or replaced. Introduce a hash per table and verify the hash on the client-side before applying captions. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Quick Diagnostic Snippet</strong> <br><br>Use this snippet to map runtime captions to DOM nodes, identify mismatches, and generate an audit mapping. Inspect the first 50–200 captions: <br><br><code>(function(){</code><br><code>  var caps = Array.isArray(window.__ptt_runtime_captions)? window.__ptt_runtime_captions.slice(0,200):[];</code><br><code>  var nodes = Array.from(document.querySelectorAll(&#x27;.table-caption, caption, h1,h2,h3&#x27;)).slice(0,200);</code><br><code>  console.log(&#x27;captions.length&#x27;, caps.length, &#x27;nodes.length&#x27;, nodes.length);</code><br><code>  for(var i=0;i&lt;Math.max(caps.length, nodes.length, 50); i++){</code><br><code>    console.log(i+1, &#x27;caption-&gt;&#x27;, caps[i], &#x27;&lt;empty&gt;&#x27;, &#x27;node-&gt;&#x27;, nodes[i] ? (nodes[i].tagName + &#x27;:&#x27; + (nodes[i].id || nodes[i].textContent.slice(0,40))) : &#x27;&lt;no-node&gt;&#x27;);</code><br><code>  }</code><br><code>})();</code><br><br>Paste output into a document to map captions to nodes, identify missing entries, and suggest exact fixes. Use it before and after patching to confirm correctness. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Immediate Safe Fix Options</strong> <br><br><strong>Option 1: Defensive caption-applier</strong> — Create a utility that listens for <code>ptt:render-complete</code> and applies captions in small batches using <code>requestIdleCallback</code> or <code>setTimeout</code> to avoid blocking the main thread. Apply captions in groups of 50–200 nodes. <br><br><strong>Option 2: Patch destructive renders</strong> — Modify <code>script.core.js</code> or <code>script.table.js</code> to prevent full container <code>innerHTML</code> replacements after captions are applied. Target only table rows or cells when updating content. Add logging around every lifecycle method that modifies the DOM to detect accidental overwrites. <br><br><strong>Option 3: Logging instrumentation</strong> — Surround critical points with verbose logging (before/after render, <code>innerHTML</code> updates, caption insertion). Example:<br><code>console.log(&#x27;Before container update:&#x27;, container.id, container.childElementCount);</code><br><code>console.log(&#x27;After container update:&#x27;, container.id, container.childElementCount);</code><br>Detect race conditions or destructive operations. <br><br><strong>Option 4: Selector normalization & fallback</strong> — Ensure applier queries <code>.table-caption, caption, h1,h2,h3</code>. Normalize IDs, strip <code>&lt;br&gt;</code> tags, and clean text content before applying. <br><br><strong>Option 5: Performance safeguards</strong> — For large document loads, update captions in chunks, prioritize visible tables with <code>IntersectionObserver</code>, defer offscreen updates. Combine with defensive applier from Option 1. <br><br><strong>Option 6: Unit test small tables</strong> — Before applying to full documents, verify caption-applier behavior on isolated, small tables to ensure logic is correct. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recommended Stepwise Approach</strong> <br><br>1. Add logging around every DOM mutation in core, table, and save scripts. <br>2. Normalize selectors to <code>.table-caption, caption, h1,h2,h3</code>. <br>3. Dispatch <code>ptt:render-complete</code> after convert or post-render operations. <br>4. Attach defensive caption-applier that applies captions in chunks using non-blocking updates. <br>5. Temporarily disable destructive <code>innerHTML</code> assignments. <br>6. Run diagnostic snippet to map captions to DOM nodes and verify correctness. <br>7. Implement chunked or <code>IntersectionObserver</code>-based updates for large tables. <br>8. Monitor performance and iterate. <br>9. Gradually re-enable save/replace functionality while monitoring overwrites. <br>10. Confirm consistent behavior across browsers and table sizes. <br>11. Add automated regression tests for tables and captions after core updates. <br>12. Document observed issues and fixes for knowledge sharing. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Additional Notes & Observations</strong> <br><br>- Server-generated captions are reliable but may be erased by client DOM updates. <br>- Race conditions often happen when render lifecycle is asynchronous or uses Promises; ensure events are fired strictly after all render operations. <br>- Large documents require deferred and batched updates; synchronous brute-force DOM operations will fail. <br>- Selector mismatches are subtle but common sources of errors; normalize both ID and tag selectors. <br>- Logging is your best immediate diagnostic tool; use before/after states to detect destructive updates. <br>- Consider unit-testing the caption-applier on small table sets before applying to full documents. <br>- Keep a defensive mindset: assume future code may overwrite captions unless explicitly protected. <br>- Ensure all patches are backward-compatible with older table data. <br>- For extremely large tables, monitor memory usage and browser responsiveness. <br>- Consider using optional web workers or deferred DOM patches for extremely heavy datasets. <br>- Keep a running audit log of caption-applier events for debugging post-deployment. </td></tr></tbody></table></div><div class="row-count">Rows: 6</div></div><div class="table-caption" id="Table3" data-table="Docu_0093_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3 • Technical Breakdown</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Prioritized File Checks</strong> <br><br><strong>assets/script.table.js</strong> — Handles caption insertion, ID assignment, copy delegation, and table-specific post-processing. Critical to ensure that <code>TableN</code> IDs are stable, especially when multiple tables are dynamically rendered. Inspect for destructive operations like <code>table.id = ...</code> or <code>caption.id = ...</code> after every render. Check that caption insertion functions respect existing IDs and do not merge tables unintentionally. <br><br><strong>assets/script.core.js</strong> — Main conversion and render lifecycle. Converts marked-up text to HTML tables, invokes caption insertion routines, and triggers post-processing events. Verify that <code>convert</code> triggers caption-applier events <strong>after DOM is fully rendered</strong>. Watch for destructive operations such as <code>container.innerHTML = ...</code> or <code>container.replaceChildren()</code>. Add verbose logging before and after these operations. <br><br><strong>render/core_table.py, render/convert.py, html_renderer.py, server.py</strong> — Server-side scripts responsible for deterministic ID generation, caption rendering, and HTML preparation. Confirm server-generated captions match client-side selectors used by the caption-applier. Differences (e.g., <code>&lt;h1&gt;</code> vs <code>&lt;caption&gt;</code> vs <code>.table-caption</code>) can cause misalignment. Consider generating a per-table hash to verify consistency between server output and client DOM. <br><br><strong>assets/script.toc.js</strong> — Builds the Table of Contents (TOC), normalizes IDs, and enables anchor navigation. Ensure it does not overwrite table/caption IDs, or alter heading nodes in ways that break the caption-applier. It should listen to <code>ptt:render-complete</code> to avoid firing prematurely. <br><br><strong>assets/script.save.js</strong> — Handles post-render DOM operations, caching, and state saving. Identify any operations that replace table containers or captions (e.g., <code>innerHTML</code> assignments). Wrap these in logging and consider temporarily disabling destructive operations for diagnostics. Ensure all DOM modifications occur <strong>after</strong> captions are applied. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Likely Failure Modes</strong> <br><br><strong>1. Client overwrites server captions:</strong> Client code may replace containers after server captions are applied. Leading cause of lost captions. Add logging before/after all DOM replacements. Temporarily comment out destructive code to confirm cause. <br><br><strong>2. Race condition:</strong> Caption-applier may execute before DOM nodes exist. Ensure applier runs <strong>after</strong> render. Use:<br><code>try { window.dispatchEvent(new CustomEvent(&#x27;ptt:render-complete&#x27;)); } catch(e){}</code><br>Listen also for <code>ptt:group-loaded</code> if tables load asynchronously. <br><br><strong>3. Selector mismatch:</strong> Renderer may emit <code>&lt;caption&gt;</code> or <code>&lt;h3&gt;</code> instead of <code>.table-caption</code>. Standardize applier selectors: <code>.table-caption, caption, h1,h2,h3</code>. Normalize IDs, strip <code>&lt;br&gt;</code> tags, and clean text content. <br><br><strong>4. Performance bottlenecks:</strong> Large tables (~290k nodes) can freeze the browser during synchronous DOM updates. Use chunked updates or "visible-first" strategy with <code>IntersectionObserver</code> + batched updates. Apply captions in groups of 50–200 nodes. Offscreen rows updated asynchronously. <br><br><strong>5. Mixed server-client DOM models:</strong> Differences between server-generated captions and client DOM can cause misalignment when table groups are reordered. Introduce per-table hash verification. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Quick Diagnostic Snippet</strong> <br><br>Map runtime captions to DOM nodes to detect mismatches: <br><br><code>(function(){</code><br><code>  var caps = Array.isArray(window.__ptt_runtime_captions)? window.__ptt_runtime_captions.slice(0,200):[];</code><br><code>  var nodes = Array.from(document.querySelectorAll(&#x27;.table-caption, caption, h1,h2,h3&#x27;)).slice(0,200);</code><br><code>  console.log(&#x27;captions.length&#x27;, caps.length, &#x27;nodes.length&#x27;, nodes.length);</code><br><code>  for(var i=0;i&lt;Math.max(caps.length, nodes.length, 50); i++){</code><br><code>    console.log(i+1,&#x27;caption-&gt;&#x27;,caps[i],&#x27;&lt;empty&gt;&#x27;,&#x27;node-&gt;&#x27;,nodes[i]? (nodes[i].tagName+&#x27;:&#x27; + (nodes[i].id || nodes[i].textContent.slice(0,40))) : &#x27;&lt;no-node&gt;&#x27;);</code><br><code>  }</code><br><code>})();</code><br><br>Use output for mapping captions to nodes, verifying mismatches, and suggesting exact fixes. Run before/after patches to confirm success. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Immediate Safe Fix Options</strong> <br><br><strong>Option 1: Defensive caption-applier</strong> — Listen to <code>ptt:render-complete</code>, apply captions in batches via <code>requestIdleCallback</code> or <code>setTimeout</code>. Chunk size: 50–200 nodes. <br><br><strong>Option 2: Patch destructive renders</strong> — Modify <code>script.core.js</code> or <code>script.table.js</code> to prevent full container <code>innerHTML</code> replacement post-caption insertion. Target only table rows/cells. Wrap DOM mutations with logging. <br><br><strong>Option 3: Logging instrumentation</strong> — Log before/after render, <code>innerHTML</code> updates, caption insertion: <br><code>console.log(&#x27;Before container update:&#x27;, container.id, container.childElementCount);</code><br><code>console.log(&#x27;After container update:&#x27;, container.id, container.childElementCount);</code><br>Detect race conditions/destructive operations. <br><br><strong>Option 4: Selector normalization & fallback</strong> — Applier queries: <code>.table-caption, caption, h1,h2,h3</code>. Strip <code>&lt;br&gt;</code> tags, normalize IDs, and text content. <br><br><strong>Option 5: Performance safeguards</strong> — For large docs, prioritize visible tables with <code>IntersectionObserver</code>. Defer offscreen updates. Combine with Option 1. <br><br><strong>Option 6: Unit-test small tables</strong> — Test applier in isolation before full documents. <br><br><strong>Option 7: Auto-fallback for missing captions</strong> — If a caption is missing after N seconds, re-run batch for that table. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recommended Stepwise Approach</strong> <br><br>1. Add logging around every DOM mutation in core, table, save scripts. <br>2. Normalize selectors to <code>.table-caption, caption, h1,h2,h3</code>. <br>3. Dispatch <code>ptt:render-complete</code> after convert/post-render. <br>4. Attach defensive caption-applier applying in chunks asynchronously. <br>5. Temporarily disable destructive <code>innerHTML</code> assignments. <br>6. Run diagnostic snippet for caption-to-node mapping. <br>7. Implement chunked/IntersectionObserver-based updates. <br>8. Monitor performance & iterate. <br>9. Gradually re-enable save/replace while monitoring overwrites. <br>10. Confirm consistent behavior across browsers/table sizes. <br>11. Add automated regression tests for tables & captions. <br>12. Document issues & fixes for knowledge sharing. <br>13. Optional: Capture a visual diff (before/after) using <code>html2canvas</code> for large tables. <br>14. Optional: Add mutation observer to detect unexpected DOM changes at runtime. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Operational Notes & Observations</strong> <br><br>- Server captions are reliable but may be erased by client DOM updates. <br>- Race conditions arise when render lifecycle is async or uses Promises; fire events strictly after render completion. <br>- Large docs require deferred/batched updates; synchronous brute-force updates will fail. <br>- Selector mismatches are subtle but common; normalize ID/tag selectors. <br>- Logging is critical; use before/after states to detect destructive updates. <br>- Unit-test small table sets before applying to full docs. <br>- Keep a defensive mindset: assume future code may overwrite captions. <br>- Ensure patches are backward-compatible with older tables. <br>- Monitor memory usage and responsiveness for huge tables. <br>- Consider optional web workers or deferred DOM patches for very heavy datasets. <br>- Keep running audit log of caption-applier events for post-deployment debugging. <br>- Integrate IntersectionObserver with <code>rootMargin</code> for offscreen updates. <br>- Optionally throttle batches dynamically based on performance metrics. <br>- Implement a “retry queue” for tables that fail initial caption insertion. <br>- Ensure all lifecycle hooks (convert, paste, save) respect defensive applier timing. <br>- Optionally provide a dashboard showing applied vs missing captions with ID mismatch detection. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Example IntersectionObserver Pattern</strong> <br><br>``<code>javascript&lt;br&gt;const observer = new IntersectionObserver((entries) =&gt; {&lt;br&gt;  entries.forEach(entry =&gt; {&lt;br&gt;    if(entry.isIntersecting) {&lt;br&gt;      applyCaptions(entry.target);&lt;br&gt;      observer.unobserve(entry.target);&lt;br&gt;    }&lt;br&gt;  });&lt;br&gt;},{ root: null, rootMargin: &#x27;0px&#x27;, threshold: 0.1 });&lt;br&gt;document.querySelectorAll(&#x27;.table-container&#x27;).forEach(table =&gt; observer.observe(table));&lt;br&gt;</code>``<br>Explanation: Only visible tables get caption-applied immediately; offscreen tables are deferred until scrolling brings them into view. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Advanced Logging & Verification Example</strong> <br><br>``<code>javascript&lt;br&gt;function logTableState(container){&lt;br&gt;  console.group(</code>Table: ${container.id}<code>);&lt;br&gt;  console.log(&#x27;Child nodes:&#x27;, container.childElementCount);&lt;br&gt;  container.querySelectorAll(&#x27;caption, .table-caption&#x27;).forEach((cap,i)=&gt; console.log(i+1, cap.textContent, cap.id));&lt;br&gt;  console.groupEnd();&lt;br&gt;}&lt;br&gt;</code>``<br>Run before/after any DOM mutation to detect unexpected caption loss. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recovery Workflow</strong> <br><br>1. Capture server-generated caption snapshot. <br>2. Apply defensive applier after render. <br>3. Compare applied captions against snapshot. <br>4. Retry missing captions in small batches. <br>5. Log all discrepancies for post-mortem debugging. <br>6. Optionally notify the user if caption insertion fails after N attempts. </td></tr></tbody></table></div><div class="row-count">Rows: 9</div></div><div class="table-caption" id="Table4" data-table="Docu_0093_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4 • Technical Breakdown</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <details><summary><strong>Prioritized File Checks</strong></summary><br><strong>assets/script.table.js</strong> — Handles caption insertion, ID assignment, copy delegation, and table-specific post-processing. Ensure <code>TableN</code> IDs are stable. Check for destructive operations (<code>table.id = ...</code>, <code>caption.id = ...</code>) and confirm captions respect existing IDs.<br><br><strong>assets/script.core.js</strong> — Main conversion and render lifecycle. Converts marked-up text to HTML tables, triggers caption-applier events <strong>after DOM is rendered</strong>, and must avoid destructive operations (<code>innerHTML</code> or <code>replaceChildren</code>). Add logging before/after these operations.<br><br><strong>render/core_table.py, render/convert.py, html_renderer.py, server.py</strong> — Server-side scripts for deterministic ID generation and caption rendering. Confirm server-generated captions match client-side selectors. Consider per-table hash for consistency.<br><br><strong>assets/script.toc.js</strong> — Builds TOC, normalizes IDs, anchors navigation. Ensure it does not overwrite table/caption IDs and listens to <code>ptt:render-complete</code> to avoid firing too early.<br><br><strong>assets/script.save.js</strong> — Handles post-render DOM operations and caching. Wrap DOM replacements with logging, temporarily disable destructive operations for diagnostics, ensure changes occur <strong>after captions are applied</strong>.</details> </td></tr><tr><td data-label="Technical Breakdown"> <details><summary><strong>Likely Failure Modes</strong></summary><br><strong>1. Client overwrites server captions:</strong> Container replacements (<code>innerHTML</code>) may erase captions. Add logging and comment out destructive code temporarily.<br><br><strong>2. Race condition:</strong> Applier may run before DOM exists. Use:<br><code>try { window.dispatchEvent(new CustomEvent(&#x27;ptt:render-complete&#x27;)); } catch(e){}</code><br>Also listen for <code>ptt:group-loaded</code> if tables load asynchronously.<br><br><strong>3. Selector mismatch:</strong> Renderer may emit <code>&lt;caption&gt;</code> or <code>&lt;h3&gt;</code> instead of <code>.table-caption</code>. Standardize selectors, normalize IDs, strip <code>&lt;br&gt;</code> tags.<br><br><strong>4. Performance bottlenecks:</strong> Large tables (~290k nodes) freeze browser with synchronous DOM updates. Use chunked updates or IntersectionObserver + batched updates (50–200 nodes per batch).<br><br><strong>5. Mixed server-client DOM:</strong> Differences in server-generated captions vs client DOM may misalign tables. Introduce per-table hash verification.</details> </td></tr><tr><td data-label="Technical Breakdown"> <details><summary><strong>Quick Diagnostic Snippet</strong></summary><br>Inspect captions vs DOM nodes (first 50–200 captions):<br><br>``<code>javascript&lt;br&gt;(function(){&lt;br&gt;  var caps = Array.isArray(window.__ptt_runtime_captions)? window.__ptt_runtime_captions.slice(0,200):[];&lt;br&gt;  var nodes = Array.from(document.querySelectorAll(&#x27;.table-caption, caption, h1,h2,h3&#x27;)).slice(0,200);&lt;br&gt;  console.log(&#x27;captions.length&#x27;, caps.length, &#x27;nodes.length&#x27;, nodes.length);&lt;br&gt;  for(var i=0;i&lt;Math.max(caps.length, nodes.length, 50); i++){&lt;br&gt;    console.log(i+1,&#x27;caption-&gt;&#x27;,caps[i],&#x27;&lt;empty&gt;&#x27;,&#x27;node-&gt;&#x27;,nodes[i]? (nodes[i].tagName+&#x27;:&#x27; + (nodes[i].id || nodes[i].textContent.slice(0,40))) : &#x27;&lt;no-node&gt;&#x27;);&lt;br&gt;  }&lt;br&gt;})();&lt;br&gt;</code>``<br>Use output to map captions to nodes, verify mismatches, and suggest fixes.</details> </td></tr><tr><td data-label="Technical Breakdown"> <details><summary><strong>Immediate Safe Fix Options</strong></summary><br><strong>Option 1: Defensive caption-applier</strong> — Listen to <code>ptt:render-complete</code>, apply captions in batches via <code>requestIdleCallback</code> or <code>setTimeout</code> (50–200 nodes).<br><br><strong>Option 2: Patch destructive renders</strong> — Prevent full container <code>innerHTML</code> replacement post-caption insertion. Target only rows/cells, add logging.<br><br><strong>Option 3: Logging instrumentation</strong> — Log before/after render, <code>innerHTML</code> updates, caption insertion:<br><code>console.log(&#x27;Before container update:&#x27;, container.id, container.childElementCount);</code><br><code>console.log(&#x27;After container update:&#x27;, container.id, container.childElementCount);</code><br><br><strong>Option 4: Selector normalization & fallback</strong> — <code>.table-caption, caption, h1,h2,h3</code>. Strip <code>&lt;br&gt;</code> tags, normalize IDs, clean text.<br><br><strong>Option 5: Performance safeguards</strong> — Prioritize visible tables via IntersectionObserver, defer offscreen updates, combine with Option 1.<br><br><strong>Option 6: Unit test small tables</strong> — Verify applier behavior before full documents.<br><br><strong>Option 7: Auto-fallback for missing captions</strong> — Retry after N seconds if captions fail.</details> </td></tr><tr><td data-label="Technical Breakdown"> <details><summary><strong>Recommended Stepwise Approach</strong></summary><br>1. Add logging around all DOM mutations.<br>2. Normalize selectors to <code>.table-caption, caption, h1,h2,h3</code>.<br>3. Dispatch <code>ptt:render-complete</code> after convert/post-render.<br>4. Attach defensive caption-applier, apply in asynchronous chunks.<br>5. Temporarily disable destructive <code>innerHTML</code> assignments.<br>6. Run diagnostic snippet for mapping captions to DOM.<br>7. Implement chunked/IntersectionObserver updates.<br>8. Monitor performance & iterate.<br>9. Re-enable save/replace while monitoring overwrites.<br>10. Confirm consistent behavior across browsers & table sizes.<br>11. Add automated regression tests for tables & captions.<br>12. Document issues & fixes.<br>13. Optional: Visual diff via <code>html2canvas</code> for large tables.<br>14. Optional: Mutation observer to detect unexpected DOM changes.</details> </td></tr><tr><td data-label="Technical Breakdown"> <details><summary><strong>Operational Notes & Observations</strong></summary><br>- Server captions are reliable but may be erased by client DOM updates.<br>- Race conditions arise when lifecycle is async/Promise-based.<br>- Large documents require deferred/batched updates.<br>- Selector mismatches are subtle but common.<br>- Logging is critical; use before/after states.<br>- Unit-test small tables before full document.<br>- Assume future code may overwrite captions.<br>- Ensure patches are backward-compatible.<br>- Monitor memory usage & responsiveness.<br>- Optional: web workers for very heavy datasets.<br>- Keep audit log for caption-applier events.<br>- Integrate IntersectionObserver with <code>rootMargin</code> for offscreen updates.<br>- Throttle batches dynamically based on performance.<br>- Implement retry queue for failed captions.<br>- Ensure lifecycle hooks respect defensive applier timing.<br>- Optionally provide dashboard of applied vs missing captions.</details> </td></tr><tr><td data-label="Technical Breakdown"> <details><summary><strong>Example IntersectionObserver Pattern</strong></summary><br>``<code>javascript&lt;br&gt;const observer = new IntersectionObserver((entries) =&gt; {&lt;br&gt;  entries.forEach(entry =&gt; {&lt;br&gt;    if(entry.isIntersecting) {&lt;br&gt;      applyCaptions(entry.target);&lt;br&gt;      observer.unobserve(entry.target);&lt;br&gt;    }&lt;br&gt;  });&lt;br&gt;},{ root: null, rootMargin: &#x27;0px&#x27;, threshold: 0.1 });&lt;br&gt;document.querySelectorAll(&#x27;.table-container&#x27;).forEach(table =&gt; observer.observe(table));&lt;br&gt;</code>``<br>Visible tables get captions immediately; offscreen tables are deferred until scrolled into view.</details> </td></tr><tr><td data-label="Technical Breakdown"> <details><summary><strong>Advanced Logging & Verification</strong></summary><br>``<code>javascript&lt;br&gt;function logTableState(container){&lt;br&gt;  console.group(</code>Table: ${container.id}<code>);&lt;br&gt;  console.log(&#x27;Child nodes:&#x27;, container.childElementCount);&lt;br&gt;  container.querySelectorAll(&#x27;caption, .table-caption&#x27;).forEach((cap,i)=&gt; console.log(i+1, cap.textContent, cap.id));&lt;br&gt;  console.groupEnd();&lt;br&gt;}&lt;br&gt;</code>``<br>Run before/after DOM mutations to detect unexpected caption loss.</details> </td></tr><tr><td data-label="Technical Breakdown"> <details><summary><strong>Recovery Workflow</strong></summary><br>1. Capture server-generated caption snapshot.<br>2. Apply defensive applier after render.<br>3. Compare applied captions against snapshot.<br>4. Retry missing captions in small batches.<br>5. Log all discrepancies.<br>6. Optionally notify user if caption insertion fails after N attempts.</details> </td></tr></tbody></table></div><div class="row-count">Rows: 9</div></div><div class="table-caption" id="Table5" data-table="Docu_0093_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5 • Technical Breakdown</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Prioritized File Checks</strong> <br><br><strong>assets/script.table.js</strong> — Handles caption insertion logic, ID assignment, and copy delegation. Critical to ensure that <code>TableN</code> IDs are stable and not overwritten by subsequent renders. Look for functions that apply captions immediately after table creation; confirm they respect existing IDs. <br><br><strong>assets/script.core.js</strong> — Core conversion and render lifecycle. Verify whether <code>convert</code> is invoked with combined marked text, and ensure it triggers caption-applier events after render completion. Check if <code>convert</code> performs destructive DOM operations such as replacing <code>innerHTML</code> on table containers. <br><br><strong>render/core_table.py, render/convert.py, html_renderer.py, server.py</strong> — Server-side rendering of captions and ID generation. Confirm that caption content generated server-side matches expected selectors and that IDs are deterministic. Check for differences in server vs. client output (e.g., h1–h3 vs. caption elements). <br><br><strong>assets/script.toc.js</strong> — Normalizes heading IDs and builds the table of contents. Ensure it does not conflict with caption IDs or alter heading nodes in ways that break applier logic. <br><br><strong>assets/script.save.js</strong> — Handles post-render DOM replacement. Identify any operations that overwrite tables or captions after initial render, such as saving to local cache or performing full container replacements. Consider adding logging here to detect destructive replacements. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Likely Failure Modes</strong> <br><br><strong>1. Client overwrites server captions:</strong> This is a common issue. Client-side code may replace the container’s <code>innerHTML</code> after server captions are inserted. Look for patterns like <code>container.innerHTML = ...</code>. Use logging statements before and after these replacements to trace the behavior. Temporarily comment out destructive re-renders to isolate the issue. <br><br><strong>2. Race condition:</strong> Caption applier might run before DOM nodes exist. Ensure the applier runs only after the renderer has completed. You can dispatch a custom event at the end of the convert lifecycle:<br><code>try { window.dispatchEvent(new CustomEvent(&#x27;ptt:render-complete&#x27;)); } catch(e){}</code><br>Then attach caption-applier logic to this event. Optionally, also listen for <code>ptt:group-loaded</code> if groups of tables are loaded asynchronously. <br><br><strong>3. Selector mismatch:</strong> Renderer may use elements like <code>&lt;caption&gt;</code> or <code>&lt;h3&gt;</code> instead of <code>.table-caption</code>. Standardize selector for caption-applier: <code>.table-caption, caption, h1,h2,h3</code>. This ensures all captions are detected regardless of node type. <br><br><strong>4. Large-scale performance bottlenecks:</strong> For extremely large tables (~290k), synchronous DOM updates can freeze the browser. Use chunked updates or a “visible-first” strategy. For example, combine <code>IntersectionObserver</code> with batched updates so only visible nodes are updated first, followed by deferred updates for off-screen nodes. This prevents UI lock-up. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Quick Diagnostic Snippet</strong> <br><br>Use this snippet in the console to map runtime captions to DOM nodes and identify mismatches. It inspects the first 50 captions and logs any discrepancies between expected captions and actual DOM nodes. <br><br><code>(function(){</code><br><code>var caps = Array.isArray(window.__ptt_runtime_captions)? window.__ptt_runtime_captions.slice(0,200):[];</code><br><code>var nodes = Array.from(document.querySelectorAll(&#x27;.table-caption, caption, h1,h2,h3&#x27;)).slice(0,200);</code><br><code>console.log(&#x27;captions.length&#x27;, caps.length, &#x27;nodes.length&#x27;, nodes.length);</code><br><code>for(var i=0;i&lt;Math.max(caps.length, nodes.length, 50); i++){</code><br><code>console.log(i+1, &#x27;caption-&gt;&#x27;, caps[i], &#x27;&lt;empty&gt;&#x27;, &#x27;node-&gt;&#x27;, nodes[i] ? (nodes[i].tagName + &#x27;:&#x27; + (nodes[i].id || nodes[i].textContent.slice(0,40))) : &#x27;&lt;no-node&gt;&#x27;);</code><br><code>}})();</code><br><br>Paste the output into a document or share it, and it can be used to generate a mapping of captions to nodes, helping to suggest exact fixes. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Immediate Safe Fix Options</strong> <br><br><strong>Option 1: Defensive caption-applier</strong> — Write a small utility that listens for <code>ptt:render-complete</code> and applies captions in batches using a non-blocking approach. Use <code>requestIdleCallback</code> or <code>setTimeout</code> for chunked updates to avoid blocking the main thread. This ensures captions are applied after DOM is stable and prevents overwrites. <br><br><strong>Option 2: Patch destructive renders</strong> — Modify <code>script.core.js</code> or <code>script.table.js</code> to prevent any <code>innerHTML</code> replacements on table containers after captions are inserted. Ensure <code>convert</code> or other lifecycle methods update content safely by targeting only the inner table cells or rows rather than replacing the container. Add logging around every lifecycle method that modifies DOM to detect accidental overwrites. <br><br><strong>Option 3: Logging instrumentation</strong> — Surround critical points (before/after render, before/after <code>innerHTML</code> updates, at caption insertion) with verbose logging. Example:<br><code>console.log(&#x27;Before container update:&#x27;, container.id, container.childElementCount);</code><br><code>console.log(&#x27;After container update:&#x27;, container.id, container.childElementCount);</code><br>This helps detect race conditions or destructive operations. <br><br><strong>Option 4: Selector normalization and fallback</strong> — Ensure caption-applier queries <code>.table-caption, caption, h1,h2,h3</code>. Normalize IDs and text content before applying to avoid mismatch. Optionally, strip HTML noise (e.g., <code>&lt;br&gt;</code>) before comparison. <br><br><strong>Option 5: Performance safeguards</strong> — For very large document loads, update captions in chunks of 50–200 nodes at a time. Use <code>IntersectionObserver</code> to prioritize visible tables. Defer updates for offscreen elements to prevent browser hangs. Combine with the defensive caption-applier from Option 1. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recommended Stepwise Approach</strong> <br><br>1. Add logging around every DOM mutation in core, table, and save scripts. <br>2. Normalize selectors to <code>.table-caption, caption, h1,h2,h3</code>. <br>3. Dispatch <code>ptt:render-complete</code> after convert or post-render operations. <br>4. Attach defensive caption-applier that listens to this event and applies captions in chunks using non-blocking updates. <br>5. Temporarily disable any destructive <code>innerHTML</code> assignments to isolate overwrites. <br>6. Run diagnostic snippet to map captions to DOM nodes and verify correctness. <br>7. Implement chunked or IntersectionObserver-based updates for large tables. <br>8. Monitor performance and iterate. <br>9. Once stable, gradually re-enable save/replace functionality while monitoring for overwrites. <br>10. Confirm consistent behavior across all browsers and table sizes. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Additional Notes & Observations</strong> <br><br>- Server-generated captions are reliable but can be erased by client DOM updates. <br>- Race conditions often happen when render lifecycle is asynchronous or uses Promises; ensure events are fired strictly after all render operations. <br>- Large documents require deferred and batched updates; synchronous brute-force DOM updates will fail. <br>- Selector mismatches are a subtle but common source of errors; normalize both ID and tag selectors. <br>- Logging is your best immediate diagnostic tool; use before/after states to detect destructive updates. <br>- Consider unit-testing the caption-applier in isolation using a small set of tables before applying to full documents. <br>- Keep a defensive mindset: assume any future code may overwrite captions unless explicitly protected. </td></tr></tbody></table></div><div class="row-count">Rows: 6</div></div><div class="table-caption" id="Table6" data-table="Docu_0093_06" style="margin-top:2mm;margin-left:3mm;"><strong>Table 6 • Technical Breakdown</strong></div>
<div class="table-wrapper" data-table-id="table-6"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>File-level summary (expanded)</strong><br><br>This plan targets reliable, low-jank rendering of very large tables (≈290k characters per table payload). Focus is on <code>assets/script.table.js</code> as the primary client-side intervention, with secondary changes in <code>assets/script.list.js</code> and server-side precomputation in <code>render/*</code> and <code>html_renderer.py</code>. Goals: eliminate caption flicker, avoid main-thread stalls, and provide a safe fall-back path (server-precomputed captions/JSON) when the client is constrained. This is pragmatic engineering. Prioritize deterministic, observable changes over clever micro-optimizations.                                                                 </td></tr><tr><td data-label="Technical Breakdown"> <strong>Primary performance levers</strong><br><br>• <strong>Delay work until needed</strong> — defer caption injection until table is near viewport using <code>IntersectionObserver</code>.<br>• <strong>Batch DOM writes</strong> — use <code>DocumentFragment</code>, <code>innerHTML</code> in single writes, and <code>requestIdleCallback</code> slices to break up long work.<br>• <strong>Group reads then writes</strong> — separate layout reads from writes to avoid forced reflow loops. Do all reads first. Do all writes second.<br>• <strong>Prefer CSS transforms/opacity</strong> — transition non-layout properties only. Do not animate height, margin, or top for reveal.<br>• <strong>Offload heavy transforms</strong> — move Markdown→HTML or heavy metadata assembly server-side or into a Web Worker. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Caption-injection strategy</strong><br><br>1. At page load do not mutate DOM for captions. Only attach light-weight markers (data attributes).<br>2. Observe tables with <code>IntersectionObserver</code> (rootMargin ~200px). When a table becomes intersecting queue it for batched injection.<br>3. Use idle slices (<code>requestIdleCallback</code> fallback to <code>setTimeout</code>) to process N tables per slice (tune N).<br>4. For injection: create or reuse a <code>&lt;caption&gt;</code> node, set <code>innerHTML</code> once, toggle a CSS class to animate opacity/translateY. This prevents layout thrash.<br>5. Safety: give a 3s fallback timer to inject for tables never observed (e.g., above fixed headers).                                </td></tr><tr><td data-label="Technical Breakdown"> <strong>Batching & scheduling model</strong><br><br>• <code>collect()</code> reads only dataset/attributes. Avoid <code>getBoundingClientRect</code> here.<br>• <code>batchProcess()</code> injects up to BATCH_SIZE entries per idle slice. Start BATCH_SIZE ~25; reduce if long tasks appear.<br>• Use a single <code>DocumentFragment</code> per caption write if multiple elements are injected alongside caption. Keep per-slice wall time < 50ms. Profile and adjust.                                                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Technical Breakdown"> <strong>Virtualization (optional, guarded)</strong><br><br>• Enable only when <code>row_count &gt; VIRTUALIZATION_THRESHOLD</code> (e.g., 200).<br>• Use naive windowing: keep a spacer with full height and render only visible rows + buffer. Update via scroll throttled to ~50ms.<br>• Requirements: consistent row height or single-sample measured height. If row heights vary widely virtualization may cause layout shifts. Start with <code>enableVirtualization=false</code> and enable per-table after manual QA.                                                                                                                                                                                                                </td></tr><tr><td data-label="Technical Breakdown"> <strong>Server-side precomputation & data attributes</strong><br><br>• Precompute caption HTML and write it as <code>data-ptt-caption-html</code> server-side when rendering pages. Client then only moves bytes from attribute to caption element. This reduces client CPU and eliminates expensive string assembly in the browser.<br>• For very large metadata prefer <code>&lt;script type=&quot;application/json&quot; data-ptt-for=&quot;table-id&quot;&gt;...&lt;/script&gt;</code> near the table rather than a large <code>data-</code> attribute. Client reads JSON only when needed.                                                                                                                                                                                     </td></tr><tr><td data-label="Technical Breakdown"> <strong>Inter-file coordination</strong><br><br>• <code>script.list.js</code> should avoid triggering full re-renders of tables. If it needs to refresh rows, it must signal <code>script.table.js</code> via a small API (e.g., <code>PTTable.refresh(table)</code>) that performs batched, idle-scheduled updates.<br>• <code>script.toc.js</code> must not force caption reflows. If TOC highlights cause layout reads, throttle updates and only read necessary properties.                                                                                                                                                                                                                                                                                </td></tr><tr><td data-label="Technical Breakdown"> <strong>Read/write access patterns to avoid</strong><br><br>• Avoid loops that read <code>offsetHeight</code> or <code>getComputedStyle</code> then write inside the same iteration for each row.<br>• Avoid <code>element.innerHTML += ...</code> in loops. Use fragments or accumulate strings and set <code>innerHTML</code> once.<br>• Avoid synchronous JSON parsing/stringifying in hot paths; precompute or defer.                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="Technical Breakdown"> <strong>CSS and animation details</strong><br><br>• CSS: transition <code>opacity</code> and <code>transform</code>. Use <code>.caption-hidden {opacity:0; transform: translateY(-6px);}</code> and remove class to reveal.<br>• Avoid <code>will-change</code> except for a small set of elements. Overuse increases memory pressure.<br>• Ensure injected styles are compact and injected once (idempotent style tag).                                                                                                                                                                                                                                                                                                                                       </td></tr><tr><td data-label="Technical Breakdown"> <strong>Progressive enhancement & fallbacks</strong><br><br>• If <code>IntersectionObserver</code> missing, fall back to batched injection on <code>DOMContentLoaded</code> with conservative BATCH_SIZE.<br>• If <code>requestIdleCallback</code> missing, fall back to <code>setTimeout</code> with short slices. Keep logic centralized.                                                                                                                                                                                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Technical Breakdown"> <strong>Testing checklist</strong><br><br>1. Replace <code>assets/script.table.js</code> and load page with large test payload. Watch for initial paint jank. 2. CPU profile cold load and with 4x CPU throttle. No main-thread tasks >200ms. 3. Scroll through many tables. Captions must appear before user reaches table due to rootMargin. 4. Toggle virtualization on a test page with 10k rows and verify visual continuity. 5. Test in Chromium and Safari (IO behavior differs).                                                                                                                                                                                                                                      </td></tr><tr><td data-label="Technical Breakdown"> <strong>Instrumentation & observability</strong><br><br>• Emit metrics: <code>ptt.tables.queued</code>, <code>ptt.tables.injected</code>, <code>ptt.batch.duration_ms</code> (histogram), <code>ptt.virtualization.enabled</code>. Log counts and slow-slice incidents to console in DEBUG. Keep production verbose low.                                                                                                                                                                                                                                                                                                                                                                                                                                       </td></tr><tr><td data-label="Technical Breakdown"> <strong>Safety & security</strong><br><br>• Treat <code>data-ptt-caption-html</code> as trusted only if server-side sanitized. If content is user-provided run DOM sanitization before <code>innerHTML</code> assignment or prefer text-only caption paths. • Avoid inserting raw unescaped HTML into attributes as this can break markup.                                                                                                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="Technical Breakdown"> <strong>Gradual rollout & migration plan</strong><br><br>1. Deploy client script with <code>enableVirtualization=false</code> and <code>precompute_captions=false</code> flags. 2. In analytics, monitor long tasks and caption injection latency. 3. If stable, enable server-side precomputed captions and <code>data-ptt-caption-html</code>. 4. Optionally enable virtualization per-host after QA.                                                                                                                                                                                                                                                                                                                                             </td></tr><tr><td data-label="Technical Breakdown"> <strong>Next files to inspect (priority order)</strong><br><br>1. <code>assets/script.list.js</code> — prevent it from retriggering caption rebuilds. 2. <code>assets/script.toc.js</code> — ensure TOC updates are throttled and non-blocking. 3. <code>render/core_utils.py</code> or <code>html_renderer.py</code> — add server-side caption precompute and <code>data-ptt-caption-html</code> writing. 4. <code>assets/utils.js</code> — consolidate small helpers (escapeHtml, throttle).                                                                                                                                                                                                                                                                                       </td></tr><tr><td data-label="Technical Breakdown"> <strong>Short-term tuning knobs</strong><br><br>• <code>BATCH_SIZE</code> — reduce if long frame times appear. • <code>rootMargin</code> — increase if captions must appear earlier. • <code>VIRTUALIZATION_THRESHOLD</code> — increase conservatively. • <code>IDLE_TIMEOUT</code> fallback — tune for lower-latency environments.                                                                                                                                                                                                                                                                                                                                                                                                                            </td></tr><tr><td data-label="Technical Breakdown"> <strong>Acceptance criteria</strong><br><br>• No visible caption flicker on full page load for representative large pages. • Page load main-thread busy time reduced by >30% vs baseline. • Captions appear before table is scrolled into view in 95% of cases. • No regressions in functional tests for TOC, list filtering, and table copy/export.                                                                                                                                                                                                                                                                                                                                                               </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>