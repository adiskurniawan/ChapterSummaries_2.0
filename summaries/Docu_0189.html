<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1769247135">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0189_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modGating — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modGating — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Preface & mandate (very explicit):</strong><br> This document is the definitive, implementation-ready specification for the <code>modGating</code> VBA module used by Project 062 — Year-End Audit Checklist Generator. It prescribes deterministic gating logic, canonical serialization/hashing recipes, audit obligations, telemetry, error taxonomies, operator runbooks, PQ orchestration contracts, DAX reporting concepts and full end-to-end operational workflows needed for legal-admissible close processes. Implementers must follow canonical orders and recipe versions (the <code>canonicalVersion</code> token) to ensure parity and reproducibility across environments. This document has been intentionally exhaustive; every function includes preconditions, postconditions, side-effects, audit obligations, sample <code>AuditLog</code> events and deterministic error codes. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>High-level objective (single-line summary):</strong><br> Provide a tamper-evident, deterministic, auditable close gating engine that consumes a canonical <code>TasksMaster</code> snapshot (from Power Query) and enforces <code>policySnapshot</code> rules to determine whether a manifest can be closed, producing <code>CloseEvent</code> artifacts, <code>CloseBlockReport</code>s, and append-only <code>AuditLog</code> entries. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Core design principles (explicit & non-negotiable):</strong><br> 1. Determinism: identical canonical inputs must always produce identical gating decisions and hashes.<br> 2. Canonicalization: apply Unicode NFKC, trim, collapse whitespace, casefold per locale; canonical date format <code>YYYY-MM-DD</code> and UTC timestamps as <code>YYYY-MM-DDTHH:MM:SSZ</code>.<br> 3. Append-only forensic model: never delete or alter historical sign-offs, evidence rows, manifests, block reports or audit entries — use compensating entries instead.<br> 4. Fail-safe defaults: gate conservatively; missing or unverified artifacts block close unless authorized override is provided and validated.<br> 5. Atomic persistence: writes that change close state must be atomic (staging → swap); avoid partial writes. Use temp file + rename semantics for file artifacts. <br> 6. Least privilege: only operators with appropriate role may perform high-risk operations (override, reopen, force-lock). <br> 7. Traceability: every mutative action must be linked to <code>AuditLog</code> events with <code>correlationId</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Principal inputs (detailed):</strong><br> • <code>manifestVersion</code> (<code>ChecklistVersionManifest.versionId</code>) — GUID identifying the generated checklist snapshot.<br> • <code>TasksMaster</code> — canonical Power Query output with required fields: <code>taskId</code>, <code>taskNameCanonical</code>, <code>descriptionCanonical</code>, <code>assignedOwnerId</code>, <code>department</code>, <code>priority</code>, <code>gatingCategory</code>, <code>computedDueDate</code>, <code>evidenceRequirements[]</code>, <code>attachedEvidenceIds[]</code>, <code>signOffEntries[]</code>, <code>taskRowChecksum</code> (sha256: over canonical subset).<br> • <code>SignOffEntries</code> — append-only sign-off rows: <code>signOffId</code>, <code>taskId</code>, <code>signedBy</code>, <code>signedRole</code>, <code>signedTs</code>, <code>signatureHash</code>, <code>versionId</code> optional.<br> • <code>SupportingDocuments</code> — evidence metadata: <code>evidenceId</code>, <code>title</code>, <code>url/platformRef</code>, <code>checksum</code> (sha256:), <code>uploaderId</code>, <code>uploadedTs</code>, <code>evidenceCategory</code>, <code>evidenceStatus</code> (<code>valid|unverified|invalid</code>), <code>accessPolicy</code>.<br> • <code>CloseParameters</code> — single-row run config: <code>closeDate</code>, <code>manifestVersion</code>, <code>operatorId</code>, <code>dryRunFlag</code>, <code>policySnapshotId</code>, <code>canonicalVersion</code>.<br> • <code>policySnapshot</code> — governance rules, versioned: <code>approvalMatrix</code>, <code>twoPersonThresholds</code>, <code>signoffTimeWindowDays</code>, <code>evidenceChecksumPolicy</code> (<code>mandatory|recommended|disabled</code>), <code>emergencyRules</code>, <code>pqBlockingSeverity</code>, <code>reasonSeverityMap</code>, <code>redactionPolicy</code>, <code>canonicalVersion</code>.<br> • <code>PQ_Issues</code> — table of PQ validation defects: <code>issueId</code>, <code>issueType</code>, <code>entityRef</code>, <code>severity</code> (<code>Info|Low|Medium|High|Blocking</code>), <code>details</code>, <code>suggestedAction</code>, <code>status</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Principal outputs (detailed):</strong><br> • <code>CloseResult</code> (runtime return): <code>{status:&quot;CloseSucceeded&quot;|&quot;CloseBlocked&quot;|&quot;Error&quot;, closeId:GUID|null, errorCode:String|null, blockReportRef:GUID|null, details:String|null}</code>.<br> • <code>CloseEvent</code> persisted row: <code>{closeId, manifestVersion, operatorId, closeDate, closedTs, policySnapshotId, closeHash, overrideApprovalRef|null, notes}</code>.<br> • <code>CloseBlockReport</code> persisted artifact (<code>blockReportId</code>, <code>blockHash</code>, manifestVersion, tasks list with reason-coded entries and remediation guidance).<br> • <code>ManifestLocks</code> append-only lock history rows for concurrency control.<br> • <code>AuditLog</code> append-only entries capturing all mutative actions and major non-mutative operations with <code>correlationId</code> linkage.<br> • Telemetry rows in <code>Telemetry</code> sheet for monitoring (metrics and distribution data). </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Error taxonomy (canonical codes & guidance):</strong><br> • <code>ERR_MANIFEST_LOCK_FAIL</code> — unable to obtain manifest lock (see <code>ManifestLocks</code>).<br> • <code>ERR_PQ_ISSUES_BLOCK</code> — PQ produced Blocking severity issues for the manifest or scope.<br> • <code>ERR_SIGNOFF_MISSING</code> — required sign-offs missing (includes missing role list in details).<br> • <code>ERR_EVIDENCE_MISSING</code> — missing evidence categories for a task. <br> • <code>ERR_EVIDENCE_UNVERIFIED</code> — evidence checksum missing or mismatched while policy requires it. <br> • <code>ERR_OVERRIDE_UNAUTHORIZED</code> — override attempt invalid, insufficient approvals, expired approvals, or operator unauthorized. <br> • <code>ERR_PERSIST_FAIL</code> — IO or persistence error during CloseEvent or block report storage. <br> • <code>ERR_CLOSE_BLOCKED</code> — generic aggregated block with <code>blockReportRef</code> included. <br> • <code>ERR_INVALID_INPUT</code> — malformed inputs (bad date, missing manifest, etc.). <br> <strong>Error handling pattern:</strong> Every returned error must include <code>auditRef</code> (AuditLog.eventId) and a human remediation suggestion. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function-level index (complete):</strong><br> 1. <code>AttemptClose</code> (public) — orchestrates lock, fetch snapshot, evaluate, optionally validate override, persist close event, export forensic bundle.<br> 2. <code>LockManifest</code> (internal) — acquire exclusive manifest lock with append-only history and forced lock semantics.<br> 3. <code>ReleaseManifestLock</code> (internal) — release lock and record unlock history.<br> 4. <code>FetchEvaluationSnapshot</code> (internal) — produce deterministic snapshot used by evaluator and persisted for replay.<br> 5. <code>EvaluateManifestForClose</code> (internal) — deterministic evaluator implementing policy rules per task.<br> 6. <code>ValidateSignOffsForTask</code> (helper) — evaluate sign-off sufficiency for one task.<br> 7. <code>ValidateEvidenceForTask</code> (helper) — evaluate evidence sufficiency and checksum compliance for one task.<br> 8. <code>ComputeCloseBlockReport</code> (internal) — build and persist block report, compute <code>blockHash</code>.<br> 9. <code>PersistCloseEvent</code> (internal) — atomic persist of <code>CloseEvent</code> and marking manifest closed with <code>closeHash</code>.<br> 10. <code>ValidateOverride</code> (internal) — validate override tokens and approvals against <code>policySnapshot.emergencyRules</code>.<br> 11. <code>ReopenClose</code> (public, governed) — reopen a closed manifest, create PostCloseAdjustment tasks and preserve original close for forensics.<br> 12. <code>CheckPQIssuesForScope</code> (helper) — return PQ issues relevant to manifest scope that meet blocking severity.<br> 13. <code>BuildCloseBlockReportExport</code> (public) — export block report as signed artifact with redaction.<br> 14. <code>DryRunEvaluate</code> (public helper) — run evaluation without persistence (operator preview). </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: AttemptClose — full contract & deterministic recipe:</strong><br> <strong>Purpose:</strong> Decide and optionally persist a close for <code>manifestVersion</code> using <code>policySnapshot</code> rules. <br> <strong>Signature (conceptual):</strong> <code>AttemptClose(manifestVersion, closeDate, operatorId, Optional overrideApprovalRef, Optional dryRun=False) -&gt; CloseResult</code>.<br> <strong>Preconditions:</strong><br> • <code>manifestVersion</code> exists in <code>ChecklistVersionManifest</code> and references <code>policySnapshotId</code> captured at generation time.<br> • <code>TasksMaster</code> snapshot used for manifest generation is available; recommended to refresh PQ immediately before invoking <code>AttemptClose</code> when feasible.<br> • Operator identity validated via <code>Operators</code> or <code>OwnerAssignments</code>. <br> <strong>Deterministic algorithm (detailed ordered steps):</strong><br> 1. Validate inputs; if invalid return <code>ERR_INVALID_INPUT</code>. Append <code>fa.checklist.closeAttempt.started</code> to <code>AuditLog</code> with <code>correlationId</code> and input metadata. <br> 2. Acquire manifest lock: <code>LockManifest(manifestVersion, operatorId, timeoutSecs)</code>; if lock acquisition fails return <code>ERR_MANIFEST_LOCK_FAIL</code> and append <code>fa.checklist.lock.fail</code>. <br> 3. Build <code>evaluationSnapshot</code> via <code>FetchEvaluationSnapshot(manifestVersion)</code> and persist snapshot with <code>snapshotHash</code>. <br> 4. If <code>dryRun=True</code>, call <code>EvaluateManifestForClose(evaluationSnapshot, policySnapshot, manifestVersion)</code> and return results packaged as <code>CloseResult</code> with <code>dryRun</code> flag; append <code>fa.checklist.closeAttempt.dryrun</code>. <br> 5. Call <code>EvaluateManifestForClose</code> normally producing <code>EvaluationResult</code> containing <code>blockedTasks[]</code>, <code>warnings[]</code>, <code>pqBlockingIssues[]</code>. <br> 6. If <code>pqBlockingIssues</code> non-empty and <code>policySnapshot.pqBlockingSeverity</code> indicates blocking, call <code>ComputeCloseBlockReport(pqBlockingIssues, ...)</code>, persist and return <code>CloseBlocked</code> with <code>blockReportRef</code> and <code>ERR_PQ_ISSUES_BLOCK</code>. <br> 7. If <code>blockedTasks</code> non-empty, call <code>ComputeCloseBlockReport(blockedTasks, evaluationSnapshot, manifestVersion, operatorId)</code> to persist <code>CloseBlockReport</code> and return <code>CloseBlocked</code> with <code>ERR_CLOSE_BLOCKED</code> and <code>blockReportRef</code>. <br> 8. If no blocks and <code>overrideApprovalRef</code> provided, call <code>ValidateOverride(operatorId, overrideApprovalRef, policySnapshot)</code>; if invalid return <code>ERR_OVERRIDE_UNAUTHORIZED</code>. If valid, append <code>fa.checklist.override.used</code> and set override metadata. <br> 9. Call <code>PersistCloseEvent(manifestVersion, operatorId, closeDate, overrideApprovalRef)</code> which persists <code>CloseEvent</code> and marks manifest closed atomically; handle IO failures with retries and return <code>ERR_PERSIST_FAIL</code> if persistent. <br> 10. Optionally generate forensic export via <code>modAudit.ExportAuditManifest</code> and append <code>fa.checklist.closed</code>. <br> 11. Release manifest lock: <code>ReleaseManifestLock(manifestVersion, lockId, operatorId)</code>. <br> 12. Write telemetry: increment <code>close.successCount</code>, record <code>close.attempt.durationMs</code>. Return <code>CloseResult</code> with <code>status=CloseSucceeded</code> and <code>closeId</code>. <br> <strong>Idempotency:</strong> If <code>manifestVersion.closed = true</code> already, return existing <code>closeId</code> and auditRef without creating duplicates. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: LockManifest — full contract & semantics:</strong><br> <strong>Purpose:</strong> Ensure exclusive mutative control for operations touching a <code>manifestVersion</code>. <br> <strong>Signature:</strong> <code>LockManifest(manifestVersion, operatorId, Optional timeoutSeconds=120) -&gt; {locked:Boolean, lockId:String|null, details:String|null}</code>. <br> <strong>Mechanics:</strong><br> 1. Append a tentative lock row to <code>ManifestLocks_staging</code> with <code>lockIdGUID</code>, <code>manifestVersion</code>, <code>operatorId</code>, <code>lockedTs=NowUTC()</code>, <code>lockExpiryTs=NowUTC()+timeoutSeconds</code>. <br> 2. Read latest lock for <code>manifestVersion</code>; if none or existing lock expired (<code>NowUTC() &gt; lockExpiryTs</code>) promote staging lock to <code>ManifestLocks</code> atomically; append <code>fa.checklist.lock.acquired</code> with <code>lockId</code>. <br> 3. If valid existing lock owned by another operator exists and not expired, return <code>locked=false</code> and include existing lock row reference in <code>details</code> and append <code>fa.checklist.lock.fail</code>. <br> 4. Forced lock path: if existing lock stale and <code>operatorId</code> has <code>forceLock</code> privilege, accept forced lock, set <code>forcedFlag=true</code>, append <code>fa.checklist.lock.forced</code>. <br> <strong>Audit & retention:</strong> Do not delete lock rows; always create unlock records; preserve history for forensics. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: ReleaseManifestLock — contract:</strong><br> <strong>Purpose:</strong> Release a previously acquired manifest lock and append unlock history. <br> <strong>Signature:</strong> <code>ReleaseManifestLock(manifestVersion, lockId, operatorId) -&gt; {released:Boolean, details:String|null}</code>. <br> <strong>Checks & behavior:</strong> Validate the <code>lockId</code> exists and either owned by <code>operatorId</code> or caller has <code>forceRelease</code> privilege. Append unlock entry <code>{lockId, unlockTs=NowUTC(), unlockedBy=operatorId}</code> to <code>ManifestLocks</code> history; append <code>fa.checklist.lock.released</code>. If validation fails return <code>released=false</code> and append <code>fa.checklist.lock.release.fail</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: FetchEvaluationSnapshot — canonical snapshot builder:</strong><br> <strong>Purpose:</strong> Produce deterministic, persisted snapshot used for evaluation and forensic replay. <br> <strong>Signature:</strong> <code>FetchEvaluationSnapshot(manifestVersion) -&gt; {snapshotId, snapshotHash, snapshotRows[]}</code>. <br> <strong>Snapshot contents:</strong><br> For each task included in manifest scope include canonical fields: <code>taskId</code>, <code>taskNameCanonical</code>, <code>descriptionCanonical</code>, <code>assignedOwnerId</code>, <code>ownerActiveFlag</code>, <code>department</code>, <code>priority</code>, <code>gatingCategory</code>, <code>explicitDueDate</code>, <code>computedDueDate (YYYY-MM-DD)</code>, <code>evidenceRequirements[]</code>, <code>attachedEvidence[]</code> (each: <code>evidenceId,title, checksum, evidenceCategory, evidenceStatus, uploaderId, uploadedTs, accessPolicy</code>), <code>signOffEntries[]</code> (each: <code>signOffId, signedBy, signedRole, signedTs, signatureHash, versionId</code>), <code>taskRowChecksum</code>, <code>pqIssueRefs[]</code>. Include manifest-level metadata: <code>manifestHash</code>, <code>generatedTs</code>, <code>policySnapshotId</code>, <code>canonicalVersion</code>, <code>pqRunHash</code>. <br> <strong>Deterministic rules:</strong> Sort <code>snapshotRows</code> by <code>taskId</code> ascending; within <code>attachedEvidence</code> sort by <code>evidenceId</code> ascending. Compute <code>snapshotHash</code> via canonical serialization (Appendix). Persist <code>EvaluationSnapshots</code> row for forensic replay. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: EvaluateManifestForClose — core evaluator (complete):</strong><br> <strong>Purpose:</strong> Apply deterministic gating rules to <code>evaluationSnapshot</code> using <code>policySnapshot</code>. <br> <strong>Signature:</strong> <code>EvaluateManifestForClose(evaluationSnapshot, policySnapshot, manifestVersion) -&gt; EvaluationResult</code> where <code>EvaluationResult = {blockedTasks[], warnings[], pqBlockingIssues[], evidenceOk:Boolean, signoffsOk:Boolean, evaluationHash:String}</code>. <br> <strong>Per-task evaluation pipeline (ordered and deterministic):</strong> For each <code>task</code> in <code>evaluationSnapshot.snapshotRows</code> (iterate in snapshot order):<br> 1. <strong>Normalization & validation:</strong> Ensure <code>computedDueDate</code> parse success; if parse fails append <code>PQ_Issues</code> entry <code>InvalidDateFormat</code> with severity per <code>policySnapshot</code>; include in <code>pqIssueRefs</code>. <br> 2. <strong>Owner validation:</strong> If <code>assignedOwnerId</code> null or owner inactive and <code>gatingCategory</code> is blocking (per policy) mark <code>MissingOwner</code> (severity mapping in policySnapshot). <br> 3. <strong>Evidence coverage:</strong> For each <code>evidenceRequirement</code> confirm an attached evidence with matching <code>evidenceCategory</code>. If none present record <code>MissingEvidence: [list]</code>. <br> 4. <strong>Evidence verification:</strong> If <code>policySnapshot.evidenceChecksumPolicy = mandatory</code> require attached evidence <code>checksum</code> present and <code>evidenceStatus = valid</code>; otherwise record <code>UnverifiedEvidence</code>. <br> 5. <strong>Evidence currency:</strong> If <code>uploadedTs</code> older than <code>policySnapshot.evidenceMaxAgeDays</code> relative to <code>closeDate</code>, flag <code>StaleEvidence</code>. <br> 6. <strong>Signoff validation:</strong> Determine <code>requiredRoles</code> from <code>policySnapshot.approvalMatrix(priority,gatingCategory)</code> and call <code>ValidateSignOffsForTask</code> which checks role coverage, two-person rules and <code>signoffTimeWindowDays</code>. Record <code>MissingSignOffRoles</code> and <code>staleRoles</code>. <br> 7. <strong>PQ issues integration:</strong> If <code>pqIssueRefs</code> contains severity >= <code>policySnapshot.pqBlockingSeverity</code> include those <code>pqIssues</code> in <code>pqBlockingIssues</code>. <br> 8. <strong>Severity classification:</strong> Map each reason to <code>Blocking|Warning|Info</code> using <code>policySnapshot.reasonSeverityMap</code>. If any <code>Blocking</code> reason present add <code>task</code> to <code>blockedTasks</code> with full reason list and remediation suggestions; otherwise if only warnings present add to <code>warnings</code>. <br> <strong>Aggregate booleans:</strong> Set <code>evidenceOk = (no blocked task has evidence-related blocking reasons)</code>, <code>signoffsOk = (no blocked task missing required signoffs)</code>. <br> <strong>Return:</strong> <code>EvaluationResult</code> with sorted <code>blockedTasks</code> (priority desc, daysToDue asc, taskId asc) and compute <code>evaluationHash</code> over canonical serialization. Append <code>fa.checklist.evaluation.completed</code> audit event with <code>evaluationHash</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Helper: ValidateSignOffsForTask — exhaustive contract:</strong><br> <strong>Purpose:</strong> Validate sign-off sufficiency against policy for a single task. <br> <strong>Signature:</strong> <code>ValidateSignOffsForTask(taskRow, requiredRoles[], signOffEntries[], policySnapshot, manifestVersion) -&gt; {ok:Boolean, missingRoles:[], staleRoles:[], signOffDetails:[]}</code>. <br> <strong>Checks:</strong><br> 1. Filter <code>signOffEntries</code> for <code>taskId</code> and for the <code>manifestVersion</code> if time-window enforcement requires manifest-scoped sign-offs. <br> 2. For each <code>requiredRole</code> confirm a signoff exists with that role; for two-person requirements ensure signoffs come from distinct <code>signedBy</code>. <br> 3. Enforce <code>signoffTimeWindowDays</code> relative to <code>evaluationSnapshot.generatedTs</code> or <code>closeDate</code>. Signoffs older than window flagged as <code>stale</code>. <br> 4. Return <code>missingRoles</code> and <code>staleRoles</code>; <code>ok = missingRoles empty and staleRoles empty unless policy allows stale acceptance</code>. Append <code>fa.signoff.validation</code> for failing tasks with <code>detailsJson</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Helper: ValidateEvidenceForTask — exhaustive contract:</strong><br> <strong>Purpose:</strong> Determine whether attached evidence meets <code>policySnapshot</code> requirements for a task. <br> <strong>Signature:</strong> <code>ValidateEvidenceForTask(taskRow, evidenceRequirements[], attachedEvidence[], policySnapshot) -&gt; {ok:Boolean, missingCategories:[], unverifiedEvidence:[], staleEvidence:[], evidenceDetails:[]}</code>. <br> <strong>Checks & mappings:</strong><br> 1. For each <code>requiredCategory</code> find at least one <code>attachedEvidence</code> matching <code>evidenceCategory</code>. If none, add to <code>missingCategories</code>. <br> 2. If <code>evidenceChecksumPolicy = mandatory</code> require <code>checksum</code> present and <code>evidenceStatus = valid</code>; otherwise record <code>unverifiedEvidence</code>. <br> 3. If evidence <code>uploadedTs</code> older than <code>evidenceMaxAgeDays</code> relative to <code>closeDate</code> mark as <code>staleEvidence</code>. <br> 4. Return <code>ok</code> only when missingCategories empty and unverifiedEvidence empty unless policy explicitly allows unverified. Append <code>fa.evidence.validation</code> with <code>evidenceDetails</code> on failure. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: ComputeCloseBlockReport — canonical persist & contents:</strong><br> <strong>Purpose:</strong> Assemble human and machine-readable block report listing blocking tasks with remediation guidance; persist and compute <code>blockHash</code>. <br> <strong>Signature:</strong> <code>ComputeCloseBlockReport(blockedTasks[], evaluationSnapshot, manifestVersion, operatorId) -&gt; blockReportId</code>.<br> <strong>Report schema (each blocked task row):</strong> <code>{taskId, taskName, assignedOwnerDisplayName, assignedOwnerId, department, priority, gatingCategory, computedDueDate, blockingReasons[]}</code> where <code>blockingReasons[]</code> contains entries <code>{reasonCode, humanMessage, severity, suggestedAction, remediationOwnerId, estimatedEffortMins, relatedEvidenceIds[], relatedSignOffIds[], pqIssueRefs[]}</code>. <br> <strong>Persistence & hashing:</strong> Canonically serialize report fields in an exact field order (Appendix) and compute <code>blockHash = sha256:</code> of UTF-8 bytes. Persist <code>CloseBlockReports</code> row with <code>blockReportId</code>, <code>manifestVersion</code>, <code>operatorId</code>, <code>createdTs</code>, <code>tasksCount</code>, <code>blockHash</code>, <code>canonicalVersion</code>. Append <code>fa.checklist.blockReport.created</code> to <code>AuditLog</code>. Return <code>blockReportId</code>. <br> <strong>Export & owner consumption:</strong> Provide <code>blockReportId</code> as hyperlink to owners with suggested action buttons: <code>AttachEvidence</code>, <code>RequestSignOff</code>, <code>MergeTask</code>, <code>Escalate</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: PersistCloseEvent — atomic persist & forensics:</strong><br> <strong>Purpose:</strong> Atomically persist final close state and mark manifest closed with tamper-evident <code>closeHash</code>. <br> <strong>Signature:</strong> <code>PersistCloseEvent(manifestVersion, operatorId, closeDate, Optional overrideApprovalRef, Optional notes) -&gt; closeId</code>.<br> <strong>Canonical serialization recipe:</strong> Fields order: <code>canonicalVersion|closeId|manifestVersion|operatorId|closeDate|closedTs|policySnapshotId|overrideApprovalRef|notes</code>. Normalize text and compute <code>closeHash = sha256:</code> over canonical bytes. <br> <strong>Atomic persistence steps:</strong><br> 1. Prepare <code>CloseEvent</code> record. <br> 2. Write to staging store <code>CloseEvents_staging</code> and verify durability. <br> 3. Update <code>ChecklistVersionManifest_staging</code> with <code>closed=true</code>, <code>closedBy=operatorId</code>, <code>closedTs=NowUTC()</code>, <code>closeRef=closeId</code>. <br> 4. Atomically swap staging to production or perform a transactional commit if backend DB supports transactions. <br> 5. On success append <code>fa.checklist.closed</code> with <code>closeId</code>, <code>manifestHash</code>, <code>closeHash</code>. On failure revert and append <code>fa.checklist.closed.fail</code> and return <code>ERR_PERSIST_FAIL</code>. <br> <strong>Post-persist exports:</strong> Optionally produce signed forensic bundle (manifest, close event, block report if any, <code>AuditLog</code> slice) and persist to long-term archive; record <code>exportPath</code> and <code>exportHash</code> in <code>CloseEvent</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: ValidateOverride — policy validation & compensating controls:</strong><br> <strong>Purpose:</strong> Validate provided override approval artifacts and operator authorization. <br> <strong>Signature:</strong> <code>ValidateOverride(operatorId, overrideApprovalRef, policySnapshot) -&gt; {ok:Boolean, validationDetails:String}</code>.<br> <strong>Checks:</strong><br> 1. Confirm <code>policySnapshot.emergencyRules</code> allows override for the manifest scope and operator's role. <br> 2. Resolve <code>overrideApprovalRef</code> to recorded approval artifact(s): <code>SignOffEntry</code> rows or external approval tokens with valid signatures. <br> 3. Confirm approval set meets <code>emergencyRules.requiredApprovers</code> (e.g., CFO + Compliance). <br> 4. Verify approvals not expired (approvalTs within allowed window). <br> 5. Confirm compensating controls recorded (e.g., <code>PostCloseAdjustment</code> tasks scheduled). <br> 6. Append <code>fa.checklist.override.validated</code> on success; return <code>ok=false</code> and <code>ERR_OVERRIDE_UNAUTHORIZED</code> if any check fails. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: ReopenClose — controlled reopen & supersede:</strong><br> <strong>Purpose:</strong> Reopen a previously closed manifest to allow remediation and create <code>PostCloseAdjustment</code> tasks while preserving original close for forensic chain-of-custody. <br> <strong>Signature:</strong> <code>ReopenClose(closeId, operatorId, reason, approvals[]) -&gt; {reopenId, status}</code>. <br> <strong>Governance & preconditions:</strong><br> 1. Only <code>reopenPrivilege</code> operators may initiate; policy may require compliance/CFO/board approvals based on <code>CloseEvent</code> severity. <br> 2. Collect <code>approvals[]</code> as <code>SignOffEntry</code> or signed tokens. <br> <strong>Steps:</strong><br> 1. Validate <code>closeId</code> exists and not already superseded. <br> 2. Create <code>ReopenEvent</code> persisted with <code>reopenId</code>, <code>closeId</code>, <code>operatorId</code>, <code>approvals</code>, <code>reason</code>, <code>reopenTs</code>; compute <code>reopenHash</code>. <br> 3. Mark original <code>CloseEvent.status = superseded</code> by appending an audit row (append-only semantics). <br> 4. Create <code>PostCloseAdjustment</code> task(s) appended to <code>TasksMaster</code> with <code>taskSource=postcloseAdjustment</code> and link to <code>originalCloseId</code>. <br> 5. Append <code>fa.checklist.reopen</code> to <code>AuditLog</code>. Return <code>reopenId</code> and <code>status=ReopenCreated</code>. <br> <strong>Forensics:</strong> Export both original and reopened bundles and record <code>supersession</code> chain metadata. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: CheckPQIssuesForScope — helper & gating integration:</strong><br> <strong>Purpose:</strong> Identify PQ-sourced blocking issues affecting manifest scope. <br> <strong>Signature:</strong> <code>CheckPQIssuesForScope(manifestVersion, scope, policySnapshot) -&gt; pqBlockingIssues[]</code>. <br> <strong>Behavior:</strong> Query <code>PQ_Issues</code> for <code>entityRef</code> matching tasks in manifest scope, filter by <code>severity &gt;= policySnapshot.pqBlockingSeverity</code> and <code>status != resolved</code>. Return list and append <code>fa.pq.issues.checked</code>. Use this result during evaluation to ensure data-quality gating. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: BuildCloseBlockReportExport — redaction & signing:</strong><br> <strong>Purpose:</strong> Produce a downloadable, signed, and optionally redacted export for a <code>CloseBlockReport</code>. <br> <strong>Signature:</strong> <code>BuildCloseBlockReportExport(blockReportId, operatorId, exportOptions) -&gt; {exportPath, exportHash}</code>. <br> <strong>Export rules:</strong><br> 1. Apply <code>policySnapshot.redactionPolicy</code> to redact PII unless <code>operatorId</code> has redaction exemption. <br> 2. Include <code>blockHash</code> and <code>manifestHash</code> and <code>canonicalVersion</code>. <br> 3. Compute <code>exportHash</code> = <code>sha256:</code> over zipped content; sign with available signing key and include signature metadata. <br> 4. Append <code>fa.checklist.blockReport.exported</code> to <code>AuditLog</code>. Return path and <code>exportHash</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Function: DryRunEvaluate — operator preview:</strong><br> <strong>Purpose:</strong> Run evaluation only (no persistence) for readiness checks and owner previews. <br> <strong>Signature:</strong> <code>DryRunEvaluate(manifestVersion, operatorId) -&gt; EvaluationResult</code>. <br> <strong>Behavior:</strong> Calls <code>FetchEvaluationSnapshot</code> and <code>EvaluateManifestForClose</code> and returns the <code>EvaluationResult</code> with <code>estimatedRemediationEffort</code> aggregated; append <code>fa.checklist.closeAttempt.dryrun</code>. No block reports or close events persisted. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Canonical serialization recipes (Appendix-level, mandatory):</strong><br> 1. Text canonicalization: Unicode NFKC normalization, trim ends, collapse internal whitespace sequences into single space, normalize smart quotes to ASCII equivalents, casefold per locale (document locale in <code>manifestMetadata</code> if needed). <br> 2. Date canonicalization: all canonical dates in manifest or snapshot use <code>YYYY-MM-DD</code>; timestamps use UTC <code>YYYY-MM-DDTHH:MM:SSZ</code>. <br> 3. Escaping: escape pipe <code>|</code> as <code>\|</code> and backslash <code>\</code> as <code>\\</code> in serialized fields for hashing. Replace newline with literal <code>\n</code>. <br> 4. Field ordering: follow explicit canonical order per artifact (CloseEvent, CloseBlockReport, TaskRow). Any change to ordering requires <code>migrationManifest</code>. <br> 5. Hashing: compute SHA-256 over canonical bytes (UTF-8) and represent as lowercase hex prefixed with <code>sha256:</code>. Persist both canonical string (or compressed artifact) and hash for verification. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>policySnapshot schema summary (must be present):</strong><br> • <code>policySnapshotId</code> (GUID), <code>createdBy</code>, <code>createdTs</code>, <code>approvalMatrix</code> map <code>(priority,gatingCategory) -&gt; requiredRoles[]</code>, <code>twoPersonThresholds</code> mapping, <code>signoffTimeWindowDays</code>, <code>evidenceChecksumPolicy</code> (<code>mandatory|recommended|disabled</code>), <code>evidenceMaxAgeDays</code>, <code>pqBlockingSeverity</code>, <code>reasonSeverityMap</code> mapping reasonCodes -> severity levels, <code>emergencyRules</code> (approvers, requiredCompensations), <code>redactionPolicy</code>, <code>canonicalVersion</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Power Query (PQ) orchestration guidance (complete, conceptual):</strong><br> PQ must be treated as the canonical table builder that the gating module consumes. PQ must implement explicit named steps with deterministic behavior; avoid ad-hoc local transforms. Required PQ pipeline (named steps & outputs):<br> 1. <code>Source_Ingest</code> — ingest <code>YearEndTaskTemplate</code>, <code>AdhocRequests</code>, <code>OwnerAssignments</code>, <code>SupportingDocuments</code> (metadata only), <code>SignOffEntries</code>, <code>CloseParameters</code> single-row config. <br> 2. <code>CanonicalizeTextStep</code> — apply Unicode NFKC normalization, trim, collapse repeated whitespace into single space and casefold per locale producing <code>taskNameCanonical</code> and <code>descriptionCanonical</code>. Record <code>canonicalizationChangeCount</code>. <br> 3. <code>DateNormalizationStep</code> — parse <code>explicitDueDate</code> or compute <code>computedDueDate = Date.AddDays(closeDate, -defaultDueOffsetDays)</code>. Format <code>YYYY-MM-DD</code>. Emit <code>PQ_Issues</code> for parse errors. <br> 4. <code>OwnerResolutionStep</code> — join <code>OwnerAssignments</code> and attach <code>assignedOwnerDisplayName</code>, <code>email</code>, <code>department</code>, <code>approverId</code>, <code>activeFlag</code>. If missing owner produce <code>PQ_Issues</code> row <code>MissingOwner</code>. Provide top-3 fuzzy suggestions for analyst UI. <br> 5. <code>EvidenceAttachStep</code> — left-join <code>SupportingDocuments</code> by <code>attachedToTaskId</code> and produce <code>attachedEvidenceIds[]</code>, <code>evidenceCategoriesCovered[]</code>. For unattached evidence perform heuristic matches by filename token overlap, date proximity to <code>computedDueDate</code> and uploader; produce <code>HeuristicMatches</code> table with <code>confidenceScore</code>. <strong>Do not compute binary checksums in PQ</strong>; checksums are computed by <code>modEvidence</code>. <br> 6. <code>SignOffAggregateStep</code> — aggregate <code>SignOffEntries</code> per task into arrays: <code>signOffEntries[]</code>, <code>signOffCount</code>, <code>signOffByRole[]</code>, <code>lastSignOffTs</code>, and mark <code>staleSignoffFlag</code> where <code>lastSignOffTs</code> outside <code>policySnapshot.signoffTimeWindowDays</code>. <br> 7. <code>GatingMetricCompute</code> — compute <code>missingCategories[]</code>, <code>evidenceMissingCount</code>, <code>gatingRisk</code> (deterministic function combining priority, overdueFlag, missingEvidence_count, missingSignoffs), <code>daysToDue</code>. <br> 8. <code>PQ_IssuesStep</code> — collate PQ issues with canonical schema <code>{issueId, issueType, entityRef, severity, details, suggestedAction, createdTs}</code>; ensure severity uses canonical enum. <br> 9. <code>TasksMasterOutput</code> — final canonical table with <code>pqRunHash</code>, <code>canonicalVersion</code>, <code>CloseParameters</code> snapshot copy. PQ must write <code>pqRunHash</code> computed deterministically and record step timestamps. <br> <strong>Operational guidance for PQ:</strong> Keep steps named for traceability. Do not attempt network HEAD/GET checks for evidence unless tenant policy allows; if performing remote HEAD, ensure results recorded in <code>SupportingDocuments.urlHealth</code> and included as <code>PQ_Issues</code> where unreachable. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX measures & reporting patterns (complete conceptual list):</strong><br> Build a Power BI dataset with <code>TasksMaster</code>, <code>ChecklistVersionManifest</code>, <code>SignOffEntries</code>, <code>SupportingDocuments</code>, <code>CloseEvents</code>, and <code>CloseBlockReports</code>. Provide these conceptual measures (no code):<br> 1. <code>TasksOpen</code> — count tasks where <code>status</code> not in (Complete, Signed Off). <br> 2. <code>CriticalOpen</code> — count tasks where <code>gatingCategory = critical</code> and not signed off. <br> 3. <code>MissingEvidenceCount</code> — sum over tasks of <code>missingCategories.Count</code>; slice by <code>evidenceCategory</code>. <br> 4. <code>SignOffCoveragePct</code> — ratio tasks with required signoffs satisfied / total tasks for manifest. <br> 5. <code>AvgDaysToClose</code> — average (<code>closeTs - generatedTs</code>) per manifest; use for SLA and trend. <br> 6. <code>ManifestParityOk</code> — boolean if recomputed <code>manifestHash</code> equals persisted <code>manifestHash</code> for each manifest; fail triggers compliance alerts. <br> 7. <code>BlockReasonDistribution</code> — distribution counts by <code>reasonCode</code> from <code>CloseBlockReports</code>. <br> 8. <code>EvidenceVerificationRate</code> — percent of <code>SupportingDocuments</code> with <code>evidenceStatus = valid</code> among attached evidence. <br> 9. <code>OverrideUsageRate</code> — percent of closes containing <code>overrideApprovalRef</code>. <br> 10. <code>OwnerRemediationVelocity</code> — median time from <code>blockReport.createdTs</code> to <code>remediationAction</code> (attach evidence, signoff, or resolution) per owner. <br> <strong>Report patterns:</strong> manifest snapshot tile (manifestHash, parity status), owner scorecards (open critical tasks and overdue items), compliance panel (list of manifests with overrides or reopens), parity tiles (mismatches and diffs). Provide drillthrough to <code>CloseBlockReport</code> and <code>AuditLog</code> slices. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Worked examples — exhaustive and precise (many edge cases):</strong><br> <strong>Example 1 — Statutory tax close (happy path):</strong><br> 1. PQ generates <code>TasksMaster</code> including <code>T-100</code> (priority=P0, gatingCategory=critical, evidenceRequirements=[taxReconPDF, signoffForm]). <code>ChecklistVersionManifest v-2026-01</code> persisted with <code>manifestHash</code>. <br> 2. Tax lead attaches local file <code>taxRecon.pdf</code> via <code>modEvidence.AttachEvidence(taskId=&quot;T-100&quot;, localFilePath=&quot;C:\tmp\taxRecon.pdf&quot;, uploaderId=&quot;alice&quot;)</code>. <code>modEvidence</code> computes <code>checksum=sha256:...</code>, sets <code>evidenceStatus=valid</code> and appends <code>fa.evidence.attached(evidenceId=e-900)</code>. <br> 3. Manager <code>mgr-1</code> records signoff via <code>modSignOff.RecordSignOff(taskId=&quot;T-100&quot;, signerId=&quot;mgr-1&quot;, signedRole=&quot;manager&quot;, approvalRef=&quot;&quot;)</code>, producing <code>signOffId s-700</code>. <br> 4. Operator runs <code>AttemptClose(manifestVersion=&quot;v-2026-01&quot;, closeDate=&quot;2026-12-31&quot;, operatorId=&quot;op-alice&quot;)</code>. <code>LockManifest</code> returns <code>lockId L-101</code>. <code>FetchEvaluationSnapshot</code> persists snapshot and <code>EvaluateManifestForClose</code> returns no blocked tasks. <code>PersistCloseEvent</code> writes <code>closeId C-222</code> with <code>closeHash</code>. <code>fa.checklist.closed</code> appended and forensic bundle exported. <br> <strong>Example 2 — Unverified evidence blocks close (blocked path):</strong><br> 1. Supporting document attached as DMS URL with no checksum (<code>e-451</code>) -> <code>evidenceStatus=unverified</code>. PQ marks this in <code>SupportingDocuments</code> and <code>PQ_Issues</code> (<code>UnverifiedEvidence</code>). <br> 2. AttemptClose runs; <code>EvaluateManifestForClose</code> marks <code>T-222</code> as blocked due to <code>UnverifiedEvidence</code> (policy requires checksum). <code>ComputeCloseBlockReport</code> persists <code>B-333</code>. <code>AttemptClose</code> returns <code>ERR_CLOSE_BLOCKED</code> with <code>blockReportRef B-333</code>. <br> 3. Remediation options: rebind evidence with checksum (<code>modEvidence.RebindEvidence</code>), upload local file to compute checksum (<code>modEvidence.AttachEvidence</code>), or obtain policy waiver (override) with documented approvals. After remediation PQ re-run and <code>AttemptClose</code> succeeds. <br> <strong>Example 3 — Stale signoff (edge):</strong><br> 1. P0 task requires owner+manager signoff within ±7 days of manifest generation. Owner signoff exists but <code>signedTs</code> 30 days prior -> flagged <code>stale</code>. <code>EvaluateManifestForClose</code> will block until manager signs within time window. <br> 2. Manager signs and <code>AttemptClose</code> proceeds; <code>fa.signoff.recorded</code> and <code>fa.signoff.validation</code> recorded. <br> <strong>Example 4 — Emergency override (governed override):</strong><br> 1. Critical close blocked only by a missing manager signoff. <code>policySnapshot.emergencyRules</code> allow CFO override with compliance co-approval and a retrospective audit. <br> 2. CFO and compliance provide approvals recorded as <code>SignOffEntry</code> rows <code>appr-001</code> and <code>appr-002</code>. Operator uses <code>AttemptClose(... overrideApprovalRef=&quot;appr-001&quot;)</code>. <code>ValidateOverride</code> verifies both approvals satisfy <code>emergencyRules</code>. <code>PersistCloseEvent</code> writes <code>overrideUsed=true</code> in <code>CloseEvent</code>. <code>PostCloseAdjustment</code> tasks created for retrospective audit. Append <code>fa.checklist.override.used</code>. <br> <strong>Example 5 — Duplicate tasks merged during close window:</strong><br> 1. PQ emits <code>PossibleDuplicate</code> for <code>T-11</code> and <code>T-14</code>. Analyst runs <code>MergeTasks(primary=T-11, secondary=[T-14])</code>. <code>MergeTasks</code> consolidates evidence and sign-offs, marks <code>T-14.deprecated=true</code> and appends <code>fa.task.merge</code>. PQ re-run updates <code>TasksMaster</code>. <code>AttemptClose</code> reflects merged state and proceeds. <br> <strong>Example 6 — Reopen & superseding close:</strong><br> 1. Post-close issue discovered: missing reconciliations omitted. Legal requests reopen. Operator runs <code>ReopenClose(closeId=C-222, operatorId=op-alice, reason=&quot;Missing recon schedule&quot;, approvals=[compliance-sig])</code>. System persists <code>ReopenEvent R-900</code>, appends <code>fa.checklist.reopen</code>, marks original <code>C-222</code> <code>superseded</code>, and creates <code>PostCloseAdjustment</code> tasks. After remediation a new <code>AttemptClose</code> creates <code>supersedingCloseId C-333</code>. Forensic bundles for both <code>C-222</code> and <code>C-333</code> archived. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Testing & parity — exhaustive test plan and acceptance tests:</strong><br> <strong>Unit tests (recommended):</strong><br> 1. <code>LockManifest</code>: simulate multi-threaded acquisitions; assert single success and others <code>ERR_MANIFEST_LOCK_FAIL</code>. Test forced lock path and stale lock detection. <br> 2. <code>FetchEvaluationSnapshot</code>: feed canonical fixture and assert <code>snapshotHash</code> equals expected golden value. <br> 3. <code>EvaluateManifestForClose</code>: test each failure reason individually (MissingOwner, MissingEvidence, UnverifiedEvidence when policy=mandatory, MissingSignOffRoles, PQBlockingIssue), assert <code>blockedTasks</code> and reason codes exactly match policy mapping. <br> 4. <code>ValidateOverride</code>: valid approvals vs invalid/expired approvals; assert correct <code>ERR_OVERRIDE_UNAUTHORIZED</code>. <br> 5. <code>PersistCloseEvent</code>: inject IO failure at different steps and assert atomicity (no partial manifest closed state). <br> 6. <code>ComputeCloseBlockReport</code>: canonical serialization and <code>blockHash</code> reproducible for fixture. <br> <strong>Integration tests (end-to-end):</strong><br> 1. Happy path fixture (<code>fixture_small</code>): ingest -> PQ -> GenerateChecklistPDF -> AttachEvidence with checksums -> RecordSignOff -> AttemptClose -> CloseSucceeded -> closeHash equals expected golden value. <br> 2. Blocked path fixture: PQ issues + unverified evidence -> <code>CloseBlocked</code> and persisted <code>CloseBlockReport</code>; after remediation re-run closes successfully. <br> 3. Override path fixture: simulate required emergency approvals and assert <code>overrideUsed</code> recorded, <code>PostCloseAdjustment</code> tasks created. <br> <strong>Performance & scale tests:</strong> PQ refresh times for 500, 2k, 10k tasks; <code>AttemptClose</code> latency under typical loads; lock contention tests with simulated concurrent operators. <br> <strong>Parity / Golden fixtures:</strong> maintain <code>fixture_small</code>, <code>fixture_mid</code>, <code>fixture_edge</code> with expected <code>manifestHash</code>, <code>snapshotHash</code>, <code>blockHash</code>, <code>closeHash</code>. Nightly parity job recomputes hashes and raises <code>fa.verify.parity.failed</code> alerts if mismatches detected. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Observability & telemetry (metrics, alerts, retention):</strong><br> <strong>Metrics to record (per attempt and as aggregates):</strong><br> 1. <code>close.attempts.count</code> — increment at start of <code>AttemptClose</code>.<br> 2. <code>close.successCount</code> — increment on successful close. <br> 3. <code>close.blockCount</code> — number of blocking tasks found on attempt. <br> 4. <code>close.overrideCount</code> — closes using override. <br> 5. <code>close.reopenCount</code> — reopen operations. <br> 6. <code>close.attempt.durationMs</code> — measured duration. <br> 7. <code>pq.blockingIssueCount</code> — number of PQ blocking issues per manifest. <br> 8. <code>evidence.unverifiedCount</code> and <code>evidence.invalidCount</code>. <br> <strong>Alert rules (recommended thresholds):</strong><br> 1. High priority: <code>CriticalOpen &gt; 0</code> and <code>closeDate - Today &lt;= 48 hours</code> → immediate compliance/ops alert. <br> 2. High priority: <code>manifestParityMismatch</code> discovered by nightly parity job → immediate compliance alert. <br> 3. Medium: <code>evidence.unverifiedCount</code> spike > baseline within 24 hour window. <br> 4. Medium: repeated <code>ERR_PERSIST_FAIL</code> events in a 24-hour window. <br> 5. Low: <code>PQ_Issues</code> trending up for multiple manifests. <br> <strong>Data retention for telemetry:</strong> keep high-cardinality telemetry short-term (30–90 days) in hot store; persist daily aggregates to archive for long-term trend analysis. Telemetry rows must include <code>manifestVersion</code> tag for correlation. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Security & privacy controls (exhaustive):</strong><br> 1. <strong>RBAC:</strong> maintain <code>Operators</code> table with roles and privileges; restrict <code>AttemptClose</code>, <code>ReopenClose</code>, <code>ForceLock</code> and <code>BuildCloseBlockReportExport</code> to privileged roles. <br> 2. <strong>No credentials in workbook:</strong> do not store DMS credentials or tokens inside workbook cells. <code>SupportingDocuments.url</code> must be token-free pointers; retrieval requiring token is the user’s responsibility. <br> 3. <strong>Redaction & PII:</strong> exported artifacts must be redacted according to <code>policySnapshot.redactionPolicy</code> unless operator has explicit exemption. <br> 4. <strong>Signed artifacts:</strong> sign forensic bundles with organizational keys when available; store signature metadata in <code>CloseEvent</code> <code>exportSignature</code>. <br> 5. <strong>Macro signing:</strong> sign the VBA project for production distribution. <br> 6. <strong>Network calls:</strong> remote HEAD/GET evidence checks only where allowed and logged with <code>verificationAttempts</code> in <code>SupportingDocuments</code>. <br> 7. <strong>Legal hold:</strong> applying <code>legalHold=true</code> must prevent deletion or normal retention lifecycle; append <code>fa.legalhold.applied</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Retention, archival & legal hold (prescriptive):</strong><br> 1. Preserve <code>ChecklistVersionManifest</code>, <code>CloseEvent</code>, <code>CloseBlockReport</code>, <code>EvaluationSnapshots</code>, <code>SignOffEntries</code>, <code>SupportingDocuments</code> metadata and <code>AuditLog</code> slices in signed forensic bundles for legal retention period (e.g., 7–10 years or per jurisdiction). <br> 2. Forensic bundle contains <code>manifestCanonicalString</code>, <code>manifestHash</code>, <code>snapshotHash</code>, <code>closeHash</code>, <code>blockHash</code> (if present), <code>AuditLog</code> slices, and references to evidence storage (not necessarily binary evidence). <br> 3. Store forensic bundles in encrypted-at-rest archive; maintain access logs. <br> 4. When legal hold active, mark all related artifacts with <code>legalHold=true</code> and suspend retention deletion. Append <code>fa.legalhold.applied</code> and <code>fa.legalhold.released</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Operator runbooks (short procedural checklists):</strong><br> <strong>Pre-close readiness (operator):</strong><br> 1. Run PQ refresh and review <code>PQ_Issues</code>; resolve High/Blocking items. <br> 2. Run <code>DryRunEvaluate(manifestVersion)</code> and review <code>EvaluationResult</code>. <br> 3. Generate PDF checklist via <code>modChecklist.GenerateChecklistPDF</code> and distribute to owners. <br> 4. Execute <code>modRemind.ScheduleReminders</code> at 14/7/3 days cadence for outstanding items. <br> 5. Verify signoffs in <code>SignOffRegistry</code> and confirm none are stale. <br> 6. Run <code>AttemptClose</code> final time; if blocked follow <code>CloseBlockReport</code> remediation items. <br> <strong>Emergency override (operator):</strong><br> 1. Confirm override permitted by <code>policySnapshot.emergencyRules</code>. <br> 2. Gather required approvals (CFO + compliance), record tokens <code>overrideApprovalRef</code>. <br> 3. Execute <code>AttemptClose</code> with <code>overrideApprovalRef</code>, ensure <code>PostCloseAdjustment</code> tasks are created and retrospective audit scheduled. <br> <strong>Reopen runbook:</strong><br> 1. Validate reopen authority and gather required approvals. <br> 2. Run <code>ReopenClose(closeId, operatorId, reason, approvals)</code>. <br> 3. Create <code>PostCloseAdjustment</code> tasks and track remediation; run new <code>AttemptClose</code> to supersede. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Developer deliverables & migration artifacts (recommended):</strong><br> 1. VBA module stubs for <code>modGating</code> implementing function signatures and placeholder <code>modAudit.AppendAudit</code> calls. <br> 2. PQ step-by-step M script documentation (names of steps and transformation intent). <br> 3. Golden fixture CSVs (<code>fixture_small</code>, <code>fixture_mid</code>, <code>fixture_edge</code>) and parity test harness verifying <code>manifestHash</code>, <code>snapshotHash</code>, <code>blockHash</code>, <code>closeHash</code>. <br> 4. Operator quick reference and compliance playbook for overrides and reopens. <br> 5. MigrationManifest template for <code>policySnapshot</code> changes (includes canary plan and rollback steps). </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Migration & change governance (prescriptive):</strong><br> 1. Any <code>policySnapshot</code> changes that affect gating semantics (approval matrix, evidence checksum requirement, signoff windows) must be versioned and accompanied by a <code>migrationManifest</code> capturing canary plan, rollback steps, affected manifests, test fixtures, and approvals. <br> 2. New policies must not be retroactively applied to previously closed manifests without documented remediation process. <br> 3. Canary on non-critical manifests, monitor <code>CriticalOpenDeltaPct</code> and <code>CloseSuccessRate</code> across cohorts; escalate if thresholds breached. <br> 4. Archive old <code>policySnapshot</code> versions and reference them in historical <code>CloseEvent</code> records. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Acceptance criteria (concrete & testable):</strong><br> 1. For canonical fixtures <code>fixture_small</code> and <code>fixture_mid</code> the system reproduces expected <code>manifestHash</code> and <code>closeHash</code>. <br> 2. <code>AttemptClose</code> produces deterministic <code>CloseResult</code> for identical inputs. <br> 3. <code>CloseBlockReport</code> contents and <code>blockHash</code> reproducible for fixture inputs. <br> 4. <code>PersistCloseEvent</code> atomicity verified through IO failure injection testing. <br> 5. Override flows require recorded approvals and produce <code>PostCloseAdjustment</code> tasks. <br> 6. <code>AuditLog</code> contains <code>fa.checklist.closeAttempt.started</code> and <code>fa.checklist.closed</code> or <code>fa.checklist.closeAttempt.blocked</code> for all attempts. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Onboarding & training materials (required):</strong><br> 1. Operator quick reference (AttemptClose, DryRunEvaluate, Reminders, Override steps). <br> 2. Analyst runbook (PQ step traceability, <code>PQ_Issues</code> remediation, duplicate merges, evidence heuristics). <br> 3. Compliance playbook (override approvals, legal hold, forensic export checklist). <br> 4. Developer docs (canonicalization rules, hashing orders, fixture generation). </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Appendix A — canonical serialization field orders (must be followed):</strong><br> • <code>TaskRow</code> canonical order for <code>taskRowChecksum</code>: <code>canonicalVersion|taskId|taskNameCanonical|assignedOwnerId|gatingCategory|computedDueDate|signoffRequired</code>.<br> • <code>SupportingDocument</code> canonical order for <code>evidenceRowChecksum</code>: <code>canonicalVersion|evidenceId|title|url|uploaderId|uploadedTs|evidenceCategory</code>.<br> • <code>SignOffEntry</code> canonical order for <code>signOffRowChecksum</code>: <code>canonicalVersion|signOffId|taskId|signedBy|signedRole|signedTs|versionId</code>.<br> • <code>ChecklistVersionManifest</code> canonical order for <code>manifestHash</code>: <code>canonicalVersion|versionId|generatedBy|generatedTs|scope|taskCount|blockingCount|taskRowsCanonical...|notes</code>.<br> • <code>CloseEvent</code> canonical order for <code>closeHash</code>: <code>canonicalVersion|closeId|manifestVersion|operatorId|closeDate|closedTs|policySnapshotId|overrideApprovalRef|notes</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Appendix B — recommended telemetry schema (row):</strong><br> <code>{metricName, timestampUTC, value, manifestVersion, operatorId, tagsJSON}</code>. Tags include scope (owner/department), reason codes, and canonicalVersion. Persist telemetry to <code>Telemetry</code> sheet and export periodically to BI or SIEM. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Appendix C — error codes & remediation mapping (compact):</strong><br> • <code>ERR_MANIFEST_LOCK_FAIL</code> — remediation: check <code>ManifestLocks</code> table; contact lock owner; if stale and authorized force lock. <br> • <code>ERR_PQ_ISSUES_BLOCK</code> — remediation: open <code>PQ_Issues</code> table and resolve high-severity issues; re-run PQ and dry-run evaluation. <br> • <code>ERR_SIGNOFF_MISSING</code> — remediation: send reminders to missing approvers; escalate if nearing closeDate. <br> • <code>ERR_EVIDENCE_MISSING</code> — remediation: request owner to attach required evidence; provide block report. <br> • <code>ERR_EVIDENCE_UNVERIFIED</code> — remediation: rebind evidence with checksum or upload local copy for checksum; verify with <code>modEvidence.VerifyEvidence</code>. <br> • <code>ERR_OVERRIDE_UNAUTHORIZED</code> — remediation: obtain required approver tokens and call <code>AttemptClose</code> with <code>overrideApprovalRef</code> or schedule remediation. <br> • <code>ERR_PERSIST_FAIL</code> — remediation: check disk space/permissions, retry persistence, escalate to IT with <code>auditRef</code>. </td></tr><tr><td data-label="modGating — Per-function Expert Technical Breakdown"> <strong>Final implementer note (concise):</strong><br> This specification is intentionally exhaustive to support legal-grade audit workflows and future migration to server-side gating systems. Preserve canonicalVersion tracking, append-only audit model, atomic persistence recipes and parity golden fixtures. If you want, the next deliverable can be ready-to-paste VBA stubs for <code>modGating</code> (full function headers, deterministic error codes, <code>modAudit.AppendAudit</code> calls) plus sample PQ step enumerations and golden fixture CSVs. Indicate which artifact(s) you want next. </td></tr></tbody></table></div><div class="row-count">Rows: 39</div></div><div class="table-caption" id="Table2" data-table="Docu_0189_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modRemind — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modRemind — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Preface & Purpose (comprehensive)</strong><br>This document is the definitive implementation blueprint for <code>modRemind</code> — the reminders & escalations automation module used by Project 062 (Year-End Audit Checklist Generator). It translates high-level requirements into explicit developer contracts, operator runbooks, test matrices, and governance guidance. The content below must be treated as prescriptive: implementers should follow canonical field names, canonicalization recipes, audit event types, manifest hashing rules, idempotency keys and rate-limit policies exactly as specified to preserve forensic parity and legal traceability. Notes on style: every numbered list in this document uses HTML <code>&lt;br&gt;</code> line breaks to match the project's rendering rules. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Scope & Boundaries</strong><br>• In scope: VBA implementation of <code>modRemind</code> inside ChecklistGeneratorWorkbook.xlsm (macros, sheets, staging tables), Power Query staging table (<code>RemindersStaging</code>) preparation, template management, Outlook/SMTP wrappers, <code>ReminderQueue</code> and <code>ReminderArtifacts</code> artifacts, <code>AuditLog</code> entries and manifest references. <br>• Out of scope: building external SMTP servers or enterprise DMS integrations beyond basic connectors; server-side migration hosting (described later as migration path). <br>• Security boundary: the workbook stores metadata, not primary evidence; no credentials to be persisted in workbook cells; use external vaults or Outlook automation. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>High level responsibilities</strong><br>1. Determine which tasks require reminders using deterministic PQ outputs and <code>policySnapshot</code>. <br>2. Produce owner-scoped, approver-scoped reminders (email or PDF) with templated content and manifest references. <br>3. Rate limit and reliably deliver reminders with retry/backoff and idempotency. <br>4. Execute escalations when owners are non-responsive per policy. <br>5. Record append-only audit events for every send, defer, retry, escalation, override and export. <br>6. Provide operator macros for preview/dry-run, bulk scheduling, retry, and forensic export. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Design principles & invariants</strong><br>1. Deterministic inputs: <code>RemindersStaging</code> table from PQ is authoritative for any send; <code>modRemind</code> must not canonicalize task rows — PQ does. <br>2. Idempotency: each planned send must have a stable <code>reminderId</code> (GUID) and <code>batchId</code> SHA-256 computed deterministically. Replays with the same <code>reminderId</code> produce no duplicate sends. <br>3. Append-only audit: every mutative action writes an <code>AuditLog</code> row; corrections are compensating audit events. <br>4. Conservative defaults: if required preconditions are missing (owner email, PQ high severity), <code>modRemind</code> must not auto-send; instead return structured errors and require operator remediation. <br>5. Least privilege & PII minimization: emails include manifest links and <code>manifestHash</code> rather than embedding PII or evidence; attachments allowed only when policy permits and recipient authorized. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Canonical inputs & configuration</strong><br>• <code>RemindersStaging</code> (PQ output): <code>batchId</code>, <code>ownerId</code>, <code>ownerEmail</code>, <code>ownerDisplayName</code>, <code>taskIdsCSV</code>, <code>taskCount</code>, <code>priorityScore</code>, <code>suggestedTemplateId</code>, <code>manifestRefsCSV</code>, <code>preparedTs</code>, <code>preparedBy</code>, <code>canonicalVersion</code>. <br>• <code>ReminderTemplates</code> sheet: <code>templateId</code>, <code>displayName</code>, <code>subjectTemplate</code>, <code>bodyTemplate</code>, <code>allowedTokens</code>, <code>maxInlineTasks</code>, <code>attachmentsAllowed</code>, <code>createdBy</code>, <code>createdTs</code>, <code>canonicalVersion</code>. <br>• <code>policySnapshot</code> sheet (single row): <code>reminderCadences</code> mapping days→templateId, <code>maxEmailsPerHour</code>, <code>rateLimitPolicy</code>, <code>retryPolicy</code>, <code>escalationPolicy</code>, <code>piiRedactionRules</code>, <code>externalEmailAllowed</code>, <code>requireApprovalForAutoSend</code>, <code>circuitBreakerThreshold</code>. <br>• <code>OwnerAssignments</code> sheet: <code>ownerId</code>, <code>displayName</code>, <code>email</code>, <code>approverId</code>, <code>escalationContactId</code>, <code>department</code>, <code>timezone</code>. <br>• <code>TasksMaster</code> canonical table (source of truth for task metadata). <br>• <code>AuditLog</code> sheet (append-only) for all events. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Event / Audit vocabulary (canonical)</strong><br><code>fa.reminder.scheduled</code> <br><code>fa.reminder.sent</code> <br><code>fa.reminder.send_failed</code> <br><code>fa.reminder.deferred</code> <br><code>fa.reminder.retry</code> <br><code>fa.reminder.escalation</code> <br><code>fa.reminder.pdf_generated</code> <br><code>fa.reminder.circuit_breaker_tripped</code> <br><code>fa.reminder.audit_export</code> <br><code>fa.templates.imported</code> <br><code>fa.reminder.queue_updated</code> <br>Each event MUST include: <code>eventId</code>, <code>eventType</code>, <code>actorId</code>, <code>timestampUTC</code>, <code>correlationId</code> (optional), <code>detailsJson</code>, <code>reminderId</code> (if applicable), <code>batchId</code> (if applicable), <code>manifestRef</code> (if applicable). </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Top-level public function list (complete)</strong><br>1. <code>SendReminder(taskIds As Variant, ownerId As String, templateId As String, operatorId As String, Optional sendMode As String, Optional correlationId As String) As Variant</code> <br>2. <code>ScheduleReminders(operatorId As String, Optional daysAhead As Integer, Optional scopeFilter As Variant, Optional requireApproval As Boolean) As Variant</code> <br>3. <code>TriggerEscalation(taskId As String, operatorId As String, Optional reason As String, Optional overrideApprovalRef As String) As Variant</code> <br>4. <code>BuildReminderEmailBody(templateId As String, tokenMap As Dictionary, Optional redactPII As Boolean, Optional maxInlineRows As Integer) As Variant</code> <br>5. <code>RenderReminderSummary(taskRows As Variant, Optional maxRows As Integer, Optional includeCsv As Boolean) As Variant</code> <br>6. <code>GroupTasksByOwner(tasks As Variant, Optional maxTasksPerEmail As Integer) As Variant</code> <br>7. <code>ValidateEmailRecipients(recipients As Variant) As Variant</code> <br>8. <code>ThrottleAndSend(payload As Variant, Optional transportMode As String) As Variant</code> <br>9. <code>LogReminderEvent(eventType As String, actorId As String, payloadJson As String, Optional evidenceRefs As Variant, Optional manifestRef As String, Optional reminderId As String, Optional batchId As String) As String</code> <br>10. <code>RetryFailedReminders(operatorId As String, Optional limit As Integer) As Variant</code> <br>11. <code>GenerateReminderReport(startDate As String, endDate As String, Optional groupBy As String) As Variant</code> <br>12. <code>ImportReminderTemplates(jsonPayload As String, operatorId As String) As Variant</code> <br>13. <code>ExportReminderTemplates(outPath As String, operatorId As String) As Variant</code> <br>14. <code>ExportRemindersAuditBundle(runId As String, outPath As String, operatorId As String, Optional signWithKey As String) As Variant</code> </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: SendReminder — exhaustive contract</strong><br><strong>Purpose:</strong> send one reminder batch with deterministic, auditable behavior. <br><strong>Inputs:</strong> <code>taskIds</code> (array), <code>ownerId</code>, <code>templateId</code>, <code>operatorId</code>, <code>sendMode</code> in <code>auto|preview|pdf-only</code>, <code>correlationId</code> optional. <br><strong>Outputs:</strong> structured variant <code>{status:&quot;OK&quot;|&quot;ERROR&quot;|&quot;DEFERRED&quot;, reminderId:GUID|null, eventId:GUID|null, errorCode:String|null, details:String|null}</code>. <br><strong>Preconditions & validations (run in order):</strong> <br>1. Verify all <code>taskIds</code> exist in <code>TasksMaster</code> and are part of <code>RemindersStaging</code> (if not return <code>ERR_TASKS_NOT_IN_SYNC</code> with <code>missingIds</code>). <br>2. Resolve owner metadata via <code>OwnerAssignments</code>; if <code>ownerEmail</code> missing return <code>ERR_OWNER_EMAIL_MISSING</code>. <br>3. Template exists in <code>ReminderTemplates</code>; else <code>ERR_TEMPLATE_NOT_FOUND</code>. <br>4. Check <code>PQ_Issues</code> intersection; if <code>High</code> severity and <code>policySnapshot.blockOnPQIssues = true</code> return <code>ERR_PQ_ISSUES_BLOCKING_SEND</code> with <code>pqIssueRefs</code>. <br>5. Compute <code>reminderId = GenerateGUID()</code> and <code>idempotencyKey = sha256(canonical(ownerId|sorted taskIds|templateId|manifestRefs|canonicalVersion))</code>. <br>6. Build <code>tokenMap</code> by calling <code>RenderReminderSummary</code> which returns HTML and optional CSV. <br>7. Call <code>BuildReminderEmailBody(templateId, tokenMap, redactPII)</code> to get <code>subject</code> and <code>bodyHTML</code>; if <code>WARN_ATTACHMENT_SUPPRESSED</code> returned, include in details. <br>8. Validate recipients via <code>ValidateEmailRecipients</code>; if suppressed or external not allowed, return <code>ERR_RECIPIENT_SUPPRESSED</code> or <code>ERR_EXTERNAL_RECIPIENT_BLOCKED</code>. <br>9. Call <code>ThrottleAndSend(payload)</code> to attempt delivery or queue. <br><strong>Side effects:</strong> write <code>AuditLog</code> event via <code>LogReminderEvent</code> with eventType <code>fa.reminder.sent</code> (on success), or <code>fa.reminder.send_failed</code> / <code>fa.reminder.deferred</code> (on failure/defer). Persist <code>ReminderQueue</code> row when deferred. <br><strong>Idempotency guarantee:</strong> If <code>reminderId</code> previously succeeded, return status <code>OK</code> with <code>eventId</code> pointing to original <code>fa.reminder.sent</code> event. If previous attempt deferred/failed, <code>SendReminder</code> may attempt re-send if <code>operatorId</code> and preconditions allow. <br><strong>Error codes (canonical):</strong> <br><code>ERR_TASKS_NOT_IN_SYNC</code> <br><code>ERR_OWNER_EMAIL_MISSING</code> <br><code>ERR_TEMPLATE_NOT_FOUND</code> <br><code>ERR_PQ_ISSUES_BLOCKING_SEND</code> <br><code>ERR_TEMPLATE_TOKEN_MISSING</code> <br><code>ERR_RECIPIENT_SUPPRESSED</code> <br><code>ERR_EXTERNAL_RECIPIENT_BLOCKED</code> <br><code>ERR_SMTP_TEMP</code> <br><code>ERR_SMTP_PERM</code> <br><code>ERR_RATE_LIMIT_EXCEEDED</code> <br>Each returned error must include <code>auditRef</code> linking to the <code>AuditLog</code> event capturing the failure for forensic trace. <br><strong>Sample narrative:</strong> Operator runs <code>SendReminder([&quot;T-101&quot;,&quot;T-102&quot;], &quot;U-12&quot;, &quot;reminder_14d&quot;, &quot;alice&quot;, &quot;auto&quot;)</code>, receives <code>{status:&quot;OK&quot;, reminderId:&quot;r-111&quot;, eventId:&quot;e-333&quot;}</code>. <code>AuditLog</code> includes <code>fa.reminder.sent</code> linking to <code>reminderId r-111</code> and <code>manifestHash</code> for the included tasks. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: ScheduleReminders — exhaustive contract</strong><br><strong>Purpose:</strong> run bulk cadence evaluation, create batches via <code>GroupTasksByOwner</code>, and orchestrate sends with rate limiting and preview/approval modes. <br><strong>Signature & return:</strong> <code>ScheduleReminders(operatorId, Optional daysAhead, Optional scopeFilter, Optional requireApproval) As Variant</code> returning <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, runId:GUID, prepared:Integer, sent:Integer, deferred:Integer, blocked:Integer, details:Object}</code>. <br><strong>Operational steps (detailed):</strong> <br>1. Validate PQ freshness: if <code>TasksMaster.lastRefreshTs</code> older than <code>policySnapshot.pqStalenessThreshold</code> abort with <code>ERR_PQ_STALE</code>. <br>2. Compute candidate tasks using <code>policySnapshot.reminderCadences</code> or <code>daysAhead</code> override. <br>3. Call <code>GroupTasksByOwner</code> to produce deterministic batches. <br>4. Preflight check: intersect <code>PQ_Issues</code> and mark batches <code>blocked</code> where <code>High</code> severity present (include <code>pqIssueRefs</code> in <code>ScheduleRunReport</code>). <br>5. If <code>requireApproval</code> true or <code>policySnapshot.requireApprovalForAutoSend=true</code>, persist <code>ScheduleRun</code> row with <code>status=&quot;PENDING_APPROVAL&quot;</code>, return <code>ScheduleRunReport</code> for operator approval. <br>6. For auto execution: call <code>SendReminder</code> for each batch respecting <code>policySnapshot.maxEmailsPerHour</code> and chunking; collect results. <br>7. Persist <code>fa.reminder.scheduled</code> audit event with <code>runId</code> and summary. <br><strong>Chunking & rate limit logic:</strong> <br>• If total batches > <code>maxEmailsPerHour</code>, send first chunk up to <code>maxEmailsPerHour</code>, persist subsequent chunks to <code>ReminderQueue</code> with scheduled times and <code>status=&quot;DEFERRED&quot;</code>. <br>• When chunking, create deterministic <code>chunkId = sha256(runId|chunkNumber|canonicalVersion)</code>. <br><strong>Safety rules:</strong> <br>• Never auto-send if any blocked batches exist unless operator explicitly provides <code>force</code> override and records <code>overrideApprovalRef</code> in <code>AuditLog</code>. <br><strong>Return example:</strong> <code>{status:&quot;OK&quot;, runId:&quot;sr-001&quot;, prepared:312, sent:200, deferred:112, blocked:4}</code> with details listing <code>blockedBatchIds</code>. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: TriggerEscalation — exhaustive contract</strong><br><strong>Purpose:</strong> produce an auditable escalation when task exceeds <code>escalationPolicy</code>. <br><strong>Inputs:</strong> <code>taskId</code>, <code>operatorId</code>, optional <code>reason</code>, optional <code>overrideApprovalRef</code>. <br><strong>Behavior & validations:</strong> <br>1. Compute <code>daysOverdue = TodayUTC() - computedDueDate</code>. <br>2. Lookup <code>policySnapshot.escalationPolicy</code> for thresholds by <code>priority</code> and <code>department</code>. <br>3. If <code>daysOverdue</code> < threshold, return <code>ERR_ESCALATION_NOT_REQUIRED</code> with <code>daysOverdue</code>. <br>4. Build escalation payload including <code>taskSummary</code>, <code>missingEvidence</code>, <code>lastReminders</code> (pull from <code>AuditLog</code>), <code>attemptCounts</code>. <br>5. Determine recipients: <code>escalationContactId</code> from <code>OwnerAssignments</code>, department head(s), optionally compliance if <code>gatingCategory = critical</code>. <br>6. If <code>priority = P0</code> and policy requires two approvals for escalations, ensure <code>overrideApprovalRef</code> present or return <code>ERR_OVERRIDE_REQUIRED</code>. <br>7. Call <code>ThrottleAndSend</code> with <code>escalation_template</code>; persist <code>fa.reminder.escalation</code> event and append <code>TaskFlag</code> record <code>escalationFlag=true</code> with <code>escalationTs</code>. <br><strong>Outputs:</strong> <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, escalationId:GUID|null, eventId:GUID|null, details}</code>. <br><strong>Audit & governance:</strong> Escalations must include <code>overrideApprovalRef</code> where applicable and be stored as structured audit fields for legal review. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: BuildReminderEmailBody — template engine</strong><br><strong>Purpose:</strong> deterministic rendering with token validation, PII redaction, and attachment policy enforcement. <br><strong>Inputs:</strong> <code>templateId</code>, <code>tokenMap</code> (dictionary), <code>redactPII</code> boolean, <code>maxInlineRows</code>. <br><strong>Outputs:</strong> <code>{subject:String, bodyHTML:String, attachments:Variant, warnings:Variant}</code>. <br><strong>Rules & validations:</strong> <br>1. Confirm template in <code>ReminderTemplates</code> and that template's <code>allowedTokens</code> match <code>tokenMap</code>. Return <code>ERR_TEMPLATE_TOKEN_MISSING</code> if mismatch. <br>2. Canonicalize token values using <code>modUtils.CanonicalizeText</code>. <br>3. Escape HTML for token values to prevent injection. <br>4. If <code>redactPII</code> true, apply <code>policySnapshot.piiRedactionRules</code> to tokens before substitution. <br>5. If <code>TaskListHTML</code> length > <code>maxInlineRows</code> or <code>policySnapshot.maxInlineTaskChars</code>, truncate and include <code>ManifestLink</code> with <code>manifestHash</code>. Return warning <code>WARN_TASKLIST_TRUNCATED</code>. <br>6. If attachments required but policy forbids, do not attach and return <code>WARN_ATTACHMENT_SUPPRESSED</code>. <br><strong>Determinism:</strong> rendering must be deterministic for identical inputs (canonical whitespace, attribute ordering) to support manifest parity checks. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: RenderReminderSummary — canonical summary</strong><br><strong>Purpose:</strong> produce accessible HTML summary and optional CSV bin for attachments. <br><strong>Inputs:</strong> <code>taskRows</code> array of row objects, <code>maxRows</code> int, <code>includeCsv</code> boolean. <br><strong>Outputs:</strong> <code>{htmlTable:String, csvByteArray:ByteArray|null, rowCount:Int, truncated:Boolean}</code>. <br><strong>Rendering rules & canonical sort order:</strong> <br>1. Sort order: <code>gatingCategory</code> (critical→optional) → <code>priority</code> (P0→P3) → <code>daysToDue</code> ascending → <code>taskId</code> ascending. <br>2. Columns: <code>taskId</code>, <code>taskName</code> (truncate to <code>policySnapshot.emailFieldMaxLen</code>), <code>daysToDue</code>, <code>missingEvidenceSummary</code>, <code>status</code>, <code>quickLink</code> (manifest link containing <code>manifestHash</code> + <code>taskRowChecksum</code>). <br>3. Accessible HTML: use semantic <code>&lt;table&gt;</code> with <code>aria-label</code> including <code>manifestHash</code>. No inline scripts. <br>4. CSV canonical order: <code>taskId,taskName,assignedOwnerId,computedDueDate,evidenceMissing,signOffRequired</code>. <br>5. If <code>rowCount &gt; maxRows</code>, return <code>truncated=true</code> and include final row linking to full manifest with <code>manifestHash</code>. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: GroupTasksByOwner — deterministic grouping</strong><br><strong>Purpose:</strong> produce stable batches per owner suitable for idempotent sends. <br><strong>Inputs:</strong> <code>tasksArray</code>, <code>maxTasksPerEmail</code>. <br><strong>Outputs:</strong> array of batch objects <code>{batchId, ownerId, ownerEmail, taskIds[], taskCount, priorityScore, suggestedTemplateId, preparedTs}</code>. <br><strong>Algorithm (required determinism):</strong> <br>1. Normalize owner key: <code>ownerKey = Canonicalize(ownerId)</code>. <br>2. Sort tasks using <code>RenderReminderSummary</code> order. <br>3. Compute <code>priorityScore</code> = weighted sum: <code>w_gating*gatingScore + w_priority*(4 - priority) + w_overdue*max(0,daysOverdue)</code> where weights come from <code>policySnapshot.batchWeights</code>. <br>4. Split into pages if <code>taskCount &gt; maxTasksPerEmail</code>. <br>5. Compute <code>batchId = sha256(canonicalized(ownerId|sorted taskIds|closeDate|canonicalVersion))</code>. <br>6. Attach aggregated <code>manifestRefs</code> (unique, sorted) and <code>preparedTs</code>. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: ValidateEmailRecipients — suppression & policy checks</strong><br><strong>Purpose:</strong> verify recipients are allowable and not suppressed. <br><strong>Inputs:</strong> <code>recipients</code> array of emails. <br><strong>Outputs:</strong> <code>{validRecipients:[], invalidRecipients:[], suppressedRecipients:[], errors:[]}</code>. <br><strong>Checks & rules:</strong> <br>1. Syntax validation per simplified RFC rules. <br>2. Query <code>SuppressionList</code> and <code>BounceList</code>; mark suppressed addresses. <br>3. If external domains and <code>policySnapshot.externalEmailAllowed=false</code>, return <code>ERR_EXTERNAL_RECIPIENT_BLOCKED</code>. <br>4. If alias detected, resolve to canonical email where possible; if alias resolution fails and <code>policySnapshot.rejectAliases=true</code> return <code>ERR_ALIAS_RESOLUTION_FAILED</code>. <br><strong>Privacy:</strong> Avoid returning full suppressed addresses to logs accessible by non-authorized roles; use hashed addresses in public telemetry. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: ThrottleAndSend — transport & reliability</strong><br><strong>Purpose:</strong> rate limited, idempotent transport with retry/backoff, circuit breaker and pdf fallback. <br><strong>Inputs:</strong> <code>payload</code> {subject, bodyHTML, recipients[], attachments[], reminderId, batchId, manifestRef}, <code>transportMode</code> optional (<code>Outlook|SMTP|pdf-only</code>). <br><strong>Outputs:</strong> <code>{status:&quot;SENT&quot;|&quot;DEFERRED&quot;|&quot;FAILED&quot;, transportId:String|null, retryAt:Timestamp|null, errorCode:String|null, details}</code>. <br><strong>Algorithm & policy enforcement:</strong> <br>1. Sliding window check against <code>policySnapshot.maxEmailsPerHour</code> using <code>Telemetry</code> counters; if exceeding, persist <code>ReminderQueue</code> entry with <code>status=DEFERRED</code> and return <code>DEFERRED</code>. <br>2. If allowed, attempt send via preferred <code>transportMode</code> (Outlook interop first if available and permitted). <br>3. Include <code>X-Reminder-Id: reminderId</code> and <code>List-Unsubscribe</code> header for traceability. <br>4. On transient errors (network timeouts, SMTP 4xx) return <code>ERR_SMTP_TEMP</code> and schedule retry per <code>policySnapshot.retryPolicy</code> (attempts, exponential backoff base seconds, jitter). <br>5. On permanent errors (SMTP 5xx permanent or invalid recipient) return <code>ERR_SMTP_PERM</code> and write permanent failure to <code>ReminderQueue</code> with <code>FAILED_PERMANENT</code>. <br>6. If <code>transportMode=&quot;pdf-only&quot;</code> or circuit breaker tripped, render HTML to PDF and store to <code>ReminderArtifacts</code> folder; return <code>SENT</code> with <code>artifactPath</code>. <br>7. Circuit breaker triggers after <code>policySnapshot.circuitBreakerThreshold</code> consecutive transient fails: write <code>fa.reminder.circuit_breaker_tripped</code>, notify admins, and switch to <code>pdf-only</code> automatically until manual reset. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: LogReminderEvent — audit & telemetry</strong><br><strong>Purpose:</strong> standardize audit log writes and telemetry increments for every modRemind event. <br><strong>Inputs:</strong> <code>eventType</code>, <code>actorId</code>, <code>payloadJson</code>, optional <code>evidenceRefs</code>, <code>manifestRef</code>, <code>reminderId</code>, <code>batchId</code>. <br><strong>Outputs:</strong> <code>eventId</code> GUID. <br><strong>Behavior:</strong> <br>1. Produce <code>eventId</code> and timestamp <code>NowUTC()</code>. <br>2. Append row to <code>AuditLog</code> with structured fields: <code>eventId,eventType,actorId,timestampUTC,correlationId,detailsJson,evidenceRefs,manifestRef,reminderId,batchId</code>. <br>3. Increment <code>Telemetry</code> counters and write <code>telemetryRow</code> for ingestion to external monitoring. <br>4. Return <code>eventId</code> for callers to reference. <br><strong>Schema:</strong> <code>detailsJson</code> must be minimized but include keys: <code>subjectHash</code>, <code>recipientsHash</code>, <code>taskCount</code>, <code>templateId</code>, <code>payloadHash</code>, <code>sendResult</code>. Keep full sensitive details in <code>ReminderArtifacts</code> protected by DMS access; do not embed raw sensitive fields in <code>AuditLog</code>. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: RetryFailedReminders — operator macro</strong><br><strong>Purpose:</strong> reconcile <code>ReminderQueue</code> entries with status <code>DEFERRED</code> or <code>TRANSIENT_FAIL</code> and attempt retries under policy. <br><strong>Inputs:</strong> <code>operatorId</code>, <code>limit</code> optional. <br><strong>Behavior:</strong> <br>1. Acquire workbook-level send lock. <br>2. Query <code>ReminderQueue</code> for <code>status IN (&quot;DEFERRED&quot;,&quot;TRANSIENT_FAIL&quot;)</code> and <code>nextAttemptTs &lt;= NowUTC()</code>, ordered by priority and earliest creation. <br>3. For each entry up to <code>limit</code>, call <code>ThrottleAndSend</code> and update <code>ReminderQueue</code> with new <code>retries</code>, <code>lastAttemptTs</code> and status. <br>4. If retries exceed <code>policySnapshot.retryPolicy.maxAttempts</code>, mark <code>FAILED_PERMANENT</code> and write <code>fa.reminder.send_failed</code>. <br>5. Release lock and return <code>RetryReport</code> with counts and list of remaining deferred entries. <br><strong>Operator guidance:</strong> run in windows consistent with <code>maxEmailsPerHour</code>. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: GenerateReminderReport — BI export</strong><br><strong>Purpose:</strong> produce flattened dataset consumable by Power BI with consistent field names for DAX measures. <br><strong>Inputs:</strong> <code>startDate</code>, <code>endDate</code>, <code>groupBy</code> optional (<code>owner|department|template</code>). <br><strong>Outputs:</strong> CSV/Sheet <code>ReminderEvents</code> including <code>eventId,eventType,reminderId,batchId,ownerId,ownerEmail,taskId,taskCount,actorId,timestampUTC,result,errorCode,manifestRef,templateId</code>. <br><strong>Report slices recommended:</strong> <code>RemindersSentByOwner</code>, <code>PendingReminders</code>, <code>Escalations</code>, <code>RetryPerformance</code>, <code>QueueDepthTimeSeries</code>. Provide <code>runId</code> and <code>ScheduleRun</code> linkage for tracing. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: ImportReminderTemplates / ExportReminderTemplates</strong><br><strong>Import rules:</strong> sanitize HTML, disallow <code>&lt;script&gt;</code>, ensure <code>allowedTokens</code> list only contains permitted tokens, compute <code>templateChecksum</code>, append <code>fa.templates.imported</code>. <br><strong>Export rules:</strong> output JSON containing templates with <code>canonicalVersion</code> and <code>sha256</code> checksum. Maintain template edit history (append only). </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Function: ExportRemindersAuditBundle — forensic export</strong><br><strong>Purpose:</strong> create signed, checksummed forensic bundles containing <code>AuditLog</code> slice, <code>ReminderQueue</code> slice, <code>ReminderArtifacts</code> (PDFs), and <code>ChecklistVersionManifest</code> rows. <br><strong>Inputs:</strong> <code>runId</code>, <code>outPath</code>, <code>operatorId</code>, optional <code>signWithKey</code>. <br><strong>Behavior:</strong> <br>1. Collect <code>AuditLog</code> rows for <code>runId</code> (or date range), referenced manifests and artifacts. <br>2. Create <code>manifest.json</code> enumerating files with <code>sha256</code> checksums. <br>3. Compress to zip and compute <code>sha256:bundleHash</code>. <br>4. Optionally sign the manifest using the provided key or organizational signing service; store signature and <code>signerId</code>. <br>5. Persist bundle to <code>outPath</code> and write <code>fa.reminder.audit_export</code> event with <code>bundleHash</code>. <br><strong>Retention:</strong> preserved per legal retention configuration; label with <code>legalTags</code> if in a legal hold. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Conceptual Power Query orchestration (expanded)</strong><br>Purpose: PQ produces deterministic <code>RemindersStaging</code> which is the canonical input for <code>modRemind</code>; PQ must be the place for heavy canonicalization, fuzzy matching, evidence heuristics, and PQ issues generation. Named PQ steps (recommended): <br>1. <code>Source_Inputs</code>: ingest <code>YearEndTaskTemplate</code>, <code>OwnerAssignments</code>, <code>SupportingDocuments</code>, <code>SignOffEntries</code>, <code>CloseParameters</code>. <br>2. <code>CanonicalizeText</code>: apply NFKC normalization, trim, collapse whitespace, casefold using <code>canonicalVersion</code> rules to create <code>taskNameCanonical</code> and <code>descriptionCanonical</code>. <br>3. <code>Compute_Dates</code>: parse <code>explicitDueDate</code> to <code>YYYY-MM-DD</code>, compute <code>computedDueDate = Date.AddDays(closeDate,-defaultDueOffsetDays)</code> when missing; compute <code>daysToDue</code>. <br>4. <code>Owner_Resolve</code>: join <code>OwnerAssignments</code> and set <code>ownerEmail</code> and <code>ownerDisplayName</code>; emit <code>PQ_Issues</code> where owner missing and suggest fuzzy matches. <br>5. <code>Evidence_Health</code>: join <code>SupportingDocuments</code>, compute <code>evidenceMissing[]</code> by comparing against <code>evidenceRequirements</code>, flag <code>evidenceStatus</code> (valid/unverified/invalid). <br>6. <code>Signoff_Enrich</code>: aggregate <code>SignOffEntries</code> and compute <code>signOffCount</code>, <code>lastSignOffTs</code>, <code>signOffByRoles</code>. <br>7. <code>Reminder_Eligibility</code>: apply <code>policySnapshot.reminderCadences</code> (days→templateId) and gating filters; create <code>reminderCandidate</code> boolean. <br>8. <code>Group_Batches</code>: compute <code>batchPriorityScore</code> and group tasks by owner producing <code>RemindersStaging</code> with canonical <code>batchId</code> computed as <code>sha256(canonical(ownerId|sortedTaskIds|closeDate|canonicalVersion))</code>. <br>9. <code>PQ_Issues</code>: produce structured issues with <code>issueId,issueType,entityRef,severity,details,suggestedAction</code>. <br>Operational notes: PQ must not compute binary file checksums; that is the responsibility of <code>modEvidence</code> due to file system and API access constraints. PQ must record <code>canonicalVersion</code> used for hashing to permit parity replays. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX measures & reporting patterns (expanded)</strong><br>Design guidelines: DAX measures should be built from the <code>ReminderEvents</code> flattened table exported by <code>GenerateReminderReport</code>. Conceptual measures (no code): <br>1. <code>RemindersSent</code> — count of events where <code>eventType = fa.reminder.sent</code>. <br>2. <code>RemindersFailed</code> — count where <code>eventType = fa.reminder.send_failed</code>. <br>3. <code>FailureRate</code> — <code>RemindersFailed / RemindersSent</code> over rolling windows. <br>4. <code>PendingQueueDepth</code> — count of <code>ReminderQueue</code> rows with <code>status IN (&quot;PENDING&quot;,&quot;DEFERRED&quot;)</code>. <br>5. <code>EscalationsIssued</code> — count of <code>fa.reminder.escalation</code>. <br>6. <code>OwnerActionRate</code> — percent of tasks acted on (evidence attached or signoff recorded) within X days after a reminder event. <br>7. <code>AvgTimeToSignoffAfterReminder</code> — average <code>signOffTs - reminderTs</code> for tasks receiving reminders. <br>Use these measures for dashboards: Owner tiles, Operations queue trends, Escalation heatmap, Template effectiveness (action rate by template), Parity tile showing <code>ScheduleRun</code> vs actual sends. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Extended worked examples & edge cases (very detailed)</strong><br>Example 1 — Standard 14-day reminder happy path (long narrative): <br>• PQ sets <code>RemindersStaging</code> batch for owner U-22 with tasks T-101,T-102; <code>suggestedTemplateId=reminder_14d</code>. <br>• Analyst runs <code>ScheduleReminders</code> in preview; <code>GroupTasksByOwner</code> produced <code>batchId=b-abc</code>. <br>• Operator runs <code>SendReminder(b-abc)</code>. <code>SendReminder</code> validates tasks in <code>TasksMaster</code>, resolves owner email, calls <code>RenderReminderSummary</code> to create <code>TaskListHTML</code>, and <code>BuildReminderEmailBody</code> which redacts sensitive fields per policy and produces subject/body. <br>• <code>ThrottleAndSend</code> sends the email via Outlook; <code>LogReminderEvent</code> writes <code>fa.reminder.sent</code> with <code>reminderId=r-1001</code> and <code>eventId=e-1001</code>. <br>• Owner uploads evidence through <code>modEvidence.AttachEvidence</code>; <code>SupportingDocuments</code> row is written with <code>checksum=sha256:...</code> and <code>evidenceStatus=valid</code>. <br>• Approver signs via <code>modSignOff.RecordSignOff</code>. <code>AttemptClose</code> later completes successfully. <br>Example 2 — Heuristic evidence & PQ blocking: <br>• PQ marks evidence as <code>heuristicMatch</code> with <code>confidenceScore=0.63</code> and emits <code>PQ_Issues</code> type <code>HeuristicEvidenceMatch</code> severity Medium. <br>• <code>ScheduleReminders</code> sees <code>High</code> severity PQ issues for some batches and sets them blocked; report returned to analyst. <br>• Analyst resolves by confirming attachments or uploading verified checksums with <code>modEvidence.VerifyEvidence</code>. After PQ refresh the batches are unblocked and <code>SendReminder</code> runs. <br>Example 3 — Rate limit & deferred chunking: <br>• <code>ScheduleReminders</code> prepares 1,200 batches but <code>policySnapshot.maxEmailsPerHour = 200</code>. System slices into 6 chunks. First chunk (200) is sent now; remaining 1,000 persisted to <code>ReminderQueue</code> with scheduled times; <code>fa.reminder.scheduled</code> event references <code>runId</code> and <code>chunkIds</code>. <code>RetryFailedReminders</code> processes subsequent windows. <br>Example 4 — Escalation & override in final close window: <br>• Critical P0 task remains unaddressed day of close. <code>TriggerEscalation</code> called with <code>overrideApprovalRef</code> from manager. System sends escalation to department head and compliance; <code>fa.reminder.escalation</code> appended and <code>TaskFlag</code> recorded. A temporary override is recorded in <code>AuditLog</code> followed by compensating control notes. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Error taxonomy & guidance for operators (exhaustive)</strong><br>1. <code>ERR_TASKS_NOT_IN_SYNC</code> — tasks referenced are missing from <code>TasksMaster</code>. <br>• Cause: stale PQ run or mismatch between <code>RemindersStaging</code> and <code>TasksMaster</code>. <br>• Remediation: refresh PQ, re-run <code>GroupTasksByOwner</code>, reattempt send. <br>2. <code>ERR_OWNER_EMAIL_MISSING</code> — owner record lacks an email. <br>• Remediation: fix <code>OwnerAssignments</code> or contact owner registry; do not manually add emails to <code>RemindersStaging</code>. <br>3. <code>ERR_TEMPLATE_NOT_FOUND</code> — requested template missing. <br>• Remediation: <code>ImportReminderTemplates</code> or select alternative template. <br>4. <code>ERR_PQ_ISSUES_BLOCKING_SEND</code> — PQ issued high severity issues intersecting batch. <br>• Remediation: review <code>PQ_Issues</code>, resolve (e.g., compute checksums, rebind evidence), refresh PQ. <br>5. <code>ERR_RECIPIENT_SUPPRESSED</code> — suppression/bounce present. <br>• Remediation: check bounce logs, request whitelist if necessary. <br>6. <code>ERR_EXTERNAL_RECIPIENT_BLOCKED</code> — policy forbids external sends. <br>• Remediation: set <code>pdf-only</code> or request exception recorded in <code>AuditLog</code>. <br>7. <code>ERR_SMTP_TEMP</code> & <code>ERR_SMTP_PERM</code> — transport errors. <br>• Transient: queued for retry per <code>retryPolicy</code>. <br>• Permanent: manual intervention required; escalate to IT. <br>8. <code>ERR_RATE_LIMIT_EXCEEDED</code> — send would exceed rate; system defers. <br>• Remediation: rely on <code>ReminderQueue</code> processing. <br>9. <code>ERR_TEMPLATE_TOKEN_MISSING</code> — tokens in template not provided. <br>• Remediation: update token map or template. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Testing & QA matrix (exhaustive)</strong><br>Unit tests (small fixtures): <br>1. <code>Canonicalization</code> tests covering Unicode NFKC, whitespace collapse, Turkish dotted/dotless <code>i</code>, bidirectional text examples. <br>2. <code>BatchId</code> parity tests: given identical <code>ownerId|sorted taskIds|closeDate|canonicalVersion</code> produce identical <code>batchId</code> \(sha256 hex\). <br>3. <code>BuildReminderEmailBody</code> token replacement and <code>ERR_TEMPLATE_TOKEN_MISSING</code>. <br>4. <code>RenderReminderSummary</code> sorting and truncation logic. <br>5. <code>ValidateEmailRecipients</code> suppression mapping and alias resolution. <br>Integration tests: <br>1. End-to-end small run: PQ fixture → <code>RemindersStaging</code> → <code>ScheduleReminders</code> preview → <code>SendReminder</code> → <code>fa.reminder.sent</code> presence → <code>modEvidence</code> attach → <code>modSignOff</code> → <code>AttemptClose</code> success. <br>2. Failure path: PQ issues block → remediations via <code>modEvidence.VerifyEvidence</code> → PQ refresh → successful send. <br>3. Rate limit simulation: prepare > <code>maxEmailsPerHour</code> batches and verify chunking behavior and <code>ReminderQueue</code> persistence. <br>Golden parity tests: <br>1. Maintain <code>fixture_small</code>, <code>fixture_mid</code>, <code>fixture_edge</code> containing canonical inputs and expected <code>batchId</code> and <code>reminderId</code> hashes. Nightly parity job recomputes and compares. <br>Performance & concurrency tests: <br>1. PQ refresh time measurement at 500, 2k, 10k tasks scale. <br>2. Send throughput test using <code>ThrottleAndSend</code> mocked transport to validate retry behavior under transient failure rate. <br>Security tests: <br>1. Scan macros for persistence of secrets; ensure no creds stored. <br>2. Template injection tests to ensure sanitized HTML output. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Observability & telemetry (detailed metrics & alerts)</strong><br>Core metrics (time-series): <br>1. <code>reminder.send.attempt</code> (count) <br>2. <code>reminder.send.success</code> (count) <br>3. <code>reminder.send.failure</code> (count) <br>4. <code>reminder.send.deferred</code> (count) <br>5. <code>reminder.queue.length</code> (gauge) <br>6. <code>escalation.count</code> (count) <br>7. <code>avg.send.durationMs</code> (histogram/percentiles) <br>8. <code>retry.successRate</code> (ratio) <br>Suggested alerting thresholds: <br>• Alert A (High): <code>reminder.send.failure</code> rate > 5% over 1 hour. <br>• Alert B (High): <code>reminder.queue.length</code> > 2× normal sustained for 60 minutes. <br>• Alert C (Critical): <code>fa.verify.parity.failed</code> for manifests used in active runs — immediate compliance escalation. <br>Implement <code>Telemetry</code> sheet as timestamped rows exportable to monitoring system for long-term retention. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Security, privacy & compliance controls (prescriptive)</strong><br>1. No credentials in workbook. Use Outlook interop or secret vault. <br>2. PII redaction at rendering time per <code>policySnapshot.piiRedactionRules</code>. <br>3. Use access-controlled manifest links; emails include <code>manifestHash</code> not raw evidence. <br>4. Operator roles defined in <code>Operators</code> sheet; enforce role checks before mutative macros. <br>5. All <code>AuditLog</code> exports and forensic bundles must be signed and checksummed; signatures preserved for legal chain-of-custody. <br>6. Provide legal hold tagging and longer retention storage for bundles under hold. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Retention, legal hold & archival guidance</strong><br>1. Store <code>ChecklistVersionManifest</code>, <code>AuditLog</code> slices and <code>ReminderArtifacts</code> in long-term archive (encrypted at rest) per organizational retention policy. <br>2. Use <code>ExportRemindersAuditBundle</code> to create signed bundles for e-discovery; preserve <code>bundleHash</code> and <code>signerId</code>. <br>3. Mark archival bundles with <code>legalTags</code> and <code>legalHold=true</code> when required; do not delete while on hold. <br>4. Provide a process to produce certified copies of artifacts for regulators with manifest and audit references. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Migration & change governance (templates, cadences, canonicalVersion)</strong><br>1. Any change to canonicalization or <code>batchId</code> recipes requires a <code>migrationManifest</code> capturing <code>changeRationale</code>, <code>canaryPlan</code>, <code>rollbackPlan</code>, <code>fixtures</code> and approvals. <br>2. Canary testing on a non-critical cohort and metrics to watch: <code>ownerActionRate</code>, <code>reminderFailureRate</code>, <code>ScheduleRun</code> parity. <br>3. Do not retroactively change semantics of previously produced manifests; if retroactive policy enforcement required, create <code>PostCloseAdjustment</code> tasks and record everything in <code>AuditLog</code>. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Scaling & server-side migration path</strong><br>For volumes beyond workbook practicality (>10k batches/run) migrate sending to server-side while preserving parity: <br>1. Keep PQ as canonical batch producer; schedule PQ output to central DWH or message queue. <br>2. Implement server <code>SendReminder</code> API that follows identical canonicalization recipes and computes the same <code>batchId</code> and <code>payloadHash</code>. <br>3. Centralize transport, retry and rate limiting on server for performance and observability. <br>4. Ensure audit schema parity: server must write <code>AuditLog</code> events with the same schema and signatures. <br>5. Maintain <code>canonicalVersion</code> field to detect drift and enforce nightly parity checks between workbook and server. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Operator CLI / macro patterns (examples & return structures)</strong><br>• <code>fa.remind.schedule --operator alice --preview</code> → runs <code>ScheduleReminders</code> preview returning <code>ScheduleRunReport</code>. <br>• <code>fa.remind.send --batchId b-abc --operator alice</code> → calls <code>SendReminder</code> and returns <code>{status, reminderId, eventId, details}</code>. <br>• <code>fa.remind.retry --operator ops --limit 200</code> → calls <code>RetryFailedReminders</code> and returns <code>RetryReport</code>. <br>• <code>fa.remind.export --runId sr-001 --outPath C:\exports\sr-001.zip</code> → calls <code>ExportRemindersAuditBundle</code>. <br>Each CLI macro must present structured JSON-like return for automation and write <code>AuditLog</code> rows for each invocation. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Operator runbooks (detailed step-by-step)</strong><br>Pre-send readiness (recommended routine): <br>1. Refresh PQ and review <code>PQ_Issues</code> for high severity. <br>2. Run <code>ScheduleReminders</code> in <code>preview</code> mode. <br>3. Inspect <code>ScheduleRunReport</code>, <code>RemindersStaging</code> rows and sample <code>RenderReminderSummary</code> outputs. <br>4. Resolve <code>PQ_Issues</code> or missing owner email rows; re-run preview. <br>5. Approve schedule (if required) and run <code>ScheduleReminders</code> in <code>auto</code>. <br>6. Monitor <code>Telemetry</code> for anomalies; use <code>RetryFailedReminders</code> when rate windows pass. <br>Emergency escalation runbook: <br>1. Confirm overdue tasks and previous reminder attempts via <code>AuditLog</code>. <br>2. Obtain <code>overrideApprovalRef</code> per policy; record in <code>AuditLog</code>. <br>3. Invoke <code>TriggerEscalation</code> and monitor responses. <br>4. Document remediation in <code>AuditLog</code> and generate forensic bundle using <code>ExportRemindersAuditBundle</code> if required. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Error codes & diagnostics catalog (compact)</strong><br><code>ERR_TASKS_NOT_IN_SYNC</code> — details: <code>missingIds</code> and <code>auditRef</code>. <br><code>ERR_OWNER_EMAIL_MISSING</code> — ownerId and <code>auditRef</code>. <br><code>ERR_TEMPLATE_NOT_FOUND</code> — templateId and <code>auditRef</code>. <br><code>ERR_PQ_ISSUES_BLOCKING_SEND</code> — <code>pqIssueRefs</code>. <br><code>ERR_TEMPLATE_TOKEN_MISSING</code> — token list mismatch and <code>auditRef</code>. <br><code>ERR_RECIPIENT_SUPPRESSED</code> — suppressed list hashed or masked, <code>auditRef</code>. <br><code>ERR_EXTERNAL_RECIPIENT_BLOCKED</code> — domain and <code>policySnapshot</code>. <br><code>ERR_SMTP_TEMP</code> — SMTP error details and <code>retryAt</code>. <br><code>ERR_SMTP_PERM</code> — SMTP permanent failure code with details. <br><code>ERR_RATE_LIMIT_EXCEEDED</code> — scheduled chunk info and next window time. <br><code>ERR_ESCALATION_NOT_REQUIRED</code> — <code>daysOverdue</code> shortfall detail. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Sample fixtures & golden datasets (recommended)</strong><br>Provide three canonical fixtures for CI parity: <br>• <code>fixture_small</code> — 25 tasks covering basic tokens and one blocked PQ issue. Includes expected <code>batchId</code> and sample <code>reminderId</code> checksums. <br>• <code>fixture_mid</code> — 600 tasks across 60 owners, mixed priorities, includes rate limit simulation and heuristic evidence. <br>• <code>fixture_edge</code> — locale edge cases (Turkish, Arabic), long task names, duplicate detection cases, multiple manifest refs per task. <br>Each fixture contains <code>RemindersStaging.csv</code>, <code>ReminderTemplates.json</code>, <code>policySnapshot.json</code> and expected <code>batchId</code>/<code>reminderId</code> checksums for parity tests. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Quality gates & acceptance criteria (must pass)</strong><br>1. PQ deterministic parity tests pass for fixtures — <code>batchId</code> hashes match golden values. <br>2. <code>SendReminder</code> end-to-end produces <code>fa.reminder.sent</code> with <code>reminderId</code> and no duplicates on replay. <br>3. <code>ThrottleAndSend</code> respects <code>maxEmailsPerHour</code> and defers appropriately. <br>4. Circuit breaker logic trips and falls back to <code>pdf-only</code> on sustained transient failures. <br>5. <code>ExportRemindersAuditBundle</code> produces signed bundle verifying <code>sha256</code> manifest included. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Onboarding & training modules (concise)</strong><br>1. Analyst playbook: PQ refresh, inspect <code>PQ_Issues</code>, fix heuristics, <code>RemindersStaging</code> preflight. <br>2. Operator playbook: <code>ScheduleReminders</code> preview, approval, <code>RetryFailedReminders</code>, circuit breaker response. <br>3. Compliance playbook: template governance, override approvals, forensic bundle retrieval. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Governance & change control (must have)</strong><br>• All <code>policySnapshot</code> changes require <code>migrationManifest</code> with approvers and canary plan. <br>• Template changes labeled <code>requiresComplianceReview</code> must be approved by compliance and appended as <code>fa.templates.imported</code> with approver IDs. <br>• Emergency override procedures must be recorded with <code>overrideApprovalRef</code> and compensating control notes. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Implementation checklist for developers (practical)</strong><br>1. Implement PQ <code>RemindersStaging</code> with named steps and <code>canonicalVersion</code> injection. <br>2. Implement <code>modRemind</code> functions in the workbook with robust validation and <code>LogReminderEvent</code> calls at each step. <br>3. Implement <code>ReminderQueue</code> with proper locking semantics and atomic writes (temp file + move pattern). <br>4. Use <code>modUtils.ComputeSHA256</code> for hashes and idempotency keys; ensure UTF-8 canonicalization. <br>5. Build retry/backoff with exponential backoff + jitter and persisted retry counters. <br>6. Implement circuit breaker state machine persisted in <code>SystemState</code> sheet. <br>7. Provide CLI macros with structured JSON returns for automation. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Troubleshooting quick reference (compact)</strong><br>• PQ stale or missing tasks → refresh PQ, inspect <code>PQ_Issues</code>. <br>• Sends failing with SMTP temp errors → check network/outbox, run <code>RetryFailedReminders</code>. <br>• High queue backlog → check <code>maxEmailsPerHour</code>, monitor <code>Telemetry</code>, consider increasing chunk windows or moving to server mode. <br>• Manifest parity mismatch → run parity diff tool, consult <code>AuditLog</code>, export bundle for forensic review. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Long term roadmap & migration notes (concise)</strong><br>• For scale, implement server-side sending and centralized audit store; keep PQ and <code>batchId</code> recipes identical. <br>• Provide API surface for <code>SendReminder</code> and <code>TriggerEscalation</code> with bearer tokens and RBAC. <br>• Offer message queue (Kafka/SQS) to buffer large runs; server workers perform <code>ThrottleAndSend</code>. <br>• Maintain identical <code>AuditLog</code> schema and signing to preserve forensic chain-of-custody. </td></tr><tr><td data-label="modRemind — Per-function Expert Technical Breakdown"> <strong>Final operational admonition (concise)</strong><br><code>modRemind</code> must be conservative, auditable and deterministic. Always source send decisions from PQ <code>RemindersStaging</code>, enforce idempotency with <code>reminderId</code>, log every action in <code>AuditLog</code>, and prefer manifest links over embedded evidence. When in doubt default to preview/dry-run. </td></tr></tbody></table></div><div class="row-count">Rows: 41</div></div><div class="table-caption" id="Table3" data-table="Docu_0189_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modAudit — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modAudit — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Preface & Purpose (largest-scope narrative):</strong> <br> This document is the single authoritative, implementation-level specification for <code>modAudit</code>, the append-only audit, manifest-export and forensic packaging module for Project 062 (Year-End Audit Checklist Generator). It converts high-level policy into operational contracts, deterministic canonicalization recipes, exhaustive function-level API contracts, error taxonomy, telemetry and observability recipes, operator runbooks, testing matrices, conceptual Power Query (PQ) orchestration guidance, conceptual DAX reporting patterns, legal/retention guidance and migration governance. The goal: enable developers, compliance officers and operators to implement <code>modAudit</code> with reproducible, tamper-evident behavior and clear auditability for legal and forensic processes. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Design principles (unified & prescriptive):</strong> <br> 1. Single source of truth: every mutative operation across modules (<code>modChecklist</code>, <code>modEvidence</code>, <code>modSignOff</code>, <code>modGating</code>, <code>modRemind</code>, etc.) MUST call <code>modAudit.AppendAudit</code> with structured <code>detailsJson</code> to produce an authoritative trace. <br> 2. Deterministic canonicalization: canonical text normalization (Unicode NFKC), stable JSON key ordering, precise field ordering for serialization and hashing. Any change to the canonical recipe must be versioned via <code>canonicalVersion</code> and accompanied by a <code>migrationManifest</code>. <br> 3. Append-only semantics: audit rows are logically immutable; corrections are recorded as compensating events linking to the original <code>eventId</code>. <br> 4. Atomic persistence: multi-step operations must commit atomically or produce compensating failure events. <br> 5. Least-privilege & redaction: <code>detailsJson</code> must avoid credentials and gratuitous PII; <code>modAudit</code> applies redaction heuristics and enforces export authorization. <br> 6. Observable & machine-friendly: deterministic error codes, structured results for CLI wrappers, telemetry counters, and parity verification hooks. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>High-level responsibilities (compact):</strong> <br> • Append audit events with deterministic checksums. <br> • Provide read/query APIs and export tooling for forensic bundles. <br> • Run parity verification of persisted checklist manifests. <br> • Support retention, legal-hold, archive and purge workflows. <br> • Emit telemetry and alerts for parity failures, export failures and suspicious patterns. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Primary tables / sheets and canonical columns (explicit):</strong> <br> 1. <code>AuditLog</code> (append-only): fields — <code>canonicalVersion</code>, <code>eventId</code>, <code>eventType</code>, <code>actorId</code>, <code>timestampUTC</code>, <code>correlationId</code>, <code>manifestRef</code>, <code>detailsJson</code>, <code>evidenceRefs</code>, <code>eventRowChecksum</code>, <code>purgedFlag</code>, <code>createdBy</code>, <code>createdTs</code>. <br> 2. <code>AuditIndex</code>: precomputed index of <code>eventType</code>, <code>actorId</code>, <code>manifestRef</code>, <code>timestampUTC</code> for fast queries. <br> 3. <code>AuditExports</code>: registry: <code>exportId</code>, <code>versionId</code>, <code>exportPath</code>, <code>exportHash</code>, <code>signedBy</code>, <code>signedTs</code>, <code>archivedFlag</code>, <code>archivePath</code>, <code>createdTs</code>. <br> 4. <code>AuditArchive</code>: metadata for purged slices. <br> 5. <code>AuditFailureLog</code>: operational failures during append/commit/export. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Canonical serialization & hashing recipe (authoritative):</strong> <br> • Canonical field order for <code>eventRowChecksum</code> serialization: <code>canonicalVersion|eventId|eventType|actorId|timestampUTC|correlationId|manifestRef|detailsJsonCompact|evidenceRefCompact</code>. <br> • <code>CanonicalizeText()</code> from <code>modUtils</code> applies Unicode NFKC normalization, whitespace collapse, trim, replacement of smart-quotes, and removal of control characters prior to serialization for any textual field. <br> • <code>detailsJsonCompact</code> must be compact JSON (no whitespace) with stable key ordering (alphabetical by key) and deterministic array ordering rules: arrays that represent sets must be sorted; arrays that represent ordered sequences must preserve order but document rationale. <br> • Serialize final canonical string as UTF-8 (no BOM); compute SHA256 digest; store as <code>eventRowChecksum = &quot;sha256:&quot; + hexLower(digest)</code>. <br> • Record <code>canonicalVersion</code> on each row to allow retroactive verification after recipe changes. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Atomic append workflow (strict contract):</strong> <br> 1. Acquire append lock (<code>AcquireAppendLock(timeoutMs)</code>) to ensure single-writer safety; lock has configurable timeout and backoff. <br> 2. Validate <code>detailsJson</code> (strict JSON parse). If invalid return <code>ERR_AUDIT_DETAILS_INVALID_JSON</code>. <br> 3. Build <code>rowObj</code> with required fields and <code>timestampUTC = NowUTC()</code>. <br> 4. Canonicalize fields and compute <code>eventRowChecksum</code> using the canonical recipe. <br> 5. Write to <code>AuditLog_Staging</code> (durable staging). <br> 6. Commit staging rows to <code>AuditLog</code> in a single transactional operation (write to <code>AuditLog</code>, update <code>AuditIndex</code>) and <code>Save</code> workbook or perform atomic file move; if commit fails roll back staging and write <code>AuditFailureLog</code> with diagnostics. <br> 7. Release append lock. <br> 8. Append a secondary <code>fa.audit.appended</code> audit event capturing append metadata (actor may be <code>system</code>). </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Public API — exhaustive function-level contracts (detailed):</strong> </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>AppendAudit(eventType As String, actorId As String, detailsJson As String, Optional evidenceRefs As String = &quot;&quot;, Optional manifestRef As String = &quot;&quot;, Optional correlationId As String = &quot;&quot;) As Variant</code></strong> <br> • <strong>Purpose:</strong> single canonical append entry point for all mutative and important non-mutative actions. <br> • <strong>Inputs:</strong> <br> 1. <code>eventType</code> — string with <code>fa.</code> or <code>compensating.</code> prefix. <br> 2. <code>actorId</code> — user/system id. <br> 3. <code>detailsJson</code> — JSON string (structured payload). <br> 4. <code>evidenceRefs</code> — optional JSON array or CSV of evidenceIds. <br> 5. <code>manifestRef</code> — optional versionId. <br> 6. <code>correlationId</code> — optional string linking multi-step operations. <br> • <strong>Returns:</strong> Variant <code>{status:&quot;OK&quot;|&quot;ERROR&quot;,&quot;eventId&quot;:GUID|null,&quot;errorCode&quot;:String|null,&quot;details&quot;:String|null,&quot;auditRowRef&quot;:String|null}</code>. <br> • <strong>Validation rules & error codes:</strong> <br> 1. If <code>eventType</code> invalid (does not match <code>^fa\.[A-Za-z0-9_.-]+$</code> or <code>^compensating\.</code>) → <code>ERR_AUDIT_EVENTTYPE_INVALID</code>. <br> 2. If <code>detailsJson</code> invalid JSON → <code>ERR_AUDIT_DETAILS_INVALID_JSON</code>. <br> 3. If <code>actorId</code> empty and <code>allowSystem=false</code> in config → <code>ERR_AUDIT_ACTOR_MISSING</code>. <br> 4. If append lock cannot be obtained → <code>ERR_AUDIT_LOCKED</code>. <br> 5. If IO commit fails → <code>ERR_AUDIT_IO_FAIL</code>. <br> • <strong>Side-effects:</strong> appends audit row, increments telemetry <code>audit.append.count</code>, writes <code>fa.audit.appended</code> internal marker event. <br> • <strong>Idempotency & duplicates:</strong> Append does not auto-deduplicate; but computes <code>candidateDuplicateChecksum</code> and returns <code>ERR_AUDIT_DUPLICATE_SUSPECT</code> if identical row exists; caller decides to proceed or abort. <br> • <strong>Examples (narrative):</strong> <br> <code>AppendAudit(&quot;fa.checklist.generated&quot;,&quot;alice&quot;,&quot;{\&quot;scope\&quot;:\&quot;Owner:U-123\&quot;,\&quot;taskCount\&quot;:523,\&quot;blockingCount\&quot;:3}&quot;,&quot;[]&quot;,&quot;m-v1-20251228&quot;,&quot;corr-20251228-001&quot;)</code> returns <code>{status:&quot;OK&quot;,eventId:&quot;e-...&quot;}</code> and <code>AuditLog</code> row appended. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>GetAudit(eventId As String, Optional verifyChecksum As Boolean = True) As Variant</code></strong> <br> • <strong>Purpose:</strong> retrieve a single audit row and optionally verify its checksum. <br> • <strong>Returns:</strong> <code>{status:&quot;OK&quot;|&quot;NOT_FOUND&quot;|&quot;ERROR&quot;,&quot;row&quot;:object|null,&quot;errorCode&quot;:String|null}</code>. <br> • <strong>Behavior:</strong> <br> 1. Locate by <code>eventId</code>. If not found return <code>NOT_FOUND</code>. <br> 2. If <code>verifyChecksum=true</code>, recompute canonicalization and compare to stored <code>eventRowChecksum</code>. On mismatch append <code>fa.verify.auditRow.failed</code> and return <code>ERR_AUDIT_CHECKSUM_MISMATCH</code>. <br> 3. Reading does not mutate <code>AuditLog</code>. <br> • <strong>Use cases:</strong> UI detail, forensic verification, automated integrity scans. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>QueryAudits(filterJson As String, Optional pageSize As Long = 250, Optional pageCursor As String = &quot;&quot;) As Variant</code></strong> <br> • <strong>Purpose:</strong> structured query engine for audit rows used by UI and exports. <br> • <strong>Filter language:</strong> JSON with keys <code>eventType</code>, <code>actorId</code>, <code>manifestRef</code>, <code>correlationId</code>, <code>fromTs</code>, <code>toTs</code>, <code>textContains</code> (search <code>detailsJson</code>). Operators: equality, prefix, date-range. <br> • <strong>Returns:</strong> <code>{status:&quot;OK&quot;,&quot;rows&quot;:[...],&quot;nextCursor&quot;:String|null}</code>; rows ordered ascending by <code>timestampUTC</code>. <br> • <strong>Notes:</strong> <code>QueryAudits</code> writes a low-severity <code>fa.audit.query</code> event for trace; avoid high-frequency queries to reduce noise. Page cursor supports stateless pagination. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>ExportAuditManifest(versionId As String, outPath As String, Optional includeEvidenceMetadata As Boolean = False, Optional signWithKey As String = &quot;&quot;) As Variant</code></strong> <br> • <strong>Purpose:</strong> produce a tamper-evident forensic export bundle for a single manifest version for legal e-discovery and archival. <br> • <strong>Inputs:</strong> <code>versionId</code>, <code>outPath</code> (absolute path or allowed archive URI), <code>includeEvidenceMetadata</code> (bool), <code>signWithKey</code> (optional signing key reference). <br> • <strong>Detailed steps and behavior:</strong> <br> 1. Validate <code>versionId</code> exists in <code>ChecklistVersionManifest</code>; if not return <code>ERR_AUDIT_EXPORT_MANIFEST_NOT_FOUND</code>. <br> 2. Query <code>AuditLog</code> rows with <code>manifestRef = versionId</code> OR with <code>correlationId</code> referencing flows tied to <code>versionId</code>. Also include <code>fa.*</code> system events relevant to the manifest. <br> 3. Produce <code>auditSlice.json</code> (compact, stable ordering by <code>timestampUTC</code>). <br> 4. Embed the <code>ChecklistVersionManifest</code> row -> <code>manifest.json</code> and include <code>manifestCanonicalString</code> and <code>manifestHash</code>. <br> 5. If <code>includeEvidenceMetadata=true</code>, join referenced <code>SupportingDocuments</code> metadata rows (metadata only; do NOT include binary files unless explicitly authorized). Require operator authorization; perform ACL checks. <br> 6. Write files to a temp directory then stream compress into <code>temp_export.zip</code> to avoid memory exhaustion. <br> 7. Compute <code>exportHash = sha256:</code> of zip bytes; write <code>export_manifest.json</code> with <code>exportHash</code> and <code>exportMetadata</code>. <br> 8. If <code>signWithKey</code> provided, attempt to sign <code>exportHash</code> with available signing backend; on failure return <code>ERR_AUDIT_EXPORT_SIGN_FAIL</code> and optionally persist unsigned export with <code>signStatus=unavailable</code> after operator confirmation. <br> 9. Move <code>temp_export.zip</code> atomically to <code>outPath</code> and persist an <code>AuditExports</code> record; append <code>fa.audit.exported</code> with <code>exportHash</code> and <code>exportPath</code>. <br> • <strong>Return:</strong> <code>{status:&quot;OK&quot;,&quot;exportPath&quot;:outPath,&quot;exportHash&quot;:exportHash}</code> or error. <br> • <strong>Failure & remediation:</strong> IO errors -> <code>ERR_AUDIT_EXPORT_IO_FAIL</code>; insufficient authorization -> <code>ERR_AUDIT_EXPORT_NOT_AUTHORIZED</code>. <br> • <strong>Security:</strong> if <code>includeEvidenceMetadata=true</code> enforce authorization and log decision in audit event. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>ArchiveAuditBundle(exportId As String, archiveStore As String) As Variant</code></strong> <br> • <strong>Purpose:</strong> copy previously created export to a long-term archive location and verify integrity. <br> • <strong>Behavior:</strong> <br> 1. Lookup <code>AuditExports</code> for <code>exportId</code>; verify file exists and <code>exportHash</code>. <br> 2. Copy export to <code>archiveStore</code> using configured connectors; verify remote file checksum equals <code>exportHash</code>. <br> 3. Update <code>AuditExports.archivePath</code> and <code>archiveTs</code>; append <code>fa.audit.archived</code>. <br> 4. On failure emit <code>fa.audit.archive.fail</code> and return <code>ERR_AUDIT_ARCHIVE_IO_FAIL</code>. <br> • <strong>Notes:</strong> archive stores should be encrypted and access-controlled; retention policy attached to archive entries. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>VerifyManifestParity(versionId As String, Optional allowPqRefresh As Boolean = False) As Variant</code></strong> <br> • <strong>Purpose:</strong> recompute canonical manifest for <code>versionId</code> and compare to persisted <code>manifestHash</code>; core integrity check. <br> • <strong>Steps:</strong> <br> 1. Ensure <code>TasksMaster</code> snapshot is current. If stale and <code>allowPqRefresh=false</code> return <code>ERR_PQ_STALE</code>. If <code>allowPqRefresh=true</code>, call PQ refresh step and ensure success. <br> 2. Obtain the same task subset used to generate the manifest; use <code>ComputeManifestCanonicalString</code> canonicalization routine to produce canonical bytes. <br> 3. Compute <code>actualHash = sha256:</code> canonicalBytes. <br> 4. Compare <code>actualHash</code> with stored <code>manifestHash</code>. <br> • <strong>Outcomes:</strong> <br> 1. If match: append <code>fa.verify.parity.success</code> with <code>taskCount</code> and return <code>{status:&quot;MATCH&quot;,&quot;manifestHash&quot;:actualHash}</code>. <br> 2. If mismatch: run <code>ComputeManifestDiff</code> to produce structured hints (tasks missing, checksum mismatches, ordering changes), append <code>fa.verify.parity.failed</code> with <code>expected</code>, <code>actual</code>, <code>diffReportRef</code> and return <code>{status:&quot;MISMATCH&quot;,&quot;expected&quot;:..., &quot;actual&quot;:..., &quot;diffReportRef&quot;:...}</code>. <br> • <strong>Operational note:</strong> Parity mismatches may indicate data drift, manual edits, or canonicalization recipe changes; open an investigation workflow and preserve forensic bundles immediately. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>ComputeAuditSliceHash(auditRowIds As Variant) As String</code></strong> <br> • <strong>Purpose:</strong> compute deterministic hash over an ordered list of audit rows for cross-system verification and export manifest integrity. <br> • <strong>Recipe:</strong> sort <code>auditRowIds</code> ascending, fetch canonical serialized form per row using row's <code>canonicalVersion</code>, concatenate bytes deterministically, compute <code>sha256:</code> hex lowercase, return string. <br> • <strong>Use cases:</strong> cross-checking exported slices against on-disk bundles, external verification. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>SignAuditExport(exportPath As String, signerKeyRef As String) As Variant</code></strong> <br> • <strong>Purpose:</strong> produce a detached cryptographic signature for an export using available signing backends (certificate store, hardware token, or key file). <br> • <strong>Behavior & constraints:</strong> <br> 1. Validate <code>signerKeyRef</code> available and signer authorized. <br> 2. Compute signature over <code>exportHash</code> or canonical bytes as required by policy. <br> 3. Write <code>exportPath.sig</code> (detached) and append <code>fa.audit.signed</code> with <code>signedBy</code> and <code>signatureRef</code>. <br> 4. On failure return <code>ERR_AUDIT_SIGN_UNAVAILABLE</code> or <code>ERR_AUDIT_SIGN_FAIL</code>. <br> • <strong>Notes:</strong> support multiple algorithms and store <code>signatureMeta.json</code> describing algorithm, signer certificate fingerprint and timestamp. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>PurgeAuditOlderThan(cutoffTs As String, Optional force As Boolean = False, Optional operatorId As String = &quot;&quot;) As Variant</code></strong> <br> • <strong>Purpose:</strong> implement retention policy; default behavior is safe soft-delete with archival; physical deletion allowed only under strict controls. <br> • <strong>Procedure:</strong> <br> 1. List candidate rows <code>timestampUTC &lt; cutoffTs</code> and <code>purgedFlag=false</code>. <br> 2. Check <code>LegalHold</code> table for any references; if any present abort with <code>ERR_AUDIT_LEGAL_HOLD</code> and list <code>legalHoldRefs</code>. <br> 3. For candidate slice, call <code>ExportAuditManifest</code> to create archival bundle and verify exportHash. <br> 4. Mark rows <code>purgedFlag = true</code> and move metadata to <code>AuditArchive</code>. Append <code>fa.audit.purged</code> with <code>purgedCount</code>, <code>cutoffTs</code>, <code>operatorId</code>. <br> 5. If <code>force=true</code> and legal policy grants permission, a physical deletion path may be executed after multi-approver confirmation; append <code>fa.audit.physicalDelete</code> if physical deletion performed. <br> • <strong>Safety:</strong> physical deletion is discouraged; always keep archival bundle. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong><code>GetAuditStats(fromTs As String, toTs As String, Optional granularity As String = &quot;hour&quot;) As Variant</code></strong> <br> • <strong>Purpose:</strong> produce telemetry aggregates for dashboards and alerting. <br> • <strong>Return:</strong> structured object including <code>eventsByType</code>, <code>topActors</code>, <code>eventsPerPeriod</code>, <code>parityFailures</code>. <br> • <strong>Notes:</strong> avoid emitting audit events for stats queries by default unless explicitly requested. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Helper & internal functions (authoritative list):</strong> <br> • <code>ComputeCanonicalAuditRow(rowAsDict As Dictionary) As String</code> — produce canonical serialized string for a row using current recipe and row's <code>canonicalVersion</code>. <br> • <code>ComputeSHA256Bytes(bytes As Variant) As String</code> — wrapper to <code>modUtils.ComputeSHA256</code> ensuring UTF-8 encoding. <br> • <code>AcquireAppendLock(timeoutMs As Long) As Boolean</code> — workbook append lock with retry policy. <br> • <code>ReleaseAppendLock()</code> — release lock. <br> • <code>WriteStagingRow(rowObj As Dictionary) As Boolean</code> — write to staging sheet. <br> • <code>CommitStagingRows()</code> — commit staging rows atomically to <code>AuditLog</code>. <br> • <code>UpdateAuditIndex(rowObj As Dictionary)</code> — update <code>AuditIndex</code>. <br> • <code>ComputeManifestDiff(versionId As String, actualCanonicalString As String) As String</code> — produce structured diff hints for investigators. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Event taxonomy and recommended <code>fa.</code> event types (comprehensive):</strong> <br> Examples of canonical events and recommended <code>detailsJson</code> fields for each: <br> 1. <code>fa.checklist.generated</code> — <code>{&quot;scope&quot;,&quot;taskCount&quot;,&quot;blockingCount&quot;,&quot;notes&quot;}</code>. <br> 2. <code>fa.checklist.pdfExport</code> — <code>{&quot;pdfPath&quot;,&quot;size&quot;,&quot;pageCount&quot;}</code>. <br> 3. <code>fa.checklist.closed</code> — <code>{&quot;closeId&quot;,&quot;closedBy&quot;,&quot;closedTs&quot;}</code>. <br> 4. <code>fa.checklist.closeAttemptBlocked</code> — <code>{&quot;reason&quot;,&quot;blockedTasks&quot;:[{taskId,missingEvidence,missingSignoffs}]}</code>. <br> 5. <code>fa.evidence.attached</code> — <code>{&quot;evidenceId&quot;,&quot;uploaderId&quot;,&quot;uploadedTs&quot;,&quot;checksum&quot;,&quot;url&quot;}</code>. <br> 6. <code>fa.evidence.verified</code> — <code>{&quot;evidenceId&quot;,&quot;verifiedBy&quot;,&quot;verifiedTs&quot;,&quot;checksumMatch&quot;}</code>. <br> 7. <code>fa.signoff.recorded</code> — <code>{&quot;taskId&quot;,&quot;signedBy&quot;,&quot;signedRole&quot;,&quot;signedTs&quot;,&quot;approvalRef&quot;}</code>. <br> 8. <code>fa.audit.exported</code> — <code>{&quot;exportId&quot;,&quot;exportPath&quot;,&quot;exportHash&quot;,&quot;includedEvidenceMeta&quot;}</code>. <br> 9. <code>fa.verify.parity.failed</code> — <code>{&quot;versionId&quot;,&quot;expectedHash&quot;,&quot;actualHash&quot;,&quot;diffReportRef&quot;}</code>. <br> 10. <code>fa.verify.parity.success</code> — <code>{&quot;versionId&quot;,&quot;manifestHash&quot;,&quot;checkedAt&quot;}</code>. <br> 11. <code>fa.audit.purged</code> — <code>{&quot;purgedCount&quot;,&quot;cutoffTs&quot;,&quot;operatorId&quot;,&quot;archiveExportId&quot;}</code>. <br> 12. <code>fa.audit.archived</code> — <code>{&quot;exportId&quot;,&quot;archivePath&quot;,&quot;archiveHash&quot;,&quot;archivedBy&quot;}</code>. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Error codes (exhaustive taxonomy with remediation hints):</strong> <br> • <code>ERR_AUDIT_LOCKED</code> — append lock unavailable; retry with backoff or escalate if persistent.<br> • <code>ERR_AUDIT_DETAILS_INVALID_JSON</code> — detailsJson failed parsing; correct JSON and re-run. <br> • <code>ERR_AUDIT_EVENTTYPE_INVALID</code> — eventType outside allowed namespace; use <code>fa.</code> prefix. <br> • <code>ERR_AUDIT_ACTOR_MISSING</code> — actorId missing; use <code>system</code> for automated flows. <br> • <code>ERR_AUDIT_DUPLICATE_SUSPECT</code> — identical event exists; check <code>candidateDuplicateChecksum</code> and correlationId. <br> • <code>ERR_AUDIT_IO_FAIL</code> — IO or save failure during commit; check disk, permissions, free space. <br> • <code>ERR_AUDIT_EXPORT_MANIFEST_NOT_FOUND</code> — provided versionId not found; check manifest registry. <br> • <code>ERR_AUDIT_EXPORT_IO_FAIL</code> — IO failure creating export; check temp path and permissions. <br> • <code>ERR_AUDIT_EXPORT_SIGN_FAIL</code> — signing failed; check key availability and permissions. <br> • <code>ERR_AUDIT_ARCHIVE_IO_FAIL</code> — archive copy failed; verify network and credentials. <br> • <code>ERR_AUDIT_CHECKSUM_MISMATCH</code> — checksum mismatch during verify; preserve artifacts and launch investigation. <br> • <code>ERR_AUDIT_LEGAL_HOLD</code> — purge blocked by legal hold; list references for compliance. <br> • <code>ERR_PQ_STALE</code> — TasksMaster not up to date; refresh PQ before parity checks. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Concurrency, locking and scaling model (practical):</strong> <br> 1. Single-writer append model: a lightweight in-workbook append lock (<code>AuditLock</code> cell) ensures write atomicity. Batch appends should be performed by a single operator/process or queued via a staging sheet; concurrent writers must retry with exponential backoff. <br> 2. Staging + commit pattern: write to <code>AuditLog_Staging</code> then <code>CommitStagingRows()</code> to move rows in atomic step; reduces partial-commit risk. <br> 3. For high-throughput environments consider moving metadata to a small DWH and exposing a server-side append API preserving canonicalization; retain workbook parity recipes. <br> 4. For large exports (>10k rows) stream to temp zip to avoid OOM and provide progress telemetry. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Operational telemetry & alerts (implementation guidance):</strong> <br> Track metrics on a <code>Telemetry</code> sheet and optionally push to external monitoring: <br> 1. <code>audit.append.count</code> — total appended per day. <br> 2. <code>audit.append.fail.count</code> — failures. <br> 3. <code>audit.export.count</code>, <code>audit.export.fail.count</code>. <br> 4. <code>audit.parity.fail.count</code> — parity mismatches. <br> 5. <code>audit.queue.depth</code> — staging rows pending commit. <br> 6. <code>audit.append.durationMs</code> — histogram. <br> <strong>Alerting thresholds (recommended):</strong> <br> • Immediate alert for <code>audit.parity.fail.count &gt; 0</code> (High). <br> • Alert if <code>audit.append.fail.count</code> spikes > 5% of daily appends (Medium). <br> • Alert if <code>audit.queue.depth</code> > 1000 (Medium). <br> Include correlationId in alerts for investigation continuity. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Security & privacy controls (explicit constraints):</strong> <br> 1. Redaction: remove suspected credentials (strings matching <code>Bearer\s+[A-Za-z0-9\-\._~\+\/]+=*</code>) and long tokens before append; if redaction performed include <code>redactionSummary</code> in <code>detailsJson</code>. <br> 2. No credentials in <code>detailsJson</code>. Use <code>tokenRef</code> to point to secret store if needed. <br> 3. Exports containing evidence metadata require <code>operatorRole=Compliance</code> and explicit approval recorded as <code>fa.audit.exportApproval</code>. <br> 4. Export bundles must be encrypted and signed where policy requires; store signing keys in protected infrastructure. <br> 5. Macro signing and workbook protections recommended for production. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Legal & retention guidance (procedural):</strong> <br> 1. Retention policy: keep <code>AuditLog</code> rows for statutory period (configurable), then archive export bundles to long-term store and mark rows <code>purgedFlag=true</code>. <br> 2. Legal hold: <code>LegalHold</code> table references manifests/evidence; purge operations must check holds and abort if present; record <code>ERR_AUDIT_LEGAL_HOLD</code> with <code>legalHoldRefs</code>. <br> 3. For e-discovery produce forensic bundle via <code>ExportAuditManifest</code> and share only via secured channels; include <code>exportHash</code> and signature metadata. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Migration & canonicalVersion governance (procedural):</strong> <br> 1. Any canonical recipe change requires a <code>migrationManifest</code> describing <code>oldVersion</code>, <code>newVersion</code>, <code>rationale</code>, <code>fixtures</code>, <code>canaryPlan</code> and <code>rollbackPlan</code>. <br> 2. Keep historical <code>canonicalVersion</code> per row to allow verification against the recipe that applied at the time of append. <br> 3. CI must run golden fixtures to ensure new recipe matches expected outputs before rollout. <br> 4. Append <code>fa.audit.migration.start</code> and <code>fa.audit.migration.complete</code> events to record the change and approvals. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Power Query (PQ) integration — conceptual orchestration & pitfalls (no code):</strong> <br> Purpose: enable reporting and dashboarding of <code>AuditLog</code> without transferring authoritative trust from <code>modAudit</code>. PQ patterns and guidance: <br> 1. <strong>Source ingestion:</strong> read <code>AuditLog</code> table as raw; preserve <code>detailsJson</code> string column. <br> 2. <strong>Normalization step:</strong> parse <code>timestampUTC</code> to DateTime (UTC) and preserve <code>timestampRaw</code>. <br> 3. <strong>JSON expansion:</strong> parse <code>detailsJson</code> into structured columns (taskId, evidenceId, manifestRef, reason, etc.) for reporting; keep <code>detailsJsonCompact</code> backup column. <br> 4. <strong>Integrity flags:</strong> PQ cannot compute SHA-256 reliably in a deterministic way across environments; it should surface rows missing <code>eventRowChecksum</code>, <code>canonicalVersion</code> mismatches, or suspicious length anomalies via <code>pqAuditIssues</code>. <br> 5. <strong>Join patterns:</strong> join <code>AuditLog</code> to <code>TasksMaster</code> on <code>manifestRef</code> for manifest-level activity; join on <code>correlationId</code> for end-to-end flow tracing. <br> 6. <strong>Outputs:</strong> produce reporting views <code>AuditActivityByManifest</code>, <code>RecentAuditEvents</code>, <code>ParityIssues</code> and <code>AuditByActor</code>. <br> 7. <strong>Performance:</strong> keep transforms shallow; prefer expanding only fields required for visualization; large <code>detailsJson</code> expansions should be batched. <br> 8. <strong>Security:</strong> PQ views used for distribution must redact sensitive fields consistent with <code>modAudit</code> redaction policy. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX reporting patterns (no snippets, descriptions only):</strong> <br> Design conceptual measures for Power BI reports that compliance/finance teams commonly need: <br> 1. <code>TotalAuditEvents</code> — count of AuditLog rows in selected period; used as a top-line KPI. <br> 2. <code>ParityFailures</code> — count of <code>fa.verify.parity.failed</code> events over trailing windows; alert tile. <br> 3. <code>ExportIntegrityRate</code> — ratio of successful exports (<code>fa.audit.exported</code>) to export attempts (<code>fa.audit.exportAttempt</code>). <br> 4. <code>SignOffLatency</code> — average time between <code>fa.checklist.generated</code> and first <code>fa.signoff.recorded</code> for each manifest; measure owner responsiveness. <br> 5. <code>TopBlockingTasks</code> — aggregated tasks referenced in <code>fa.checklist.closeAttemptBlocked</code> events; use to prioritize remediation. <br> 6. <code>AuditEventsByActor</code> — actor-level distribution; can surface anomalous actor activity. <br> 7. <code>ExportVerification</code> — tile showing <code>exportHash</code> verification status for recent exports. <br> Visualization patterns: timeline of parity failures, heatmap showing blocking tasks by department, drillthrough from manifest tile to <code>auditSlice</code> for forensic review. Ensure dataset includes <code>manifestRef</code>, <code>eventType</code>, <code>actorId</code>, <code>timestampUTC</code> and parsed <code>detailsJson</code> fields for drilling. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Testing & QA matrix (comprehensive):</strong> <br> <strong>Unit tests:</strong> <br> 1. Canonicalization: sample strings across locales including Turkish <code>I</code>/<code>i</code>, Cyrillic, combining marks must produce expected normalized outputs. <br> 2. <code>ComputeSHA256</code> output must match golden hex for known bytes (e.g., canonical string fixtures). <br> 3. JSON validation: <code>AppendAudit</code> rejects malformed JSON and returns <code>ERR_AUDIT_DETAILS_INVALID_JSON</code>. <br> <strong>Integration tests:</strong> <br> 1. End-to-end: <code>GenerateChecklistPDF</code> → <code>AppendAudit</code> → <code>ExportAuditManifest</code> → <code>ArchiveAuditBundle</code> and verify <code>exportHash</code> recomputation. <br> 2. Parity: intentionally change stored manifest and ensure <code>VerifyManifestParity</code> returns <code>MISMATCH</code> and emits <code>fa.verify.parity.failed</code>. <br> 3. Concurrency: simulate concurrent appenders to test <code>AcquireAppendLock</code> and staging commit rollback on failure. <br> <strong>Golden fixtures:</strong> maintain <code>fixture_small</code>, <code>fixture_mid</code>, <code>fixture_edge</code> with expected <code>eventRowChecksum</code> and <code>manifestHash</code>. CI must run fixture parity before merging changes to canonical recipe. <br> <strong>Performance tests:</strong> <br> 1. Export performance for 10k–50k audit rows using streaming compression. <br> 2. Append throughput under batch load (e.g., 500 events/min) with lock contention tests. <br> <strong>Security tests:</strong> ensure <code>detailsJson</code> redaction removes tokens and PII; exports require operator auth for evidence metadata. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Operator runbooks & standard operating procedures (detailed actionable):</strong> <br> <strong>Daily pre-close runbook:</strong> <br> 1. Refresh PQ to update <code>TasksMaster</code> and ensure <code>upToDate=true</code>. <br> 2. Run <code>VerifyManifestParity</code> for active manifests and investigate parity failures. <br> 3. Check telemetry: <code>audit.append.fail.count</code>, <code>audit.parity.fail.count</code>, <code>audit.queue.depth</code>. <br> 4. If <code>parity.fail</code> found, create <code>fa.verify.investigation.started</code> with <code>correlationId</code> and export forensic bundle via <code>ExportAuditManifest</code>. <br> <strong>Export & archive runbook:</strong> <br> 1. Use <code>ExportAuditManifest(versionId,outPath, includeEvidenceMetadata,signKey)</code> to produce export. <br> 2. Verify <code>exportHash</code> using local recompute tool. <br> 3. Call <code>ArchiveAuditBundle(exportId,archiveStore)</code> to push to long-term archive and confirm remote checksum. <br> <strong>Purge & retention runbook:</strong> <br> 1. Query <code>LegalHold</code> and ensure no holds overlap with cutoff. <br> 2. Run <code>ExportAuditManifest</code> for candidate purge slice and store export in secure archive. <br> 3. Call <code>PurgeAuditOlderThan(cutoffTs,operatorId)</code> to soft-delete rows and append <code>fa.audit.purged</code>. <br> 4. If physical deletion required, perform multi-approver sign-off and append <code>fa.audit.physicalDelete</code>. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Examples — long-form worked scenarios (deeply detailed):</strong> <br> <strong>Example A — Critical statutory tax submission (end-to-end):</strong> <br> 1. Template: Task "Finalize statutory tax reconciliation" is <code>gatingCategory=critical</code>, <code>priority=P0</code>, <code>evidenceRequirements=[taxReconciliationPDF,signedManagerApproval]</code>. <br> 2. Operator runs <code>GenerateChecklistPDF</code> which calls <code>AppendAudit(&quot;fa.checklist.generated&quot;,...)</code> and produces <code>ChecklistVersionManifest m-v1-2025</code>. <br> 3. Tax lead attaches <code>taxReconciliation.pdf</code> via <code>modEvidence.AttachEvidence</code> which calls <code>AppendAudit(&quot;fa.evidence.attached&quot;,...)</code>. Evidence includes <code>checksum</code> computed by <code>modUtils.ComputeSHA256</code> and stored. <br> 4. Manager records sign-off via <code>modSignOff.RecordSignOff</code> producing <code>fa.signoff.recorded</code>. <br> 5. <code>AttemptClose</code> validates evidence checksums and sign-offs; on success it appends <code>fa.checklist.closed</code> and <code>AppendAudit(&quot;fa.checklist.closed&quot;,...)</code> persists close event. <br> 6. Compliance exports forensic bundle via <code>ExportAuditManifest(m-v1-2025, outPath, True, &quot;key-ops-1&quot;)</code> → returns <code>exportHash</code> and archive path. <br> 7. For legal record the export is archived and <code>fa.audit.archived</code> appended. <br> <strong>Example B — Physical asset count with photo evidence and heuristics:</strong> <br> 1. Task requires <code>assetCountSheet</code> and <code>photoEvidence</code>. PQ heuristic attaches photos based on filename tokens; PQ emits <code>pqAuditIssues</code> with <code>HeuristicEvidenceMatch</code>. <br> 2. Analyst confirms heuristic matches and <code>modEvidence.AttachEvidence</code> writes <code>fa.evidence.attached</code>. For photo evidence, <code>modEvidence.VerifyEvidence</code> inspects EXIF timestamps and compares to <code>computedDueDate</code>; verification results produce <code>fa.evidence.verified</code>. <br> 3. Two-person approval enforced: <code>modSignOff.RecordSignOff</code> needs <code>owner</code> and <code>inventoryController</code>. Close only allowed when both sign-offs present and evidence verification valid. <br> <strong>Example C — Duplicate detection and merge:</strong> <br> 1. PQ emits <code>PossibleDuplicate</code> for two tasks with <code>similarityScore&gt;0.8</code>. <br> 2. Analyst runs <code>MergeTasks(primaryTaskId, secondaryTaskIds[], operatorId)</code>. <code>modAudit.AppendAudit(&quot;fa.task.merge&quot;,operator, detailsJson)</code> records merge rationale, and <code>modChecklist</code> updates <code>TasksMaster</code> (secondary rows flagged <code>deprecated=true</code>). <br> 3. Evidence and sign-offs re-bound to primary task id; <code>fa.evidence.rebound</code> and <code>fa.signoff.rebound</code> events appended. Historical rows are retained for forensics. <br> <strong>Example D — Emergency override during close window:</strong> <br> 1. Ad-hoc emergency task created with <code>priority=P0</code> and <code>emergency=true</code>. <br> 2. <code>policySnapshot.emergencyRules</code> allow <code>manager</code> override with compensating control. Operator uses <code>AttemptClose</code> with <code>overrideApprovalRef</code> and <code>modAudit.AppendAudit(&quot;fa.checklist.closeOverride&quot;,operator, detailsJson)</code> records <code>overrideReason</code>, <code>approverIds</code> and <code>compensatingControls</code>. <br> 3. Append <code>fa.audit.override</code> and include <code>approvalRef</code> linking to external approval system. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Edge cases & mitigations (thorough):</strong> <br> 1. <strong>Corrupted <code>detailsJson</code>:</strong> <code>AppendAudit</code> refuses append, logs <code>fa.audit.append.fail</code> and returns <code>ERR_AUDIT_DETAILS_INVALID_JSON</code>. Recommend analyst to fix payload and re-run. <br> 2. <strong>Stale PQ on parity check:</strong> <code>VerifyManifestParity</code> returns <code>ERR_PQ_STALE</code>; operator may set <code>allowPqRefresh=true</code> to atomically refresh PQ before parity. If refresh fails, treat as parity failure and escalate. <br> 3. <strong>Append lock starvation:</strong> monitor <code>audit.queue.depth</code> and if lock contention persists, move append traffic to batch staging process controlled by orchestration layer. <br> 4. <strong>Binary evidence inclusion in export:</strong> by default exclude binaries; if binaries required for legal purposes, enforce multi-approver sign-off, limit retention, and store in sealed encrypted container. Append <code>fa.audit.export.withBinaries</code> and record <code>binaryManifest</code> with checksums. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Observability & incident response (procedural):</strong> <br> 1. Parity failure incident response: <br> • Run <code>VerifyManifestParity(versionId)</code> to produce <code>diffReportRef</code>. <br> • Immediately <code>ExportAuditManifest(versionId)</code> to capture current audit slice. <br> • Append <code>fa.verify.investigation.started</code> with <code>correlationId</code>. <br> • Triage: compare <code>actualHash</code> to <code>expectedHash</code> and <code>ComputeManifestDiff</code> hints (task missing, checksum mismatch, ordering). <br> • If tampering suspected, escalate to legal & infra, preserve forensic archive. <br> 2. Export failure incident response: <br> • Inspect <code>AuditFailureLog</code>, check IO/permission issues. <br> • Retry with exponential backoff; if persistent, escalate with <code>fa.audit.export.fail</code> and perform manual secure export. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Operational metrics snapshot example (sample values):</strong> <br> • <code>audit.append.count</code> = 7,432 (last 30d) <br> • <code>audit.append.fail.count</code> = 3 (IO lock) <br> • <code>audit.export.count</code> = 24 <br> • <code>audit.parity.fail.count</code> = 1 <br> • <code>audit.queue.depth</code> = 0 (staging) </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Governance & approvals (procedural):</strong> <br> 1. Changing canonicalVersion requires documented <code>migrationManifest</code> with approvals from engineering, compliance and legal. Append <code>fa.audit.migration.start</code> and <code>fa.audit.migration.complete</code>. <br> 2. Purge operations that perform physical deletion require sign-off from compliance + legal and must be recorded via <code>fa.audit.purgeApproval</code> event. <br> 3. Exporting evidence metadata requires compliance role approval recorded as <code>fa.audit.exportApproval</code>. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Developer guidance (implementation notes):</strong> <br> 1. Use <code>modUtils.ComputeSHA256</code> for all hashing to keep parity across modules. <br> 2. Keep <code>CanonicalizeText()</code> implementation stable; document locale-specific overrides (e.g., Turkish <code>I</code>) in <code>canonicalVersion</code> change log. <br> 3. Implement <code>AppendAudit</code> with robust error handling and deterministic return objects; do not throw unhandled exceptions. <br> 4. Forlong-running runs (export compressions), emit progress events <code>fa.audit.export.progress</code> periodically to support operator monitoring and telemetry. <br> 5. Use atomic file moves (write temp then rename) for export persistence. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>CI / CD test recipe (practical):</strong> <br> 1. Run unit tests for canonicalization and hash outputs for fixture inputs. <br> 2. Execute end-to-end integration for small fixture: generate checklist manifest, append audit events, create export and verify <code>exportHash</code> recomputed matches. <br> 3. Run parity test by modifying manifest bytes to confirm <code>VerifyManifestParity</code> detects mismatch and emits <code>fa.verify.parity.failed</code>. <br> 4. Security static scan: ensure no secrets in code or <code>detailsJson</code> samples. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Acceptance criteria (explicit & testable):</strong> <br> 1. <code>AppendAudit</code> must append valid rows with <code>eventRowChecksum</code> computed using canonical recipe; <code>GetAudit(...,verifyChecksum=True)</code> returns OK. <br> 2. <code>ExportAuditManifest</code> returns zip where recomputed sha256 matches stored <code>exportHash</code>. <br> 3. <code>VerifyManifestParity</code> detects controlled mismatches during test and emits <code>fa.verify.parity.failed</code>. <br> 4. Redaction engine removes credential-like strings before append and records <code>redactionSummary</code>. <br> 5. Operator runbooks exercised and operators trained. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Onboarding & training (succinct curriculum):</strong> <br> 1. Developer onboarding: canonicalization rules, <code>modUtils</code> primitives, unit tests, and migration manifest process. <br> 2. Operator onboarding: running exports, verify <code>exportHash</code>, parity checks, runbooks for parity failures and purge. <br> 3. Compliance onboarding: approval authorities for exports, legal-hold procedures, retention policy. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Appendices — templates, canonical orders, and example payloads (explicit):</strong> <br> Appendix A — <code>AuditLog</code> canonical serialization order (repeat): <code>canonicalVersion|eventId|eventType|actorId|timestampUTC|correlationId|manifestRef|detailsJsonCompact|evidenceRefCompact</code>. <br> Appendix B — Example <code>detailsJson</code> templates: <br> • <code>fa.checklist.generated</code>: <code>{&quot;scope&quot;:&quot;Owner:U-123&quot;,&quot;taskCount&quot;:523,&quot;blockingCount&quot;:3,&quot;notes&quot;:&quot;Pre-close run&quot;}</code>. <br> • <code>fa.evidence.attached</code>: <code>{&quot;evidenceId&quot;:&quot;e-111&quot;,&quot;uploader&quot;:&quot;bob&quot;,&quot;uploadedTs&quot;:&quot;2025-12-28T09:12:00Z&quot;,&quot;checksum&quot;:&quot;sha256:...&quot;,&quot;url&quot;:&quot;sp://...&quot;}</code>. <br> • <code>fa.signoff.recorded</code>: <code>{&quot;taskId&quot;:&quot;T-100&quot;,&quot;signedBy&quot;:&quot;mgr:alice&quot;,&quot;signedRole&quot;:&quot;manager&quot;,&quot;signedTs&quot;:&quot;2025-12-28T10:00:00Z&quot;,&quot;approvalRef&quot;:&quot;appr-321&quot;}</code>. <br> Appendix C — Sample <code>AuditExports</code> registry fields: <code>exportId, versionId, exportPath, exportHash, signedBy, signedTs, archivedFlag, archivePath, createdTs</code>. </td></tr><tr><td data-label="modAudit — Per-function Expert Technical Breakdown"> <strong>Long-form final guidance (single-line operational summary):</strong> <br> <code>modAudit</code> must be implemented as the single, canonical audit ingress/egress for Project 062; ensure durable append-only storage, canonical serialization with versioning, atomic exports with signatures, robust parity verification, explicit retention and legal-hold controls, and end-to-end telemetry and runbooks to preserve forensic integrity and compliance readiness. </td></tr></tbody></table></div><div class="row-count">Rows: 40</div></div><div class="table-caption" id="Table4" data-table="Docu_0189_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modUtils — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modUtils — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Preface & purpose (authoritative):</strong> <br> <code>modUtils</code> is the deterministic primitive layer for Project 062 (Year-End Audit Checklist Generator). It provides canonical, versioned, deterministic primitives used by higher-level modules (<code>modChecklist</code>, <code>modEvidence</code>, <code>modSignOff</code>, <code>modGating</code>, <code>modAudit</code>, <code>modRemind</code>). <code>modUtils</code> responsibilities: canonical text normalization, deterministic UTF-8 encoding, cryptographic hashing for tamper-evidence, canonical row & manifest serialization, deterministic GUID generation, safe streaming file read/write, atomic file persistence, safe workbook lock primitives, small encoding helpers, telemetry hooks and well-defined error codes. <br> The module MUST be the single source of truth for any operation that affects checksums, fingerprinting or canonical bytes used for manifest generation. Changing canonicalization or serialization rules MUST be governed by <code>migrationManifest</code> and canary runs described in governance. This document specifies every public surface in exhaustive detail: contracts, side-effects, error conditions, example usages, integration patterns with Power Query (PQ), conceptual DAX measures that depend on outputs, testing matrices, telemetry, security guidance and operator runbooks. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Design principles & invariants (normative):</strong> <br> 1. <strong>Determinism:</strong> given identical inputs and the same <code>CANONICAL_VERSION</code>, functions return identical outputs across hosts and runs. <br> 2. <strong>Versioned canonical rules:</strong> all canonicalization, escaping and serialization references <code>CANONICAL_VERSION</code>. Any change requires a <code>migrationManifest</code>. <br> 3. <strong>UTF-8 canonical encoding:</strong> all textual inputs are converted to UTF-8 bytes before hashing; byte sequences are canonical input to cryptographic primitives. <br> 4. <strong>Pure primitives where possible:</strong> functions without I/O must be side-effect free. <br> 5. <strong>Minimal I/O surface:</strong> only functions named for I/O perform file or network operations. <br> 6. <strong>Append-only audit:</strong> callers must append audit events for mutative operations; <code>modUtils</code> functions return an <code>auditRef</code> where helpful to correlate. <br> 7. <strong>No secrets stored:</strong> <code>modUtils</code> must never persist credentials or tokens. <br> 8. <strong>Atomic persistence:</strong> any artifact used for legal or audit purposes must be persisted atomically with its <code>manifestHash</code> and <code>ChecklistVersionManifest</code> row. <br> 9. <strong>Observability:</strong> instrument counters and timings for high-value primitives. <br> 10. <strong>Multi-host parity:</strong> when migrating to server-side implementations preserve exact canonicalization, escaping and serialization rules. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Global constants & configuration (normative):</strong> <br> - <code>CANONICAL_VERSION</code> — canonicalization recipe id (string), e.g., <code>&quot;v1&quot;</code>. <br> - <code>HASH_PREFIX</code> — <code>&quot;sha256:&quot;</code>. <br> - <code>DATE_ISO_FORMAT</code> — <code>&quot;YYYY-MM-DD&quot;</code> for <code>computedDueDate</code>. <br> - <code>TIMESTAMP_ISO_FORMAT</code> — <code>&quot;YYYY-MM-DDTHH:MM:SSZ&quot;</code>. <br> - <code>DEFAULT_LOCALE</code> — <code>&quot;en-US&quot;</code>. <br> - <code>TMP_FILE_PREFIX</code> — <code>&quot;ye_tmp_&quot;</code>. <br> - <code>LOCK_EXPIRY_SECONDS</code> — default <code>1800</code> (30 minutes). <br> Any change to these constants requires <code>migrationManifest</code> and recorded approvals. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Canonical error taxonomy (complete, machine-friendly):</strong> <br> <code>ERR_OK</code> — success. <br> <code>ERR_ARG_INVALID</code> — required parameter missing or wrong type. <br> <code>ERR_HASH_FAIL</code> — cryptographic provider failure. <br> <code>ERR_FILE_IO</code> — read/write error. <br> <code>ERR_ENC_FAIL</code> — encoding/decoding failure (UTF-8 errors, invalid hex). <br> <code>ERR_UUID_FAIL</code> — GUID generation failure. <br> <code>ERR_CANONICAL_RULE</code> — canonicalization rule violation or unsupported locale. <br> <code>ERR_LOCK_FAIL</code> — workbook-level lock acquisition failed. <br> <code>ERR_TIMEOUT</code> — operation timed out. <br> <code>ERR_PERMISSION</code> — permission denied for file or system operation. <br> All error returns must include <code>errorCode</code>, human-readable <code>message</code>, <code>details</code> (structured), and if applicable an <code>auditRef</code> string linking to the <code>AuditLog</code> event. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Telemetry keys (recommended):</strong> <br> <code>modutils.hash.calls</code> <br> <code>modutils.hash.failures</code> <br> <code>modutils.hash.timeMs.p50|p95|p99</code> <br> <code>modutils.canonicalize.calls</code> <br> <code>modutils.canonicalize.timeMs.p50|p95</code> <br> <code>modutils.file.reads</code> <br> <code>modutils.file.writes</code> <br> <code>modutils.lock.acquire.count</code> <br> <code>modutils.lock.acquire.failures</code> <br> Telemetry is appended to a <code>Telemetry</code> sheet or exported nightly to a monitoring sink; telemetry must never include PII. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Security & privacy posture (normative):</strong> <br> 1. <code>modUtils</code> must not store authentication tokens or credentials. <br> 2. Hashes are tamper-evidence only, not proof of authenticity. For non-repudiation integrate with enterprise signing services. <br> 3. Evidence content remains in the DMS; <code>modUtils</code> may compute checksums on local or staged copies only if permitted by policy. <br> 4. When writing temporary files use restrictive ACLs when host supports them. <br> 5. Provide <code>redactionMode</code> hooks for PDF export orchestration (implemented by <code>modChecklist</code>) — <code>modUtils</code> provides the canonical bytes and escaping but redaction decisions occur at higher layers. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Overview: improvements to function-level explanations (what follows):</strong> <br> Each function block below contains: <br> • Purpose and high-level intent. <br> • Canonical contract: inputs, outputs, optional parameters. <br> • Deterministic rules & canonical recipe steps. <br> • Preconditions, validations and explicit error returns. <br> • Postconditions and invariants. <br> • Side-effects and audit integration guidance. <br> • Concurrency and locking guidance where relevant. <br> • Performance characteristics and resource recommendations. <br> • Security notes and access control considerations. <br> • Observability and telemetry guidance. <br> • Practical examples, unit & integration test cases, and recommended golden fixtures. <br> All numbered lists below use explicit <code>&lt;br&gt;</code> line breaks as requested. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: ComputeSHA256 — contract & exhaustive explanation:</strong> <br> <strong>Purpose & intent:</strong> compute a deterministic SHA-256 digest for strings or raw bytes used for tamper-evidence on tasks, evidence and manifests. Provide consistent formatting <code>&quot;sha256:&lt;hex&gt;&quot;</code> across all consumers. Designed to be pure and side-effect free. <br> <strong>Canonical contract (inputs):</strong> <br> • <code>input</code>: String or Byte array. <br> • <code>canonicalVersion</code> optional (default <code>CANONICAL_VERSION</code>) used to record provenance in <code>details</code>. <br> <strong>Canonical contract (outputs):</strong> <br> Returns an object: <code>{ status: &quot;OK&quot; | &quot;ERROR&quot;, hash: &quot;sha256:&lt;hex&gt;&quot; | null, errorCode: string | null, details: { inputLength: integer, canonicalVersion: string, algorithm: &quot;SHA-256&quot;, timestampUTC: string, notes?: string } }</code>. <br> <strong>Deterministic recipe & byte-encoding rules:</strong> <br> 1. If <code>input</code> is String: normalize line endings to LF, apply no other transformations, and encode bytes using a deterministic UTF-8 encoder that performs NFKC normalization only where callers explicitly request it; <code>ComputeSHA256</code> is not permitted to alter the input except for deterministic UTF-8 encoding. <br> 2. If <code>input</code> is Byte array, use bytes exactly as provided. <br> 3. Compute SHA-256 over the entire byte sequence and return lower-case hex prefixed by <code>sha256:</code>. <br> <strong>Preconditions & validation:</strong> <br> • If <code>input</code> omitted or Null → return <code>ERR_ARG_INVALID</code>. <br> • If <code>input</code> is string and UTF-8 conversion fails → return <code>ERR_ENC_FAIL</code>. <br> <strong>Postconditions & invariants:</strong> <br> • <code>hash</code> is deterministic and stable for identical byte sequences. <br> • <code>details.inputLength</code> equals counted bytes after UTF-8 conversion. <br> <strong>Side-effects:</strong> none. <br> <strong>Audit integration guidance:</strong> callers should append <code>AuditLog</code> entries for operations that rely on <code>ComputeSHA256</code> for legal artifacts (e.g., manifest generation), referencing the returned <code>hash</code> in the <code>details</code>. <br> <strong>Concurrency & thread-safety:</strong> stateless; safe for concurrent callers. <br> <strong>Performance characteristics:</strong> O(n) time in number of bytes; memory proportional to input only if a single-buffer implementation used. For large inputs callers should use <code>ComputeSHA256File</code> instead. <br> <strong>Security & platform notes:</strong> use well-tested cryptographic provider (Windows CryptoAPI, BouncyCastle on server) with stable outputs; avoid homegrown hash implementations unless thoroughly tested. <br> <strong>Telemetry:</strong> increment <code>modutils.hash.calls</code>; on error increment <code>modutils.hash.failures</code>. <br> <strong>Examples:</strong> <br> • <code>ComputeSHA256(&quot;&quot;)</code> -> <code>sha256:e3b0c44298fc1c149...</code> (standard empty string vector). <br> • <code>ComputeSHA256(&quot;abc&quot;)</code> -> standard vector. <br> <strong>Unit tests & vectors:</strong> include empty string, "abc", multi-byte Unicode string containing emoji and astral plane characters, and a binary file fixture. Validate hex value against external sha256 tool. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: ComputeSHA256File — streaming file hashing (exhaustive):</strong> <br> <strong>Purpose & intent:</strong> efficiently compute <code>sha256:</code> for files of arbitrary size without loading the entire file into memory. Used for evidence binary validation and large manifest payload verification when stored in a file. <br> <strong>Canonical contract (inputs):</strong> <br> • <code>filePath</code> — absolute or relative path to file. <br> • <code>chunkSize</code> optional — integer bytes per read (recommended default 8192). <br> • <code>canonicalVersion</code> optional for provenance. <br> <strong>Outputs:</strong> <code>{ status, hash, fileSize, readTimeMs, errorCode, details }</code> where <code>hash</code> is <code>sha256:...</code>. <br> <strong>Deterministic recipe & rules:</strong> <br> 1. Open file in binary mode; read sequentially in <code>chunkSize</code> increments; feed into SHA-256 update operation; finalize to produce digest. <br> 2. Ensure consistent binary read ordering and no additional bytes appended or trimmed by the reading layer (no BOM insertion or encoding guards). <br> <strong>Preconditions & validation:</strong> <br> • If file not found or not readable → return <code>ERR_FILE_IO</code> with underlying OS error in <code>details</code>. <br> • If <code>chunkSize</code> <= 0 or > 16MB → return <code>ERR_ARG_INVALID</code>. <br> <strong>Postconditions & invariants:</strong> <br> • <code>hash</code> equals the digest of the file's raw bytes; <code>fileSize</code> equals total bytes read. <br> <strong>Side-effects:</strong> none. <br> <strong>Concurrency & file-lock considerations:</strong> <br> • If file may be concurrently written to, callers must obtain a stable read snapshot or copy to staging before calling <code>ComputeSHA256File</code>. If platform provides file locks, attempt a read-lock; if unavailable, document risk of transient mismatch. <br> <strong>Performance:</strong> streaming O(n); chunk size tuned to host I/O buffer size. For high-throughput servers consider 64KB or 256KB chunk sizes; for Excel VBA keep chunk sizes small (8KB) to avoid memory pressure in 32-bit hosts. <br> <strong>Security:</strong> never pass untrusted path strings that could exploit traversal vulnerabilities; validate allowed directories. <br> <strong>Observability:</strong> record <code>modutils.file.reads</code> and per-call <code>readTimeMs</code> in telemetry. <br> <strong>Examples:</strong> compute checksums for local evidence copies before persisting metadata. <br> <strong>Test cases:</strong> read a 500MB file and verify hash equals external sha256, test permission denied and missing file cases. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: HexEncode & HexDecode (detailed):</strong> <br> <strong>Purpose & intent:</strong> deterministic conversion between byte arrays and lowercase hex strings used by hashing and GUID functions. Provide robust validation and consistent formatting. <br> <strong>Contracts:</strong> <br> • <code>HexEncode(bytes) -&gt; {status, hex, details}</code>. <br> • <code>HexDecode(hexString) -&gt; {status, bytes, errorCode, details}</code>. <br> <strong>Behavioral rules:</strong> <br> 1. <code>HexEncode</code> returns lowercase hex characters without any <code>0x</code> prefix or separators. <br> 2. <code>HexDecode</code> accepts uppercase or lowercase hex; validates even-length and hex characters only. <br> <strong>Errors:</strong> <code>ERR_ENC_FAIL</code> on malformed input. <br> <strong>Side-effects:</strong> none. <br> <strong>Security:</strong> ensure decoded bytes length within anticipated bounds before using as inputs to cryptographic functions. <br> <strong>Testing:</strong> round-trip encode/decode for several byte arrays, including empty array. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: CanonicalizeText — expanded, explicit recipe and edge-cases:</strong> <br> <strong>Purpose & intent:</strong> produce authoritative canonical textual form used for deduplication, canonical row serialization and user-visible comparators. This is the single authoritative textual normalization routine. It is used by <code>ComputeRowChecksum</code> and callers MUST not implement ad-hoc variants. <br> <strong>Inputs:</strong> <br> • <code>inputText</code> — raw string. <br> • <code>locale</code> optional (<code>DEFAULT_LOCALE</code> by default). <br> • <code>options</code> optional dictionary: <code>{ preserveLineBreaks: bool = False, stripDiacritics: bool = False, mapSmartQuotes: bool = True, removeControlChars: bool = True }</code>. <br> <strong>Outputs:</strong> <code>{status, canonical, changedSteps: [list], originalLength, canonicalLength, canonicalVersion, errorCode, details}</code>. <br> <strong>Full canonical pipeline (apply in this strict order — each step recorded):</strong> <br> 1. <strong>NFKC normalization</strong> — apply Unicode compatibility decomposition plus recomposition to produce stable decomposed/composed forms for characters and ligatures. <br> 2. <strong>Line break normalization</strong> — convert CRLF and CR to LF (<code>\n</code>). <br> 3. <strong>Control character removal</strong> — remove U+0000–U+001F and U+007F–U+009F except optionally preserve LF if <code>preserveLineBreaks=True</code>. <br> 4. <strong>Smart quote & ligature mapping</strong> — replace <code>“</code>/<code>”</code>/<code>„</code> -> <code>&quot;</code>; <code>‘</code>/<code>’</code> -> <code>&#x27;</code>; <code>ﬁ</code>, <code>ﬂ</code> -> <code>fi</code>, <code>fl</code> respectively; mapping table versioned by <code>CANONICAL_VERSION</code>. <br> 5. <strong>Trim outer whitespace</strong> — remove leading/trailing spaces, tabs, NBSP. <br> 6. <strong>Collapse internal whitespace</strong> — sequences of space/tab/NBSP collapse to a single ASCII space U+0020; if <code>preserveLineBreaks=True</code>, preserve a single LF while collapsing additional LFs and other whitespace segments. <br> 7. <strong>Locale-aware full casefold</strong> — apply Unicode full casefolding (not simple <code>.ToLower</code>) to ensure case-insensitive canonical comparisons; if <code>locale</code> is <code>tr-TR</code> or <code>az-AZ</code>, apply special dotted/dotless <code>I</code> rules. <br> 8. <strong>Optional diacritic removal</strong> — if <code>stripDiacritics=True</code>, remove combining diacritics using canonical decomposition + removal of combining marks. <br> 9. <strong>Punctuation normalization</strong> — consecutive punctuation sequences are normalized according to <code>CANONICAL_VERSION</code> rules (e.g., collapse repeated punctuation to single token if so configured). <br> 10. <strong>Final validation</strong> — ensure result length < host limits and return. <br> <strong>Preconditions & validations:</strong> <br> • Null/empty inputs allowed; return empty canonical string with <code>status: OK</code>. <br> • Unknown locale → <code>ERR_CANONICAL_RULE</code>. <br> <strong>Postconditions:</strong> <br> • <code>canonical</code> is stable across runs given same <code>CANONICAL_VERSION</code>. <br> <strong>Edge-case behaviors and specifics:</strong> <br> • Combining characters (e.g., a + accent) must be normalized to composed or decomposed form consistently (NFKC chosen for compatibility). <br> • Emoji sequences and ZWJ sequences preserved; do not strip emoji. <br> • Complex scripts: do not attempt language-specific transliteration; leave script-specific forms intact except for casefolding where applicable. <br> • Nonprinting controls removed except stable explicit tokens (LF preserved if requested). <br> <strong>Concurrency & performance:</strong> vectorize in PQ for bulk rows; <code>modUtils</code> used for single-value canonicalization where exact parity required. <br> <strong>Security:</strong> be careful when canonicalizing user input used in file paths — canonicalization may change file names; validate path handling separately. <br> <strong>Observability:</strong> increment <code>modutils.canonicalize.calls</code> and record <code>timeMs</code>. <br> <strong>Examples & tests:</strong> <br> • <code>&quot;Résumé – Final  &quot;</code> -> canonical <code>&quot;résumé - final&quot;</code> with <code>stripDiacritics=false</code>. <br> • Turkish <code>&quot;I&quot;</code> -> with <code>locale=tr-TR</code> casefold -> <code>&quot;ı&quot;</code> or <code>&quot;i&quot;</code> per dotted/dotless rules; include explicit unit test. <br> • Strings containing <code>\r\n</code> result in <code>\n</code> only. <br> <strong>Interoperability note:</strong> PQ and server-side canonicalization must implement identical pipeline; include <code>CANONICAL_VERSION</code> to detect drift. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: NormalizeWhitespace (helper) — explicit behavior and edge-cases:</strong> <br> <strong>Purpose:</strong> focused whitespace normalizer; used inside canonicalization and escaping when generating human-readable strings or canonical fields. <br> <strong>Inputs:</strong> <code>inputText</code> and <code>preserveLineBreaks</code> boolean. <br> <strong>Outputs:</strong> <code>{status, normalized, details}</code>. <br> <strong>Rules:</strong> trim outer whitespace; collapse internal whitespace sequences to single ASCII space; if <code>preserveLineBreaks=True</code> then collapse multiple LF to single LF and preserve single LF tokens between lines while collapsing other whitespace to spaces. <br> <strong>Edge-cases:</strong> preserve NBSP inside words when needed? By default convert NBSP to space to avoid visual differences. <br> <strong>Testing:</strong> sequences with mixture of tabs, form feeds. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: EscapeForManifest (complete):</strong> <br> <strong>Purpose & intent:</strong> deterministic reversible escaping of field values to ensure manifest canonical string is unambiguous and reversible by a forensic tool. Escape rules are minimal and versioned by <code>CANONICAL_VERSION</code>. <br> <strong>Inputs:</strong> <code>inputText</code> and optional <code>escapeMap</code> allowing extension. <br> <strong>Outputs:</strong> <code>{status, escaped, details}</code>. <br> <strong>Canonical escaping map (default):</strong> <br> • <code>\</code> -> <code>\\</code> <br> • <code>|</code> -> <code>\|</code> <br> • <code>\n</code> -> <code>\\n</code> <br> Additional escapes are permitted but must be recorded in <code>CANONICAL_VERSION</code> migration manifest. <br> <strong>Preconditions:</strong> input can be empty. <br> <strong>Reversibility:</strong> escaping must be reversible by <code>UnescapeFromManifest</code> using the same escape map; implementers should provide a matching unescape helper in the toolset. <br> <strong>Edge-cases:</strong> inputs containing backslash sequences like <code>\n</code> (two chars) must be unambiguously escaped and unescaped. <br> <strong>Security considerations:</strong> do not perform de-escaping on untrusted data without validation when the result is used to access file paths or run OS commands. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: ComputeRowChecksum — exhaustive contract and recipe:</strong> <br> <strong>Purpose & intent:</strong> compute canonical checksum for a structured row using a strict field order; returns canonical string and <code>sha256:</code> checksum. This function is the canonical per-row hashing routine used by <code>TasksMaster</code> rows and other entities; it must be the only routine used to compute those checksums. <br> <strong>Inputs:</strong> <br> • <code>fieldDict</code> — map of fieldName->value. <br> • <code>fieldOrder</code> — ordered array specifying serialization order. <br> • Optional <code>canonicalVersion</code>. <br> <strong>Outputs:</strong> <code>{status, checksum, canonicalString, bytesLength, details}</code> where <code>checksum</code> is <code>sha256:...</code> and <code>canonicalString</code> is the exact string used for hashing. <br> <strong>Canonical recipe (strict):</strong> <br> 1. Validate that <code>fieldOrder</code> contains the canonical field names defined in Appendix and that required fields are present. Missing required -> <code>ERR_ARG_INVALID</code>. <br> 2. For each <code>fieldName</code> in <code>fieldOrder</code>: <br> a. Convert <code>fieldValue</code> to string according to host rules (Dates -> <code>DATE_ISO_FORMAT</code>, Booleans -> <code>&quot;true&quot;/&quot;false&quot;</code>, Null -> <code>&quot;&quot;</code>). <br> b. Call <code>CanonicalizeText(value, preserveLineBreaks=False)</code> for textual fields. <br> c. Call <code>EscapeForManifest</code> on the canonicalized string. <br> d. Append <code>fieldName=valueEscaped</code> to a buffer separated by pipe <code>|</code>. <br> 3. After iteration, produce <code>canonicalString</code> (no trailing whitespace, no trailing newline) and convert to UTF-8 bytes. <br> 4. Call <code>ComputeSHA256</code> on bytes to produce <code>checksum</code>. <br> <strong>Preconditions & validation:</strong> <br> • Field types must be coerced to canonical forms before canonicalization; date parsing errors -> <code>ERR_ARG_INVALID</code>. <br> <strong>Postconditions & invariants:</strong> <br> • <code>canonicalString</code> contains <code>canonicalVersion</code> as the first token when included in <code>fieldOrder</code>. <br> • For identical <code>fieldDict</code> and <code>fieldOrder</code> under same canonicalVersion, <code>checksum</code> stable. <br> <strong>Side-effects:</strong> none; however caller should append <code>AuditLog</code> entries if the checksum is used in legal artifacts. <br> <strong>Concurrency:</strong> stateless and safe for concurrent runs. <br> <strong>Performance:</strong> O(sum(length(fields))). For large text fields avoid repeated canonicalizations; cache where safe. <br> <strong>Observability:</strong> report <code>modutils.canonicalize.calls</code> and <code>modutils.hash.calls</code> as appropriate. <br> <strong>Examples:</strong> <br> • For task row: fieldOrder must be exactly <code>canonicalVersion|taskId|taskName|assignedOwnerId|gatingCategory|computedDueDate|signoffRequired</code>. Provide unit tests that assert canonicalString equals expected string for golden row. <br> <strong>Test cases:</strong> missing fields, date parsing errors, control characters in <code>taskName</code>, long text fields and diacritics handling. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: ComputeManifestCanonicalString — exhaustive contract & recipe:</strong> <br> <strong>Purpose & intent:</strong> create the exact canonical UTF-8 string for a manifest. This string is hashed into <code>manifestHash</code>. It is the top-level artifact for legal and forensic uses and must be byte-for-byte reproducible. <br> <strong>Inputs:</strong> <code>manifestMeta</code> map (must include <code>versionId</code>, <code>generatedBy</code>, <code>generatedTs</code>, <code>scope</code>, <code>canonicalVersion</code>), <code>orderedTaskChecksums</code> array of <code>sha256:</code> strings, optional <code>notes</code>. <br> <strong>Outputs:</strong> <code>{status, canonicalString, bytesLength, details}</code>. <br> <strong>Canonical recipe & deterministic rules:</strong> <br> 1. Validate <code>manifestMeta</code> required fields present; missing -> <code>ERR_ARG_INVALID</code>. <br> 2. Escape textual fields in <code>manifestMeta</code> using <code>EscapeForManifest</code>. <br> 3. Construct the top-level canonical string in exact order: <code>canonicalVersion|versionId|generatedBy|generatedTs|scope|taskCount|blockingCount|&lt;each taskRowChecksum appended in array order&gt;|notes</code> where <code>taskCount</code> is integer and <code>blockingCount</code> computed from the snapshot used. <br> 4. Do not append a trailing newline. <br> 5. Return canonicalString and bytesLength. <br> <strong>Rationale for using <code>taskRowChecksum</code>:</strong> decouples task-level canonicalization from manifest-level assembly and keeps manifest compact while forcing each task row to be auditable independently. <br> <strong>Preconditions:</strong> <code>orderedTaskChecksums</code> must be precomputed by <code>ComputeRowChecksum</code> and should be stable; invalid checksum strings cause <code>ERR_ARG_INVALID</code>. <br> <strong>Postconditions/invariants:</strong> canonicalString reproducible; any change to canonical rules requires <code>migrationManifest</code>. <br> <strong>Side-effects:</strong> none. <br> <strong>Performance & memory:</strong> manifest string size approx sum of checksums + meta; for very large manifests keep canonical bytes streaming-compatible if needed. <br> <strong>Testing:</strong> golden manifest fixtures for small/mid/edge. <br> <strong>Examples:</strong> produce <code>manifestHash</code> by passing canonicalString to <code>ComputeSHA256</code>. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: ComputeManifestHash (wrapper) — transactional guidance:</strong> <br> <strong>Purpose:</strong> convenience wrapper which computes <code>manifestHash</code> by calling <code>ComputeManifestCanonicalString</code> then <code>ComputeSHA256</code>. Additionally returns metadata useful for atomic persistence workflows. <br> <strong>Inputs/Outputs:</strong> pass through manifests; returns <code>{status, manifestHash, canonicalStringSize, details}</code>. <br> <strong>Transactional steps recommended for callers:</strong> <br> 1. Acquire workbook lock / operator lock. <br> 2. Generate canonicalString and compute <code>manifestHash</code>. <br> 3. Write PDF artifact using <code>WriteAtomicFile</code> to <code>pdfPath</code> and verify success. <br> 4. Persist <code>ChecklistVersionManifest</code> row in workbook/table atomically (write staging then commit). <br> 5. Append <code>fa.checklist.generated</code> <code>AuditLog</code> entry with <code>manifestHash</code>, <code>versionId</code> and operator. <br> Failure to perform atomic write order may produce inconsistent state — <code>modUtils</code> does not automatically persist manifest rows. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: GenerateGUID & GenerateDeterministicGUID — exhaustive:</strong> <br> <strong>Purpose:</strong> produce RFC-4122 style GUIDs for stable identifiers. Provide both random and deterministic GUID generation with explicit provenance for imports. <br> <strong>GenerateGUID():</strong> <br> • Outputs: <code>{status, guid, details}</code> where <code>guid</code> is lower-case canonical RFC-4122 v4 string. <br> • Preconditions: platform RNG available. <br> • Errors: <code>ERR_UUID_FAIL</code> if RNG unavailable. <br> <strong>GenerateDeterministicGUID(seed, canonicalVersion=CANONICAL_VERSION):</strong> <br> • Purpose: produce reproducible IDs for imports and mapping of external row keys. <br> • Deterministic recipe: compute <code>ComputeSHA256(seed || canonicalVersion)</code> producing 32 bytes, map first 16 bytes to GUID fields, set version nibble to 4 and variant bits per RFC-4122, format lower-case. Return <code>seedHashSnippet</code> (first 8 hex) in <code>details</code>. <br> <strong>Preconditions & validations:</strong> <code>seed</code> must be non-empty string. <br> <strong>Side-effects:</strong> none but callers must record <code>seed</code> provenance in <code>AuditLog</code> when used for production import. <br> <strong>Concurrency & collisions:</strong> deterministic algorithm is collision-resistant given SHA-256, but seeds must be unique for desired stable mapping; include collision check in acceptance tests. <br> <strong>Testing:</strong> sample seeds produce stable GUIDs across hosts; validate variant/version bits set correctly. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: FormatDateISO & ParseDateISO — strict date contracts:</strong> <br> <strong>Purpose:</strong> canonical date formatting and strict parsing to avoid cross-locale misinterpretation. <br> <strong>FormatDateISO(dateValue) -> {status, isoDate, details}.</strong> <br> <strong>ParseDateISO(isoString) -> {status, dateValue, errorCode, details}</strong> — strict parser; reject <code>MM/DD/YYYY</code> or other non-ISO formats. <br> <strong>Rules:</strong> enforce leap-year validation, month/day ranges. <br> <strong>Errors:</strong> <code>ERR_ARG_INVALID</code> for invalid dates. <br> <strong>Testing:</strong> boundary dates, leap year cases, invalid month/day combos. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: NowUTC & FormatTimestampISO — timestamp contracts:</strong> <br> <strong>Purpose:</strong> provide canonical UTC timestamps for audit entries and manifest metadata. <br> <strong>NowUTC() -> {status, timestamp, epochMs, details}:</strong> returns <code>YYYY-MM-DDTHH:MM:SSZ</code> string and epoch millisecond. <br> <strong>FormatTimestampISO(dateValue) -> {status, isoTimestamp, details}:</strong> format input to canonical timestamp; always include <code>Z</code>. <br> <strong>Preconditions:</strong> callers must convert localized times to UTC prior to calling if they hold local times. <br> <strong>Observability:</strong> record timestamp generation in <code>AuditLog</code> entries for traceability. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: ReadFileBytes & WriteAtomicFile — safe I/O expanded:</strong> <br> <strong>ReadFileBytes(path) -> {status, bytes, fileSize, readTimeMs, errorCode, details}</strong> <br> • Behavior: open file in binary, stream bytes into buffer(s) using chunked reads, return bytes as array in host representation and file metadata. <br> • Errors: <code>ERR_FILE_IO</code> on permission or missing file. <br> <strong>WriteAtomicFile(targetPath, bytes, Optional perms) -> {status, tempPath, finalPath, errorCode, details}</strong> <br> • Atomic recipe: write into same-directory temp file <code>&lt;basename&gt;.tmp.&lt;pid&gt;.&lt;rand&gt;</code>, flush & fsync if supported, optionally set ACLs, then rename to target; finally return <code>finalPath</code>. <br> • Failure behavior: attempt cleanup of temp file; on repeated failure return <code>ERR_FILE_IO</code> and produce <code>AuditLog</code> event <code>fa.file.write.fail</code> with diagnostic details. <br> <strong>Platform nuances:</strong> on Windows rename is atomic if same volume; on network filesystems atomicity may vary — return diagnostic <code>hostAtomicRenameOk</code> boolean. <br> <strong>Security:</strong> ensure path validation to avoid symlink attacks and do not accept user-supplied path strings without canonicalization and allowlist. <br> <strong>Testing:</strong> simulate disk-full mid-write, permission denied, rename failure and verify no partial target files exist. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: AcquireWorkbookLock & ReleaseWorkbookLock — improved operational lock semantics:</strong> <br> <strong>Purpose:</strong> lightweight single-writer lock for mutative operations in shared workbook environments. Not a replacement for server-side concurrency control but reduces race conditions for Excel macro runs. <br> <strong>Mechanism:</strong> hidden sheet named range or custom document property containing JSON <code>{ownerId, lockTsUtc, expirySeconds, lockId}</code>. <br> <strong>AcquireWorkbookLock(actorId, timeoutSeconds) -> {status, lockId, expiryTs, errorCode, details}</strong> <br> • Algorithm: attempt to write lock cell using <code>Application.ScreenUpdating=False</code> and <code>Workbook.Save</code> where appropriate to minimize race window; if a lock exists and <code>lockTsUtc + expirySeconds</code> > now, return <code>ERR_LOCK_FAIL</code> with <code>details.currentOwner</code>. If expired, allow takeover but record <code>fa.lock.forcedRelease</code> if takeover not gentle. <br> <strong>ReleaseWorkbookLock(actorId, force=False) -> {status, released, details}</strong> <br> • Only owner may release; forced release allowed if lock expired or operator authorized; forced releases must record full justification in <code>AuditLog</code>. <br> <strong>Concurrency & race windows:</strong> use a small transactional write with <code>Workbook.Save</code> or protected Range write to increase atomicity; document risk when multiple Excel instances are active on network drives. <br> <strong>Testing:</strong> simulate concurrent acquisition attempts and verify only single owner succeeds. <br> <strong>Observability:</strong> <code>modutils.lock.acquire.count</code> and <code>.failures</code>. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: ComputeParityDigest (manifest parity orchestration helper expanded):</strong> <br> <strong>Purpose:</strong> re-compute manifest digest from persisted canonical bytes or reassemble from stored taskRowChecksums to detect parity drift between persisted manifest and recomputed artifact. Intended for nightly parity checks and forensic validation. <br> <strong>Signature:</strong> <code>ComputeParityDigest(manifestId) -&gt; {status, persistedHash, recomputedHash, match: bool, diffSummary, details}</code>. <br> <strong>Behavior & modes:</strong> <br> 1. If persistent canonicalString stored: compute <code>ComputeSHA256(canonicalBytes)</code> and compare. <br> 2. If canonicalString not stored, reassemble manifest canonicalString using stored <code>taskRowChecksum</code> entries in canonical order and <code>manifestMeta</code> snapshot, then compute hash. <br> <strong>On mismatch:</strong> append <code>fa.verify.parity.failed</code> with <code>manifestId</code> and <code>diffSummary</code> and schedule forensic export via <code>modAudit.ExportAuditManifest</code>. <br> <strong>DiffSummary content:</strong> small, named differences (missing taskRowChecksum, changed taskCount, changed blockingCount). Avoid including full canonical bytes in audit due to size. <br> <strong>Testing:</strong> create changed task row to produce mismatch and validate alerting. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Function: ComputeCRC32 (auxiliary):</strong> <br> <strong>Purpose:</strong> quick non-cryptographic checksum for caches and indexing; not for tamper-evidence. <br> <strong>Contract:</strong> <code>ComputeCRC32(bytes) -&gt; {status, crc32Hex}</code>. <br> <strong>Note:</strong> do not use for security-critical verification. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Integration pattern: Power Query (PQ) + modUtils (conceptual orchestration, prescriptive):</strong> <br> Rationale: PQ is efficient at bulk table transforms; <code>modUtils</code> enforces byte-level determinism and canonicalization. <br> Pattern steps: <br> 1. <strong>Ingest (PQ):</strong> ingest <code>YearEndTaskTemplate</code>, <code>OwnerAssignments</code>, <code>AdhocRequests</code>, <code>SupportingDocuments</code>, <code>SignOffEntries</code>, <code>CloseParameters</code>. <br> 2. <strong>Bulk transforms (PQ):</strong> perform table-level normalizations, date parsing, approximate duplicate detection heuristics and produce <code>TasksStaging</code> and <code>SupportingDocsStaging</code> hidden sheets. <br> 3. <strong>Per-row canonical pass (VBA using modUtils):</strong> iterate staging rows and call <code>CanonicalizeText</code> and <code>ComputeRowChecksum</code> for fields that are used in manifest hashing; compute <code>taskRowChecksum</code> and persist in <code>TasksMaster</code>. <br> 4. <strong>Manifest generation (VBA):</strong> assemble ordered <code>taskRowChecksum</code> list, call <code>ComputeManifestCanonicalString</code> then <code>ComputeSHA256</code> -> <code>manifestHash</code>; persist PDF and manifest via <code>WriteAtomicFile</code> and persist <code>ChecklistVersionManifest</code> row atomically. <br> 5. <strong>Evidence verification:</strong> PQ flags presence of <code>SupportingDocuments.checksum</code>; <code>modUtils.ComputeSHA256File</code> verifies binary checksums when file available locally or via DMS staging. <br> 6. <strong>Parity job:</strong> nightly job re-runs PQ staging and <code>ComputeParityDigest</code> to compare persisted vs recomputed manifest hashes; alert on mismatch. <br> <strong>Guidance & rationales:</strong> <br> • Use PQ for set-oriented transforms (joins, merges, mass normalizations). <br> • Use <code>modUtils</code> for exact byte-level operations (hashing, canonicalization that affects checksums, deterministic GUID generation). <br> • Keep <code>CANONICAL_VERSION</code> identical in PQ recipes and <code>modUtils</code>. <br> <strong>Operational tip:</strong> export PQ staging sheets in a stable order to minimize diff noise for parity. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX measures and reporting patterns that depend on modUtils outputs (no code):</strong> <br> These conceptual measures guide BI authors on how to use <code>modUtils</code> outputs for audit oversight. Use persisted tables as data sources. <br> 1. <strong>ManifestParityOK</strong> — Boolean per manifest where <code>recomputedHash == persisted manifestHash</code>. Use as high-priority tile and drill to <code>AuditLog</code>. <br> 2. <strong>ChecksumCoverageRate</strong> — percent of supporting documents with <code>evidenceStatus = valid</code>. Aggregate by owner/department. <br> 3. <strong>CriticalOpenCount</strong> — count tasks with <code>gatingCategory = critical</code> and <code>status</code> not <code>Signed Off</code>. Alert when >0 near <code>closeDate</code>. <br> 4. <strong>SignOffCompletenessRate</strong> — percent of tasks with required sign-offs per <code>policySnapshot.approvalMatrix</code>. <br> 5. <strong>TaskChecksumDriftCount</strong> — count of tasks where current <code>taskRowChecksum</code> differs from checksum at manifest generation. <br> 6. <strong>AvgDaysToClose</strong> — average of (<code>closedTs - generatedTs</code>) per manifest. <br> <strong>Visual patterns:</strong> parity tile with manifest list, evidence heatmap (department × evidenceCategory showing <code>ChecksumCoverageRate</code>), sign-off registry table with filters by signer and manifest. Always show <code>manifestHash</code> and <code>canonicalVersion</code> for traceability. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Comprehensive worked examples (long-form narratives):</strong> <br> <strong>Example 1 — Pre-close canonicalization & manifest creation (happy-path):</strong> <br> 1. PQ refresh populates <code>TasksStaging</code> with 320 rows; <code>CloseParameters</code> contains <code>closeDate</code> and <code>canonicalVersion</code>. <br> 2. Operator runs <code>AcquireWorkbookLock(&quot;alice&quot;,600)</code> and receives lockId; <code>fa.lock.acquired</code> appended. <br> 3. For each staging row operator calls <code>CanonicalizeText(taskName)</code> then <code>ComputeRowChecksum</code> with normative task field order; store <code>taskRowChecksum</code> into <code>TasksMaster</code>. <br> 4. Build <code>orderedTaskChecksums</code> sorted by <code>gatingCategory</code>, <code>priority</code>, <code>computedDueDate</code>; call <code>ComputeManifestCanonicalString(manifestMeta, orderedTaskChecksums)</code> producing canonical bytes (no trailing newline). <br> 5. Call <code>ComputeSHA256(canonicalBytes)</code> to obtain <code>manifestHash</code>; call <code>WriteAtomicFile(pdfPath, pdfBytes)</code>; on success persist <code>ChecklistVersionManifest</code> row with <code>manifestHash</code> and call <code>modAudit.AppendAudit(&quot;fa.checklist.generated&quot;, &quot;alice&quot;, details)</code>. <br> 6. Release lock and run immediate <code>ComputeParityDigest(versionId)</code> to confirm persisted <code>manifestHash</code> aligns with recomputed one; if match, distribute PDFs to owners. <br> <strong>Example 2 — Evidence attach & verification:</strong> <br> 1. Owner uploads <code>tax_recon.pdf</code>; <code>modEvidence.AttachEvidence</code> calls <code>modUtils.ComputeSHA256File(localPath)</code> which returns <code>sha256:</code> checksum and fileSize; persist into <code>SupportingDocuments.checksum</code>. <br> 2. Later evidence migrated to a different DMS site. <code>modEvidence.RebindEvidence</code> downloads a staging copy and calls <code>ComputeSHA256File</code> to re-verify; reproduced checksum differs -> <code>ERR_EVIDENCE_CHECKSUM_MISMATCH</code> returned and <code>fa.evidence.invalid</code> appended; task flagged as blocking. <br> 3. Remediation occurs by re-uploading original file or restoring DMS artifact; <code>ComputeSHA256File</code> returns expected checksum and <code>fa.evidence.verified</code> appended. <br> <strong>Example 3 — Deterministic import & stable IDs:</strong> <br> 1. Import pipeline provides <code>sourceTemplateId</code> and row index; call <code>GenerateDeterministicGUID(seed = sourceTemplateId || &quot;:&quot; || rowIndex)</code> producing stable <code>taskId</code>. <br> 2. Re-importing the same sources re-generates same <code>taskId</code> values enabling stable mapping across ETL runs; <code>ComputeRowChecksum</code> yields stable <code>taskRowChecksum</code> supporting fixture parity. <br> <strong>Example 4 — Parity failure forensic process:</strong> <br> 1. Nightly parity job detects mismatch and emits <code>fa.verify.parity.failed</code> with <code>manifestId</code>. <br> 2. Operator runs <code>ComputeParityDigest(manifestId)</code> producing <code>persistedHash</code> vs <code>recomputedHash</code> and <code>diffSummary</code>. <br> 3. Export forensic bundle: <code>modAudit.ExportAuditManifest(manifestId, outPath)</code> including manifest canonicalString, AuditLog slice, and task checksum snapshots. <br> 4. If unexplained mutation escalate to compliance and preserve forensic bundle with signatures if available. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Testing & CI matrix (exhaustive):</strong> <br> <strong>Unit tests (per-function):</strong> <br> 1. <code>ComputeSHA256</code> vectors: empty string, <code>&quot;abc&quot;</code>, sample PDF bytes. <br> 2. <code>ComputeSHA256File</code> streaming correctness across file sizes (1KB, 1MB, 200MB). <br> 3. <code>CanoncalizeText</code> multilingual vectors covering Turkish <code>I</code>, Greek, Cyrillic, Arabic, Hebrew, diacritic toggles, ligatures, emoji and control-character removal. <br> 4. <code>ComputeRowChecksum</code> ordering tests, missing-field errors and expected canonicalString comparisons. <br> 5. <code>GenerateDeterministicGUID</code> stable GUIDs for seeds and variant/ version bits. <br> 6. <code>ReadFileBytes</code>/<code>WriteAtomicFile</code> mid-write failure tests and atomicity verification. <br> <strong>Integration tests:</strong> <br> 1. PQ staging -> per-row canonicalization -> manifest generation -> compare manifestHash for golden fixtures. <br> 2. Evidence attach -> rebind -> verify expected audit events and gating. <br> 3. Lock concurrency simulation across multiple Excel instances. <br> <strong>Golden fixtures (mandatory):</strong> <br> - <code>fixture_small</code> (25 tasks, English) expected <code>manifestHash_small</code>. <br> - <code>fixture_mid</code> (500 tasks, mixed locales) expected <code>manifestHash_mid</code>. <br> - <code>fixture_edge</code> (Turkish <code>I</code>, diacritics, emojis, duplicate tasks) expected <code>manifestHash_edge</code>. <br> Nightly CI must recompute and assert equality; on mismatch create incident and attach <code>diffSummary</code>. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Observability & alerting (practical rules):</strong> <br> 1. <strong>Parity failure</strong> (<code>manifestHash</code> mismatch) — emit <code>fa.verify.parity.failed</code>, severity High. <br> 2. <strong>Hash errors spike</strong> — <code>modutils.hash.failures</code> spike triggers ops notification. <br> 3. <strong>Evidence invalid count</strong> spike — notify compliance. <br> 4. <strong>Lock acquisition failures in scheduled runs</strong> — page on-call. <br> 5. Telemetry aggregation: produce daily rollups and <code>p50|p95|p99</code> timings for hash and canonicalize operations. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Governance & migration process for canonical changes (procedural):</strong> <br> Changing <code>CANONICAL_VERSION</code> or canonical rules requires a <code>migrationManifest</code> with: <br> 1. <code>migrationId</code>, <code>author</code>, <code>createdTs</code>. <br> 2. <code>oldCanonicalVersion</code> and <code>newCanonicalVersion</code>. <br> 3. <code>changedRulesSummary</code> and rationale. <br> 4. <code>goldenFixtureBeforeHash</code> and <code>goldenFixtureAfterHash</code>. <br> 5. <code>canaryPlan</code> with cohort and pass/fail metrics (parity drift, criticalOpenDelta). <br> 6. <code>rollbackPlan</code> and approvers list (Tech Lead, Compliance, Product). <br> Process: run canary, gather metrics, sign-off, then roll out; archive old canonical code for historical verification. Append <code>fa.canonical.migration</code> to <code>AuditLog</code> with manifest id. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Operator runbooks (concise, stepwise):</strong> <br> <strong>Pre-close readiness:</strong> <br> 1. Refresh PQ; resolve <code>PQ_Issues</code> high severity. <br> 2. Acquire workbook lock. <br> 3. Run per-row <code>CanonicalizeText</code> + <code>ComputeRowChecksum</code>; persist <code>TasksMaster</code>. <br> 4. Generate manifest and PDF atomically. <br> 5. Run immediate parity check; if mismatch invoke forensic flow. <br> 6. Release lock and append <code>fa.checklist.generated</code>. <br> <strong>Parity failure triage:</strong> <br> 1. Run <code>ComputeParityDigest(manifestId)</code> to confirm mismatch details. <br> 2. Export forensic bundle and analyze <code>AuditLog</code> around generation time. <br> 3. If unexplained, escalate to compliance and preserve bundle. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Security, legal-hold & retention guidance (operational):</strong> <br> 1. Do not store evidence content in workbook; store pointers and checksums. <br> 2. Export forensic bundles signed by enterprise PKI if available. <br> 3. Mark manifests and evidence with <code>legalHold=true</code> to prevent deletion. <br> 4. Archive manifests and audit logs into secure long-term storage with <code>manifestHash</code> and optional digital signature. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Scaling & migration strategies (practical):</strong> <br> 1. For >10k tasks or many binary evidence items, migrate metadata to a DWH; replicate <code>CANONICAL_VERSION</code> rules in a server-side <code>modUtils</code> SDK. <br> 2. Offload file hashing of large binaries to a serverless worker with access to DMS and the same UTF-8 encoding rules. <br> 3. Replace workbook PDF generation with templating engine while preserving canonical bytes used for <code>manifestHash</code>. <br> 4. Maintain golden fixtures and canonical test harness to verify parity after migration. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Common pitfalls & explicit mitigations:</strong> <br> 1. <strong>UTF-8 drift:</strong> different UTF-8 conversion implementations produce different bytes — mitigate by centralizing UTF-8 encoder and unit tests. <br> 2. <strong>Locale drift (Turkish I):</strong> ensure <code>CanoncalizeText</code> handles <code>tr-TR</code>/<code>az-AZ</code> specially and is versioned. <br> 3. <strong>Trailing newline mismatch:</strong> canonical strings must deliberately exclude trailing newline; enforce in <code>ComputeManifestCanonicalString</code>. <br> 4. <strong>Non-atomic persistence:</strong> always use <code>WriteAtomicFile</code>; persist manifest row only after PDF write success. <br> 5. <strong>Storing credentials in URLs:</strong> disallow; store only DMS pointers and fetch under authenticated context external to <code>modUtils</code>. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Acceptance checklist for <code>modUtils</code> integration (testable):</strong> <br> 1. Unit tests pass for all functions across supported hosts. <br> 2. Golden fixture hashes match expected values. <br> 3. PQ→VBA pipeline produces identical manifest bytes for representative manifests. <br> 4. <code>WriteAtomicFile</code> succeeds under simulated failure scenarios and leaves no partial target files. <br> 5. Lock behavior prevents concurrent mutative actions in simulated multi-editor tests. <br> 6. Parity job detects tamper in controlled tests and triggers <code>fa.verify.parity.failed</code>. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Appendix — canonical field order normative (must be used verbatim):</strong> <br> - Task row order for <code>ComputeRowChecksum</code>: <code>canonicalVersion</code> <code>|</code> <code>taskId</code> <code>|</code> <code>taskName</code> <code>|</code> <code>assignedOwnerId</code> <code>|</code> <code>gatingCategory</code> <code>|</code> <code>computedDueDate</code> <code>|</code> <code>signoffRequired</code>. <br> - Evidence row order: <code>canonicalVersion</code> <code>|</code> <code>evidenceId</code> <code>|</code> <code>title</code> <code>|</code> <code>url</code> <code>|</code> <code>uploaderId</code> <code>|</code> <code>uploadedTs</code> <code>|</code> <code>evidenceCategory</code>. <br> - Sign-off row order: <code>canonicalVersion</code> <code>|</code> <code>signOffId</code> <code>|</code> <code>taskId</code> <code>|</code> <code>signedBy</code> <code>|</code> <code>signedTs</code> <code>|</code> <code>versionId</code>. <br> - Manifest top-level order: <code>canonicalVersion</code> <code>|</code> <code>versionId</code> <code>|</code> <code>generatedBy</code> <code>|</code> <code>generatedTs</code> <code>|</code> <code>scope</code> <code>|</code> <code>taskCount</code> <code>|</code> <code>blockingCount</code> <code>|</code> <code>[taskRowChecksums...]</code> <code>|</code> <code>notes</code>. <br> Any deviation requires documented <code>migrationManifest</code>. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Appendix — golden fixtures (developer guidance):</strong> <br> - <code>fixture_small</code>: 25 tasks (English), small evidence set; expected <code>manifestHash_small</code>. <br> - <code>fixture_mid</code>: 500 tasks, multi-locale, mixed evidence; expected <code>manifestHash_mid</code>. <br> - <code>fixture_edge</code>: Turkish <code>I</code>, combining diacritics, emojis, duplicates; expected <code>manifestHash_edge</code>. <br> Keep fixtures in CI and re-run parity nightly. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Appendix — canonical migration manifest template (what to capture):</strong> <br> - <code>migrationId</code>, author, <code>oldCanonicalVersion</code>, <code>newCanonicalVersion</code>, <code>changedRulesSummary</code>, <code>goldenFixtureBeforeHash</code>, <code>goldenFixtureAfterHash</code>, <code>canaryPlan</code>, <code>approvals</code> and <code>rollbackPlan</code>. <br> Append <code>fa.canonical.migration</code> to <code>AuditLog</code> referencing the manifest. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Operational examples (concise checklist style):</strong> <br> 1. To recompute manifest parity for <code>versionId</code>: run <code>ComputeParityDigest(versionId)</code> and compare <code>persistedHash</code> to <code>recomputedHash</code> then append <code>fa.verify.parity.result</code>. <br> 2. To re-verify evidence after DMS migration: <code>RebindEvidence</code> -> <code>ComputeSHA256File</code> -> if mismatch append <code>fa.evidence.invalid</code>. <br> 3. For emergency override during close: <code>AttemptClose</code> with <code>overrideApprovalRef</code> only when <code>policySnapshot.emergencyRules</code> permits; require compensating controls and <code>fa.checklist.closed.override</code> in <code>AuditLog</code>. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Forensic runbook excerpt (detailed):</strong> <br> - <strong>Trigger:</strong> <code>fa.verify.parity.failed</code> received. <br> - <strong>Step 1:</strong> Do not modify workbook. Acquire a read-only snapshot copy. <br> - <strong>Step 2:</strong> Run <code>ComputeParityDigest(manifestId)</code> against snapshot to reproduce mismatch. <br> - <strong>Step 3:</strong> Export <code>AuditLog</code> slice for 1 hour before and after <code>generatedTs</code>. <br> - <strong>Step 4:</strong> Export canonical manifest bytes and <code>taskRowChecksum</code> list to a zipped forensic bundle and compute SHA-256 of the bundle. <br> - <strong>Step 5:</strong> Escalate to compliance with bundle location and <code>manifestHash</code> values. Preserve chain of custody. </td></tr><tr><td data-label="modUtils — Per-function Expert Technical Breakdown"> <strong>Closing operational guidance (required):</strong> <br> Treat <code>modUtils</code> as the single authoritative primitive layer. Preserve <code>CANONICAL_VERSION</code> discipline, test changes with golden fixtures, document <code>migrationManifest</code> for any canonical changes, and guarantee that parity checks run nightly. Any suspected parity failure is a high-priority compliance incident requiring forensic export and preservation. </td></tr></tbody></table></div><div class="row-count">Rows: 40</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>