<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;}</style>
<link rel="stylesheet" href="assets/style.css?v=1759294520">
<link rel="stylesheet" href="assets/overrides.css?v=1759294520">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header"><div><h1>Tables Viewer v2.1</h1></div><div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" type="search" placeholder="Search" aria-label="Search tables" style="min-width:420px; width:44ch;"/>
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllMdBtn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy all tables as markdown">Copy All Tables (Markdown)</button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset all tables">Reset All Tables</button>
</div></div>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#table-1">Table 1</a></li></ul></div></div>
<div class="table-wrapper" data-table-id="table-1"><h3 id="table-1">Table 1</h3><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th style="width:28.57%;" role="button" aria-label="Sort by File: **html_renderer.py** — Logic &amp; structure"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">File: <strong>html_renderer.py</strong> — Logic & structure</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th style="width:71.43%;" role="button" aria-label="Sort by Expanded conceptual notes"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Expanded conceptual notes</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Role</strong>: High-level entrypoint that assembles final HTML pages. Orchestrates consuming fragment files, injecting assets and templates, producing `output_combined` site artifacts and manifest for deployment. This is the glue between rendering internals and the final deliverable the user opens in a browser.                                                                                                                                                                                                                                                                                                           </td><td data-label="Expanded conceptual notes"><strong>Purpose & responsibilities</strong>: <br>• Read fragment metadata and content produced by `core<em>fragments`. <br>• Resolve and include assets provided by `core</em>assets` (CSS, JS, worker). <br>• Apply templates and placeholders (head, nav, content, scripts). <br>• Insert search index and worker registration if enabled. <br>• Write final HTML files atomically via `core_io` and emit a build manifest. </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Inputs</strong>: fragment map (index→path/content/title), asset manifest, configuration (theme defaults, embed vs copy, base URL), template files (Jinja2 or simple string templates), optional extra metadata (author, title, date).                                                                                                                                                                                                                                                                                                                                                                                              </td><td data-label="Expanded conceptual notes"><strong>Outputs</strong>: final HTML pages in `output_combined/`, an `assets/` subfolder with copied assets, optional `manifest.json` or search index files, and a structured report of warnings/errors.                                                                                                                                                                                                               </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>High-level flow</strong>: <br>1. Load global templates and per-fragment template variants. <br>2. Compute per-page asset list (deduped, ordered) using `core<em>assets.generate</em>asset<em>tags`. <br>3. For each fragment: assemble head (meta, CSS), body (navigation, header, fragment content), scripts (deferred `script.js` and worker registration). <br>4. Inline small assets if configuration requests, otherwise reference copied assets. <br>5. If search indexing enabled, inject search index snippet or reference worker. <br>6. Write page file atomically using `</em>atomic_write`. <br>7. Emit manifest and return summary. </td><td data-label="Expanded conceptual notes"><strong>Template considerations</strong>: Use clear placeholders and avoid executing arbitrary code in templates. Prefer safe templating (Jinja2 with autoescape) or a minimal templating approach that performs explicit escaping for untrusted fields. Document required placeholders and provide default template fallback shipped with package.                                                                    </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Asset injection & order</strong>: Insert `<link rel="stylesheet">` tags in HEAD in deterministic order: `style.css` first, then `overrides.css`, then any other CSS. Insert `<script defer>` tags near the end of `<body>` or use module/defer attributes per config. If inlining CSS, place `<style>` blocks early to avoid FOUC.                                                                                                                                                                                                                                                                                                 </td><td data-label="Expanded conceptual notes"><strong>Accessibility & performance</strong>: Include `<meta charset="utf-8">`, viewport meta, and preload hints for critical assets if desired. Avoid blocking scripts that delay rendering. Consider critical CSS in head for first paint improvements. Provide `rel="preload"` for important assets.                                                                                                                </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Fragment placement</strong>: Fragments should be inserted into a stable DOM container (e.g., `<main id="content">`) to enable client-side behavior (like incremental navigation). Ensure fragment HTML does not accidentally introduce duplicate IDs across pages; sanitize or scope fragment IDs (prefix with fragment slug) if necessary.                                                                                                                                                                                                                                                                                        </td><td data-label="Expanded conceptual notes"><strong>ID collisions mitigation</strong>: When assembling multiple fragments into one page, prefix internal fragment IDs with the fragment identifier (slug or index) to avoid duplicate `id` attributes; update any internal fragment links accordingly.                                                                                                                                                             </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Search index handling</strong>: If building client-side search, gather title, excerpt, and path from fragments. Either inline a compact JSON into a script tag (if small) or emit a separate `search-index.json` under `assets/` and register worker to load it. When using a worker, ensure `worker.js` path matches copied asset location and registration scope.                                                                                                                                                                                                                                                                </td><td data-label="Expanded conceptual notes"><strong>Privacy/size tradeoff</strong>: Large search indices can bloat pages; prefer separate worker-hosted index for big sites. Provide compression (gz) in deploy step if supported by server. On client, worker should fetch and parse incrementally where possible.                                                                                                                                                </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>HTML writing strategy</strong>: Use `core<em>io.</em>atomic_write` to produce final files. For each page, write to a temp file then `os.replace` into final path to avoid partial files. Maintain predictable file permissions and optionally set `mtime` based on content hash to assist caching.                                                                                                                                                                                                                                                                                                                                        </td><td data-label="Expanded conceptual notes"><strong>Manifest and integrity</strong>: Produce `manifest.json` listing page paths, fragment sources, asset versions (SRI), and timestamps. This assists debugging and verifying that the build preserved filenames (underscores).                                                                                                                                                                                    </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Theming & dark mode</strong>: Provide toggle UI hooked to client JS that sets `data-theme="dark"` or toggles `body.dark-mode` class as expected by `overrides.css`. If server-side rendering of theme variants is needed, allow configuration to generate two sets of CSS/HTML or use client JS to switch.                                                                                                                                                                                                                                                                                                                         </td><td data-label="Expanded conceptual notes"><strong>Recommendation</strong>: Default to client-side toggle using localStorage. Ensure CSS supports both theme variables, and that initial render is acceptable in default theme to avoid flash.                                                                                                                                                                                                                    </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Error handling</strong>: If a fragment file is missing or unreadable, include a placeholder message in the page and add a warning to manifest. If asset copying fails for critical CSS, abort final write and surface error. Document severity levels for different failures.                                                                                                                                                                                                                                                                                                                                                      </td><td data-label="Expanded conceptual notes"><strong>Resilience</strong>: Implement a dry-run mode to validate assembly without writing files. Provide verbose logging to list pages that will be written and assets included.                                                                                                                                                                                                                                      </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Performance & scalability</strong>: For large numbers of pages, parallelize asset copy and page assembly where safe, but ensure atomic final writes are done without conflict. Consider chunked writes for very large pages. Provide streaming templates if memory is a concern.                                                                                                                                                                                                                                                                                                                                                   </td><td data-label="Expanded conceptual notes"><strong>Optimizations</strong>: Cache asset tags and template render results for repeated fragments. Use content hashes to skip writing unchanged pages (atomic<em>write</em>if_changed).                                                                                                                                                                                                                                     </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Security</strong>: Escape untrusted metadata (titles, descriptions). Only insert sanitized fragment HTML produced by `markdown.py` / `sanitize.py`. Avoid embedding user-provided scripts. For inline scripts, consider CSP with nonces.                                                                                                                                                                                                                                                                                                                                                                                           </td><td data-label="Expanded conceptual notes"><strong>CSP</strong>: Generate a per-build nonce if inline scripts are necessary, include it in script tags and set CSP header instructing browsers to accept that nonce.                                                                                                                                                                                                                                              </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Testing & CI</strong>: Unit tests for template assembly, asset injection order, and manifest content. Integration tests that run full assembly and verify produced HTML contains required elements and preserved filenames. Snapshot tests for produced pages, and end-to-end test using headless browser to verify theme toggle and sticky column behavior.                                                                                                                                                                                                                                                                       </td><td data-label="Expanded conceptual notes"><strong>Suggested commit message</strong>: `feat(html_renderer): assemble pages with preserved filenames, deterministic assets, and search index support`                                                                                                                                                                                                                                                              </td></tr><tr><td data-label="File: htmlrenderer.py — Logic &amp; structure"><strong>Acceptance criteria</strong>: Given fragment files and asset manifest, `html<em>renderer.py` must produce pages in `output</em>combined` with assets present in `output<em>combined/assets/`, manifest matching expectations, preserved filenames (e.g., `html</em>renderer.py` references remain intact), and no partial writes observed.                                                                                                                                                                                                                                                                                                       </td><td data-label="Expanded conceptual notes">nan</td></tr></tbody></table></div><div class='row-count'></div></div><script src="assets/xlsx.full.min.js?v=1759294520" defer></script>
<script src="assets/script.js?v=1759294520" defer></script>
<script src="assets/worker.js?v=1759294520" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
</script>
</div>
</body>
</html>