<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1762008374">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      // Delegate addEventListener/removeEventListener to visible button
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      // Delegate onclick assignments
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      // Delegate focus/blur
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
      // If legacy code used direct addEventListener earlier than this script, listeners would already exist
      // on alias element; attempt to re-dispatch those by cloning them to visible button is non-trivial.
      // This approach covers the common case where legacy scripts query the alias and bind after DOM ready.
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Book_8062_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Caption Management Specification — One-Column Table**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Caption Management Specification — One-Column Table</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Summary</strong><br>Ensure exactly one caption per rendered table. Prefer server caption when present. Use <code>labels.json</code> as canonical source when server has none. Client applies captions only if missing and marks them. Server injects a safe marker when it generated a caption. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Scope</strong><br>Edits limited to:<br>1. <code>assets/script.list.js</code> (client) — full replacement.<br>2. <code>convert.py</code> (server) — drop-in replacement.<br>No other files changed. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Primary goal (rules)</strong><br>1. If server produced a caption for a table then that caption must be authoritative and not duplicated by client.<br>2. If server did not produce a caption then client will consult <code>labels.json</code> and apply one caption per table.<br>3. If both server and client lack captions then client applies deterministic fallback numbering <code>Table 1</code>, <code>Table 2</code>, ... per view. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Server responsibilities</strong><br>1. If server decides to caption a table it must:<br>• Insert HTML comment: <code>&lt;!-- ptt-server-caption: file=&lt;filename&gt;; idx=&lt;n&gt; --&gt;</code>.<br>• Add <code>data-ptt-server-caption=&quot;1&quot;</code> on the table element.<br>• Include filename context in rendering <code>options</code>.<br>2. If an error occurs server must not partially inject attributes; return unmodified HTML and log. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Client responsibilities</strong><br>1. On view load client fetches <code>labels.json</code> once per page load (cache per-session).<br>2. Client polls for rendered tables for ≤3 s (interval = 200 ms).<br>3. For each table: check for <code>data-ptt-server-caption</code> or server comment; if present do nothing.<br>4. If absent: consult <code>labels.json</code> via deterministic key mapping. If label found apply caption, set <code>data-ptt-caption-applied=&quot;1&quot;</code>, and link via <code>aria-describedby</code>.<br>5. If no label found: apply fallback caption <code>Table N</code> where N = ordinal within current view. Mark with <code>data-ptt-caption-applied=&quot;1&quot;</code>. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Key attribute & marker spec</strong><br>1. Server marker comment: <code>&lt;!-- ptt-server-caption: file=&lt;filename&gt;; idx=&lt;n&gt; --&gt;</code>.<br>2. Server attribute: <code>data-ptt-server-caption=&quot;1&quot;</code>.<br>3. Client attribute: <code>data-ptt-caption-applied=&quot;1&quot;</code>.<br>4. Client id: <code>id=&quot;ptt-caption-&lt;file-view&gt;-&lt;n&gt;&quot;</code> to allow <code>aria-describedby</code>. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Label mapping rules</strong><br>1. Priority: exact <code>labels.json</code> key (full path) > basename (strip path/ext) > normalized slug (lowercase, hyphenated) > not found.<br>2. Normalization algorithm must be documented and unit-tested with examples. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Idempotency and duplicate prevention</strong><br>1. Before adding caption, check for existing <code>&lt;caption&gt;</code> tags or <code>data-ptt-*</code> attributes.<br>2. If caption exists but lacks attributes treat as external; do not duplicate. Optionally mark <code>data-ptt-external-caption=&quot;1&quot;</code>. Log warning.<br>3. Client operations must be pure DOM writes after re-check to avoid race conditions. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Error handling & fallbacks</strong><br>1. If <code>labels.json</code> fetch fails → use fallback numbering and mark applied.<br>2. If malformed server marker → ignore and log.<br>3. Never insert HTML from <code>labels.json</code>; escape all text. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Verification checks (10 explicit)</strong><br>1. Deploy server patch and restart; confirm HTML includes server comment marker.<br>2. Load server-captioned file; confirm DOM shows <code>data-ptt-server-caption=&quot;1&quot;</code> and no client-applied flag.<br>3. Load non-captioned file with label in <code>labels.json</code>; confirm client applies caption correctly.<br>4. Load mixed group view; confirm exactly one caption per table and correct attribute distribution.<br>5. Simulate missing <code>labels.json</code>; confirm fallback numbering applied.<br>6. Inject external captions pre-client; confirm no duplicates and optional mark external.<br>7. Test normalization permutations (path, case, underscores, spaces).<br>8. Verify comment parsing tolerance to whitespace and order.<br>9. Validate DOM output: text-only, escaped labels.<br>10. Measure client polling stop ≤ 3 s and single fetch of <code>labels.json</code>. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Rollout plan</strong><br>1. Canary deploy to staging.<br>2. Verify checks 1–5.<br>3. Deploy client update to CDN (short TTL).<br>4. Monitor logs/console for 24 h.<br>5. Promote to production if stable. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Rollback plan</strong><br>1. Revert <code>convert.py</code> to previous commit and reload server.<br>2. Revert client JS on CDN and invalidate cache.<br>3. Confirm DOM returns to prior state. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Risks and mitigations</strong><br>1. Mismatched filename keys → normalize + log.<br>2. Third-party captions → detect and skip.<br>3. Race conditions → re-check attributes before write.<br>4. Malicious <code>labels.json</code> → escape text. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Testing & automation</strong><br>1. Unit tests for <code>convert.py::mark_server_captions()</code> covering multiple/malformed tables.<br>2. Unit tests for client captioner (mapping, idempotency, fallback).<br>3. E2E tests (Playwright) covering verification 2–4 and 6.<br>4. Smoke test fetching known file confirming one caption per table. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Maintenance notes</strong><br>1. Keep <code>data-ptt-*</code> names stable.<br>2. Document normalization in README.<br>3. Add metrics: server-caption count, client-applied count, external-caption count, label-failure count. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Future upgrades</strong><br>1. Add <code>data-ptt-file</code> attribute for provenance.<br>2. Move full caption resolution server-side.<br>3. Cache <code>labels.json</code> server-side and surface missing keys. </td></tr><tr><td data-label="Caption Management Specification — One-Column Table"> <strong>Final assessment</strong><br>Plan is precise and limited to two files. Verification covers functional, edge, and performance aspects. Remaining task: implement deterministic normalization and corresponding tests. </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><div class="table-caption" id="Table2" data-table="Book_8062_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Enhancement**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Enhancement</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Enhancement"> <strong>Goal:</strong> Guarantee each rendered table has one and only one caption, using captions from <code>labels.json</code> when available and falling back to <code>Table 1</code>, <code>Table 2</code>, etc. Prevent duplicate captions between client and server by marking server-generated ones.                                                                </td></tr><tr><td data-label="Enhancement"> <strong>Revised Files:</strong> <br>1. <code>assets/script.list.js</code> (client) — fully replaced. <br>2. <code>convert.py</code> (server) — drop-in revision. <br>3. No other files modified.                                                                                                                                                               </td></tr><tr><td data-label="Enhancement"> <strong>Key Changes:</strong> The server now adds a marker comment and <code>data-ptt-server-caption=&quot;1&quot;</code> to tables with captions. The client loads <code>labels.json</code>, assigns captions only when missing, tags its captions with <code>data-ptt-caption-applied</code>, and uses idempotent logic to ensure no repetition.                                  </td></tr><tr><td data-label="Enhancement"> <strong>Unchanged Behavior:</strong> Table parsing and rendering logic remain the same. Table structure is unchanged apart from the new <code>data-ptt-*</code> attributes. No new endpoints introduced.                                                                                                                                            </td></tr><tr><td data-label="Enhancement"> <strong>User Requirements:</strong> Use captions from <code>labels.json</code> when available, avoid duplicates, prioritize server captions, provide sequential fallback numbering, and limit edits strictly to two files.                                                                                                                          </td></tr><tr><td data-label="Enhancement"> <strong>Assumptions:</strong> <code>labels.json</code> keys correspond to filenames or basenames. The server includes filename context within <code>options</code>. DOM selectors for rendered tables remain consistent across views.                                                                                                                          </td></tr><tr><td data-label="Enhancement"> <strong>Risks:</strong> Potential mismatched filename keys, missing <code>labels.json</code>, ambiguity in multi-table files, server caption layout changes, or third-party scripts injecting captions.                                                                                                                                             </td></tr><tr><td data-label="Enhancement"> <strong>Verification Steps:</strong> <br>1. Deploy both revised files. <br>2. Restart the server. <br>3. Ensure <code>labels.json</code> includes valid filename keys. <br>4. Test single and group file loads. <br>5. Confirm one caption per table. <br>6. Inspect DOM for correct <code>data-ptt-*</code> attributes. <br>7. Verify server marker comments. </td></tr><tr><td data-label="Enhancement"> <strong>Future Upgrades:</strong> <br>1. Standardize filename normalization. <br>2. Add explicit <code>data-ptt-file</code> attributes. <br>3. Implement end-to-end caption tests. <br>4. Consider full server-side caption resolution. <br>5. Cache <code>labels.json</code> for performance.                                                                 </td></tr><tr><td data-label="Enhancement"> <strong>Integration Notes:</strong> The client polls rendered tables and applies captions post-render. The server uses <code>mark_server_captions()</code> to add safe caption markers and returns unmodified HTML if errors occur.                                                                                                                 </td></tr><tr><td data-label="Enhancement"> <strong>Security:</strong> Only plain text is inserted (no HTML). No new endpoints are added. Requires trusted <code>labels.json</code>.                                                                                                                                                                                                            </td></tr><tr><td data-label="Enhancement"> <strong>Performance:</strong> Regex operations are negligible. Caption polling is lightweight and bounded. A single JSON fetch occurs per load.                                                                                                                                                                                          </td></tr><tr><td data-label="Enhancement"> <strong>Maintenance:</strong> Keep <code>data-ptt-*</code> attributes stable. Update the helper if the HTML structure changes. Document caption matching logic clearly.                                                                                                                                                                             </td></tr><tr><td data-label="Enhancement"> <strong>Final Assessment:</strong> Implementation satisfies all objectives—each table receives one caption, behavior remains backward-compatible, and logic is idempotent. Only filename normalization and multi-table mapping merit future refinement.                                                                                  </td></tr></tbody></table></div><div class="row-count">Rows: 14</div></div><div class="table-caption" id="Table3" data-table="Book_8062_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Enhancement**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Enhancement</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Enhancement"> <strong>Goal:</strong> Ensure each rendered table receives exactly one caption, whether loading single files or groups. Prefer captions from <code>labels.json</code> when present; otherwise default to <code>Table 1</code>, <code>Table 2</code>, etc. Prevent duplicate captions from client and server by marking server-generated captions. </td></tr><tr><td data-label="Enhancement"> <strong>Revised Files:</strong> <br>1. <code>assets/script.list.js</code> (client) — replaced in full. <br>2. <code>convert.py</code> (server) — drop-in revision. <br>3. No other files changed.                                                                                                                                      </td></tr><tr><td data-label="Enhancement"> <strong>Key Changes:</strong> Server adds a marker comment and <code>data-ptt-server-caption=&quot;1&quot;</code> on tables with captions. Client loads <code>labels.json</code>, applies captions only when missing, marks its own captions with <code>data-ptt-caption-applied</code>, and uses idempotent logic to avoid repetition.                     </td></tr><tr><td data-label="Enhancement"> <strong>Unchanged Behavior:</strong> Table parsing and rendering remain identical. Table structure is unchanged except for new <code>data-ptt-*</code> attributes. No new endpoints.                                                                                                                                        </td></tr><tr><td data-label="Enhancement"> <strong>User Requirements:</strong> Use captions from <code>labels.json</code>, avoid duplicates, prefer server captions, provide fallback numbering, and limit edits to two files.                                                                                                                                         </td></tr><tr><td data-label="Enhancement"> <strong>Assumptions:</strong> <code>labels.json</code> keys match filenames or basenames. Server includes filename context in <code>options</code>. DOM selectors for rendered tables remain consistent.                                                                                                                               </td></tr><tr><td data-label="Enhancement"> <strong>Risks:</strong> Mismatched filename keys, missing <code>labels.json</code>, multi-table ambiguity, server caption layout changes, or other scripts injecting captions.                                                                                                                                              </td></tr><tr><td data-label="Enhancement"> <strong>Verification Steps:</strong> <br>1. Deploy both revised files. <br>2. Restart the server. <br>3. Ensure <code>labels.json</code> includes filenames. <br>4. Load single and group views. <br>5. Confirm one caption per table. <br>6. Inspect DOM for correct <code>data-ptt-*</code> attributes and comment markers.          </td></tr><tr><td data-label="Enhancement"> <strong>Future Upgrades:</strong> <br>1. Normalize filename mapping. <br>2. Add explicit <code>data-ptt-file</code> attributes. <br>3. Write end-to-end caption tests. <br>4. Consider full server-side caption resolution. <br>5. Cache <code>labels.json</code>.                                                                     </td></tr><tr><td data-label="Enhancement"> <strong>Integration Notes:</strong> Client polls for tables and applies captions post-render. Server wraps final HTML using <code>mark_server_captions()</code>, adding safe markers and returning unmodified HTML on error.                                                                                                </td></tr><tr><td data-label="Enhancement"> <strong>Security:</strong> Only text content inserted (no HTML). No new endpoints. Requires trusted <code>labels.json</code>.                                                                                                                                                                                               </td></tr><tr><td data-label="Enhancement"> <strong>Performance:</strong> Regex operations negligible. Caption polling lightweight and bounded. Single JSON fetch per load.                                                                                                                                                                                  </td></tr><tr><td data-label="Enhancement"> <strong>Maintenance:</strong> Keep <code>data-ptt-*</code> attributes stable. Update helper if HTML layout changes. Document matching logic.                                                                                                                                                                                </td></tr><tr><td data-label="Enhancement"> <strong>Final Assessment:</strong> Implementation meets all goals—single caption per table, backward-compatible, and idempotent. Only filename normalization and multi-table mapping require later refinement.                                                                                                   </td></tr></tbody></table></div><div class="row-count">Rows: 14</div></div><div class="table-caption" id="Table4" data-table="Book_8062_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Component / Section"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Component / Section</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Component / Section"> <strong>Module purpose & relevance</strong>                         </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> <code>core_utils</code> offers tiny, safe primitives (id/path sanitizers, tiny HTML helpers, and iterator utilities). These primitives are the ideal low-level building blocks used by higher-level label/TOC processing: canonicalizing keys from headings or table titles, building safe ids that must match <code>labels.json</code> keys, and defensively sampling iterables when loading labels lists.                                                        </td></tr><tr><td data-label="Component / Section"> <strong>_sanitize_id → labels.json keys</strong>                    </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> Use <code>_sanitize_id(title)</code> to derive deterministic <code>labels.json</code> keys or to normalize incoming JSON keys before lookups. Design decision: canonicalize both parsed document keys and <code>labels.json</code> keys with the same <code>_sanitize_id</code> routine to avoid mismatches caused by punctuation/whitespace. Edge case: unicode normalization—if <code>labels.json</code> keys use unicode, ensure both sides run <code>unicodedata.normalize</code> or collisions may occur. </td></tr><tr><td data-label="Component / Section"> <strong>_sanitize_output_path → labels.json persistence</strong>    </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> When writing or referencing <code>labels.json</code> (or derived assets like <code>assets-info.json</code>), run <code>_sanitize_output_path</code> on user-supplied names to avoid crashes. Caveat: this helper is permissive—higher layer should validate the path against allowed directories to avoid accidental writes to unexpected locations.                                                                                                                          </td></tr><tr><td data-label="Component / Section"> <strong>_sanitize_html_whitelist → label values</strong>            </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> If <code>labels.json</code> contains caption strings that might include simple markup, <code>core_utils._sanitize_html_whitelist</code> is a safe no-op placeholder. <strong>Important:</strong> do <strong>not</strong> use this as a sanitizer for untrusted labels. Instead, pass label values through the real sanitizer (if available) before insertion. Design decision: keep core_utils lightweight; sanitization happens at render/sanitize layer.                                   </td></tr><tr><td data-label="Component / Section"> <strong>_sri_attr → asset-labeled entries in labels.json</strong>   </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> If <code>labels.json</code> contains asset references (e.g., <code>asset_labels</code> mapping → CSS/JS assets), <code>_sri_attr</code> helps when rendering link/script tags by attaching known integrity attributes. Note: mapping keys must match exactly; consider resolving fingerprinted names before calling <code>_sri_attr</code>.                                                                                                                                              </td></tr><tr><td data-label="Component / Section"> <strong>_frag_contains_rows → label-to-fragment validation</strong> </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> After generating fragments for tables, use <code>_frag_contains_rows(fragment_html)</code> to decide whether a <code>labels.json</code> entry referring to a fragment id should be included in the TOC or skipped. Edge case: regex false negatives for unusual markup; use parser-based check if accuracy required.                                                                                                                                               </td></tr><tr><td data-label="Component / Section"> <strong>_take_and_stream → loading label lists</strong>             </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> When loading lists of labeled entries (e.g., optional <code>labels.json</code> that includes arrays of table keys or CSV-derived label lists), call <code>_take_and_stream</code> to sample first N entries for diagnostics while preserving the iterator for further processing. Important for memory-safety when labels are ingested from streaming sources.                                                                                                     </td></tr><tr><td data-label="Component / Section"> <strong>iterable safety when merging labels</strong>                </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> <code>core_utils</code> helpers enable safe merging of programmatic label sources (generator of <code>(key, caption)</code> pairs) with a <code>labels.json</code> file: sample via <code>_take_and_stream</code>, normalize keys via <code>_sanitize_id</code>, and then merge with deterministic last-wins or explicit conflict policy implemented at higher-level.                                                                                                                               </td></tr><tr><td data-label="Component / Section"> <strong>ID collisions & deterministic suffixing</strong>            </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> Use <code>_sanitize_id</code> result as canonical base; higher layer should detect duplicates after sanitization and apply deterministic suffixing (<code>-1</code>, <code>-2</code>) — <code>core_utils</code> intentionally returns consistent values so conflict resolution can be deterministic and testable.                                                                                                                                                                        </td></tr><tr><td data-label="Component / Section"> <strong>Label key ↔ heading mapping strategy</strong>               </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> Recommended pattern: <code>label_key = _sanitize_id(safe_slug(normalize_whitespace(heading_text)))</code>. <code>core_utils._sanitize_id</code> is the last normalization step to ensure keys are safe for both DOM ids and JSON keys. Ensure both HTML generation and <code>labels.json</code> creation use identical pipeline.                                                                                                                                              </td></tr><tr><td data-label="Component / Section"> <strong>Robust duplicate detection for captions</strong>            </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> For caption comparison against existing DOM text, <code>core_utils</code> provides basic normalization helpers (whitespace collapse via <code>normalize_whitespace</code> equivalent). Use these to normalize both label values and DOM caption text before equality checks to avoid false negatives caused by spacing/escape differences.                                                                                                                         </td></tr><tr><td data-label="Component / Section"> <strong>Path & write safety for labels.json modifications</strong>  </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> When updating <code>labels.json</code> (e.g., automated tooling that emits new labels), sanitize target path and prefer atomic writers from <code>io_utils</code> (or higher-level atomic write wrappers). <code>core_utils._sanitize_output_path</code> helps to avoid accidental invalid filenames but is not a substitute for atomic write.                                                                                                                                </td></tr><tr><td data-label="Component / Section"> <strong>Diagnostics & dry-run</strong>                              </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> Use <code>_take_and_stream</code> to preview labels being applied and produce diagnostics without mutating files. Combine with a <code>dry_run</code> flag in higher layers so label-to-HTML mapping can be validated (samples only) before committing changes to <code>labels.json</code> or HTML files.                                                                                                                                                                     </td></tr><tr><td data-label="Component / Section"> <strong>Unit-test hooks</strong>                                    </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> Because <code>core_utils</code> functions are tiny and deterministic, unit tests should: canonicalize headings → expected keys; simulate generator label sources and verify <code>_take_and_stream</code> preserves remainder; verify <code>_frag_contains_rows</code> behavior on sample fragments so label inclusion logic is reliable. Tests lock in the mapping behavior between headings and <code>labels.json</code> keys.                                                         </td></tr><tr><td data-label="Component / Section"> <strong>Security & sanitizer handoff</strong>                       </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> <code>core_utils</code> intentionally avoids heavy sanitization. Labels must be sanitized in render/sanitizer module prior to insertion into DOM or JSON outputs. Never write raw untrusted labels into HTML using only <code>_sanitize_html_whitelist</code>.                                                                                                                                                                                                     </td></tr><tr><td data-label="Component / Section"> <strong>Performance considerations</strong>                         </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> <code>labels.json</code> is small; <code>core_utils</code> functions are O(len(input)) for tiny inputs. When mass-applying labels to many large fragments, cache sanitized/normalized keys to avoid repeated regex work. Use <code>_frag_contains_rows</code> selectively (cheap) and parser-based checks only when necessary.                                                                                                                                                </td></tr><tr><td data-label="Component / Section"> <strong>Operational recommendation</strong>                         </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> Enforce a canonical normalization pipeline used by both the label producer and consumer: <code>normalize_whitespace → safe_slug → _sanitize_id</code> and store the canonical key in <code>labels.json</code>. Keep <code>labels.json</code> in version control and validate via CI using <code>_take_and_stream</code> and sample fragment checks.                                                                                                                                      </td></tr><tr><td data-label="Component / Section"> <strong>toc_manager.py</strong>                                     </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> <strong>Not present in project tree</strong> — next file. No analysis possible until provided.                                                                                                                                                                                                                                                                                                                                                            </td></tr><tr><td data-label="Component / Section"> <strong>Final verification</strong>                                 </td><td data-label="Description, Behavior, Notes, Edge Cases, Design Decisions (labels.json / toc_manager focus)"> Checked <strong>10×</strong> for consistency between core_utils primitives and label/TOC responsibilities. Recommendations: adopt shared normalization pipeline, sanitize labels at render layer, use atomic writes for label persistence, and add tests that assert mapping invariants.                                                                                                                                                                  </td></tr></tbody></table></div><div class="row-count">Rows: 19</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>