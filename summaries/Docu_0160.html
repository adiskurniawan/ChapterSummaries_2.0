<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1766816637">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0160_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modSecurity)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modSecurity)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Overview:</strong> Exhaustive, per-function technical breakdown of <code>modSecurity</code> (VBA). Each entry documents: purpose, signature (inputs/outputs), internal behavior, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended tests, and maintainers' notes. Use this as authoritative inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Constants / Configuration</strong> — <em>module-level constants and defaults</em><br><strong>Purpose:</strong> Centralize magic values and defaults used by security helpers (audit procedure name, config proc names, export policy key, timeouts, sheet names, length caps).<br><strong>Signature:</strong> (module-level constants; no runtime parameters).<br><strong>Behavior:</strong> Provide stable values for callers and internal helpers. Constants influence behavior of audit, prompt timeouts, message truncation, self-test iterations, and export-policy checks.<br><strong>Complexity:</strong> O(1) – constant access.<br><strong>Side-effects:</strong> None directly; changing constants alters runtime behavior across functions.<br><strong>Invariants:</strong> Constants are read-only at runtime; tests assume these values (e.g., <code>AUDIT_MESSAGE_MAX_LEN = 1000</code>).<br><strong>Failure modes:</strong> Mis-tuned timeouts (too low) may prematurely abort long operations; incorrect audit proc name causes audit delegation to fall back to local append.<br><strong>Security:</strong> Keep names of external handlers current; ensure <code>AUDIT_PROC_NAME</code> matches host implementation. Do not expose secret values here.<br><strong>Tests:</strong> Validate constants used by functions (self-test uses <code>SELFTEST_ITER</code>).<br><strong>Notes:</strong> When changing defaults, increment module test coverage and communicate backward compatibility to integrators. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_CheckWorkbookSignature</strong> — <em>workbook signature presence check</em><br><strong>Purpose:</strong> Determine if workbook has at least <code>minSignatures</code> digital signatures; audit the result.<br><strong>Signature:</strong> <code>Security_CheckWorkbookSignature(Optional ByVal minSignatures As Long = DEFAULT_MIN_SIGNATURES) -&gt; Boolean</code><br><strong>Behavior:</strong> Returns False early if workbook unavailable. Reads <code>ThisWorkbook.Signatures.count</code> defensively (uses <code>On Error Resume Next</code> around COM property access). Compares count to <code>minSignatures</code>. Generates correlation id and calls <code>Security_Audit</code> with count and boolean result. On exceptions, calls <code>Security_HandleError</code> and returns False.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Audit entry produced. May swallow COM errors silently for resilience.<br><strong>Invariants:</strong> Never throws to caller; always returns Boolean. If workbook unavailable returns False.<br><strong>Failure modes:</strong> Office hosts without <code>Signatures</code> support return error which is swallowed and treated as zero signatures. False negatives possible on platforms where Signatures property is inaccessible.<br><strong>Security considerations:</strong> Does not read signature content (only count). Audit message contains numeric count only. Ensure audit redaction doesn't accidentally log signature metadata.<br><strong>Recommended tests:</strong> 1) workbook with 0/1/2 signatures; 2) host where <code>Signatures</code> raises; 3) minSignatures variants; 4) confirm audit row created (or delegated).<br><strong>Notes for maintainers:</strong> Keep defensive <code>On Error</code> pattern when accessing possibly-missing COM members; if adding signature content checks, ensure no secret data is persisted. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_IsVBAProjectProtected</strong> — <em>VBA project protection probe</em><br><strong>Purpose:</strong> Query <code>ThisWorkbook.VBProject.Protection</code> to check if VB project is password-protected / locked; return <code>CVErr(xlErrNA)</code> if not determinable.<br><strong>Signature:</strong> <code>Security_IsVBAProjectProtected() -&gt; Variant</code> (returns protection value or <code>CVErr(xlErrNA)</code>).<br><strong>Behavior:</strong> Returns <code>xlErrNA</code> when workbook unavailable or access denied. Uses <code>On Error Resume Next</code> to catch access restrictions (host security, trust center). Audits the observed protection value or <code>NA</code> result. On unexpected exception, funnels to <code>Security_HandleError</code> and returns <code>xlErrNA</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Audit entry. Does not mutate workbook.<br><strong>Invariants:</strong> Caller must treat <code>CVErr(xlErrNA)</code> as "unknown / not applicable".<br><strong>Failure modes:</strong> Access to <code>VBProject</code> often blocked by host; result will be NA rather than raising for callers. False negatives when host denies access.<br><strong>Security:</strong> Does not reveal sensitive project contents. Audit must not include protected code content.<br><strong>Tests:</strong> Simulate accessible and inaccessible <code>VBProject</code> contexts (e.g., trust center locked). Ensure no unhandled errors. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_VerifyMacroSettings</strong> — <em>AutomationSecurity check</em><br><strong>Purpose:</strong> Check <code>Application.AutomationSecurity</code> to ensure macros are not forcibly disabled (AutomationSecurity <> 2).<br><strong>Signature:</strong> <code>Security_VerifyMacroSettings() -&gt; Boolean</code><br><strong>Behavior:</strong> Reads <code>Application.AutomationSecurity</code>. Returns True if not equal to 2 (i.e., macros are allowed/possible). Audits the numeric setting and the boolean 'ok' result. On error, handles via <code>Security_HandleError</code> and returns False.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Audit entry.<br><strong>Invariants:</strong> Always returns Boolean. Rarely provides actionable remediation beyond logging.<br><strong>Failure modes:</strong> Some hosts may present non-standard <code>AutomationSecurity</code> values; treat unknown values as not-ok and log. Caller should not rely on this alone to determine macro safety — it is a heuristic.<br><strong>Security:</strong> No secrets; used to detect hostile macro configuration. <br><strong>Tests:</strong> Mock <code>Application.AutomationSecurity</code> values 0/1/2; assert return and audit. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_IsUserAdmin</strong> — <em>best-effort local admin detection</em><br><strong>Purpose:</strong> Best-effort detection whether current user belongs to local Administrators group by executing <code>whoami /groups</code> (Windows) and scanning for 'administrators'.</br><strong>Signature:</strong> <code>Security_IsUserAdmin() -&gt; Boolean</code><br><strong>Behavior:</strong> Returns False early for non-windows hosts or when <code>whoami</code> pipeline unavailable. Calls <code>Security_RunCmdAndGetOutput(&quot;whoami /groups&quot;)</code> and searches its lowercase output for substring <code>administrators</code>. Uses defensive error handling. Produces audit entries (when detected or not). Default to False when uncertain.<br><strong>Complexity:</strong> O(output length) where output is <code>whoami</code> result; effectively O(n).<br><strong>Side-effects:</strong> Calls <code>Security_RunCmdAndGetOutput</code> which may spawn WSH Exec; logs audit. On Mac, path is skipped and an audit 'skipped_platform_mac' produced.<br><strong>Invariants:</strong> Never throws; returns Boolean.<br><strong>Failure modes:</strong> False negatives when <code>whoami</code> missing or output language/localization differs (non-English group names). False positives if output contains the string in an unrelated context. <br><strong>Security/privacy:</strong> Does not leak PII—only logs boolean outcome; avoid logging full <code>whoami</code> output. <br><strong>Tests:</strong> Windows host with admin and non-admin accounts; mocked <code>Security_RunCmdAndGetOutput</code> returning varying outputs including localized group names; ensure fallback behavior. <br><strong>Notes:</strong> Consider later improving by checking SID membership rather than plaintext substring to avoid localization issues. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_AllowExportToPath</strong> — <em>policy-based export path allowlist</em><br><strong>Purpose:</strong> Check whether <code>targetPath</code> is allowed for exports based on configured CSV allowlist (<code>Config_Get</code>), or default to workbook path when no config provided.<br><strong>Signature:</strong> <code>Security_AllowExportToPath(ByVal targetPath As String) -&gt; Boolean</code><br><strong>Behavior:</strong> Returns False when target empty. Calls delegated <code>Application.Run(CONFIG_GET_PROC, DEFAULT_EXPORT_ALLOW_KEY)</code> defensively; if empty, falls back to <code>ThisWorkbookPathFallback()</code> as allowed root. Normalizes both target and root with <code>NormalizePath()</code> and tests hierarchical containment with <code>Security_PathIsUnder</code>. If config present, splits CSV and checks each entry. Audits normalized path and allow boolean. Exceptions funnel to <code>Security_HandleError</code> and result False.<br><strong>Complexity:</strong> O(k) where k = number of configured roots; normalization cost O(len(path)).<br><strong>Side-effects:</strong> Audit entry. Reads external config via <code>Application.Run</code> (side-effect depends on that proc).<br><strong>Invariants:</strong> Comparisons are case-insensitive and folder-semantics aware due to NormalizePath ensuring trailing slash. <br><strong>Failure modes:</strong> Malformed CSV entries; relative paths from config might yield unexpected normalization; config proc missing → fallback to workbook path. <br><strong>Security:</strong> Prevents export to arbitrary paths; ensure <code>NormalizePath</code> canonicalization is robust to symlinks and junctions (on Windows symlinks/junctions can subvert path containment checks). Consider canonicalizing via Win32 API when available. <br><strong>Tests:</strong> 1) allowedCsv empty -> target within workbook path allowed, outside denied; 2) allowedCsv with multiple roots (with/without trailing slashes) – test containment boundaries; 3) paths with case differences; 4) symlink/junction tests if possible. <br><strong>Notes:</strong> Document that this is a best-effort check and may be bypassable by OS-level symlink tricks; for high-assurance deployments validate via privileged platform APIs. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_GetCredential</strong> — <em>credential retrieval with secure store preference and deprecated fallback</em><br><strong>Purpose:</strong> Retrieve a credential for <code>credKey</code> using Config_GetSecret when available; fall back to deprecated CustomXMLParts search (no logging of secret value), then interactive prompt if needed. Always audit only the key (redacted) and retrieval method — never the secret itself.<br><strong>Signature:</strong> <code>Security_GetCredential(ByVal credKey As String) -&gt; String</code> (empty string on not found/cancel).<br><strong>Behavior:</strong> 1) Validate key non-empty. 2) Try <code>Application.Run(CONFIG_GETSECRET_PROC, credKey)</code> under <code>On Error Resume Next</code>; if non-empty result, audit <code>method=store</code> and return it. 3) Iterate <code>ThisWorkbook.CustomXMLParts</code> searching for <code>&lt;CredentialKey&gt;credKey&lt;/CredentialKey&gt;</code>; if matched, extract <code>&lt;Value&gt;</code> content (string slicing) — <strong>do not log extracted secret</strong>; audit <code>customxml_deprecated</code> but with redacted key. 4) If still not found, call <code>Security_PromptForSecret</code> (unmasked InputBox) to ask user; if provided, audit <code>method=prompt</code> with redacted key and return it. Use defensive error handling; on exceptions call <code>Security_HandleError</code> and return empty string.<br><strong>Complexity:</strong> O(n_xml_parts * xml_size) for CustomXMLParts scan. Prompt path is user-blocking. <br><strong>Side-effects:</strong> May show InputBox to user; audit entries (only redacted meta); reading CustomXMLParts may trigger host security checks.<br><strong>Invariants:</strong> Never writes credential to audit or logs; only redacted key and method. Caller must treat returned string as sensitive and avoid persisting it insecurely. <br><strong>Failure modes:</strong> Config_GetSecret absent or failing; CustomXMLParts format mismatch causing extraction to fail; InputBox cancellation returns empty. <br><strong>Security/privacy:</strong> Strong emphasis: secrets never appear in audit. Interactive prompt is unmasked — caller should prefer secure store. Recommend implementing and encouraging secure secret store use. <br><strong>Tests:</strong> 1) Config_GetSecret returns value; 2) CustomXMLParts present with proper tags and with malformed XML; 3) InputBox cancel; 4) ensure no secret logged in AppendLocalAudit. <br><strong>Notes:</strong> Consider replacing InputBox with a masked credential dialog where host API allows. Deprecate CustomXMLParts storage with a migration helper that moves secrets into secure store. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_SetCredential</strong> — <em>store credential via secure store only; refuse insecure persistence</em><br><strong>Purpose:</strong> Persist credential via secure store (CONFIG_SETSECRET_PROC) when available; refuse to save if secure store not present (avoid insecure persistence). Audit only redacted key and method/result.<br><strong>Signature:</strong> <code>Security_SetCredential(ByVal credKey As String, ByVal credValue As String) -&gt; Boolean</code><br><strong>Behavior:</strong> Validate key non-empty. Call <code>Application.Run CONFIG_SETSECRET_PROC, credKey, credValue</code> under <code>On Error Resume Next</code>. If no error, mark ok True and audit <code>method=store</code>. If failing, audit <code>method=refused_no_store</code> and return False. On exception, call <code>Security_HandleError</code>. No attempt to persist to CustomXMLParts or cleartext persistence — explicit design decision.<br><strong>Complexity:</strong> O(1) to call store procedure. <br><strong>Side-effects:</strong> Delegated storage may have side-effects depending on store implementation. No local persistent writes performed by this function. <br><strong>Invariants:</strong> Never persists insecurely. <br><strong>Failure modes:</strong> Config set proc missing or raises; function returns False. <br><strong>Security:</strong> Prevents accidental storing of secrets in workbook; caller must handle unsuccessful storage accordingly. <br><strong>Tests:</strong> Mock CONFIG_SETSECRET_PROC success and failure; assert return value and that no secret appears in audit. <br><strong>Notes:</strong> Document failure modes for UX — callers should provide fallback guidance (e.g., "cannot save securely"). Consider returning richer error codes for UX later. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_RunCmdAndGetOutput</strong> — <em>WSH Exec wrapper with timeout & streaming</em><br><strong>Purpose:</strong> Run external command (Windows) via WScript.Shell Exec, stream StdOut lines up to <code>CMD_TIMEOUT_SEC</code>, return concatenated output. On Mac returns empty and logs skip. Audits execution summary but never logs raw command (redacted).<br><strong>Signature:</strong> <code>Security_RunCmdAndGetOutput(ByVal cmd As String) -&gt; String</code><br><strong>Behavior:</strong> Early-exit for empty cmd. If running on Mac: audit skip and return empty. Otherwise CreateObject("WScript.Shell"), call <code>Exec(cmd)</code> defensively. Loop reading <code>execObj.StdOut.ReadLine</code> while not <code>AtEndOfStream</code> and respecting <code>Timer - startT</code> timeout. Uses <code>DoEvents</code> and checks <code>execObj.status</code> for finish. On output non-empty, audit <code>output_len</code>; otherwise audit timed-out/no-output. Returns collected output string. Errors funnel to <code>Security_HandleError</code> and return empty. <br><strong>Complexity:</strong> O(output length) and limited by CMD_TIMEOUT_SEC runtime. <br><strong>Side-effects:</strong> Spawns WSH process (security-sensitive). May be blocked/disabled by host or anti-virus; must be used sparingly. <br><strong>Invariants:</strong> Returns empty string on failure. Does not throw. <br><strong>Failure modes:</strong> Exec unavailable, <code>StdOut</code> inaccessible, long-running command exceeding timeout, or <code>execObj</code> API differences across hosts. <br><strong>Security/privacy:</strong> Avoid logging command or full output in audit; current code audits only <code>output_len</code> or that exec failed. Ensure any additional telemetry excludes sensitive output. <br><strong>Tests:</strong> 1) successful small command; 2) long-running command timeout; 3) invalid command; 4) host without WScript support. Mocking Exec may be necessary. <br><strong>Notes:</strong> Consider using more robust process APIs when available; avoid executing untrusted input. If future requirement arises, add controlled whitelist for allowed commands. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_VerifyExportPathWritable</strong> — <em>try-create-temp-file writable probe</em><br><strong>Purpose:</strong> Verify write permission to a targetPath by attempting to create and delete a uniquely named temporary file in the parent folder; returns True if create succeeded (delete attempted).<br><strong>Signature:</strong> <code>Security_VerifyExportPathWritable(ByVal targetPath As String) -&gt; Boolean</code><br><strong>Behavior:</strong> Validate input, use <code>Scripting.FileSystemObject</code> to detect folder; if target looks like file, compute parent folder. If folder missing or not exists, return False. Build unique tmp name using GUID from <code>Scriptlet.TypeLib</code> if available, fallback to timestamp+rand. Compose test file path and <code>CreateTextFile(testFile, True)</code> -> write "ok" and close; attempt <code>DeleteFile</code>. If create succeeded, mark True even if delete later fails (still attempt cleanup). On errors, attempt cleanup in ErrHandler and return False. Audits normalized folder path and writable boolean. <br><strong>Complexity:</strong> O(1) file operations; underlying file system latency dominates. <br><strong>Side-effects:</strong> Creates and deletes a temp file in the target folder (observable by watchers). <br><strong>Invariants:</strong> If create succeeded but delete failed, function still returns True (acknowledges writable). <br><strong>Failure modes:</strong> Antivirus or file-lock preventing file creation or deletion, network share permissions, path normalization issues, race conditions. <br><strong>Security/privacy:</strong> Use conservative test content; avoid writing secrets. Temporary file creation may be visible to system logs — choose safe temporary naming conventions. <br><strong>Tests:</strong> 1) writable folder; 2) read-only folder; 3) non-existent folder; 4) network share with delayed delete semantics; 5) ensure cleanup attempted on error. <br><strong>Notes:</strong> For higher assurance, open file with exclusive lock and immediate delete if supported by host; consider using OS-level permission checks where available. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_SelfTest</strong> — <em>comprehensive deterministic self-tests</em><br><strong>Purpose:</strong> Run deterministic, repeated sanity checks over key security posture routines (macro settings, signatures, VBA protection, admin detection, export path writability) and write a minimal test result row to a hidden sheet for CI/Release checks.<br><strong>Signature:</strong> <code>Security_SelfTest() -&gt; Boolean</code><br><strong>Behavior:</strong> Generates cid; loops <code>SELFTEST_ITER</code> times and runs <code>Security_VerifyMacroSettings</code>, <code>Security_CheckWorkbookSignature</code>, <code>Security_IsVBAProjectProtected</code> (non-error), and <code>Security_IsUserAdmin</code> (audits admin=false if not admin). After loop, derives root path via <code>ThisWorkbookPathFallback</code> or environment fallbacks and checks <code>Security_VerifyExportPathWritable(root)</code>. Aggregates boolean <code>ok</code>. Calls <code>WriteSelfTestResult(correlationId, ok, SELFTEST_ITER)</code> and audits <code>SelfTestResult</code>. On exception funnels to <code>Security_HandleError</code> and returns False.<br><strong>Complexity:</strong> O(SELFTEST_ITER) calls to the underlying checks; dependent on each check complexity. <br><strong>Side-effects:</strong> Audits, writes into a hidden test results sheet (creating if absent). May produce prompt if <code>Security_GetCredential</code> path used elsewhere. <br><strong>Invariants:</strong> Deterministic loops ensure repeated-run stability for regression detection. <br><strong>Failure modes:</strong> False failures caused by environment differences (e.g., lack of Signatures property, VBProject access blocked). <br><strong>Security/privacy:</strong> Test results sheet is VeryHidden and contains correlationId and username; ensure this sheet is protected in automated pipelines to avoid leak. <br><strong>Tests:</strong> Run in varied environments (CI agent, dev laptop, locked-down VM) to ensure results reflect expected environment capabilities. <br><strong>Notes:</strong> Consider adding a boolean <code>SELFTEST_VERBOSE</code> flag for debug; ensure CI reads the VeryHidden sheet reliably (some CI runners may ignore hidden sheets). </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_Audit</strong> — <em>centralized audit forwarding with redaction and fallback</em><br><strong>Purpose:</strong> Attempt to delegate audit to external <code>LogAudit</code> proc (preferred signature: action, message, correlationId), falling back to <code>AppendLocalAudit</code> when delegation fails. Always redacts possible secrets with <code>RedactSecrets</code> and truncates long messages. Ensures an audit record exists even on errors.<br><strong>Signature:</strong> <code>Security_Audit(ByVal action As String, ByVal message As String, Optional ByVal cid As String = &quot;&quot;)</code> (Sub)<br><strong>Behavior:</strong> Compose <code>action | message</code>, call <code>RedactSecrets</code> then clamp to <code>AUDIT_MESSAGE_MAX_LEN</code>. Ensure <code>cid</code> exists or generate <code>NewCorrelationId</code>. Attempt <code>Application.Run AUDIT_PROC_NAME, action, shortMsg, usedCid</code> inside <code>On Error Resume Next</code>. If error, clear and call <code>AppendLocalAudit</code>. If any exception in Security_Audit itself, ErrHandler calls <code>AppendLocalAudit</code> with a short error description. <br><strong>Complexity:</strong> O(len(message)) for redaction. <br><strong>Side-effects:</strong> Calls external LogAudit if present; may create VeryHidden audit sheet. <br><strong>Invariants:</strong> Never logs raw secrets due to <code>RedactSecrets</code>. Always attempts to persist an audit record; tolerant of missing external proc. <br><strong>Failure modes:</strong> If <code>RedactSecrets</code> fails unexpectedly, fallback ensures local audit entry. <br><strong>Security/privacy:</strong> Strong redaction first step is essential; ensure <code>RedactSecrets</code> pattern catches real-world secret formats used in project. <br><strong>Tests:</strong> 1) LogAudit available and succeeds; 2) LogAudit raises and fallback to local append; 3) long message truncation; 4) message containing <code>password=xxx</code> results in <code>[REDACTED]</code> in stored message. <br><strong>Notes:</strong> When integrating with external logging backends, confirm their own retention/policy characteristics and encryption at rest. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>AppendLocalAudit</strong> — <em>local VeryHidden worksheet append</em><br><strong>Purpose:</strong> Append audit lines to module-named VeryHidden worksheet (<code>_IFRS_Audit</code>) when external audit delegate not available. Columns: Timestamp, CorrelationId, User, Action, Message.<br><strong>Signature:</strong> <code>AppendLocalAudit(ByVal action As String, ByVal correlationID As String, ByVal message As String)</code> (Private Sub)<br><strong>Behavior:</strong> If <code>ThisWorkbook</code> available, find or create the audit sheet (VeryHidden), create headers on first creation, find next row using <code>.Cells(.Rows.Count,1).End(xlUp).Row+1</code>, write timestamp, correlationID, Application.UserName, action, truncated message. Errors logged via <code>Debug.Print</code> when append fails. <br><strong>Complexity:</strong> O(1) amortized; may be O(n) scanning worksheets count to find sheet. <br><strong>Side-effects:</strong> Alters workbook by adding VeryHidden sheet (mutates workbook state). <br><strong>Invariants:</strong> Sheet created as <code>xlSheetVeryHidden</code> and header only created once. <br><strong>Failure modes:</strong> Protected workbook preventing sheet creation, lack of workbook handle, or COM errors. Function exits silently in such cases but attempts to log via Debug.Print. <br><strong>Security:</strong> Audit sheet contains username; in sensitive deployments ensure workbook storage policy prevents exfiltration. <br><strong>Tests:</strong> 1) Append when sheet exists; 2) Append when sheet absent -> sheet created; 3) workbook protected -> ensure graceful failure. <br><strong>Notes:</strong> Consider writing audits to an external secure store when available, rather than embedding in workbook for production use. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>WriteSelfTestResult</strong> — <em>write minimal CI-friendly test result row</em><br><strong>Purpose:</strong> Persist <code>Security_SelfTest</code> result into <code>_IFRS_TestResults</code> VeryHidden sheet with timestamp, correlationId, ok boolean, iterations, and user; used for CI/Release checks.<br><strong>Signature:</strong> <code>WriteSelfTestResult(ByVal correlationID As String, ByVal ok As Boolean, ByVal iterations As Long)</code> (Private Sub)<br><strong>Behavior:</strong> If workbook not available, exit. Find or create <code>TEST_RESULTS_SHEET_NAME</code> sheet (VeryHidden), create header row on new sheet, append row with fields. Errors <code>Debug.Print</code> on failure. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates workbook (adds hidden sheet). <br><strong>Invariants:</strong> Row appended at bottom. <br><strong>Failure modes:</strong> Protected workbook preventing sheet creation; ensure CI agents can read VeryHidden sheets. <br><strong>Security/privacy:</strong> Contains Application.UserName — CI systems must redact or secure workbook before upload. <br><strong>Tests:</strong> Run SelfTest and verify row appended with expected values; simulate protected workbook and assert graceful failure. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_PathIsUnder</strong> — <em>hierarchical path containment check</em><br><strong>Purpose:</strong> Determine if <code>path</code> is a descendant of <code>root</code> after normalization (case-insensitive, forward slashes, ensuring trailing slash semantics).<br><strong>Signature:</strong> <code>Security_PathIsUnder(ByVal path As String, ByVal root As String) -&gt; Boolean</code> (Private Function)<br><strong>Behavior:</strong> Validates inputs; lowercases and replaces <code>\</code> with <code>/</code>; appends trailing <code>/</code> to both; returns True if <code>Left$(pNorm, Len(rNorm)) = rNorm</code>. Defensive error handling returns False on exceptions. <br><strong>Complexity:</strong> O(len(path)+len(root)).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Both inputs normalized to end in <code>/</code>; uses textual containment only (no filesystem canonicalization). <br><strong>Failure modes:</strong> Symlinks, junctions, or path canonicalization differences can produce false positives/negatives. <br><strong>Security:</strong> Textual check insufficient against symlink attacks—document that this is a best-effort policy check. <br><strong>Tests:</strong> Cases with/without trailing slashes, case differences, deeper nested paths, sibling directories that partially match prefix. <br><strong>Notes:</strong> For Windows, consider resolving to canonical path (GetFinalPathNameByHandle) for higher assurance. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>NormalizePath</strong> — <em>normalize path strings for comparisons</em><br><strong>Purpose:</strong> Convert path string to forward-slash form, expand <code>~</code> on Mac, and ensure trailing slash to indicate folder semantics.<br><strong>Signature:</strong> <code>NormalizePath(ByVal p As String) -&gt; String</code> (Private Function)<br><strong>Behavior:</strong> Trim, replace <code>\</code> with <code>/</code>. On Mac, expand leading <code>~/</code> to <code>MacHomePathFallback()</code>. If resulting string non-empty and missing trailing <code>/</code>, append <code>/</code>. If empty, return empty string. Uses <code>On Error Resume Next</code> to be robust. <br><strong>Complexity:</strong> O(len(p)).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Output either empty string or ends with <code>/</code>. <br><strong>Failure modes:</strong> Does not canonicalize symlinks nor resolve <code>.</code>/<code>..</code> segments — caller should be aware. <br><strong>Security:</strong> Avoid trusting string-manipulated path for security-critical checks. <br><strong>Tests:</strong> Paths with backslashes, with/without trailing slashes, <code>~/</code> on Mac, empty input. <br><strong>Notes:</strong> Consider implementing <code>.</code>/<code>..</code> normalization and canonicalization if available. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_PromptForSecret</strong> — <em>ephemeral interactive secret prompt (unmasked)</em><br><strong>Purpose:</strong> Ask user for a secret via <code>Application.InputBox</code> (Type 2), auditing only that a prompt was shown (no secret content logged). Returns empty on cancel or error.<br><strong>Signature:</strong> <code>Security_PromptForSecret(ByVal prompt As String, Optional ByVal cid As String = &quot;&quot;) -&gt; String</code> (Private Function)<br><strong>Behavior:</strong> Ensure <code>cid</code> available, call <code>Security_Audit &quot;PromptForSecret&quot;,&quot;prompt_shown&quot;,cid</code>, show <code>Application.InputBox(prompt, &quot;Secret required&quot;, Type:=2)</code> returns string or False (boolean) on cancel; return empty string in cancellation case. On error, return empty. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Shows blocking InputBox to the user. <br><strong>Invariants:</strong> InputBox unmasked — caller warned in docs. <br><strong>Failure modes:</strong> InputBox may be disallowed in some hosts; ensure caller can handle empty return. <br><strong>Security/privacy:</strong> InputBox is not secure; strongly recommend secure store usage. Audit only notes that user was prompted. <br><strong>Tests:</strong> Simulate user input and cancel states; check that no secret is written to audit. <br><strong>Notes:</strong> Replace with masked credential prompt when host supports a secure credential dialog. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_HandleError</strong> — <em>robust, multi-signature error forwarding with audit fallback</em><br><strong>Purpose:</strong> Unified error funnel that attempts multiple <code>HandleError</code> invocation signatures (modern and legacy) then falls back to <code>Security_Audit</code> to ensure error is recorded; avoids leaking secrets by using <code>RedactSecrets</code> on error descriptions and includes a correlation id.<br><strong>Signature:</strong> <code>Security_HandleError(ByVal procName As String, ByVal errNum As Long, ByVal errDesc As String)</code> (Private Sub)<br><strong>Behavior:</strong> Generate <code>cid</code>, clamp and sanitize <code>errDesc</code>, redact secrets, replace newlines. Try <code>Application.Run &quot;HandleError&quot;, procName, errNum, safeDesc, cid</code> then legacy orders (<code>procName, errNum, errDesc</code>), numeric-first variant, single-string fallback. If all fail, call <code>Security_Audit &quot;Error&quot;, procName &amp; &quot;:&quot; &amp; safeDesc, cid</code> and <code>Debug.Print</code>. Always swallow errors during attempt to delegate. <br><strong>Complexity:</strong> O(len(errDesc)).<br><strong>Side-effects:</strong> Calls external <code>HandleError</code> hook if present; otherwise writes to local audit. <br><strong>Invariants:</strong> Always ensures an audit record remains and does not propagate exception further. <br><strong>Failure modes:</strong> If <code>RedactSecrets</code> fails to remove certain sensitive patterns, they could be stored in fallback audit — but code uses <code>RedactSecrets</code> first. <br><strong>Security/privacy:</strong> Core to preventing logs from containing secrets. Ensure <code>RedactSecrets</code> regex/pattern stays up-to-date. <br><strong>Tests:</strong> 1) <code>HandleError</code> present with modern signature; 2) legacy handler signatures; 3) absence of <code>HandleError</code> and ensure fallback audit. 4) errDesc containing a <code>password=...</code> is redacted. <br><strong>Notes:</strong> Keep ordering of attempted signatures to match host versions; add telemetry if necessary to count which signature path used in production. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>NewCorrelationId</strong> — <em>correlation id generator with GUID primary, timestamp fallback</em><br><strong>Purpose:</strong> Provide unique correlation IDs for audits and error flows. Try GUID from <code>Scriptlet.TypeLib</code>; fallback to deterministic timestamp+random string when GUID unavailable.<br><strong>Signature:</strong> <code>NewCorrelationId() -&gt; String</code> (Private Function)<br><strong>Behavior:</strong> Attempt <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code>, strip braces and lowercase; on failure <code>Randomize</code> then return <code>cid-yyyymmddHHNNSS-&lt;rand&gt;</code> formatted string. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Always returns a non-empty string. <br><strong>Failure modes:</strong> Unlikely; if both <code>Scriptlet.TypeLib</code> missing and system cannot provide <code>Now</code>, fallback still produces string. <br><strong>Security/privacy:</strong> Correlation ids are non-secret but should be unique. <br><strong>Tests:</strong> Call multiple times ensure uniqueness, format validation. <br><strong>Notes:</strong> Consider switching to platform GUID APIs for more robust IDs. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>WorkbookAvailable</strong> — <em>safe workbook handle check</em><br><strong>Purpose:</strong> Verify provided <code>wb</code> object is not Nothing and usable without raising errors.<br><strong>Signature:</strong> <code>WorkbookAvailable(ByVal wb As Workbook) -&gt; Boolean</code> (Private Function)<br><strong>Behavior:</strong> Returns False if <code>wb</code> is Nothing or COM access raises. Defensive. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Simple null-check abstraction to centralize safe workbook access. <br><strong>Failure modes:</strong> None beyond COM failures which are caught. <br><strong>Tests:</strong> Null and valid workbook references. <br><strong>Notes:</strong> Use wherever direct <code>ThisWorkbook</code> is accessed to reduce duplication. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>LooksLikeFolder</strong> — <em>heuristic to decide folder vs file path</em><br><strong>Purpose:</strong> Heuristic boolean: treat trailing slash as folder; otherwise if last dot after last slash exists treat as file; else folder. <br><strong>Signature:</strong> <code>LooksLikeFolder(ByVal path As String) -&gt; Boolean</code> (Private Function)<br><strong>Behavior:</strong> Returns False for empty; True if trailing separator; else compute positions of last slash and last dot and compare to infer file vs folder. Uses <code>On Error Resume Next</code>. <br><strong>Complexity:</strong> O(len(path)).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Heuristic only — may misclassify names containing dots but representing folders. <br><strong>Failure modes:</strong> Ambiguous paths (e.g., 'C:\folder.name\') might be misclassified if no trailing slash provided. <br><strong>Security:</strong> Solely used to pick parent folder for write test; errors could lead to testing parent folder incorrectly. <br><strong>Tests:</strong> Paths with/without trailing slash, filenames with multiple dots, paths with no slashes. <br><strong>Notes:</strong> Where possible prefer using FSO object to detect <code>FolderExists</code> vs <code>FileExists</code> for higher accuracy. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>ThisWorkbookPathFallback</strong> — <em>robust fallback for workbook path discovery</em><br><strong>Purpose:</strong> Return <code>ThisWorkbook.path</code> when available; else fallback to environment variables <code>USERPROFILE</code> or Mac home fallback, then default to <code>&quot;C:\&quot;</code> as last-resort.<br><strong>Signature:</strong> <code>ThisWorkbookPathFallback() -&gt; String</code> (Private Function)<br><strong>Behavior:</strong> Defensive access to <code>ThisWorkbook.path</code>. If empty, use <code>Environ$(&quot;USERPROFILE&quot;)</code>, then <code>MacHomePathFallback()</code> on Mac, else <code>&quot;C:\&quot;</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Returns non-empty string except in extreme env misconfiguration. <br><strong>Failure modes:</strong> Environment variables missing or empty; returns <code>C:\</code> which may be inappropriate on some systems — callers should consider OS. <br><strong>Tests:</strong> When ThisWorkbook has path, when not (unsaved workbook), on Mac with HOME env absent. <br><strong>Notes:</strong> Consider returning fully normalized path (call <code>NormalizePath</code>) to ensure trailing slash semantics downstream. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>IsMac / MacHomePathFallback</strong> — <em>platform helpers</em><br><strong>Purpose:</strong> <code>IsMac()</code> tests Application.OperatingSystem string for "Mac". <code>MacHomePathFallback()</code> returns <code>Environ$(&quot;HOME&quot;)</code> or <code>/Users</code> fallback. <br><strong>Signature:</strong> <code>IsMac() -&gt; Boolean</code>, <code>MacHomePathFallback() -&gt; String</code><br><strong>Behavior:</strong> <code>IsMac</code> uses InStr on <code>Application.OperatingSystem</code>. <code>MacHomePathFallback</code> reads <code>HOME</code> env and defaults to <code>/Users</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> These are simple heuristics and may not cover all host variants. <br><strong>Failure modes:</strong> <code>Application.OperatingSystem</code> string variation could miss <code>Mac</code> substring; robust enough for mainstream Office on Mac. <br><strong>Tests:</strong> Simulate different OperatingSystem strings; ensure fallback path returned. <br><strong>Notes:</strong> Consider centralizing platform detection in a single cross-module utility. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>RedactSecrets</strong> — <em>regex-based redaction of credential-like tokens</em><br><strong>Purpose:</strong> Remove or replace common credential patterns (e.g., <code>password=</code>, <code>token=</code>, <code>apikey=</code>) with <code>[REDACTED]</code> to avoid leaking secrets in audit/error messages.<br><strong>Signature:</strong> <code>RedactSecrets(ByVal txt As String) -&gt; String</code> (Private Function)<br><strong>Behavior:</strong> Primary path uses <code>VBScript.RegExp</code> with case-insensitive global pattern capturing <code>key[:=]VALUE</code> where VALUE contains no whitespace/comma/semicolon; replaces value with <code>[REDACTED]</code>. Fallback naive scanner replaces known substrings and trims until next space/comma/semicolon. Returns redacted string. <br><strong>Complexity:</strong> O(len(txt)) for regex replace or scan. <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Must not alter non-sensitive content except matched patterns. <br><strong>Failure modes:</strong> Regex may not exist in some minimal hosts (fallback used). Pattern might miss secrets with whitespace or multiline formats or XML-encoded secrets; ensure tests include multiple secret encodings. Over-redaction risk: replace legitimate tokens that match pattern. <br><strong>Security/privacy:</strong> Critical function — false negatives leak secrets; false positives degrade usefulness of logs. Keep the pattern updated to match new key names used in the project (documented whitelist/blacklist). <br><strong>Tests:</strong> 1) typical <code>password=abc123</code> -> <code>password=[REDACTED]</code>; 2) <code>token:eyJ..</code> -> redacted; 3) secrets with trailing punctuation; 4) multiline inputs; 5) ensure fallback path yields same redaction when RegExp unavailable. <br><strong>Notes:</strong> Consider expanding pattern to capture XML attributes, JSON <code>{&quot;password&quot;:&quot;...&quot;}</code>, and <code>Authorization: Bearer ...</code> headers. Add unit tests for all formats seen in telemetry. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>RedactKey</strong> — <em>redact short key names for audit metadata</em><br><strong>Purpose:</strong> Produce a redacted representation of a credential key for audit entries (show small prefix and suffix, mask the middle).<br><strong>Signature:</strong> <code>RedactKey(ByVal key As String) -&gt; String</code> (Private Function)<br><strong>Behavior:</strong> If length <= 6, show first char then <code>*</code> repeated; else show first 2 chars, <code>*</code>*(len-4), last 2 chars. Defensive <code>On Error Resume Next</code>. <br><strong>Complexity:</strong> O(len(key)).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Output length equals input length. <br><strong>Failure modes:</strong> Very short keys produce minimal information; acceptable. <br><strong>Tests:</strong> Keys of lengths 1..10; ensure patterns match expectations. <br><strong>Notes:</strong> This is acceptable for audit metadata; do not use for security-critical decisions. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Module-level maintenance notes & recommended improvements</strong><br>1. <strong>Canonical path resolution:</strong> <code>Security_PathIsUnder</code> uses textual checks; consider adding canonical path resolution (Win32 <code>GetFinalPathNameByHandle</code>) to prevent symlink/junction escape. Document fallback behavior. <br>2. <strong>Masked prompt:</strong> Replace <code>Application.InputBox</code> with a masked credential dialog if host supports credential APIs — avoid unmasked InputBox for secrets. <br>3. <strong>Redaction coverage:</strong> Expand <code>RedactSecrets</code> to JSON, XML, Authorization headers; maintain test vectors. <br>4. <strong>Worker/host differences:</strong> Many functions use <code>On Error Resume Next</code> when accessing COM members that may be unavailable on different Office hosts (Mac/online). Keep tests across target hosts (Windows desktop, Mac desktop, Office Online when applicable) and document differences. <br>5. <strong>Audit storage policy:</strong> For production, prefer encrypted centralized audit (LogAudit) over workbook-local <code>VeryHidden</code> sheets. Ensure <code>LogAudit</code> retention, encryption, and access policy are audited. <br>6. <strong>Credential store integration:</strong> Encourage adding a migration helper to move deprecated CustomXMLParts secrets into secure store with user consent. <br>7. <strong>Testing:</strong> Add automated unit tests (where possible) and CI job that runs <code>Security_SelfTest</code> on a controlled runner that has access to write hidden sheets. <br>8. <strong>Correlation id consistency:</strong> Pass correlation id through higher-level flows to correlate audit and error logs across modules. <br>9. <strong>Telemetry:</strong> Add counters (debug-only) to record how often fallback branches are used (e.g., <code>LogAudit</code> missing, <code>Scriptlet.TypeLib</code> GUID fallback) — surfaced only in debug builds. <br>10. <strong>Documentation:</strong> Maintain developer-facing README summarizing host compatibility (which functions degrade on Mac/Online), and required external procs (<code>LogAudit</code>, <code>Config_GetSecret</code>, <code>Config_SetSecret</code>, <code>HandleError</code>). </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Recommended test matrix (concise)</strong><br>- Platforms: Windows Desktop Office (multiple versions), MacOffice, Online (if feature parity).<br>- Scenarios:<br>  • No external delegates present (LogAudit, Config_GetSecret/SetSecret, HandleError) → verify all fallbacks (AppendLocalAudit, prompt refused/no-store behavior, Security_HandleError fallback).<br>  • Secure store present → GetCredential/SetCredential success flows and audit entries (no secret content).<br>  • CustomXMLParts present with correct and malformed XML → ensure extraction but no secret logging. <br>  • <code>whoami</code> outputs: english & localized, missing <code>whoami</code> command → admin detection robustness. <br>  • Export path policy: CSV rules, single root fallback, symlink/junction escape attempts (if possible).<br>  • File system write tests: writable, readonly, network share conditions, deletion failure. <br>  • Error handling: force <code>HandleError</code> variants to exercise signature fallbacks. <br>  • Redaction: test JSON, XML, header, and inline cases. <br>  • SelfTest run in CI agent and local dev machine. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security & compliance checklist (practical)</strong><br>- Ensure <code>LogAudit</code> endpoint enforces encryption and retention policies.<br>- Avoid storing any plaintext secrets in workbook CustomXMLParts — provide migration tool.<br>- Limit <code>Security_RunCmdAndGetOutput</code> usage to trusted, whitelisted commands; document and audit its use.<br>- Ensure audit sheet(s) are excluded from customer deliverables or encrypted when shipped.<br>- Validate <code>RedactSecrets</code> patterns against real telemetry samples under controlled environment before trusting automatic redaction. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Final summary (one paragraph)</strong><br>The <code>modSecurity</code> module implements a conservative set of security helpers focused on: detection of macro/signature/VBA-protection state, secure credential retrieval with a strong preference for delegated secure stores, safe export-path policy checks, writeability probing, centralized audited error handling with robust redaction, and deterministic self-tests that persist minimal results for CI. The module favors defensive <code>On Error</code> patterns and fallback behaviors (delegation to external procs with local VeryHidden-sheet fallbacks). Key limitations: textual path containment (not canonicalized), unmasked InputBox fallback for secrets, and heuristics for admin detection (localized <code>whoami</code> output). Recommended improvements are canonical path resolution, masked credential UI, expanded redaction rules, and stronger telemetry for fallback branches. </td></tr></tbody></table></div><div class="row-count">Rows: 30</div></div><div class="table-caption" id="Table2" data-table="Docu_0160_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modStatements.bas)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modStatements.bas)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>Overview:</strong> This table provides an exhaustive, per-function technical breakdown of the <code>modStatements</code> VBA module you provided. For each routine it documents: purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security/host considerations, recommended tests, and maintenance notes. Use it as authoritative inline documentation for reviewers, auditors, and QA. This is deliberately exhaustive and precise. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>AssembleStatementPackage(packageID, sourceLines, [templateName], [author])</strong> — <em>construct statement package object</em><br><strong>Purpose:</strong> Build a canonical package object (Scripting.Dictionary) representing a statement package with metadata and normalized line items. Designed to be defensive and safe to call during deferred init and ribbon jobs.<br><strong>Signature:</strong> <code>AssembleStatementPackage(ByVal packageID As String, ByVal sourceLines As Variant, Optional ByVal templateName As String = &quot;&quot;, Optional ByVal author As String = &quot;&quot;) As Object</code> — returns Dictionary-like object on success, <code>Nothing</code> on fatal error.<br><strong>Behavior:</strong> Creates Dictionary; sets PackageID, CorrelationID using <code>SafeNewCorrelationID</code>, SchemaVersion constant, TemplateName, Author (falls back to <code>Application.UserName</code> if blank), CreatedUTC via <code>SafeGetUtcIsoTimestamp</code>, Lines via <code>NormalizeLines(sourceLines)</code>, and Status="Assembled". Logs via <code>SafeLog</code> with line count. Returns package object. Wrapped in <code>On Error</code> with <code>SafeHandleError</code> and returns <code>Nothing</code> on error.<br><strong>Complexity:</strong> O(N) where N is number of source lines due to normalization copy. Overhead small for metadata operations.<br><strong>Side-effects:</strong> Calls <code>SafeNewCorrelationID</code>, <code>SafeGetUtcIsoTimestamp</code>, and <code>SafeLog</code> which may call host helpers or append audits; may read <code>Application.UserName</code>.<br><strong>Invariants:</strong> Returned package has <code>Lines</code> as either 1-based array or Empty per <code>NormalizeLines</code>. <code>SchemaVersion</code> equals <code>STATEMENT_PACKAGE_SCHEMA</code> constant.<br><strong>Failure modes:</strong> Invalid <code>sourceLines</code> may be wrapped into single-element array by <code>NormalizeLines</code>. Host helper failures are tolerated via Safe* wrappers; only catastrophic VB runtime errors result in <code>Nothing</code> being returned.<br><strong>Security/Host:</strong> No secrets. Uses host probes (<code>NewCorrelationID</code>) if present. Audit may record package metadata; ensure host audit policy avoids PII capture.<br><strong>Recommended tests:</strong> Supply arrays, Dictionary, single-item scalars, empty inputs; assert correct Lines normalization, Author fallback, CreatedUTC format, and that function returns object not <code>Nothing</code> on normal inputs; introduce failure in <code>NewCorrelationID</code> host call to verify fallback ID form.<br><strong>Notes:</strong> Maintains public API; keep <code>SchemaVersion</code> stable for consumers. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>ValidateStatementPackage(pkg)</strong> — <em>validate package integrity and business rules</em><br><strong>Purpose:</strong> Produce a Dictionary of issues describing structural and business validation problems for a given package object (e.g., missing lines, missing LineID, non-numeric amounts, non-zero total beyond tolerance). Meant to be non-throwing and report all issues found.<br><strong>Signature:</strong> <code>ValidateStatementPackage(ByVal pkg As Object) As Object</code> — returns Dictionary of issueKey->message. If pkg is invalid, returns dictionary with relevant keys; on internal error returns <code>Nothing</code>.<br><strong>Behavior:</strong> Defensive checks in this order: nil pkg → "PackageMissing"; not object → "PackageInvalidType"; missing "Lines" → "LinesMissing". Retrieves <code>lines = pkg(&quot;Lines&quot;)</code>. If zero lines → add "NoLines". Iterates lines 1..GetLineCount(lines): ensures each line is dict-like (<code>IsDictLike</code>), tests presence of <code>LineID</code> (non-empty string) and numeric <code>Amount</code> (via <code>IsNumericDict</code>). Accumulates issues per-line (keys like "LineID_3"). After line checks computes <code>total</code> sum of Amounts via <code>NzDoubleDict</code>. If <code>Abs(total)</code> > <code>STATEMENT_BALANCE_TOLERANCE</code> adds "TotalNotZero" with formatted total. Logs via <code>SafeLog</code> and returns issues dictionary.<br><strong>Complexity:</strong> O(N) where N = number of lines. Numeric sum is linear.<br><strong>Side-effects:</strong> Calls <code>SafeLog</code>, <code>IsDictLike</code>, <code>Nz*</code> helpers. Non-mutating.<br><strong>Invariants:</strong> Always returns a Dictionary (possibly empty) when input is object; never mutates the package. A non-empty issues dictionary indicates at least one problem. Tolerance used for de minimis rounding is <code>STATEMENT_BALANCE_TOLERANCE</code> constant.<br><strong>Failure modes:</strong> If pkg has malformed Lines (non-array object) helpers still attempt to iterate robustly; catastrophic errors handled by ErrHandler returning <code>Nothing</code> and logging via <code>SafeHandleError</code>.<br><strong>Security/Host:</strong> No secrets; logs may include PackageID (sanitise if PII).<br><strong>Recommended tests:</strong> Valid balanced package, unbalanced package just within tolerance, invalid Amount types, missing LineID, non-dict line items, large lists to verify performance, host logging failures tolerance. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>RenderStatementToSheet(pkg, sheetName, [targetWb])</strong> — <em>render package lines to worksheet</em><br><strong>Purpose:</strong> Materialize a package into a worksheet table (headers + rows). Safe to call headlessly in background job. Uses defensive sheet creation and clearing without selecting/activating.<br><strong>Signature:</strong> <code>RenderStatementToSheet(ByVal pkg As Object, ByVal sheetName As String, Optional ByVal targetWb As Workbook = Nothing) As Boolean</code> — returns True on success, False on failure.<br><strong>Behavior:</strong> Resolve workbook via <code>ResolveWorkbook(targetWb)</code>. If wb or pkg missing → fail. Obtains worksheet via <code>SafeGetWorksheet</code>; if missing, creates via <code>SafeCreateSheet</code>. If worksheet exists, clears contents (<code>ws.Cells.Clear</code>) under <code>On Error Resume Next</code> to avoid errors. Writes header labels ("LineID","Label","Amount","Sign","AccountRefs","Notes") using a 1xN 2D array (<code>hdr2</code>) and sets row font bold. Iterates normalized <code>lines</code> and writes each row into successive rows starting at row 2 using Nz helpers and <code>JoinAccountRefs</code> for AccountRefs. Sets <code>pkg(&quot;Status&quot;) = &quot;Rendered&quot;</code>. Calls <code>SafeLog</code>. Returns True. On errors, uses <code>SafeHandleError</code> and returns False.<br><strong>Complexity:</strong> O(N) for N lines (worksheet writes are per-row cell assignments; consider bulk writes if performance required).<br><strong>Side-effects:</strong> Creates/deletes worksheets, clears existing sheet content, sets pkg status, invokes host APIs via workbook operations, may trigger Excel recalculation/UI events. Uses <code>SafeCreateSheet</code> which deletes existing same-named sheet before creating—this permanently removes any previous sheet with same name.<br><strong>Invariants:</strong> After success, worksheet contains header row and one row per line in package order. <code>pkg(&quot;Status&quot;)</code> updated to "Rendered". The function avoids Activate/Select patterns.<br><strong>Failure modes:</strong> Write permission or worksheet protection may cause failure. Large numbers of rows may be slow because cells are written individually; consider writing bulk arrays for performance. Sheet name collisions are handled by deleting existing sheet (careful: data loss) — callers should pass unique names or snapshots to avoid accidental deletion.<br><strong>Security/Host:</strong> Operation will modify workbook; ensure host/workbook state is appropriate. Avoid running on macro-protected or read-only workbooks.<br><strong>Recommended tests:</strong> Render small/large packages, sheet pre-exists case, protected sheet scenario, templateName differences, ensure <code>pkg(&quot;Status&quot;)</code> set. Test that existing sheet is cleared and replaced. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>CreateStatementSnapshot(pkg, [targetWb])</strong> — <em>create hidden snapshot sheet containing package lines + metadata</em><br><strong>Purpose:</strong> Capture package state into a uniquely-named, very-hidden worksheet for later restore/audit. Includes SnapshotUTC, CorrelationID, PackageID metadata and then writes header + lines starting at row 6/7. Returns created sheet name or empty string on failure.<br><strong>Signature:</strong> <code>CreateStatementSnapshot(ByVal pkg As Object, Optional ByVal targetWb As Workbook = Nothing) As String</code> — returns snapshot sheet name (actual sheet name) or <code>&quot;&quot;</code> on error/abort.<br><strong>Behavior:</strong> Validates pkg & resolves workbook. Builds <code>baseSnapName</code> as <code>STATEMENT_SNAPSHOT_PREFIX &amp; PackageID &amp; &quot;_&quot; &amp; SafeTimestampCompact()</code>. Calls <code>SafeCreateSheetUnique</code> to add sheet with unique name (veryHidden by default). Writes metadata at rows 1..3 (SnapshotUTC, CorrelationID, PackageID) using <code>SafeGetUtcIsoTimestamp</code> and pkg fields. Writes header at A6 and lines starting at row 7 using same per-line field writes as Render. Sets sheet.Visible = <code>xlSheetVeryHidden</code>. Logs and returns actual sheet name. Errors handled by <code>SafeHandleError</code> and returning empty string.<br><strong>Complexity:</strong> O(N) in number of lines. Additional overhead for unique name generation loop (bounded by 1000) in <code>SafeCreateSheetUnique</code>.<br><strong>Side-effects:</strong> Creates a new very-hidden sheet in workbook (persisted). This is intended for snapshot/reconciliation/audit; hidden sheets may be sensitive. Uses <code>SafeCreateSheetUnique</code> (which ensures no accidental deletion of existing data) rather than destructive delete.<br><strong>Invariants:</strong> Snapshot contains the exact <code>Lines</code> content at the time of invocation; CorrelationID and Timestamp included. Sheet name uses timestamp compact format for uniqueness.<br><strong>Failure modes:</strong> Lack of permission to add sheets, workbook being protected, naming collision beyond safety cap (k>1000) (then function may fail). Hidden sheets may be difficult to access for ordinary users; provide restore APIs. Large packages may hit Excel row limits; function does not check available rows; caller should ensure size is reasonable.<br><strong>Security/Host:</strong> Snapshot may contain sensitive accounting data; consider workbook encryption or restricted access. Audit trail (sheet) is stored inside workbook; be mindful of distribution/export.<br><strong>Recommended tests:</strong> Snapshot + restore round-trip (CreateStatementSnapshot then RestoreStatementSnapshot), verify visibility, test with duplicate PackageID invocations, test very large packages approaching sheet row limits. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>RestoreStatementSnapshot(snapshotSheetName, targetSheetName, [targetWb])</strong> — <em>restore snapshot sheet as visible sheet for inspection</em><br><strong>Purpose:</strong> Copy a hidden snapshot sheet into a visible worksheet and rename it to a requested name (with collision-handling) to let users inspect previously-saved package snapshots. Intended to be safe and idempotent (doesn't modify snapshot sheet).<br><strong>Signature:</strong> <code>RestoreStatementSnapshot(ByVal snapshotSheetName As String, ByVal targetSheetName As String, Optional ByVal targetWb As Workbook = Nothing) As Boolean</code> — returns True on success, False on failure.<br><strong>Behavior:</strong> Resolves workbook. Safely obtains source snapshot via <code>SafeGetWorksheet</code>. If missing, exit False. If a destination sheet with <code>targetSheetName</code> exists, deletes it (with <code>Application.DisplayAlerts = False</code>) to ensure copy can rename. Copies the snapshot sheet as a new sheet (src.Copy After:=wb.Worksheets(wb.Worksheets.count)) so that original remains untouched. Attempts to rename the copied sheet to <code>targetSheetName</code>; on name collision attempts <code>targetSheetName_&lt;k&gt;</code> with k incrementing up to safety cap 1000. Makes new sheet visible (<code>xlSheetVisible</code>) and logs. On error, <code>SafeHandleError</code> and return False.<br><strong>Complexity:</strong> O(1) for metadata + cost of workbook.Copy operation (Excel internal). Name-collision loop is bounded.<br><strong>Side-effects:</strong> May delete existing destination sheet (destructive). Copies snapshot content to new visible sheet. May change workbook sheet ordering.<br><strong>Invariants:</strong> Snapshot sheet remains unchanged. Restored sheet is visible and named as requested (or with appended _k suffix if needed).<br><strong>Failure modes:</strong> Copy operation might fail in protected workbooks, or when workbook has insufficient space/permissions. If attempted rename keeps failing beyond k>1000, fails to avoid infinite loop. If destination exists and deletion fails (locked/protected), operation fails; callers should confirm no important existing sheet uses the target name.<br><strong>Security/Host:</strong> Restore reveals potentially sensitive snapshot content; ensure user has permission. Recommend user confirms before overwriting existing sheets.<br><strong>Recommended tests:</strong> Restore with fresh target name, restore when target exists (ensure deletion), ensure snapshot remains unchanged, test rename collision path to ensure suffixing works. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>GenerateReconciliation(pkg, tbRange)</strong> — <em>map package lines to trial-balance values and compute diffs</em><br><strong>Purpose:</strong> For each line in <code>pkg(&quot;Lines&quot;)</code>, sum values from a provided table-range keyed by AccountRef (first column) and produce an array of rows [LineID, Amount, sumTb, Amount - sumTb]. Useful for reconciliation reports and variance analysis.<br><strong>Signature:</strong> <code>GenerateReconciliation(ByVal pkg As Object, ByVal tbRange As Range) As Variant</code> — returns a 2D Variant array (1..n,1..4) for n lines; returns <code>Array()</code> (empty) when no lines; returns <code>Empty</code> on error.<br><strong>Behavior:</strong> Defensive early exits if pkg or tbRange are Nothing. Builds dictionary <code>tb</code> mapping account string → aggregated Double by iterating tbRange rows: key = cell(r,1).value (string), value = sum of cell(r,2).value as double (with <code>NZDouble</code>). Normalizes <code>lines</code> from pkg and for each line calls <code>NormalizeRefsToArray</code> on "AccountRefs". If refs is array, iterates each ref element and accumulates <code>sumTb</code> adding tb(key) for keys found. If refs is scalar, treat as single key. For each package line writes into output rows: LineID, Amount, sumTb, difference. Uses <code>GetLineCount(lines)</code> for n. Logs via <code>SafeLog</code> and returns <code>out</code> array. On no lines returns <code>Array()</code> (zero-length). Errors handled via <code>SafeHandleError</code> and returns <code>Empty</code>.<br><strong>Complexity:</strong> O(R + N * M) where R is number of rows in tbRange, N = number of package lines, M = average number of refs per line. Typical costs are linear; account lookup is dictionary O(1).<br><strong>Side-effects:</strong> Calls <code>SafeLog</code>. Non-mutating to pkg or sheet.<br><strong>Invariants:</strong> Output array has same order as package lines and row count equals GetLineCount(lines). Each output row contains numeric values (0 for missing sums). If package has 0 lines returns empty array rather than Null/Empty to indicate nothing to reconcile.<br><strong>Failure modes:</strong> If tbRange has non-string account cells, keys are converted via <code>CStr</code> and trimmed; blank keys are skipped. Missing or malformed AccountRefs handled gracefully. If tbRange covers large ranges with many empty rows performance may be affected. If <code>GetLineCount(lines)</code> returns 0 returns <code>Array()</code> as per design.<br><strong>Security/Host:</strong> Reads worksheet values only. Ensure tbRange corresponds to correct trial balance area. <br><strong>Recommended tests:</strong> Small TB with duplicate accounts aggregated, lines with single/multiple refs, refs that don't match TB keys (sumTb=0), empty lines, very large TB. Ensure outputs numeric types and differences computed correctly. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>ExportSheetToCsv(sh, filepath)</strong> — <em>export used range of worksheet to CSV file</em><br><strong>Purpose:</strong> Emit the <code>UsedRange</code> of a worksheet to a CSV file on disk with conservative quoting/escaping and culture-independent decimal formatting (dots). Returns Boolean success flag. Intended as a lightweight file-export helper that avoids Excel SaveAs complexities.(Public function.)<br><strong>Signature:</strong> <code>ExportSheetToCsv(ByVal sh As Worksheet, ByVal filepath As String) As Boolean</code> — returns True on success, False on failure.<br><strong>Behavior:</strong> Guard clauses for <code>sh</code> and <code>filepath</code>. Uses <code>FreeFile</code> to open Output file. Acquires <code>ur = sh.UsedRange</code>. Computes startRow/startCol/maxRow/maxCol from <code>ur</code>. Iterates rows and columns: reads <code>v = sh.Cells(r,c).value</code>; formats to string: empty->"", numeric -> <code>CStr(v)</code> with decimal separator replaced by dot (<code>Replace(CStr(v), Application.DecimalSeparator, &quot;.&quot;)</code>), else <code>CStr(v)</code>. Escapes double quotes by doubling them. Wraps fields containing comma/quote/newline in quotes. Joins lineParts with commas and writes line with <code>Print #fnum, outLine</code>. Closes file and returns True. On errors uses <code>SafeHandleError</code> and ensures file closed in ErrHandler, returning False.<br><strong>Complexity:</strong> O(R*C) where R and C are dimensions of UsedRange. Filesystem write is linear in bytes output. Memory per-row is O(C) for lineParts array.<br><strong>Side-effects:</strong> Creates/overwrites <code>filepath</code> on local disk; writes textual CSV using system/Excel decimal separator awareness. Requires filesystem write permissions; may fail on locked paths.<br><strong>Invariants:</strong> Output uses <code>.</code> as decimal separator irrespective of user locale; quotes doubled per CSV rules; each output line has same number of comma-separated fields as maxCol. Newlines in cells are preserved inside quoted fields. Function closes file on both success and handled exceptions.<br><strong>Failure modes:</strong> Opening file may fail (permissions, locked file). Non-serializable cell types (e.g., objects) are coerced via <code>CStr</code> and may raise errors; these are caught and handled by ErrHandler. Large sheets cause large files; consider streaming/partitioning if memory constraints apply. If <code>UsedRange</code> is Nothing function returns False. Locale decimal conversion is handled but maybe lose precision for some specialized numeric formats (dates, currencies) that should be formatted explicitly if required.<br><strong>Security/Host:</strong> Writes to local file system — be careful with file paths and user access. Do not write to network file paths without confirming user permissions.<br><strong>Recommended tests:</strong> Export small table with numeric/strings/quotes/commas/newlines, export with non-standard decimal separator (simulate different Application.DecimalSeparator), test file overwrite protection and error handling when file is locked or path invalid. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>NormalizeLines(v)</strong> — <em>internal: produce 1-based array of line items from various input shapes</em><br><strong>Purpose:</strong> Accept many shapes for <code>sourceLines</code>: VB arrays, Dictionary (Dictionary.Items), Collection-like objects, generic objects enumerable via <code>For Each</code>, or single scalar; return either a 1-based array (1..n) when items exist, or <code>Empty</code> when no items. Intended to normalise callers' inputs to a stable line-array form used across public APIs.<br><strong>Signature:</strong> <code>Private Function NormalizeLines(ByVal v As Variant) As Variant</code> — returns 1-based array or Empty.<br><strong>Behavior:</strong> Multi-branch: If <code>IsArray(v)</code> then reindex to 1-based array copying elements. If <code>IsObject(v)</code> and <code>TypeName(v)=&quot;Dictionary&quot;</code> use <code>.Items</code> then reindex. Else if object with <code>.count</code> property use For Each to copy items into 1-based array. Fallback iterate <code>For Each</code> building array with <code>ReDim Preserve tmp(1 To count)</code> (rare). Error fallback wraps single value into 1-element array (SingleFallback) to guarantee a usable array for callers. Returns <code>Empty</code> for empty collections/arrays.<br><strong>Complexity:</strong> O(N) copying cost. Uses ReDim Preserve in fallback which is O(N^2) if many items; typical code paths use known counts to avoid repeated preserves.<br><strong>Side-effects:</strong> None external. Uses <code>On Error</code> fallbacks liberally to be robust against unusual object types.<br><strong>Invariants:</strong> Always returns either <code>Empty</code> (no items) or 1-based array (1..n). Preserves iteration order when possible (Dictionary.Items preserves insertion order in MS Scripting.Dictionary).<br><strong>Failure modes:</strong> If input is an object whose <code>For Each</code> enumerator raises errors, function catches and falls back to wrapping single value. If <code>TypeName(v)</code> returns unexpected values for unknown host objects, fallback still attempts <code>For Each</code> iteration. Very large input sizes might be slow if fallback using ReDim Preserve is used. <br><strong>Recommended tests:</strong> Arrays with 0-based and 1-based indexes, Dictionary inputs, Collection objects, single scalars, empty arrays, objects whose <code>.count</code> raises error. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>GetLineCount(v)</strong> — <em>internal: safe line count for normalized arrays</em><br><strong>Purpose:</strong> Return 0 for non-arrays/uninitialized arrays; return element count for 1-based arrays safely. Used widely so it must be reliable even when passed unusual Variants.<br><strong>Signature:</strong> <code>Private Function GetLineCount(ByVal v As Variant) As Long</code> — returns 0..Large.<br><strong>Behavior:</strong> If IsArray(v) then obtains LBound/UBound under <code>On Error Resume Next</code> to avoid errors on jagged/invalid arrays; returns <code>ub - lb + 1</code> if ub>=lb else 0. Non-array returns 0. Errors result in 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Never negative. Returns 0 for any non-array or ill-formed array.<br><strong>Failure modes:</strong> None; intentionally defensive. <br><strong>Recommended tests:</strong> Pass Empty, Null, scalar, 0-length arrays, normal 1..n arrays, 0-based arrays and arrays with invalid bounds. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>IsDictLike(v)</strong> — <em>internal: probe whether object behaves like dictionary</em><br><strong>Purpose:</strong> Decide whether a variant is dictionary-like (preferably <code>Scripting.Dictionary</code>) by safe probing of TypeName or presence of <code>.Exists</code> method without letting exceptions bubble up. Avoids false positives for unrelated objects.<br><strong>Signature:</strong> <code>Private Function IsDictLike(ByVal v As Variant) As Boolean</code> — returns True/False.<br><strong>Behavior:</strong> If not IsObject returns False. If <code>TypeName(v)=&quot;Dictionary&quot;</code> returns True. Else attempt <code>v.Exists(&quot;__IFRS_PROBE__&quot;)</code> under <code>On Error Resume Next</code>; if call does not raise error assume dict-like. Clears Err and returns boolean. Verbose error-safe probing to avoid runtime exceptions for objects lacking this method.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None beyond transient Err state clears.<br><strong>Invariants:</strong> True implies <code>DictHasKey</code> and <code>Nz*</code> helpers will function sensibly.<br><strong>Failure modes:</strong> Some objects may implement <code>Exists</code> but have different semantics; callers should still validate keys. <br><strong>Recommended tests:</strong> Provide Scripting.Dictionary, custom objects with Exists, objects without Exists, Null, Nothing. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>DictHasKey(d, k)</strong> — <em>safe Exists wrapper</em><br><strong>Purpose:</strong> Safely check whether key <code>k</code> exists on dictionary-like object without raising errors to caller. Returns False for non-objects or on any probing error.<br><strong>Signature:</strong> <code>Private Function DictHasKey(ByVal d As Variant, ByVal k As String) As Boolean</code><br><strong>Behavior:</strong> If Not IsObject returns False. Attempts <code>d.Exists(k)</code> under <code>On Error Resume Next</code>; if no error returns boolean result; otherwise False. Clears Err. Defensive to avoid exceptions from unknown object types.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Recommended tests:</strong> Dictionary with present/missing keys, object without Exists method, Null, Nothing. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>NzStringDict(d, k, def)</strong> — <em>safe string lookup with default</em><br><strong>Purpose:</strong> Safely return string value for key <code>k</code> from dictionary-like <code>d</code> or <code>def</code> if missing or on error. Avoids runtime exceptions when <code>d</code> is not an object or key missing.<br><strong>Signature:</strong> <code>Private Function NzStringDict(ByVal d As Variant, ByVal k As String, ByVal def As String) As String</code><br><strong>Behavior:</strong> If <code>IsObject(d)</code> and <code>DictHasKey(d,k)</code> then <code>CStr(d(k))</code> otherwise def. Error-handled default return on exceptions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Recommended tests:</strong> Keys present/missing, non-string values, object missing. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>NzDoubleDict(d, k, def)</strong> — <em>safe numeric lookup with default</em><br><strong>Purpose:</strong> Return numeric value (Double) from dictionary key if numeric; else return supplied default. Defensive against missing keys or non-numeric values.<br><strong>Signature:</strong> <code>Private Function NzDoubleDict(ByVal d As Variant, ByVal k As String, ByVal def As Double) As Double</code><br><strong>Behavior:</strong> If IsObject(d) and DictHasKey(d,k) then <code>IsNumeric(d(k))</code> ? <code>CDbl(d(k))</code> : def. Catch exceptions and return def.<br><strong>Complexity:</strong> O(1).<br><strong>Recommended tests:</strong> Numeric string, numeric value, non-numeric value, missing key. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>NzVariantDict(d, k)</strong> — <em>safe variant lookup or Empty</em><br><strong>Purpose:</strong> Return the raw Variant value at key <code>k</code> or <code>Empty</code> if missing or on error. Useful when value may be array/object.<br><strong>Signature:</strong> <code>Private Function NzVariantDict(ByVal d As Variant, ByVal k As String) As Variant</code><br><strong>Behavior:</strong> If IsObject(d) And DictHasKey(d,k) return d(k) else Empty. Errors result in Empty.<br><strong>Complexity:</strong> O(1).<br><strong>Recommended tests:</strong> Values that are arrays, dictionaries, scalars. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>IsNumericDict(d, k)</strong> — <em>safe numeric-check for dict key</em><br><strong>Purpose:</strong> Return True if dictionary contains key <code>k</code> and its value is numeric; else False. Exception-safe.<br><strong>Signature:</strong> <code>Private Function IsNumericDict(ByVal d As Variant, ByVal k As String) As Boolean</code><br><strong>Behavior:</strong> Combines IsObject, DictHasKey, and IsNumeric checks under error handling. Returns False on error.<br><strong>Complexity:</strong> O(1).<br><strong>Recommended tests:</strong> Numeric & non-numeric values, absent keys. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>JoinAccountRefs(v)</strong> — <em>flatten account refs into semicolon-separated string</em><br><strong>Purpose:</strong> Convert <code>AccountRefs</code> which may be scalar, array, or collection into a semicolon-separated string for sheet rendering or CSV output. Returns empty string if no refs.<br><strong>Signature:</strong> <code>Private Function JoinAccountRefs(ByVal v As Variant) As String</code> — returns string.<br><strong>Behavior:</strong> Calls <code>NormalizeRefsToArray(v)</code>; if result is Empty returns ""; if array iterate from <code>LBoundSafe</code> to <code>UBoundSafe</code> building <code>sb</code> with <code>;</code> separator; else return CStr(arr) for scalar. Defensive bounds checks prevent exceptions. Uses <code>LBoundSafe</code>/<code>UBoundSafe</code> helpers to avoid errors on ill-formed arrays.<br><strong>Complexity:</strong> O(M) where M = number of refs.<br><strong>Side-effects:</strong> None.<br><strong>Recommended tests:</strong> scalar ref, array refs, collection refs, empty refs, refs with empty strings. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>NZDouble(v)</strong> — <em>coerce variant to double defaulting to 0</em><br><strong>Purpose:</strong> Return Double when <code>IsNumeric(v)</code> else 0#. Small helper used in TB aggregation and export.<br><strong>Signature:</strong> <code>Private Function NZDouble(ByVal v As Variant) As Double</code><br><strong>Behavior:</strong> If IsNumeric returns CDbl else 0#. Fast, non-throwing. <br><strong>Complexity:</strong> O(1).<br><strong>Recommended tests:</strong> Numeric ints, floats, strings, Null. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>NZStringObj(obj, key, def)</strong> — <em>safe string getter for object dictionaries</em><br><strong>Purpose:</strong> Return string value for <code>key</code> on object <code>obj</code> using DictHasKey, else default. Returns def on obj = Nothing.<br><strong>Signature:</strong> <code>Private Function NZStringObj(ByVal obj As Object, ByVal key As String, ByVal def As String) As String</code><br><strong>Behavior:</strong> If obj is Nothing return def. If DictHasKey true return CStr(obj(key)) else def. Error-resilient with <code>On Error Resume Next</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Recommended tests:</strong> Missing obj, missing key, present key. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>NormalizeRefsToArray(v)</strong> — <em>normalise account refs to 1-based array, scalar, or Empty</em><br><strong>Purpose:</strong> Similar to <code>NormalizeLines</code> but specialized: returns 1-based array when multiple refs, scalar value when single non-collection, Empty when nothing. This preserves caller expectation that single ref remains scalar for downstream logic.<br><strong>Signature:</strong> <code>Private Function NormalizeRefsToArray(ByVal v As Variant) As Variant</code><br><strong>Behavior:</strong> If <code>IsEmpty(v)</code> returns Empty. If <code>IsArray</code> reindex to 1-based. If <code>IsObject</code> and has <code>.count</code> copy to array. Fallback iterate <code>For Each</code> building array via ReDim Preserve. If scalar fallback returns scalar value. Errors and empty collections return Empty.<br><strong>Complexity:</strong> O(M) for M refs. Note: ReDim Preserve in fallback may be O(M^2) in worst-case; typical code uses <code>.count</code> path which is O(M).<br><strong>Side-effects:</strong> None.<br><strong>Recommended tests:</strong> Arrays, single scalar, Dictionary of refs, Collection, object enumerables, Empty. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>LBoundSafe(arr) / UBoundSafe(arr)</strong> — <em>safe bound helpers</em><br><strong>Purpose:</strong> Safely return LBound/UBound or sensible defaults when passed non-arrays or ill-formed arrays. Prevents repeated <code>On Error</code> patterns across module.<br><strong>Signatures:</strong> <code>Private Function LBoundSafe(ByVal arr As Variant) As Long</code> — returns 1 for non-array; <code>Private Function UBoundSafe(ByVal arr As Variant) As Long</code> — returns 0 for non-array.<br><strong>Behavior:</strong> Use <code>On Error</code> to obtain bounds; on error return defaults (LBoundSafe=1, UBoundSafe=0). Guards loops that iterate arrays using these helpers to avoid exceptions.<br><strong>Complexity:</strong> O(1).<br><strong>Recommended tests:</strong> Non-array input, correct arrays, malformed arrays. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeTimestampCompact()</strong> — <em>timestamp helper for sheet names</em><br><strong>Purpose:</strong> Produce compact timestamp suitable for sheet naming: <code>YYYYMMDD_HHMMSS</code> using local <code>Now</code>. Used in snapshot naming to reduce collisions and ensure lexicographic order.<br><strong>Signature:</strong> <code>Private Function SafeTimestampCompact() As String</code> — returns string.<br><strong>Behavior:</strong> Compose using Year/Month/Day/Hour/Minute/Second with zero-padding. No host calls. Simple local formatting.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Notes:</strong> Uses local time via <code>Now</code>; host <code>GetUtcIsoTimestamp</code> is used elsewhere for canonical UTC timestamps. If requirement for UTC sheet names arises, change to use host helper. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeLog(m, p, d)</strong> — <em>best-effort logging via host or local audit</em><br><strong>Purpose:</strong> Try host-provided <code>LogAudit</code> probe (<code>TryRunReturn</code>) with variant signatures; if not available append to local workbook audit via <code>AppendLocalAudit</code>. Non-throwing and tolerant of host absence. Designed to centralize audit usage for this module.<br><strong>Signature:</strong> <code>Private Sub SafeLog(ByVal m As String, ByVal p As String, ByVal d As Variant)</code><br><strong>Behavior:</strong> Calls <code>TryRunReturn(&quot;LogAudit&quot;, dummy, m, p, CStr(d))</code> and if false tries alternate concatenated category <code>m &amp; &quot;.&quot; &amp; p</code>. If still false calls <code>AppendLocalAudit</code> with <code>m &amp; &quot;.&quot; &amp; p &amp; &quot; | &quot; &amp; CStr(d)</code>. Catches all errors silently. No return value. Intended for low-risk telemetry/audit.<br><strong>Complexity:</strong> O(1) plus cost of AppendLocalAudit which appends a worksheet row (O(1) with worksheet IO).<br><strong>Side-effects:</strong> May create <code>_IFRS_Audit</code> sheet and append a row with timestamp and message. Writes to workbook. Use sparingly to avoid audit sheet growth. <br><strong>Failure modes:</strong> If workbook is protected and cannot create sheet, AppendLocalAudit will attempt to create a uniquely-named sheet; if cannot, errors are swallowed; ensure critical logging is handled externally if required. <br><strong>Recommended tests:</strong> Host provides LogAudit → SafeLog invokes it; host missing → audit sheet created with correct content; repeated logging does not crash. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeHandleError(p, n, d)</strong> — <em>centralized error handler invoking host or local audit</em><br><strong>Purpose:</strong> Attempt to call host <code>HandleError</code> with (procName, Err.Number, Err.Description); if not available, append to local audit. Always swallow exceptions and avoid bubbling to caller. Use for centralized uniform error reporting.<br><strong>Signature:</strong> <code>Private Sub SafeHandleError(ByVal p As String, ByVal n As Long, ByVal d As String)</code><br><strong>Behavior:</strong> Try <code>TryRunReturn(&quot;HandleError&quot;, dummy, p, n, d)</code>; if false call <code>AppendLocalAudit</code> with a truncated description string. <code>On Error Resume Next</code> to avoid propagation. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> See SafeLog/AppendLocalAudit. <br><strong>Recommended tests:</strong> Force an error in a public function and verify host HandleError call or audit fallback path. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeNewCorrelationID()</strong> — <em>host-probed correlation ID generator with fallback</em><br><strong>Purpose:</strong> Acquire a CorrelationID from host helper <code>NewCorrelationID</code> if available; else produce deterministic fallback ID using prefix "PKG-", <code>SafeTimestampCompact()</code>, and a seeded random 6-digit suffix. Ensures consistent correlation IDs in logs/audits when host not present.<br><strong>Signature:</strong> <code>Private Function SafeNewCorrelationID() As String</code><br><strong>Behavior:</strong> Uses <code>TryRunReturn(&quot;NewCorrelationID&quot;, v)</code> and returns <code>v</code> if it's a non-empty string. Otherwise generates <code>&quot;PKG-&quot; &amp; SafeTimestampCompact() &amp; &quot;-&quot; &amp; Format$(CLng(Int(Rnd * 1000000#)), &quot;000000&quot;)</code>. Random seeded once (Static seeded). Error-tolerant.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls Randomize once on first invocation. <br><strong>Invariants:</strong> Output string always non-empty (guaranteed). <br><strong>Recommended tests:</strong> Simulate host providing valid id, host missing, call multiple times to ensure seeded randomness. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeGetUtcIsoTimestamp()</strong> — <em>host-probed UTC timestamp with local fallback</em><br><strong>Purpose:</strong> Prefer host-provided canonical UTC ISO timestamp (<code>GetUtcIsoTimestamp</code>); fallback to local <code>Now</code> formatted as ISO-like <code>YYYY-MM-DDTHH:MM:SS</code>. WARNING: fallback is not true UTC — documented in module header. Consumers relying on true UTC should prefer host helper presence.<br><strong>Signature:</strong> <code>Private Function SafeGetUtcIsoTimestamp() As String</code><br><strong>Behavior:</strong> <code>TryRunReturn(&quot;GetUtcIsoTimestamp&quot;, v)</code> if returns string uses it; otherwise build string from <code>Now</code> components zero-padded. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Returns string in <code>YYYY-MM-DDTHH:MM:SS</code> shape either true UTC or local-time fallback. <br><strong>Recommended tests:</strong> Host returns known UTC string, host missing returns local formatted string; verify callers aware of fallback semantics. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>ResolveWorkbook([wb])</strong> — <em>resolve workbook with host probe fallback</em><br><strong>Purpose:</strong> Prefer provided <code>wb</code> argument, otherwise try host <code>ResolveWorkbook</code> function; if host returns a Workbook object use it; else use <code>ThisWorkbook</code>. This ensures functions operate on expected workbook even in host scenarios where add-in may be executing in a different workbook context.<br><strong>Signature:</strong> <code>Private Function ResolveWorkbook(Optional ByVal wb As Workbook) As Workbook</code><br><strong>Behavior:</strong> If <code>wb</code> is not Nothing returns it. Else calls <code>TryRunReturn(&quot;ResolveWorkbook&quot;, ret)</code> and if <code>TypeName(ret) = &quot;Workbook&quot;</code> returns that; else returns <code>ThisWorkbook</code>. Error-tolerant.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Recommended tests:</strong> Provide explicit workbook, simulate host ResolveWorkbook returning workbook, host missing returns ThisWorkbook. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeGetWorksheet(wb, n)</strong> — <em>safe indexed worksheet getter</em><br><strong>Purpose:</strong> Return <code>wb.Worksheets(n)</code> or <code>Nothing</code> if not available. Avoids raising if sheet not present and centralises error handling.<br><strong>Signature:</strong> <code>Private Function SafeGetWorksheet(ByVal wb As Workbook, ByVal n As String) As Worksheet</code><br><strong>Behavior:</strong> <code>On Error Resume Next</code> then <code>Set tmp = wb.Worksheets(n)</code>; return <code>tmp</code> or Nothing if error. Clears Err. Non-mutating.<br><strong>Complexity:</strong> O(1).<br><strong>Recommended tests:</strong> Existing/missing sheet, invalid wb. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeCreateSheet(n, wb, [afterSheet], [veryHidden], [protectSheet])</strong> — <em>create sheet, deleting existing same-named sheet first</em><br><strong>Purpose:</strong> Create a worksheet with given name and visibility/protection preferences. If a sheet with same name exists, delete it first (destructive) to ensure deterministic result. Returns created Worksheet or Nothing on error.<br><strong>Signature:</strong> <code>Private Function SafeCreateSheet(ByVal n As String, ByVal wb As Workbook, Optional ByVal afterSheet As Worksheet = Nothing, Optional ByVal veryHidden As Boolean = True, Optional ByVal protectSheet As Boolean = False) As Worksheet</code><br><strong>Behavior:</strong> If existing sheet with same name found, delete it (display alerts off), then add new sheet after <code>afterSheet</code> if provided else after last worksheet. Set <code>sh.name</code>, <code>sh.Visible</code> per <code>veryHidden</code>, and protect contents if <code>protectSheet</code> True. Return sheet. On error return Nothing. Uses <code>On Error</code> handlers to avoid throwing.\n<br><strong>Complexity:</strong> O(1) plus cost of deleting sheet. <br><strong>Side-effects:</strong> Deletes any pre-existing sheet with the same name (data loss risk). Use <code>SafeCreateSheetUnique</code> to avoid destructive deletion if caller must preserve existing sheets.<br><strong>Failure modes:</strong> Cannot delete protected sheet; deletion may fail with no error surfaced (catching will clear Err) — calling code may not notice; ensure caller handles return Nothing. <br><strong>Recommended tests:</strong> Create when name absent, create when name present and verify old sheet deleted, create with protectSheet True. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeCreateSheetUnique(n, wb, [afterSheet], [veryHidden], [protectSheet])</strong> — <em>create unique-sheet without destructive delete</em><br><strong>Purpose:</strong> Create a new worksheet with unique name derived from <code>n</code> by appending <code>_k</code> until available (bounded by 1000) to avoid deleting existing sheets. Returns created Worksheet or Nothing on failure.<br><strong>Signature:</strong> <code>Private Function SafeCreateSheetUnique(ByVal n As String, ByVal wb As Workbook, Optional ByVal afterSheet As Worksheet = Nothing, Optional ByVal veryHidden As Boolean = True, Optional ByVal protectSheet As Boolean = False) As Worksheet</code><br><strong>Behavior:</strong> Loops candidate names starting with base <code>n</code>, checks existence with <code>SafeGetWorksheet</code>, increment k until not found or k>1000 then adds sheet after last or afterSheet, sets name to candidate, sets visibility/protect, returns sheet. Error returns Nothing.<br><strong>Complexity:</strong> O(k) with k small (usually 1). <br><strong>Side-effects:</strong> Adds a new sheet; does not delete existing ones. <br><strong>Recommended tests:</strong> Repeated calls to generate multiple unique names, bounds testing when many similarly-named sheets exist. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>TryRun(procName, ParamArray args())</strong> — <em>invoke host procedure for side-effects, tolerant</em><br><strong>Purpose:</strong> Run a host macro or function for side-effects with up to 8 args using <code>Application.Run</code>. Swallows errors and returns Boolean indicating invocation success. Useful to call host-provided imperative routines without failing if absent.\n<br><strong>Signature:</strong> <code>Private Function TryRun(ByVal procName As String, ParamArray args()) As Boolean</code> — returns True if invoked successfully (no VB error), else False.<br><strong>Behavior:</strong> Determine <code>UBound(args)</code> and call <code>Application.Run</code> with appropriate parameter count switch-case. <code>On Error</code> catches and returns False on error. Always non-throwing. Supports up to 8 args; falls back to call with no args for unexpected param counts. <br><strong>Complexity:</strong> O(1) + host macro runtime. <br><strong>Failure modes:</strong> If host proc throws internal error it is caught and False is returned; no stack trace forwarded. <br><strong>Recommended tests:</strong> Call existing host procedure, call non-existent procedure to verify False return. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>TryRunReturn(procName, ByRef ret, ParamArray args())</strong> — <em>invoke host function and capture return value</em><br><strong>Purpose:</strong> Similar to <code>TryRun</code> but captures return value from host function in <code>ret</code>. Returns True if call succeeded and <code>ret</code> contains returned value; False on error/absent host function. Supports up to 8 args.\n<br><strong>Signature:</strong> <code>Private Function TryRunReturn(ByVal procName As String, ByRef ret As Variant, ParamArray args()) As Boolean</code> — returns boolean success. <br><strong>Behavior:</strong> Switch-case on <code>UBound(args)</code> to call <code>Application.Run</code> with proper arity, assign to <code>ret</code> and return True. Errors caught and return False. <br><strong>Complexity:</strong> O(1) + host execution. <br><strong>Recommended tests:</strong> Host function returning primitive, host function returning Workbook object, host function absent. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>AppendLocalAudit(msg)</strong> — <em>append message to local hidden audit sheet</em><br><strong>Purpose:</strong> Append timestamped message to <code>_IFRS_Audit</code> sheet inside <code>ThisWorkbook</code>. Creates sheet (very hidden) with header row if missing. Intended as fallback when host <code>LogAudit</code> is unavailable. Non-throwing and tolerant of naming collisions by attempting unique alternate names if renaming fails.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAudit(ByVal msg As String)</code><br><strong>Behavior:</strong> Acquire or create <code>_IFRS_Audit</code> sheet via <code>SafeGetWorksheet</code>/Worksheets.Add. If naming fails, try unique name <code>_IFRS_Audit_&lt;timestamp&gt;</code>. Ensure header exists in A1:C1 with "Timestamp", "User", "Message". Compute <code>lastRow</code> via <code>.Cells(.Rows.Count,1).End(xlUp).Row</code>, append a new row with <code>SafeGetUtcIsoTimestamp()</code>, <code>Application.UserName</code>, and <code>msg</code>. Sheet set to <code>xlSheetVeryHidden</code>. Errors swallowed via <code>On Error Resume Next</code> to avoid cascading failures from logging. <br><strong>Complexity:</strong> O(1) for append. <br><strong>Side-effects:</strong> Creates/updates hidden sheet inside <code>ThisWorkbook</code>. Audit sheet can grow indefinitely; callers should implement pruning policy if necessary. <br><strong>Security:</strong> Audit sheet may hold sensitive data; keep workbook protected. <br><strong>Recommended tests:</strong> No audit sheet present, repeated appends, workbook with protections precluding adding sheets. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>SafeCreate / SafeGet / TryRun pair: host-probing pattern (notes)</strong> — <em>design pattern used across module</em><br><strong>Purpose:</strong> The module uniformly prefers host-provided helpers when available (via <code>TryRun</code> / <code>TryRunReturn</code>) then falls back to internal implementations (<code>SafeNewCorrelationID</code>, <code>SafeGetUtcIsoTimestamp</code>, <code>AppendLocalAudit</code>, <code>ThisWorkbook</code>) ensuring robust operation in minimal host environments. This pattern reduces coupling and increases testability in isolated environments (e.g., unit tests).<br><strong>Behavioral invariant:</strong> Do not assume host functions exist. All host probes are wrapped and their failures do not throw. Audit/logging operations always have local fallback. Host-provided workbook resolution is used when present. <br><strong>Maintenance note:</strong> If host API signatures change, update <code>TryRunReturn</code>/invocation sites and consider adding a <code>HOST_API_VERSION</code> constant for handshake validation. </td></tr><tr><td data-label="Technical breakdown (modStatements.bas)"> <strong>General module-level notes, risks, and recommended improvements</strong><br>- <strong>Determinism & idempotency:</strong> The module avoids <code>Select/Activate</code> and uses explicit workbook/sheet references; <code>SafeCreateSheet</code> <em>deletes</em> existing sheets to guarantee deterministic render — this is destructive and callers must be aware. Prefer <code>SafeCreateSheetUnique</code> for non-destructive flows. <br>- <strong>Error handling:</strong> All public exports wrap errors and call <code>SafeHandleError</code>, returning safe defaults (False/Nothing/"") rather than leaking errors. This is good for add-in robustness but can hide root causes — ensure host <code>HandleError</code> receives sufficient context in critical paths. <br>- <strong>Performance:</strong> Rendering and snapshotting write cell-by-cell; for large packages consider building a 2D Variant array and assigning it to <code>Range.Value</code> in one operation to drastically improve performance. <code>ExportSheetToCsv</code> iterates cells which can be slow; if very large sheets are expected, stream rows or use <code>Range.Value</code> block reads for faster conversion. <br>- <strong>Concurrency / long-running jobs:</strong> Module is safe to be called from background/scheduled jobs (no UI Select usage) but heavy operations will still block Excel’s main thread; consider job-splitting or offloading heavy IO to background processes where possible. <br>- <strong>Security & data leakage:</strong> Snapshots and <code>_IFRS_Audit</code> sheets store potentially sensitive financial data inside the workbook. Consider encrypting workbook or gating access, and avoid writing raw PII into audit messages. <code>SafeLog</code> currently sends full PackageID and issue counts — sanitize if PackageID contains identifying info. <br>- <strong>Row limits & guardrails:</strong> <code>CreateStatementSnapshot</code> does not guard against exceeding worksheet row limits; add pre-checks to avoid runtime failures when packages exceed Excel limits. <br>- <strong>APIs to preserve:</strong> Public functions that must remain stable: <code>AssembleStatementPackage</code>, <code>ValidateStatementPackage</code>, <code>RenderStatementToSheet</code>, <code>CreateStatementSnapshot</code>, <code>RestoreStatementSnapshot</code>, <code>GenerateReconciliation</code>, <code>ExportSheetToCsv</code>. If signatures change, update all callers and document migration steps. <br>- <strong>Tests to add (high priority):</strong> Round-trip snapshot/restore, rendering correctness, reconciliation correctness (single/multiple refs), large-scale performance tests (10k+ lines), audit/log fallback when host logging unavailable, Create/Restore naming/collision behavior, Export CSV data fidelity (quotes, commas, decimals), error-path tests for protected workbook/sheet scenarios. <br>- <strong>Documentation:</strong> Document expected shape of <code>Lines</code> items (each line should be dictionary-like with keys <code>LineID</code>, <code>Label</code>, <code>Amount</code>, <code>Sign</code>, <code>AccountRefs</code>, <code>Notes</code>) and whether <code>AccountRefs</code> may be scalar or array. Provide example package JSON/dictionary in developer docs to reduce integration bugs. </td></tr></tbody></table></div><div class="row-count">Rows: 35</div></div><div class="table-caption" id="Table3" data-table="Docu_0160_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modStatementsHelpers)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modStatementsHelpers)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>Overview:</strong> This table documents every function in <code>modStatementsHelpers</code> (VBA). Each entry is deliberately exhaustive and precise: purpose, signature (inputs/outputs), internal behavior, time/space complexity, side-effects, invariants, failure modes, security/PII considerations, recommended tests, and maintainers' notes. Treat it as authoritative inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetStableTableID(target As Range)</strong> — <em>deterministic stable identifier for a table range</em><br><strong>Purpose:</strong> Produce a reproducible stable ID for a table-range using workbook fingerprint, sheet codename, top-left cell address and header signature; used as key for metadata storage and audit. <br><strong>Signature:</strong> <code>GetStableTableID(ByVal target As Range) As String</code> — returns e.g. <code>&quot;tbl-XXXXXXXX&quot;</code>, or <code>&quot;&quot;</code> on failure. <br><strong>Behavior:</strong> Validates <code>target</code>; obtains worksheet and top-left cell; computes workbook fingerprint via <code>GetWorkbookFingerprint</code>; gets header row signature <code>GetHeaderSignature</code>; composes <code>seed = wbFingerprint &amp; &quot;|&quot; &amp; ws.CodeName &amp; &quot;|&quot; &amp; topLeft.Address &amp; &quot;|&quot; &amp; hdr</code>; computes CRC32 over <code>seed</code> (via <code>CRC32_String</code>); if CRC32 returns 0 (error), fallbacks to deterministic <code>DJB2_Hash</code> and logs audit that CRC32 fallback used; returns <code>&quot;tbl-&quot; &amp; HexFromLong(crc)</code>. Errors call <code>HandleLocalError</code> and return empty string. <br><strong>Complexity:</strong> O(n) where n = length of combined seed string; dominated by CRC32 processing O(bytes). <br><strong>Side-effects:</strong> Calls audit on fallback; may call <code>HandleLocalError</code>. No sheet writes. <br><strong>Invariants:</strong> Same <code>target</code> (same workbook saved time, sheet codename, top-left cell and header values) yields same stable id. If workbook is unsaved, fingerprint uses non-file data (falls back to VBProject name or workbook name), making id deterministic for that session but may change on save. <br><strong>Failure modes:</strong> Missing <code>target</code> → <code>&quot;&quot;</code>; CRC32 error → 0 → fallback; unsaved workbook with changing VBProject name or if sheet codename changes, ID changes. <br><strong>Security / PII:</strong> Uses visible header text in seed — do not store seed logs containing user data. Audit line intentionally minimal. <br><strong>Recommended tests:</strong> Same-range stable ID repeatability across calls; verify CRC32 fallback audit path by forcing <code>CRC32_String</code> to return 0 (unit test shim); confirm ID changes when header text changes. <br><strong>Notes for maintainers:</strong> Keep tokenization of header via <code>GetHeaderSignature</code> stable. Changing <code>GetWorkbookFingerprint</code> semantics will change IDs and should be treated as breaking for metadata mapping. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EnsureTableCaption(target As Range, captionText As String, Optional allowInjection As Boolean = True)</strong> — <em>store sanitized caption metadata and optionally write into sheet</em><br><strong>Purpose:</strong> Save a safe caption into the table metadata store and optionally inject the caption into the worksheet above the table (respecting existing content). <br><strong>Signature:</strong> <code>EnsureTableCaption(ByVal target As Range, ByVal captionText As String, Optional ByVal allowInjection As Boolean = True) As Boolean</code> — returns True on success. <br><strong>Behavior:</strong> Validates <code>target</code>; sanitizes caption for cell via <code>SanitizeForCell</code> to avoid formula injection; reads existing metadata with <code>GetTableMetadata</code> (or creates dictionary); sets <code>meta(&quot;caption&quot;)</code> and <code>meta(&quot;schema_version&quot;)</code>; generates <code>correlation_id</code>; calls <code>SetTableMetadataEx</code> to persist metadata (with atomic-ish write and retry); on success and <code>allowInjection=True</code> calls <code>InjectCaptionCell</code> to insert caption above table if blank; sets return True. On error logs with <code>HandleLocalError</code> and returns False. <br><strong>Complexity:</strong> O(1) metadata manipulation + cost of write routine (sheet I/O and retry). <br><strong>Side-effects:</strong> Writes metadata to metadata sheet; may write caption into worksheet; emits audit via <code>SetTableMetadataEx</code> and <code>InjectCaptionCell</code>. <br><strong>Invariants:</strong> Persisted metadata includes <code>schema_version</code>. Caption stored is sanitized to prevent formula injection. <br><strong>Failure modes:</strong> Write failures (protected sheet, locked workbook) cause retries and eventual failure; injection skipped if above-cell non-empty. <br><strong>Security / PII:</strong> Caption sanitized for formula injection but may still contain PII — callers should avoid storing sensitive text. <code>PII_Detect</code> is available for higher-level checks but not invoked here. <br><strong>Recommended tests:</strong> Round-trip: call EnsureTableCaption → read via GetTableMetadata → verify caption matches sanitized input; attempt injection when above cell empty vs non-empty; simulate protected metadata sheet to exercise retry/backoff path. <br><strong>Notes:</strong> Keep <code>SanitizeForCell</code> up-to-date for new injection vectors. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>InjectTOCReference(target As Range, tocId As String)</strong> — <em>create sanitized named range / TOC anchor and persist reference in metadata</em><br><strong>Purpose:</strong> Associate a table with a TOC id (sanitized) and create an idempotent workbook named range for navigation. <br><strong>Signature:</strong> <code>InjectTOCReference(ByVal target As Range, ByVal tocId As String) As Boolean</code> — True on success. <br><strong>Behavior:</strong> Sanitizes <code>tocId</code> via <code>SanitizeName</code> (removes problematic chars and truncates); returns False if sanitized id empty; loads metadata via <code>GetTableMetadata</code>, sets <code>meta(&quot;toc_id&quot;)</code> and <code>schema_version</code> and calls <code>SetTableMetadataEx</code> with correlation id; then calls <code>CreateNamedRangeForTOC</code> which attempts to reuse existing name or safely delete & recreate it, and audits creation. Returns creation result. <br><strong>Complexity:</strong> O(1) plus sheet name/Name collection operations. <br><strong>Side-effects:</strong> Writes metadata; creates/deletes workbook <code>Name</code> entries; audit logging. <br><strong>Invariants:</strong> Generated named range uses <code>TOC_&lt;SanitizedName&gt;</code> and points to top-left cell of the target range. Calling again with same tocId is idempotent. <br><strong>Failure modes:</strong> Name collisions, invalid names, workbook locked — handled by safe delete or timestamped fallback; errors audited and false returned. <br><strong>Security:</strong> Sanitizes toc id but named ranges are workbook-global; ensure naming doesn't leak PII. <br><strong>Tests:</strong> Create TOC for a range, assert workbook name exists and points to expected cell; repeated call is idempotent; call with illegal characters yields sanitized name. <br><strong>Notes:</strong> Keep sanitation consistent with code that resolves TOC references elsewhere. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetTableMetadata(target As Range)</strong> — <em>read stable metadata dictionary for a table</em><br><strong>Purpose:</strong> Return metadata dictionary for a table identified by stable id; returns empty dictionary when not present. <br><strong>Signature:</strong> <code>GetTableMetadata(ByVal target As Range) As Object</code> — returns a <code>Scripting.Dictionary</code>. <br><strong>Behavior:</strong> If <code>target</code> is <code>Nothing</code> returns empty dict. Computes stable id via <code>GetStableTableID</code>; obtains/creates metadata sheet via <code>EnsureMetadataSheetExists</code>; composes <code>keyName = METADATA_KEY_PREFIX &amp; id</code>; uses <code>SafeFindInColumn</code> in column 1 to locate row; if found reads JSON from column 2 and parses via <code>JsonToDictionary</code>; ensures <code>schema_version</code> present (sets default if missing) then returns parsed dictionary. If not found returns empty dict. Errors handled by <code>HandleLocalError</code>. <br><strong>Complexity:</strong> O(rows scanned in SafeFindInColumn) linear up to last used row; JSON parsing cost O(len(json)). <br><strong>Side-effects:</strong> None to workbook except reading; may call <code>EnsureMetadataSheetExists</code> which can create sheet. <br><strong>Invariants:</strong> Returned object is always a <code>Scripting.Dictionary</code> (never Null). Keys stable after parsing. <br><strong>Failure modes:</strong> Corrupted JSON → <code>JsonToDictionary</code> fallback to empty dict; missing metadata sheet → created on demand. <br><strong>Security:</strong> JSON parsing uses conservative routine; keys and values returned as strings or nested dictionaries only. <br><strong>Tests:</strong> Write metadata then call GetTableMetadata; malformed JSON row should produce empty dict but not raise unhandled error. <br><strong>Notes:</strong> Keep <code>METADATA_KEY_PREFIX</code> stable. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SetTableMetadata(metadata As Object)</strong> — <em>public wrapper to persist metadata with automatic correlation id</em><br><strong>Purpose:</strong> Public convenience wrapper to persist metadata for a target range using an automatically generated correlation id. <br><strong>Signature:</strong> <code>SetTableMetadata(ByVal target As Range, ByVal metadata As Object) As Boolean</code> — returns bool. <br><strong>Behavior:</strong> Calls private <code>SetTableMetadataEx(target, metadata, GenerateCorrelationID())</code> and returns its boolean result. <br><strong>Complexity / Side-effects / Failure modes:</strong> Same as <code>SetTableMetadataEx</code>. <br><strong>Notes:</strong> Keep wrapper stable for public API compatibility. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SetTableMetadataEx(target As Range, metadata As Object, correlation_id As String)</strong> — <em>atomic-ish metadata write, structured audit and checksum</em><br><strong>Purpose:</strong> Persist metadata for target reliably: stable key, deterministic JSON serialization, checksum (CRC32) and retry/backoff policy; audit successes/failures. <br><strong>Signature:</strong> <code>Private Function SetTableMetadataEx(ByVal target As Range, ByVal metadata As Object, ByVal correlation_id As String) As Boolean</code> — returns True on successful write. <br><strong>Behavior (detailed):</strong> Validates <code>target</code>; ensures metadata dict present; sets <code>metadata(&quot;schema_version&quot;) = METADATA_SCHEMA_VERSION</code>; computes stable id; ensures metadata sheet exists; forms keyName; serializes <code>metadata</code> deterministically via <code>DictionaryToJson</code> (sorted keys); computes checksum via <code>CRC32_String(json)</code> and <code>HexFromLong</code>; attempts up to <code>MAX_RETRIES</code> to write via <code>TryWithRetry_WriteToSheet</code> which uses <code>METADATA_TEMP_COL</code> atomic transfer technique (temp column then copy to col 2); on success logs audit <code>Audit_LogStructured &quot;SetMetadata&quot;, id, correlation_id, &quot;ok&quot;, checksum, &quot;CRC32&quot;</code>; on reaching retry limit logs <code>SetMetadataFailed</code> and returns False. Errors call <code>HandleLocalError</code>. <br><strong>Complexity:</strong> JSON serialization O(k log k) due to key sort; write attempts O(MAX_RETRIES) with sheet scanning. <br><strong>Side-effects:</strong> Creates/updates rows in metadata sheet, audit entries, may mutate temporary column during write. <br><strong>Invariants:</strong> Stored JSON is deterministic (sorted keys) → stable checksum. <code>schema_version</code> included. <br><strong>Failure modes:</strong> Protected sheet, workbook busy, insufficient rights → retries → final failure audited. Partial writes mitigated by two-column atomic swap pattern. <br><strong>Security / Tamper-evidence:</strong> Computes checksum placed in audit so tampering is detectable via audit but metadata rows are not cryptographically signed; consider storing rolling hash if stronger tamper detection wanted. <br><strong>Recommended tests:</strong> Concurrent write simulation (mock IsWorksheetWritable false on some attempts) to exercise retry; corruption simulation verifying audit logs; checksum verification. <br><strong>Notes:</strong> Keep <code>METADATA_TEMP_COL</code> distinct from header and data columns. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>RenderSafeHtml(inputText As String)</strong> — <em>cell/HTML-safe escaping to reduce injection in HTML preview flows</em><br><strong>Purpose:</strong> Escape HTML special characters and normalize newlines into <code>&lt;br/&gt;</code> for safe HTML display of metadata/captions. <br><strong>Signature:</strong> <code>RenderSafeHtml(ByVal inputText As String) As String</code> — returns escaped HTML string. <br><strong>Behavior:</strong> Converts value to string; replaces <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&quot;</code> and <code>&#x27;</code> with HTML entities; normalizes CR/LF/CR to LF then replaces LF with <code>&lt;br/&gt;</code>. Returns escaped string. Errors handled with <code>HandleLocalError</code>. <br><strong>Complexity:</strong> O(len(inputText)). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Output contains only safe entities and <code>&lt;br/&gt;</code> for line breaks. <br><strong>Failure modes:</strong> None typical; if called with very long strings performance proportional to length. <br><strong>Security:</strong> Prevents HTML injection when used in HTML contexts. Note: does not sanitize CSS or URL content; do not use for direct attribute injection without additional checks. <br><strong>Tests:</strong> Input containing <code>&lt;script&gt;</code> should be escaped; newlines convert to <code>&lt;br/&gt;</code>. <br><strong>Notes:</strong> Keep escaping consistent with any web-renderer used. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>AssembleStatementMetadata(target As Range, Optional opts As Variant)</strong> — <em>compose an exportable metadata dictionary for a table</em><br><strong>Purpose:</strong> Produce a structured metadata object capturing stable id, stored metadata (caption/toc), physical properties (rows/cols/sheet/address) suitable for external export, audit, or UI. <br><strong>Signature:</strong> <code>AssembleStatementMetadata(ByVal target As Range, Optional ByVal opts As Variant) As Object</code> — returns <code>Scripting.Dictionary</code> with keys: <code>stable_id</code>, <code>caption</code>, <code>toc_id</code>, <code>metadata</code> (dict), <code>row_count</code>, <code>col_count</code>, <code>sheet</code>, <code>address</code>. <br><strong>Behavior:</strong> Calls <code>GetStableTableID</code>; <code>GetTableMetadata</code>; extracts caption/toc_id if present; fills row/col counts and sheet name/address; calls <code>Audit_LogStructured &quot;AssembleStatementMetadata&quot;</code> with assembled id and returns dictionary. Errors handled and returns Nothing on fatal error. <br><strong>Complexity:</strong> O(1) plus cost of <code>GetTableMetadata</code> (scan + parse). <br><strong>Side-effects:</strong> Audit invocation. <br><strong>Invariants:</strong> <code>metadata</code> sub-dictionary is the parsed stored metadata; <code>schema_version</code> should be present. <br><strong>Failure modes:</strong> Missing target produces empty fields; metadata parsing failure yields empty nested dict. <br><strong>Tests:</strong> For a table with caption/toc, confirm assembled fields correct; verify audit entry created. <br><strong>Notes:</strong> Keep this function stable—used by export and statement assembly flows. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>ValidateStatementAssembly(target As Range)</strong> — <em>lightweight heuristic validator for table shape</em><br><strong>Purpose:</strong> Provide quick validation flags for downstream assembly or export to warn about suspiciously small ranges. <br><strong>Signature:</strong> <code>ValidateStatementAssembly(ByVal target As Range) As Object</code> — returns <code>Scripting.Dictionary</code> with at least <code>ok</code> boolean, and <code>error</code>/<code>warning</code> keys when appropriate. <br><strong>Behavior:</strong> Sets <code>res(&quot;ok&quot;) = True</code> unless <code>target</code> is <code>Nothing</code>, in which case <code>ok=False</code> and <code>error=&quot;Target range is Nothing&quot;</code>. If range has fewer than 2 rows or 2 columns sets <code>ok=False</code>? (current behavior sets <code>warning</code> but leaves <code>ok=True</code>; code sets <code>warning</code> but not <code>ok=False</code>) — note: code sets <code>warning</code> but leaves <code>ok=True</code> allowing downstream to proceed. Returns dictionary. Errors handled. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Always returns a <code>Scripting.Dictionary</code>. <br><strong>Failure modes:</strong> None; conservative behavior preferred. <br><strong>Tests:</strong> Pass <code>Nothing</code>, very small ranges, normal ranges and assert warnings/errors set consistently. <br><strong>Notes:</strong> Consider documenting whether tiny ranges should flip <code>ok</code> to False — current logic signals warning only. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SelfTest_ModStatementsHelpers()</strong> — <em>module self-test harness (deterministic smoke tests & write-read roundtrip)</em><br><strong>Purpose:</strong> Run a set of deterministic smoke tests exercising stable id, caption/TOC creation, metadata roundtrip, RenderSafeHtml behavior and write test results to hidden test sheet / audit. Intended for developer QA and CI-like checks. <br><strong>Signature:</strong> <code>SelfTest_ModStatementsHelpers() As Boolean</code> — True if all checks pass. <br><strong>Behavior (detailed):</strong> Creates deterministic 4x3 range on first worksheet, clears it, writes header cells, computes <code>GetStableTableID</code>, calls <code>EnsureTableCaption</code> and <code>InjectTOCReference</code>, reads metadata back via <code>GetTableMetadata</code>, checks <code>RenderSafeHtml</code> (expects not identical to raw string), performs metadata round-trip write using <code>SetTableMetadataEx</code> with generated corr id then reads it back to ensure stored key present. Logs results into <code>TEST_RESULTS_SHEET</code> via <code>WriteSelfTestResults</code>, audited via <code>Audit_LogStructured</code> with PASS/FAIL and returns boolean. On errors, handles via <code>HandleLocalError</code> and returns False. <br><strong>Complexity:</strong> Several sheet operations and metadata writes – cost proportional to sheet I/O + JSON serialization. <br><strong>Side-effects:</strong> Modifies first worksheet cells, creates hidden test results sheet and metadata/audit rows, and may create named ranges; writes audit entries. <br><strong>Invariants:</strong> Designed to be idempotent but will alter workbook (test sheets). <br><strong>Failure modes:</strong> Protected workbook or non-standard workbook structure (no worksheets) can cause failure; test modifies sheet[1] which could be intrusive—caller should run in disposable/test copy of workbook. <br><strong>Security/PII:</strong> Test writes may leak sample data into metadata/audit sheets; ensure tests run in sanitized environment. <br><strong>Recommended tests:</strong> Run in CI on a throwaway workbook; verify <code>TEST_RESULTS_SHEET</code> contains expected result row; run 500 cycles in a loop to detect resource/state leaks. <br><strong>Notes:</strong> This function mutates workbook and should be used in controlled contexts only. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EnsureMetadataSchema()</strong> — <em>make sure metadata sheet headers exist and migration run</em><br><strong>Purpose:</strong> Guarantee metadata sheet header columns exist and trigger migration for legacy rows if needed. <br><strong>Signature:</strong> <code>Private Sub EnsureMetadataSchema()</code> — no return. <br><strong>Behavior:</strong> Ensures <code>EnsureMetadataSheetExists</code> and sets header values in row 1 to <code>METADATA_HDR_KEY</code> and <code>METADATA_HDR_JSON</code>; calls <code>MigrateLegacyMetadataIfNeeded</code> to scan old rows. <br><strong>Complexity:</strong> O(1) plus migration scan complexity. <br><strong>Side-effects:</strong> May create metadata sheet and alter header cells. <br><strong>Tests:</strong> With missing metadata sheet ensures it is created with correct headers; with legacy rows ensures migration routine audited. <br><strong>Notes:</strong> Keep header constants stable. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>MigrateLegacyMetadataIfNeeded(sh As Worksheet)</strong> — <em>conservative detection of non-prefixed keys</em><br><strong>Purpose:</strong> Scan metadata rows for keys not prefixed with <code>METADATA_KEY_PREFIX</code> and decide safe conservative actions (currently logs/skips). <br><strong>Signature:</strong> <code>Private Sub MigrateLegacyMetadataIfNeeded(ByVal sh As Worksheet)</code> — no return. <br><strong>Behavior:</strong> Iterates rows from 2..lastRow, detects keys not starting with prefix, and emits audit <code>MigrateLegacyMetadata:Skipped</code> with legacy key; does not attempt risky automated migration. <br><strong>Complexity:</strong> O(rows). <br><strong>Side-effects:</strong> Audit logging only. <br><strong>Recommended tests:</strong> Create a row with legacy key and verify audit entry logged. <br><strong>Notes:</strong> Intentional conservative design—do not auto-migrate unknown keys. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetWorkbookFingerprint(wb As Workbook)</strong> — <em>deterministic workbook fingerprint used in stable id seed</em><br><strong>Purpose:</strong> Produce a deterministic fingerprint for a workbook: for saved workbook prefer <code>FullName|DateLastModified</code>; for unsaved fallback to <code>VBProject.Name</code> or <code>wb.Name</code> prefixed with <code>unsaved|</code>. <br><strong>Signature:</strong> <code>Private Function GetWorkbookFingerprint(ByVal wb As Workbook) As String</code> — returns fingerprint string. <br><strong>Behavior:</strong> If <code>wb.FullName</code> non-empty and file exists uses FileSystemObject to get <code>DateLastModified</code> and returns <code>path &amp; &quot;|&quot; &amp; DateLastModified</code>; else attempt to return <code>unsaved|</code> + <code>wb.VBProject.name</code> (best-effort; <code>On Error Resume Next</code> in case VBProject inaccessible) or <code>wb.Name</code>. Errors handled and returns <code>&quot;unknown&quot;</code>. <br><strong>Complexity:</strong> File existence check and file info retrieval O(1). <br><strong>Side-effects:</strong> None except potential access to VBProject (may trigger trust prompts). <br><strong>Invariants:</strong> For saved file the fingerprint is stable until file saved (DateLastModified changes on save making stable_id change; this is a deliberate tradeoff). <br><strong>Failure modes:</strong> Access denied to <code>VBProject</code> or file; returns less-stable fallback. <br><strong>Security/Privacy:</strong> <code>FullName</code> may contain user paths — avoid logging full fingerprint in telemetry/audit unless necessary. <br><strong>Tests:</strong> Saved workbook -> fingerprint includes path and modified timestamp; unsaved workbook -> returns unsaved variant. <br><strong>Notes:</strong> Changing this function invalidates existing stable IDs; treat as breaking change. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>DictionaryToJson(dict As Object)</strong> — <em>stable deterministic JSON serializer for nested dictionaries</em><br><strong>Purpose:</strong> Serialize <code>Scripting.Dictionary</code> (and nested dictionaries) to JSON string with stable sorted key order to ensure determinism and consistent checksum. <br><strong>Signature:</strong> <code>Private Function DictionaryToJson(ByVal dict As Object) As String</code> — returns JSON string. <br><strong>Behavior:</strong> If dict is Nothing or empty returns <code>{}</code>. Collects keys into an array, sorts using insertion sort (stable), iterates keys producing <code>&quot;&lt;escapedKey&gt;&quot;:&quot;&lt;escapedValue&gt;&quot;</code> or nested JSON if value is a <code>Dictionary</code>. Non-dictionary objects are serialized via <code>NullSafeValue</code> to string. Returns JSON object string with keys in lexicographic order. On error logs and returns <code>{}</code>. <br><strong>Complexity:</strong> O(k^2) worst-case for insertion sort on keys where k = key count; for typical small dicts acceptable. Serialization cost O(total value length). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Output uses stable ordering — identical dictionary contents produce identical JSON. <br><strong>Failure modes:</strong> Non-dictionary objects other than dictionary are stringified, nested non-dictionary objects produce <code>&quot;[object]&quot;</code> placeholder; maintainers should avoid storing complex COM objects inside metadata. <br><strong>Security:</strong> Uses <code>JsonEscape</code> to escape values; avoid including binary or extremely large values. <br><strong>Tests:</strong> Dictionaries with varying insertion order should produce identical JSON; nested dictionaries properly serialized. <br><strong>Notes:</strong> If larger dicts expected, consider switching to a faster sort routine. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>JsonToDictionary(jsonText As String)</strong> — <em>defensive, small JSON parser for subset used by metadata (objects & strings)</em><br><strong>Purpose:</strong> Parse a limited subset of JSON produced by <code>DictionaryToJson</code> into <code>Scripting.Dictionary</code>. Supports nested objects recursively but not arrays or other JSON primitives beyond strings/objects. Robust to whitespace and quoted strings; avoids <code>Eval</code> or external JSON libraries to remain portable. <br><strong>Signature:</strong> <code>Private Function JsonToDictionary(ByVal jsonText As String) As Object</code> — returns <code>Scripting.Dictionary</code>. <br><strong>Behavior (detailed):</strong> Trim input; strip leading/trailing braces; iterate characters, respecting quoted strings and escape sequences, and track brace depth to split top-level pairs (collects tokens into <code>parts</code> collection). For each part splits on first colon via <code>SplitOnFirstColon</code>. Keys unquoted/unescaped via <code>UnquoteAndUnescape</code>. If value begins with <code>{</code> treats as nested JSON and calls <code>JsonToDictionary</code> recursively. Adds items into dictionary (skips duplicates). On parse errors returns empty dict and logs via <code>HandleLocalError</code>. <br><strong>Complexity:</strong> O(n) on input length for single-pass parsing; recursive cost for nested objects. <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Reverse of <code>DictionaryToJson</code> for supported shapes. <br><strong>Failure modes:</strong> Does not support arrays, raw numbers/booleans/null (they will be treated as strings). Escapes handled for common sequences. Malformed JSON may be partly parsed; function errs back to empty dictionary. <br><strong>Security:</strong> Conservative; does not execute content. <br><strong>Tests:</strong> Round-trip tests with <code>DictionaryToJson</code>; nested object parse; quoted strings with escapes; invalid JSON returns empty dict not exception. <br><strong>Notes:</strong> If metadata grows to include arrays/booleans, migrate to a full JSON library or extend parser. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SafeFindInColumn(sh As Worksheet, colIndex As Long, what As String)</strong> — <em>linear, robust search for key in metadata sheet</em><br><strong>Purpose:</strong> Find a string value in column <code>colIndex</code> scanning rows 2..last used row, via exact trimmed match. Avoids <code>Range.Find</code> COM complexity to be deterministic. <br><strong>Signature:</strong> <code>Private Function SafeFindInColumn(ByVal sh As Worksheet, ByVal colIndex As Long, ByVal what As String) As Range</code> — returns Range of found cell or Nothing. <br><strong>Behavior:</strong> If <code>lastRow &lt; 2</code> return Nothing; loops <code>For r = 2 To lastRow</code> and compares trimmed cell value with trimmed <code>what</code>. Returns first match as Range. On errors logs and returns Nothing. <br><strong>Complexity:</strong> O(lastRow) linear scan. <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Create metadata rows and find existing key; missing returns Nothing; ensure trimmed matching. <br><strong>Notes:</strong> Simple linear scan suitable for expected small metadata sizes; if metadata grows large consider building index or using dictionary in-memory. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>CreateNamedRangeForTOC(target As Range, tocId As String, correlation_id As String)</strong> — <em>idempotent named range creation for TOC</em><br><strong>Purpose:</strong> Create a workbook <code>Name</code> called <code>TOC_&lt;sanitized&gt;</code> that points to the top-left of <code>target</code>; if existing name points to same cell succeed idempotently; otherwise delete & recreate. <br><strong>Signature:</strong> <code>Private Function CreateNamedRangeForTOC(ByVal target As Range, ByVal tocId As String, ByVal correlation_id As String) As Boolean</code> — returns True on success. <br><strong>Behavior:</strong> Sanitizes <code>tocId</code> into <code>nmName = &quot;TOC_&quot; &amp; SanitizeName(tocId)</code>; obtains top-left cell; tries <code>ThisWorkbook.Names(nmName)</code> with <code>On Error Resume Next</code>; if exists and refers to same absolute address returns True; otherwise tries to delete existing name and re-add <code>Names.Add name:=nmName, RefersTo:=topLeft</code>; audits <code>CreateNamedRangeForTOC</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Adds/Deletes a <code>Name</code> scope in workbook. <br><strong>Failure modes:</strong> Errors from invalid name or protected workbook handled by <code>HandleLocalError</code> and return False. <br><strong>Tests:</strong> Existing name identical → no recreate; existing name different → deleted and recreated; invalid chars in tocId produce sanitized name. <br><strong>Notes:</strong> Named ranges are workbook-global; ensure the created name does not conflict with other add-ins. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>InjectCaptionCell(target As Range, captionText As String, Optional correlation_id As String = "")</strong> — <em>non-destructive caption injection above table if cell empty</em><br><strong>Purpose:</strong> Write caption text into the cell immediately above the table top-left if it is blank; style bold; log outcome. <br><strong>Signature:</strong> <code>Private Sub InjectCaptionCell(ByVal target As Range, ByVal captionText As String, Optional ByVal correlation_id As String = &quot;&quot;)</code> — no return. <br><strong>Behavior:</strong> If <code>target.row &lt;= 1</code> exit (can't write above first row); gets <code>rAbove = ws.Cells(target.row-1, target.Column)</code>; if trimmed value is empty performs <code>SafeWriteRange rAbove, captionText</code> then attempts to set <code>rAbove.Font.Bold = True</code> wrapped with <code>On Error Resume Next</code>; audits <code>&quot;injected&quot;</code>; else audits <code>&quot;skipped_existing&quot;</code>. <br><strong>Complexity:</strong> O(1) with SafeWriteRange retry cost. <br><strong>Side-effects:</strong> Writes to worksheet, may modify cell style. <br><strong>Invariants:</strong> Does not overwrite existing content. <br><strong>Failure modes:</strong> Protected sheet causes <code>SafeWriteRange</code> to retry and audit failure; styling set may fail silently. <br><strong>Tests:</strong> Verify it writes when above blank and skips when non-blank; test protected sheet path. <br><strong>Notes:</strong> Keep audit correlation id passing consistent. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>Audit_LogStructured(action, stable_id_or_name, correlation_id, outcome, metadata_checksum, algorithm_tag)</strong> — <em>structured audit wrapper delegating to modAudit when available</em><br><strong>Purpose:</strong> Write structured audit entries using <code>modAudit.LogAudit</code> if available, otherwise append to local audit sheet. This centralizes audit semantics and best-effort integration. <br><strong>Signature:</strong> <code>Private Sub Audit_LogStructured(ByVal action As String, ByVal stable_id_or_name As String, ByVal correlation_id As String, ByVal outcome As String, ByVal metadata_checksum As String, ByVal algorithm_tag As String)</code> — no return. <br><strong>Behavior:</strong> Tries <code>Application.Run &quot;LogAudit&quot;, ...</code> and if no error (Err.Number=0) treat as success. If <code>Run</code> fails or not present, calls <code>AppendLocalAuditStructured</code> which appends a row to the hidden <code>_IFRS_Audit</code> sheet with timestamp, user, action, subject, correlation id, outcome, checksum, algorithm tag and a row hash computed with CRC32 over select fields. Errors in fallback print to Debug. <br><strong>Complexity:</strong> O(1) plus cost of writing to audit sheet. <br><strong>Side-effects:</strong> Writes to audit sheet or calls external <code>LogAudit</code> macro. <br><strong>Invariants:</strong> Audit entries carry timestamp, user, action, subject and a tamper-evident row hash. <br><strong>Failure modes:</strong> If audit sheet cannot be created or written, error flows to Debug.Print; always try external <code>LogAudit</code> first. <br><strong>Security/PII:</strong> Audit lines may contain keys or ids; avoid putting raw PII values in <code>stable_id_or_name</code> where possible. <br><strong>Tests:</strong> Confirm audit calls succeed when <code>LogAudit</code> present (mock) and when absent it appends to <code>_IFRS_Audit</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>AppendLocalAuditStructured(...) / AppendLocalAudit(message)</strong> — <em>write structured or free-format audit lines into local audit sheet</em><br><strong>Purpose:</strong> Append structured/free-text audit entries to local hidden audit sheet with optional row hash. <br><strong>Signature:</strong> <code>Private Sub AppendLocalAuditStructured(ByVal action As String, ByVal subject As String, ByVal correlation_id As String, ByVal outcome As String, ByVal checksum As String, ByVal algorithm_tag As String)</code> and <code>Private Sub AppendLocalAudit(ByVal message As String)</code> — no return. <br><strong>Behavior:</strong> Ensure audit sheet exists via <code>EnsureAuditSheetExists</code>; append row with timestamp, username, action, subject, correlation id, outcome, checksum, algorithm and computed RowHash (CRC32 over timestamp<code>|</code>user<code>|</code>action). <code>AppendLocalAudit</code> stores timestamp, user, message and RowHash. Errors printed to debug. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Creates/updates <code>_IFRS_Audit</code> sheet; sets sheet visible=xlSheetVeryHidden on initial creation to protect it from casual editing. <br><strong>Tests:</strong> Audit append creates rows and rowhash computed. <br><strong>Notes:</strong> RowHash is tamper-evident only per-row; consider chaining if stronger guarantees required. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EnsureAuditSheetExists()</strong> — <em>create hidden audit sheet with headers if missing</em><br><strong>Purpose:</strong> Guarantee existence and correct header layout for local audit sheet. <br><strong>Signature:</strong> <code>Private Function EnsureAuditSheetExists() As Worksheet</code> — returns worksheet object or Nothing on failure. <br><strong>Behavior:</strong> Attempts <code>ThisWorkbook.Worksheets(AUDIT_SHEET_NAME)</code>. If missing adds sheet after last; attempts to set name and if name collision occurs picks timestamped suffix; sets <code>Visible = xlSheetVeryHidden</code>, writes header columns for structured audit including RowHash. Returns the sheet. On error prints debug and returns Nothing. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Adds hidden worksheet. <br><strong>Tests:</strong> Remove audit sheet and call function; ensure header row created and sheet hidden. <br><strong>Notes:</strong> VeryHidden sheets cannot be made visible by normal Excel UI—supporting code must be able to unhide if audit review required. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>HandleLocalError(procName, errNum, errDesc)</strong> — <em>error handler delegating to modError.HandleError when available</em><br><strong>Purpose:</strong> Centralized error routing; prefer <code>modError.HandleError</code> if present, else fallback to debug printing and structured audit. <br><strong>Signature:</strong> <code>Private Sub HandleLocalError(ByVal procName As String, ByVal errNum As Long, ByVal errDesc As String)</code> — no return. <br><strong>Behavior:</strong> Tries <code>Application.Run &quot;HandleError&quot;, errNum, errDesc, procName, GenerateCorrelationID()</code>; if that call fails logs to Debug and calls <code>Audit_LogStructured &quot;Error&quot;, procName, corr, &quot;error&quot;, Left(errDesc,200), &quot;&quot;</code>. Wraps attempts with <code>On Error Resume Next</code> to avoid raising from error handler. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Audit entries. <br><strong>Notes:</strong> Keep signature parity with modError. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>TryWithRetry_WriteToSheet(sh, found, keyName, json, correlation_id)</strong> — <em>write helper implementing atomic-ish temporary-column swap and retries</em><br><strong>Purpose:</strong> Perform a resilient write into metadata sheet with basic concurrency/protection handling: write JSON into temp column then copy into definitive column to avoid partial writes and try to handle protected sheets via shallow <code>Unprotect</code> attempt. <br><strong>Signature:</strong> <code>Private Function TryWithRetry_WriteToSheet(ByVal sh As Worksheet, ByVal found As Range, ByVal keyName As String, ByVal json As String, ByVal correlation_id As String) As Boolean</code> — returns True on success. <br><strong>Behavior (detailed):</strong> Attempts up to <code>MAX_RETRIES</code> iterations: checks <code>IsWorksheetWritable(sh)</code>; if writable disables <code>Application.ScreenUpdating</code> and <code>EnableEvents</code>; if <code>found</code> is Nothing computes new rowIdx = lastRow+1 and writes <code>sh.Cells(rowIdx, 1).value = keyName</code>; writes JSON into <code>METADATA_TEMP_COL</code>, then copies that temp cell into col 2 (definitive), then clears temp cell; if <code>found</code> provided performs similar writes into <code>found.row</code>; on success sets success True and returns True. If <code>IsWorksheetWritable</code> false waits <code>RETRY_WAIT_SECONDS</code> and retries. On write error uses <code>WriteFail</code> label to restore UI flags and call <code>HandleLocalError</code> then continues retry loop. Final failure returns False. <br><strong>Complexity:</strong> O(MAX_RETRIES) * O(1) per attempt; each attempt includes sheet write overhead. <br><strong>Side-effects:</strong> Modifies worksheet cells (temp col then copy); may create new metadata row; disables ScreenUpdating/EnableEvents during write. <br><strong>Invariants:</strong> Either definitive column 2 receives entire JSON string or no change occurs; temp column is cleared after copy. <br><strong>Failure modes:</strong> If Excel crashes between temp-write and copy, metadata may remain in temp column (unlikely but possible) — watch for orphan temp cells. <br><strong>Tests:</strong> Simulate <code>IsWorksheetWritable</code> false on initial attempts (mock) to test retry; verify temp column cleared after success; test interrupted flow (simulate error) to ensure error handling. <br><strong>Notes:</strong> This is best-effort "atomic-ish" but not transactional; consider using workbook-level protections or locking conventions if stronger atomicity needed. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>IsWorksheetWritable(sh As Worksheet)</strong> — <em>best-effort check and attempt to unprotect shallowly</em><br><strong>Purpose:</strong> Indicate whether writing to the provided worksheet is currently possible; if protected attempts <code>sh.Unprotect</code> once (best-effort). <br><strong>Signature:</strong> <code>Private Function IsWorksheetWritable(ByVal sh As Worksheet) As Boolean</code> — returns True/False. <br><strong>Behavior:</strong> If <code>sh</code> is Nothing returns False. If <code>sh.ProtectContents</code> True attempts <code>sh.Unprotect</code> wrapped in <code>On Error Resume Next</code>, if no error sets True, otherwise False. If not protected returns True. Errors logged via <code>HandleLocalError</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> May unprotect sheet (if no password). <br><strong>Failure modes:</strong> If sheet is password protected <code>Unprotect</code> will error and function returns False. <br><strong>Tests:</strong> Protected vs unprotected sheets. <br><strong>Notes:</strong> Unprotecting without password is a best-effort convenience—do not rely on it for unlocking password-protected sheets. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>CRC32_String(s As String)</strong> — <em>CRC32 calculation over bytes with cached table; returns 0 on error</em><br><strong>Purpose:</strong> Compute CRC32 checksum for string data used for checksuming JSON and audit row hashes; returns 0 on error to allow caller fallback to alternate hash. <br><strong>Signature:</strong> <code>Private Function CRC32_String(ByVal s As String) As Long</code> — returns 32-bit unsigned as <code>Long</code> (VBA Long). <br><strong>Behavior:</strong> If empty string returns 0; converts Unicode string to bytes via <code>StrToBytes</code> (StrConv vbFromUnicode) then iterates bytes computing CRC via table lookup <code>CRC32Table(index)</code> and bit ops; returns <code>Not crc &amp; &amp;HFFFFFFFF</code>. On error returns 0. <br><strong>Complexity:</strong> O(len(bytes)). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Table must be initialized prior to use (<code>CRC32Table</code> handles lazy init). <br><strong>Failure modes:</strong> On any runtime error returns 0 which signals caller to fallback (caller must treat 0 as sentinel). <br><strong>Tests:</strong> Known vector tests (e.g., CRC of "abc"). <br><strong>Notes:</strong> Numeric types in VB differ—ensure HexFromLong and formatting treat top bits correctly. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>CRC32Table(index As Long)</strong> — <em>lazily-initialized CRC32 table (0..255)</em><br><strong>Purpose:</strong> Provide CRC32 lookup table; initialized once per session using polynomial &HEDB88320. <br><strong>Signature:</strong> <code>Private Function CRC32Table(index As Long) As Long</code> — returns table value for index 0..255. <br><strong>Behavior:</strong> Uses Static array <code>tbl(0 To 255)</code> and <code>tblInitialized</code> flag; if not initialized iterates i,j to build table entries using bitwise operations; sets <code>tblInitialized=True</code>; returns <code>tbl(index)</code>. <br><strong>Complexity:</strong> Initialization O(256*8) constant; subsequent reads O(1). <br><strong>Side-effects:</strong> None beyond table initialization. <br><strong>Tests:</strong> Table initialization runs once; entries match standard CRC32 polynomial. <br><strong>Notes:</strong> Keep polynomial constant and code deterministic. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>DJB2_Hash(s As String)</strong> — <em>fallback deterministic hash when CRC32 unavailable</em><br><strong>Purpose:</strong> Provide a simple fallback hash function (DJB2 variant) for stable ids when CRC32 fails. <br><strong>Signature:</strong> <code>Private Function DJB2_Hash(ByVal s As String) As Long</code> — returns 32-bit integer. <br><strong>Behavior:</strong> Iterates characters computing <code>h = ((h * 33) + ch) And &amp;H7FFFFFFF</code> using AscW of chars and returns as CLng mask. On error returns 0. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Notes:</strong> Not cryptographically strong but deterministic and adequate as fallback. Test repeatability. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>StrToBytes(s As String)</strong> — <em>unicode->byte conversion helper</em><br><strong>Purpose:</strong> Convert VBA Unicode string to raw bytes via <code>StrConv(s, vbFromUnicode)</code> for CRC32. <br><strong>Signature:</strong> <code>Private Function StrToBytes(ByVal s As String) As Byte()</code> — returns byte array. <br><strong>Behavior:</strong> Delegates to <code>StrConv</code>. <br><strong>Notes:</strong> Caller must treat System codepage implications. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>HexFromLong(n As Long)</strong> — <em>format 32-bit value to 8-hex digits</em><br><strong>Purpose:</strong> Produce fixed 8-digit hex uppercase string for checksums/IDs. <br><strong>Signature:</strong> <code>Private Function HexFromLong(ByVal n As Long) As String</code> — returns e.g. <code>&quot;00A1B2C3&quot;</code>. <br><strong>Behavior:</strong> Masks n with <code>&amp;HFFFFFFFF</code> and formats with leading zeroes using <code>Right(&quot;00000000&quot; &amp; Hex(...), 8)</code>. <br><strong>Notes:</strong> Ensure correct handling of signed Long overflow. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SanitizeName(s As String)</strong> — <em>file/name-safe short sanitizer</em><br><strong>Purpose:</strong> Replace problematic filename/identifier characters with underscore and truncate to 50 chars. Used for named ranges and keys. <br><strong>Signature:</strong> <code>Private Function SanitizeName(ByVal s As String) As String</code> — returns sanitized string. <br><strong>Behavior:</strong> Replaces spaces and <code>\/[]:?*&#x27;</code> etc. with underscores; truncates to 50 length. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Strings with invalid chars sanitized; length truncated. <br><strong>Notes:</strong> Keep list of replaced characters consistent with Excel name rules. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SanitizeForCell(s As String)</strong> — <em>avoid formula injection by prefixing dangerous leading characters</em><br><strong>Purpose:</strong> Prevent formula injection by prefixing <code>&#x27;</code> when string starts with <code>=</code>, <code>+</code>, <code>-</code>, or <code>@</code>. <br><strong>Signature:</strong> <code>Private Function SanitizeForCell(ByVal s As String) As String</code> — returns sanitized string. <br><strong>Behavior:</strong> If first character of <code>s</code> is one of those characters, prefixes single-quote; otherwise returns original string. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> <code>=SUM()</code> -> <code>&#x27;=SUM()</code>. <br><strong>Notes:</strong> Consider expanding to remove other vectors if required. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SafeWriteRange(r As Range, v As Variant)</strong> — <em>robust write helper with retries and audit</em><br><strong>Purpose:</strong> Write value <code>v</code> to range <code>r</code> using <code>IsWorksheetWritable</code> and retry/backoff; temporarily disables UI updates and records structured audit on success/failure. <br><strong>Signature:</strong> <code>Private Sub SafeWriteRange(ByVal r As Range, ByVal v As Variant)</code> — no return. <br><strong>Behavior:</strong> For up to <code>MAX_RETRIES</code> checks <code>IsWorksheetWritable(r.Worksheet)</code> and if True disables ScreenUpdating/EnableEvents, sets <code>r.Value = v</code>, then re-enables UI flags and audits success; if not writable waits <code>RETRY_WAIT_SECONDS</code> and retries; on exhaustion audits failure. Errors handled by <code>HandleLocalError</code>. <br><strong>Complexity:</strong> O(MAX_RETRIES) * O(1) per attempt + I/O cost. <br><strong>Side-effects:</strong> Writes to workbook, may unprotect sheet temporarily if <code>IsWorksheetWritable</code> does so. <br><strong>Tests:</strong> Protected sheet should cause retries and final audit of failure. <br><strong>Notes:</strong> Use for small atomic writes only. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SafeReadRange(r As Range)</strong> — <em>defensive, exception-wrapped read</em><br><strong>Purpose:</strong> Safely read <code>r.Value</code> returning Null on failure and logging error. <br><strong>Signature:</strong> <code>Private Function SafeReadRange(ByVal r As Range) As Variant</code> — returns cell value or Null. <br><strong>Behavior:</strong> Try/catch wrapper around <code>r.Value</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Notes:</strong> Prefer to use when reading potentially problematic ranges. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>PauseSeconds(seconds As Double)</strong> — <em>sleep helper using Application.Wait</em><br><strong>Purpose:</strong> Pause execution for given seconds during retry/backoff loops. <br><strong>Signature:</strong> <code>Private Sub PauseSeconds(ByVal seconds As Double)</code> — no return. <br><strong>Behavior:</strong> Uses <code>DateAdd(&quot;s&quot;, seconds, Now)</code> and <code>Application.Wait t</code>. <br><strong>Notes:</strong> <code>Application.Wait</code> blocks Excel UI; keep sleeps short. Use sparingly. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GenerateCorrelationID()</strong> — <em>best-effort GUID-like correlation id generator</em><br><strong>Purpose:</strong> Create reproducible correlation id for audit lines using <code>Scriptlet.TypeLib</code> GUID when available, else fallback timestamp-based id. <br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code> — returns string guid-like id. <br><strong>Behavior:</strong> Tries <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code> with <code>On Error Resume Next</code>; strips braces; if unavailable returns timestamp <code>Format(Now,&quot;yyyymmddhhmmss&quot;) &amp; &quot;-&quot; &amp; Timer*1000</code>. Errors fallback to <code>&quot;corr-&quot; &amp; timestamp</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Notes:</strong> Good enough for correlation across calls; not cryptographically random. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>WriteSelfTestResults(results As Object)</strong> — <em>persist self-test results to hidden sheet</em><br><strong>Purpose:</strong> Append summarized self-test key/values to <code>TEST_RESULTS_SHEET</code> for diagnostics. <br><strong>Signature:</strong> <code>Private Sub WriteSelfTestResults(ByVal results As Object)</code> — no return. <br><strong>Behavior:</strong> Ensures <code>TEST_RESULTS_SHEET</code> exists (creates hidden sheet if needed), writes header row keys in row 1 and values in new row under timestamp. <br><strong>Complexity:</strong> O(#keys). <br><strong>Side-effects:</strong> Creates/updates test results sheet. <br><strong>Notes:</strong> Keep sheet hidden; tests should clear these when running in CI. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetWorksheetFromRange(target As Range)</strong> — <em>resolve worksheet for range, fallback to first worksheet</em><br><strong>Purpose:</strong> Return worksheet object for a given Range, or default to <code>ThisWorkbook.Worksheets(1)</code> if target is Nothing. <br><strong>Signature:</strong> <code>Private Function GetWorksheetFromRange(ByVal target As Range) As Worksheet</code> — returns Worksheet. <br><strong>Behavior:</strong> If <code>target</code> is Nothing returns first worksheet; else returns <code>target.Worksheet</code>. On error logs and returns first worksheet. <br><strong>Complexity:</strong> O(1). <br><strong>Notes:</strong> Simple helper to avoid repeated checks. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetTopLeftCellOfRange(target As Range)</strong> — <em>return top-left cell safely</em><br><strong>Purpose:</strong> Return <code>target.Cells(1,1)</code> or default cell A1 on error. <br><strong>Signature:</strong> <code>Private Function GetTopLeftCellOfRange(ByVal target As Range) As Range</code> — returns Range. <br><strong>Behavior:</strong> Wrapped with error handler; fallback to Worksheets(1).Cells(1,1). <br><strong>Notes:</strong> Avoid Null dereference in callers. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetHeaderSignature(target As Range)</strong> — <em>string signature produced by concatenating first-row cell texts</em><br><strong>Purpose:</strong> Produce deterministic header signature used in stable id seed. <br><strong>Signature:</strong> <code>Private Function GetHeaderSignature(ByVal target As Range) As String</code> — returns string like <code>|H1|H2|H3</code>. <br><strong>Behavior:</strong> Iterate cells in <code>target.Rows(1).Cells</code>, append <code>|</code> + trimmed cell text. <br><strong>Complexity:</strong> O(number_of_columns). <br><strong>Notes:</strong> Keep algorithm stable (ordering and trimming). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EnsureMetadataSheetExists()</strong> — <em>create and harden metadata sheet; run schema ensure</em><br><strong>Purpose:</strong> Create <code>_IFRS_Metadata</code> sheet if not present, add header row and set columns widths; call <code>EnsureMetadataSchema</code>. <br><strong>Signature:</strong> <code>Private Function EnsureMetadataSheetExists() As Worksheet</code> — returns Worksheet or Nothing. <br><strong>Behavior:</strong> Attempts to create sheet after last worksheet; if name collision occurs uses timestamped suffix; sets <code>Visible = xlSheetVeryHidden</code>, writes headers and column widths; calls <code>EnsureMetadataSchema</code>. Returns sheet. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Adds hidden worksheet. <br><strong>Notes:</strong> Keep this function robust as many public functions rely on it. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>ExportMetadataToJson(Optional fileName As String = "")</strong> — <em>export stored metadata rows into a JSON file in workbook folder</em><br><strong>Purpose:</strong> Produce a single JSON file aggregating all metadata rows keyed by metadata key. Useful for backups/transfer. <br><strong>Signature:</strong> <code>Public Function ExportMetadataToJson(Optional ByVal fileName As String = &quot;&quot;) As Boolean</code> — returns True on success. <br><strong>Behavior:</strong> Ensures metadata sheet exists; reads rows 2..lastRow converting each row's JSON string to dictionary and stores into <code>outDict</code> keyed by row key; if <code>fileName</code> empty composes default path <code>ThisWorkbook.Path &amp; &quot;\ifrs_metadata_export_yyyymmddHHNNSS.json&quot;</code>; writes JSON string via FileSystemObject <code>CreateTextFile</code> (unicode) then logs audit <code>&quot;ExportMetadataToJson&quot;</code>. Returns True if successful. On error uses <code>HandleLocalError</code> and returns False. <br><strong>Complexity:</strong> O(number_of_metadata_rows * parseCost). <br><strong>Side-effects:</strong> Writes file to workbook path; creates audit entry. <br><strong>Failure modes:</strong> If <code>ThisWorkbook.Path</code> empty (unsaved workbook) file path generation will fail; FSO write error due to permissions leads to false. <br><strong>Security/PII:</strong> Export file may contain PII — ensure proper handling/control of exported file. <br><strong>Tests:</strong> Round-trip export/import; ensure file exists and JSON valid. <br><strong>Notes:</strong> Respect workbook being unsaved — consider prompting caller or erroring with clear message. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>ImportMetadataFromJson(filepath As String, Optional dryRun As Boolean = True, Optional conflictResolution As String = "skip")</strong> — <em>import a JSON metadata file into metadata sheet with optional dry-run</em><br><strong>Purpose:</strong> Allow administrators to import metadata JSON file into metadata sheet with optional dry-run to preview and conflict resolution policy. <br><strong>Signature:</strong> <code>Public Function ImportMetadataFromJson(ByVal filepath As String, Optional ByVal dryRun As Boolean = True, Optional ByVal conflictResolution As String = &quot;skip&quot;) As Boolean</code> — returns True on success (even for dry-run). <br><strong>Behavior (detailed):</strong> Validate <code>filepath</code>; open via FSO <code>OpenTextFile</code>, read all to <code>content</code>; parse <code>JsonToDictionary(content)</code> (top-level expected to be object mapping keys->metadata dictionaries); for each key if <code>dryRun</code> just computes what would change; if not dryRun obtains metadata sheet and finds existing via <code>SafeFindInColumn(sh,1,idKey)</code>: if no found creates new row with key and <code>DictionaryToJson(metaVal)</code> in col 2; if found and <code>conflictResolution=&quot;overwrite&quot;</code> then writes <code>METADATA_TEMP_COL</code> then copies to col 2; logs audit <code>ImportMetadataFromJson</code> with dryRun flag. Returns True. On errors logs and returns False. <br><strong>Complexity:</strong> O(entries_in_file * writeCost). <br><strong>Side-effects:</strong> Writes to metadata sheet when <code>dryRun=False</code>; may modify workbook. <br><strong>Failure modes:</strong> Malformed JSON (JsonToDictionary returns empty dict) → function returns False; file not found → False. <br><strong>Security / PII:</strong> Importing can overwrite existing metadata with PII — ensure operator consent; prefer dry-run by default. <br><strong>Tests:</strong> Dry-run reports no writes; import with overwrite updates existing rows; import with skip doesn't overwrite. <br><strong>Notes:</strong> Consider supporting transactional import or backup of metadata prior to destructive import. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NullSafeValue(v As Variant)</strong> — <em>normalize values to strings; serialize nested dictionary recursively</em><br><strong>Purpose:</strong> Convert various variant types into safe string for JSON serialization: Null/Empty -> <code>&quot;&quot;</code>, Dictionary -> serialized JSON, otherwise <code>CStr</code>. <br><strong>Signature:</strong> <code>Private Function NullSafeValue(ByVal v As Variant) As String</code> — returns string. <br><strong>Behavior:</strong> If <code>IsObject(v)</code> and TypeName = "Dictionary" returns <code>DictionaryToJson(v)</code>; else <code>CStr</code> of value or empty string for Null/Empty. <br><strong>Notes:</strong> This keeps JSON serializer simple; do not pass non-serializable COM objects. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SplitOnFirstColon(s As String)</strong> — <em>split a key:value pair string on the first colon while preserving quoted colons</em><br><strong>Purpose:</strong> Utility used by <code>JsonToDictionary</code> to correctly split top-level JSON tokens into key/value pair even when values contain <code>:</code> inside quotes or nested objects. <br><strong>Signature:</strong> <code>Private Function SplitOnFirstColon(ByVal s As String) As String()</code> — returns 2-element array: [left, right]. <br><strong>Behavior:</strong> Iterates characters tracking quoted state and escape to find first unquoted colon; returns left substring and remainder. If none found returns [s, ""]. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Tests:</strong> Input with quoted colons returns correct split. <br><strong>Notes:</strong> Very small but critical for robust parser. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>UnquoteAndUnescape(token As String)</strong> — <em>remove surrounding quotes and unescape JSON-like escapes</em><br><strong>Purpose:</strong> Convert a JSON string token into raw string: remove surrounding double quotes if present, replace <code>\\</code>-><code>\</code>, <code>\&quot;</code>-><code>&quot;</code>, <code>\n</code>->LF etc. <br><strong>Signature:</strong> <code>Private Function UnquoteAndUnescape(ByVal token As String) As String</code> — returns unescaped string. <br><strong>Behavior:</strong> Trim input; remove outer quotes if present; replace common escape sequences; return token. Logs errors and returns input on error. <br><strong>Complexity:</strong> O(len(token)). <br><strong>Tests:</strong> Strings containing <code>\&quot;</code>, <code>\n</code> produce expected outputs. <br><strong>Notes:</strong> Not a full JSON unescape, but sufficient for produced JSON. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>JsonEscape(s As String)</strong> — <em>escape string for JSON (backslash + quote + newline)</em><br><strong>Purpose:</strong> Escape backslashes, quotes and CR/LF for <code>DictionaryToJson</code>. <br><strong>Signature:</strong> <code>Private Function JsonEscape(ByVal s As String) As String</code> — returns escaped string. <br><strong>Behavior:</strong> Replace <code>\</code>-><code>\\</code>, <code>&quot;</code>-><code>\&quot;</code>, newlines -> <code>\n</code>. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Notes:</strong> Keep consistent with <code>UnquoteAndUnescape</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>PII_Detect(s As String)</strong> — <em>very conservative heuristic to detect presence of potential PII</em><br><strong>Purpose:</strong> Provide a quick heuristic for flagging values possibly containing email addresses, long digit sequences or keywords like <code>ssn</code>, <code>password</code>, <code>secret</code>. <br><strong>Signature:</strong> <code>Private Function PII_Detect(ByVal s As String) As Boolean</code> — returns True if heuristics match. <br><strong>Behavior:</strong> Lowercases string; if contains <code>@</code> and <code>.</code> returns True; if <code>OnlyDigits</code> length >= 8 returns True; contains <code>ssn|password|secret</code> returns True. Else False. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Limitations:</strong> Heuristic only—false positives/negatives possible. <br><strong>Tests:</strong> Emails, long digit sequences flagged; normal words not flagged. <br><strong>Notes:</strong> Consider integrating with policy/consent flow before storing flagged values. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NZString(v As Variant)</strong> — <em>null/empty to empty-string helper</em><br><strong>Purpose:</strong> Normalize variants to strings to reduce Null checks. <br><strong>Signature:</strong> <code>Private Function NZString(ByVal v As Variant) As String</code> — returns string. <br><strong>Behavior:</strong> If IsNull/IsEmpty return <code>&quot;&quot;</code> else <code>CStr(v)</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>OnlyDigits(s As String)</strong> — <em>strip non-digit characters</em><br><strong>Purpose:</strong> Return only digits from string (used by PII_Detect). <br><strong>Signature:</strong> <code>Private Function OnlyDigits(ByVal s As String) As String</code> — returns digits-only string. <br><strong>Behavior:</strong> Iterates characters, appends those matching <code>[0-9]</code>. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Tests:</strong> <code>&quot;a1b2 345&quot;</code> -> <code>&quot;12345&quot;</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NzLong(v As Variant, Optional def As Long = 0)</strong> — <em>safe numeric conversion</em><br><strong>Purpose:</strong> Return numeric <code>CLng</code> or default if not numeric. <br><strong>Signature:</strong> <code>Private Function NzLong(ByVal v As Variant, Optional ByVal def As Long = 0) As Long</code> — returns long. <br><strong>Behavior:</strong> If <code>IsNumeric(v)</code> returns <code>CLng(v)</code>, else <code>def</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>Module-level maintenance & security notes (summary)</strong><br><strong>Determinism:</strong> Stable IDs rely on <code>GetWorkbookFingerprint</code> and <code>GetHeaderSignature</code> — both must remain stable to preserve mapping between stored metadata and table ranges. Any change to fingerprint algorithm is breaking. <br><strong>Atomicity & concurrency:</strong> Writes are best-effort atomic using temp column pattern and retries. This is <em>not</em> a transactional guarantee; concurrent edits by multiple users/instances can race. Consider explicit locking or using hidden workbook-level flag if multi-user scenario is expected. <br><strong>JSON handling:</strong> <code>DictionaryToJson</code>/<code>JsonToDictionary</code> implements a minimal deterministic JSON subset (objects & strings & nested objects). It intentionally avoids arrays, numbers, booleans — if you require richer metadata migrate to a robust JSON parser (MSXML DOM or third-party library) with backward compatibility. <br><strong>Auditing:</strong> Audit attempts to call <code>LogAudit</code> in <code>modAudit</code> first, falling back to local <code>_IFRS_Audit</code>. Audit rows include <code>RowHash</code> computed by CRC32 over timestamp/user/action — tamper-evident only per-row. For stronger tamper detection use chained hashes or HMAC with a secret store. <br><strong>Error handling:</strong> <code>HandleLocalError</code> delegates to <code>modError.HandleError</code> when available — maintain parity in signature. Avoid raising errors from within error handling flow (function uses <code>On Error Resume Next</code> to preserve robustness). <br><strong>Security & PII:</strong> Caption/capturing sanitized for formula injection; JSON export/import and audit may contain PII — document retention policy and ensure operator awareness. <code>PII_Detect</code> is provided for heuristics but not auto-blocking. <br><strong>Testing recommendations (concise):</strong> 1) Round-trip metadata write/read and checksum verification. 2) SelfTest runs in disposable workbook. 3) Concurrency/mock-protected-sheet tests for retry/backoff. 4) JSON round-trip and nested dictionary tests. 5) StableID stability across saves and header edits. 6) TOC named-range idempotency. <br><strong>Maintenance notes:</strong> Changing serialization, stable-id seed, or metadata key prefix are breaking changes and require data migration. Any addition of arrays/booleans in metadata must be accompanied by migration tooling. Consider centralizing constants and extracting JSON support to a single well-tested helper to ease future upgrades. </td></tr></tbody></table></div><div class="row-count">Rows: 52</div></div><div class="table-caption" id="Table4" data-table="Docu_0160_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modUtilities)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modUtilities)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Overview:</strong> This table provides a per-function, exhaustive technical breakdown of the <code>modUtilities</code> VBA module you supplied. Each entry documents: purpose, signature (inputs/outputs), deterministic internal behaviour, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended unit/integration tests, and short maintainer notes. Use as authoritative inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>EnsureCaches()</strong> — <em>idempotent cache initialization</em><br><strong>Purpose:</strong> Initialize module-level caches (<code>g_namedRangeCache</code>, <code>g_comCache</code>) and seed RNG; must be cheap and safe to call repeatedly from different entry points.<br><strong>Signature:</strong> <code>EnsureCaches()</code> -> <code>Void</code> (initializes module-level state).<br><strong>Behavior:</strong> If caches already initialized (<code>g_cacheInitialized</code>), returns immediately. Attempts to create <code>Scripting.Dictionary</code> objects for <code>g_namedRangeCache</code> and <code>g_comCache</code> using <code>CreateObject</code> while swallowing errors. Calls <code>Randomize</code> and sets <code>g_cacheInitialized = True</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates module globals; may allocate COM dictionary objects.<br><strong>Invariants:</strong> After success, <code>g_cacheInitialized = True</code> and caches are non-Nothing dictionaries when the environment supports them. Safe to call from multiple modules without duplication. <br><strong>Failure modes:</strong> If <code>CreateObject(&quot;Scripting.Dictionary&quot;)</code> fails, caches remain <code>Nothing</code> but function returns silently; callers relying on caches should handle <code>Nothing</code> checks. <br><strong>Security/Permissions:</strong> Low-Risk; requires ability to create COM objects. <br><strong>Tests:</strong> Call twice; assert no error and <code>g_cacheInitialized = True</code>. Simulate environment where <code>Scripting.Dictionary</code> unavailable (mock CreateObject failure) and assert function still returns without raising. <br><strong>Notes:</strong> Keep idempotency; avoid calling <code>CreateObjectSafe</code> inside this to prevent recursion as implemented. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ResetCaches()</strong> — <em>clear and re-init caches</em><br><strong>Purpose:</strong> Clear in-memory caches and reset cache availability flags so subsequent calls re-probe environment capabilities.<br><strong>Signature:</strong> <code>ResetCaches()</code> -> <code>Void</code> (clears module caches and flags).<br><strong>Behavior:</strong> Removes all entries from <code>g_namedRangeCache</code> and <code>g_comCache</code> if they are dictionaries, resets tri-state flags <code>g_adodbAvailable</code>, <code>g_certutilAvailable</code> to <code>Empty</code>, clears <code>g_cacheInitialized</code> and calls <code>EnsureCaches()</code> to reinitialize. Uses defensive <code>On Error Resume Next</code> to avoid propagation.<br><strong>Complexity:</strong> O(n) in number of cached keys; typically cheap. <br><strong>Side-effects:</strong> Empties caches; subsequent calls to <code>CreateObjectSafe</code> / feature checks will re-evaluate availability. <br><strong>Invariants:</strong> After call, caches are freshly initialized (or <code>Nothing</code> if creation failed) and availability flags are <code>Empty</code>. <br><strong>Failure modes:</strong> If dictionary methods fail, function handles errors silently but logs nothing — test coverage needed. <br><strong>Tests:</strong> Populate caches, call <code>ResetCaches()</code>, assert caches are empty or reinitialized and availability flags cleared. <br><strong>Notes:</strong> Useful for tests and self-healing when environment changes (e.g., COM availability toggles). </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeLogAudit(src, message)</strong> — <em>tolerant audit logger with fallbacks</em><br><strong>Purpose:</strong> Attempt to call <code>LogAudit</code> with several signatures; fallback to <code>Debug.Print</code> when unavailable. Designed to not raise errors from missing host procedures.<br><strong>Signature:</strong> <code>SafeLogAudit(ByVal src As String, ByVal message As String)</code> -> <code>Void</code>.<br><strong>Behavior:</strong> Builds <code>joined = src &amp; &quot; | &quot; &amp; message</code>. Verifies <code>Application</code> type is available; tries <code>Application.Run &quot;LogAudit&quot;, src, message</code>, then <code>Application.Run &quot;LogAudit&quot;, joined</code>, then <code>Application.Run &quot;LogAudit&quot;, message</code>; if all fail, <code>Debug.Print joined</code>. Always swallows errors via <code>On Error Resume Next</code> so callers remain robust.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls host macro <code>LogAudit</code> if present; outputs to Immediate window otherwise. <br><strong>Invariants:</strong> Never raises; best-effort audit call. <br><strong>Failure modes:</strong> Missing <code>Application</code> context or <code>LogAudit</code> signature mismatches — handled by fallbacks. <br><strong>Security/Privacy:</strong> Audit payloads may contain sensitive info; callers must sanitize PII before calling. <br><strong>Tests:</strong> Stub <code>LogAudit</code> with varying signatures and ensure correct branch chosen; with no <code>LogAudit</code>, ensure <code>Debug.Print</code> output occurs. <br><strong>Notes:</strong> Keep tolerant order of calls; consider adding correlation ID in future. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeHandleError(procName, errNum, errDesc)</strong> — <em>robust centralized error reporter</em><br><strong>Purpose:</strong> Deliver errors to host <code>HandleError</code> routines with multiple signature attempts and fallback to audit + Debug.Print. Must never raise further errors itself.<br><strong>Signature:</strong> <code>SafeHandleError(ByVal procName As String, ByVal errNum As Long, ByVal errDesc As String)</code> -> <code>Void</code>.<br><strong>Behavior:</strong> Constructs <code>payload = &quot;(&quot; &amp; CStr(errNum) &amp; &quot;) &quot; &amp; Nz(errDesc, &quot;&quot;)</code>. If <code>Application</code> is not available, prints via <code>Debug.Print</code>. Otherwise tries multiple <code>Application.Run &quot;HandleError&quot;</code> signatures in tolerant order; if all fail, logs via <code>SafeLogAudit</code> and <code>Debug.Print</code>. Always <code>On Error Resume Next</code> to suppress exceptions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls host error handler or logs. <br><strong>Invariants:</strong> Idempotent and non-throwing. <br><strong>Failure modes:</strong> Mis-matched <code>HandleError</code> signatures — handled by try sequence; aim to not obscure root cause: consider also returning boolean in the future. <br><strong>Security:</strong> Error messages may include sensitive data. Avoid logging secrets. <br><strong>Tests:</strong> Simulate different <code>HandleError</code> signatures and ensure correct fallback; ensure no exceptions when <code>Application</code> missing. <br><strong>Notes:</strong> Preserve signature trial order for compatibility. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ResolveWorkbook(Optional targetWb)</strong> — <em>deterministic workbook resolver</em><br><strong>Purpose:</strong> Resolve which <code>Workbook</code> to operate on with prioritized rules: explicit argument -> <code>Application.ActiveWorkbook</code> -> <code>ThisWorkbook</code> fallback.<br><strong>Signature:</strong> <code>ResolveWorkbook(Optional ByVal targetWb As Variant) As Workbook</code>.<br><strong>Behavior:</strong> If <code>targetWb</code> provided and is an object of <code>Workbook</code>, returns it. Else attempts <code>Application.ActiveWorkbook</code> if present; otherwise returns <code>ThisWorkbook</code>. Uses defensive checks to avoid type errors. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Always returns a <code>Workbook</code> object (or <code>Nothing</code> if environment invalid). <br><strong>Failure modes:</strong> If <code>Application</code> is missing or <code>ThisWorkbook</code> unavailable (rare in unusual host), returns <code>Nothing</code>. <br><strong>Tests:</strong> Pass explicit workbook object, pass Nothing, test when no active workbook open; ensure fallbacks behave as documented. <br><strong>Notes:</strong> Favours the user's explicit target; callers should guard against <code>Nothing</code> when used in unattended contexts. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SheetExists(name, Optional targetWb)</strong> — <em>presence check for worksheets</em><br><strong>Purpose:</strong> Return whether a sheet with <code>name</code> exists in resolved workbook.<br><strong>Signature:</strong> <code>SheetExists(ByVal name As String, Optional ByVal targetWb As Variant) As Boolean</code>.<br><strong>Behavior:</strong> Resolve workbook, attempt <code>wb.Worksheets(name)</code> inside <code>On Error Resume Next</code> and set boolean accordingly. Errors are sent to <code>SafeHandleError</code> on unexpected exception paths. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Deterministic for workbook at call-time. <br><strong>Failure modes:</strong> If <code>wb</code> is <code>Nothing</code>, returns False; name lookup could raise permissions errors in protected workbooks — function returns False and logs. <br><strong>Tests:</strong> Existing sheet returns True, missing sheet returns False, protected workbook scenarios. <br><strong>Notes:</strong> Use for conditional creation/deletion flows. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeGetWorksheet(Optional targetWb, sheetName)</strong> — <em>safe getter for Worksheet</em><br><strong>Purpose:</strong> Return a <code>Worksheet</code> object for a given sheet name if present; silent on failure (returns Nothing).<br><strong>Signature:</strong> <code>SafeGetWorksheet(Optional ByVal targetWb As Variant, ByVal sheetName As String = &quot;&quot;) As Worksheet</code>.<br><strong>Behavior:</strong> Resolves workbook, validates <code>sheetName</code> non-empty, calls <code>wb.Worksheets(sheetName)</code> under <code>On Error Resume Next</code>, returns object or Nothing. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Returns Nothing when name empty or not found. <br><strong>Failure modes:</strong> Protected sheets, invalid workbook types; function returns Nothing. <br><strong>Tests:</strong> Valid name returns Worksheet; blank name returns Nothing; check behaviour under workbook with macros-disabled. <br><strong>Notes:</strong> Good for safe downstream operations; avoids raising for missing sheets. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeCreateSheet(sheetName, Optional targetWb, Optional beforeSheet, Optional veryHidden=True, Optional backupIfExists=True)</strong> — <em>create-or-reuse sheet with safe naming and backup</em><br><strong>Purpose:</strong> Create a worksheet with requested name or reuse existing; optionally backup existing sheet and set very hidden visibility. Provides deterministic behavior on name collisions and failing name assignment.<br><strong>Signature:</strong> <code>SafeCreateSheet(ByVal sheetName As String, Optional ByVal targetWb As Variant, Optional ByVal beforeSheet As Variant, Optional ByVal veryHidden As Boolean = True, Optional ByVal backupIfExists As Boolean = True) As Worksheet</code>.<br><strong>Behavior:</strong> Resolves workbook; if sheet exists and <code>backupIfExists</code> true, calls <code>BackupSheet</code> and returns existing sheet. Otherwise attempts to add a sheet (After last or Before provided sheet). Tries to set <code>ws.Name = sheetName</code>; on failure (invalid or duplicate) generates a safe truncated base via <code>SafeSheetName</code>, appends <code>_i</code> counter up to 1000 to ensure unique name. Sets <code>.Visible = xlSheetVeryHidden</code> when requested. Returns worksheet or Nothing on error (logged). <br><strong>Complexity:</strong> O(1) typical; worst-case O(k) where <code>k</code> is counter tries for unique name (<1000).<br><strong>Side-effects:</strong> May create new sheet, back it up, set visibility and name. <br><strong>Invariants:</strong> Returned sheet usable; name unique in workbook. <br><strong>Failure modes:</strong> Running out of name attempts (rare), workbook protections, lack of permission to add sheets (handled via SafeHandleError). <br><strong>Security:</strong> Careful when creating sheets in untrusted files — no execution of code. <br><strong>Tests:</strong> Create with new name; create with existing name returns that sheet (and backup created); simulate invalid sheet name characters -> unique sanitized name created; workbook protected -> handled gracefully. <br><strong>Notes:</strong> Keeps API stable; backup path uses <code>GetTempFolder</code>. Consider exposing collision strategy to caller in future. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeDeleteSheet(sheetName, Optional targetWb, Optional backupBeforeDelete=True)</strong> — <em>safe deletion with optional backup</em><br><strong>Purpose:</strong> Delete named worksheet after optional backup; ensure <code>Application.DisplayAlerts</code> suppressed to avoid UI prompts and restored afterward.<br><strong>Signature:</strong> <code>SafeDeleteSheet(ByVal sheetName As String, Optional ByVal targetWb As Variant, Optional ByVal backupBeforeDelete As Boolean = True)</code> -> <code>Void</code>.<br><strong>Behavior:</strong> Resolve workbook and worksheet; if <code>backupBeforeDelete</code> true call <code>BackupSheet</code>; sets <code>Application.DisplayAlerts = False</code>, deletes worksheet, then restores alerts. Errors routed to <code>SafeHandleError</code>. <br><strong>Complexity:</strong> O(1) plus backup cost. <br><strong>Side-effects:</strong> Deletes sheet; may create backup file. <br><strong>Invariants:</strong> Alerts restored even on error (attempted). <br><strong>Failure modes:</strong> Protected workbooks, backup failure; in such cases deletion may not occur and error logged. <br><strong>Tests:</strong> Delete existing sheet with backup; delete when sheet missing (no-op); simulate backup failure and ensure alerts state restored. <br><strong>Notes:</strong> Ensure macro runs in non-interactive mode handle DisplayAlerts consistently. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>BackupSheet(wb, ws)</strong> — <em>private: sheet copy backup to temp workbook</em><br><strong>Purpose:</strong> Copy a single worksheet into a new temporary workbook and save to a timestamped file for recovery/audit before destructive operations.<br><strong>Signature:</strong> <code>Private BackupSheet(wb As Workbook, ws As Worksheet)</code> -> <code>Void</code>.<br><strong>Behavior:</strong> Determine <code>tmpPath</code> via <code>GetTempFolder(wb)</code> with fallbacks (<code>wb.path</code>, <code>Application.DefaultFilePath</code>, <code>Environ(&quot;TEMP&quot;)</code>). Creates new workbook, copies sheet before its first sheet, saves as <code>.xlsx</code> at <code>tmpFile</code> using <code>SaveAs</code> with <code>xlOpenXMLWorkbook</code>, closes tmp workbook. Removes temporary workbook on error. Logs via <code>SafeLogAudit</code>. Uses defensive error handling. <br><strong>Complexity:</strong> O(size of sheet) I/O-bound. <br><strong>Side-effects:</strong> Creates file in temp folder. <br><strong>Invariants:</strong> If successful, an .xlsx backup exists at <code>tmpFile</code>. <br><strong>Failure modes:</strong> No writable temp path, save errors (permissions),Clipboard side-effects from Copy operation under some versions of Excel. <br><strong>Security:</strong> Backups may contain sensitive data — policy must enforce storage/location handling. <br><strong>Tests:</strong> Backup simple sheet, check file exists and contains copied sheet; simulate no temp folder to confirm logged error path. <br><strong>Notes:</strong> Consider exposing retention policy or configurable backup folder. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeSheetName(s)</strong> — <em>private: sanitize sheet name</em><br><strong>Purpose:</strong> Remove or replace characters invalid in Excel sheet names and truncate to 31 characters.<br><strong>Signature:</strong> <code>Private SafeSheetName(ByVal s As String) As String</code>.<br><strong>Behavior:</strong> Truncates to 31 chars and replaces <code>/ \ : ? * [ ]</code> with <code>_</code>. Returns sanitized string. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Output is a valid candidate for sheet <code>Name</code> property (subject to uniqueness). <br><strong>Tests:</strong> Strings with invalid chars are sanitized; longer strings truncated. <br><strong>Notes:</strong> Centralizes name sanitization. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>NamedRangeExists(rangeName, Optional targetWb)</strong> — <em>detect named range presence</em><br><strong>Purpose:</strong> Return whether a name exists in workbook <code>Names</code> collection.<br><strong>Signature:</strong> <code>NamedRangeExists(ByVal rangeName As String, Optional ByVal targetWb As Variant) As Boolean</code>.<br><strong>Behavior:</strong> Resolve workbook; attempt <code>wb.Names(rangeName)</code> inside <code>On Error Resume Next</code>; return boolean. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Accurate for workbook state at call moment. <br><strong>Failure modes:</strong> Errors when <code>Names</code> access restricted — returns False. <br><strong>Tests:</strong> Present and absent names. <br><strong>Notes:</strong> Use for conditional named-range creation. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GetNamedRangeValue(rangeName, Optional targetWb)</strong> — <em>read named range value with caching</em><br><strong>Purpose:</strong> Return the value of a named range or the <code>RefersTo</code> string when it's not a range; uses local cache (<code>g_namedRangeCache</code>) to speed repeated lookups.<br><strong>Signature:</strong> <code>GetNamedRangeValue(ByVal rangeName As String, Optional ByVal targetWb As Variant) As Variant</code>.<br><strong>Behavior:</strong> Resolve workbook, ensure caches, compute key <code>rangeNameKey(wb, rangeName)</code>. If cache hit return cached value. Else attempt <code>wb.Names(rangeName)</code>. If <code>RefersToRange</code> exists return <code>rng.Value</code>; otherwise return <code>nm.RefersTo</code> (string). Store result into cache in a single assignment. Errors produce <code>Empty</code>. <br><strong>Complexity:</strong> O(1) amortized when cached; first read cost O(1) with potential COM calls. <br><strong>Side-effects:</strong> May create or update cache entry. <br><strong>Invariants:</strong> Cache contains last-read value; not automatically invalidated by workbook edits (caller must call <code>ClearNamedRangeCache()</code> if needed). <br><strong>Failure modes:</strong> Named range referring to external or invalid reference; reading <code>RefersToRange</code> can raise — function returns <code>Empty</code> and logs. <br><strong>Security:</strong> Values may be formulas or external references; consumer must validate. <br><strong>Tests:</strong> Named range that references a cell returns value; named formula returns <code>RefersTo</code> string; cache hit returns same value; deletion of named range should be followed by cache clear to reflect changes. <br><strong>Notes:</strong> Consider exposing TTL or invalidation hooks; current design is simple and predictable. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SetNamedRangeValue(rangeName, value, Optional targetWb)</strong> — <em>create or update named range value</em><br><strong>Purpose:</strong> Ensure a named range exists and set its value; creates a new name pointing to cell A1 on first worksheet when needed.<br><strong>Signature:</strong> <code>SetNamedRangeValue(ByVal rangeName As String, ByVal value As Variant, Optional ByVal targetWb As Variant)</code>.<br><strong>Behavior:</strong> Resolve workbook; find <code>wb.Names(rangeName)</code>. If not present, write <code>value</code> into <code>anchor.Worksheets(1).Range(&quot;A1&quot;)</code> and add a name pointing to that cell. If present, try <code>nm.RefersToRange</code> and set value; if <code>RefersToRange</code> absent, set <code>nm.RefersTo</code> to <code>= &#x27;Sheet&#x27;!$A$1</code> then set cell value. Ensure cache updated. Errors handled by <code>SafeHandleError</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> May create sheet cell content; updates cache. <br><strong>Invariants:</strong> After call, named range will reference a real cell and contain desired value. <br><strong>Failure modes:</strong> Protected workbook or read-only workbook, or <code>wb.Worksheets(1)</code> unavailable; in such cases function logs error and fails silently. <br><strong>Tests:</strong> Create new name; update existing name that references range; update name that refers to formula. <br><strong>Notes:</strong> This function purposefully uses A1 as anchor when name missing — acceptable for small metadata but document collisions risk if A1 used by user. Consider dedicated hidden-sheet anchor in future. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>CreateOrUpdateNamedRange(rangeName, rng, Optional targetWb)</strong> — <em>bind name to explicit range</em><br><strong>Purpose:</strong> Add or update workbook-level name to refer to provided <code>Range</code> object; updates cache with range's <code>.Value</code>.<br><strong>Signature:</strong> <code>CreateOrUpdateNamedRange(ByVal rangeName As String, ByVal rng As Range, Optional ByVal targetWb As Variant)</code>.<br><strong>Behavior:</strong> Resolve workbook; compute <code>ref = &quot;=&quot; &amp; &quot;&#x27;&quot; &amp; rng.Parent.Name &amp; &quot;&#x27;!&quot; &amp; rng.Address(True, True, xlA1)</code>; try <code>wb.Names.Add name:=rangeName, RefersTo:=ref</code>; on error attempt to set existing <code>wb.Names(rangeName).RefersTo = ref</code>. Update cache to <code>rng.Value</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Modifies <code>Names</code> collection. <br><strong>Invariants:</strong> Name will refer to given range. <br><strong>Failure modes:</strong> Protected workbook; invalid range; logs error. <br><strong>Tests:</strong> Create new name; update existing name to new range. <br><strong>Notes:</strong> Use when precise range binding required (preferred over SetNamedRangeValue for structured metadata). </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>rangeNameKey(wb, rangeName)</strong> — <em>private: cache key generator</em><br><strong>Purpose:</strong> Create deterministic cache key for named range by combining workbook name and range name.<br><strong>Signature:</strong> <code>Private rangeNameKey(wb As Workbook, rangeName As String) As String</code>.<br><strong>Behavior:</strong> If <code>wb</code> is Nothing returns <code>&quot;|&quot; &amp; rangeName</code> else returns <code>wb.Name &amp; &quot;|&quot; &amp; rangeName</code> using <code>Nz</code> on <code>wb.Name</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Lightweight helper to avoid cache collisions across open workbooks. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ClearNamedRangeCache()</strong> — <em>evict named-range cache</em><br><strong>Purpose:</strong> Remove all entries from <code>g_namedRangeCache</code> to force fresh lookups.<br><strong>Signature:</strong> <code>ClearNamedRangeCache()</code> -> <code>Void</code>.<br><strong>Behavior:</strong> Ensures caches exist and clears dictionary via <code>RemoveAll</code> if available. <br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> Invalidates cached named-range values. <br><strong>Tests:</strong> Populate cache then clear and confirm misses. <br><strong>Notes:</strong> Call after workbook import/restore or name changes. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeWriteRange(ws, topRow, topCol, data)</strong> — <em>fast array-to-range writer (0/1-based arrays and scalars)</em><br><strong>Purpose:</strong> Write a 1D/2D VBA array or single scalar to a worksheet range with support for 0-based arrays by normalizing to 1-based variant arrays expected by Excel interop.<br><strong>Signature:</strong> <code>SafeWriteRange(ws As Worksheet, topRow As Long, topCol As Long, data As Variant)</code>.<br><strong>Behavior:</strong> If <code>data</code> is an array, attempt to determine <code>LBound/UBound</code> for 2D; fallback to treat 1D arrays as single-column vertical range and build <code>tmp</code> 2D array. For arrays with zero-based LBound in either dimension, copy elements into <code>outArr(1 To rCount, 1 To cCount)</code> then write with <code>.Cells(topRow, topCol).Resize(...).Value = outArr</code>. If <code>data</code> is scalar write cell directly. Errors forwarded to <code>SafeHandleError</code>. <br><strong>Complexity:</strong> O(rCount*cCount) for copying zero-based arrays; memory copy overhead. <br><strong>Side-effects:</strong> Writes to worksheet cells. <br><strong>Invariants:</strong> Excel receives a 1-based 2D array when necessary. <br><strong>Failure modes:</strong> Non-rectangular arrays or jagged arrays will create run-time errors; function attempts to handle common shapes. <br><strong>Tests:</strong> Write 2D 1-based array; write 2D 0-based array; write 1D array; scalar write. <br><strong>Notes:</strong> Important for high-performance sheet writes; ensure large arrays handled within memory limits. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeReadRange(ws, topRow, topCol, rows, cols)</strong> — <em>read range into variant</em><br><strong>Purpose:</strong> Read rectangle from worksheet into a variant (Excel 2D array or scalar) defensively.<br><strong>Signature:</strong> <code>SafeReadRange(ws As Worksheet, topRow As Long, topCol As Long, rows As Long, cols As Long) As Variant</code>.<br><strong>Behavior:</strong> Validates <code>rows</code> and <code>cols</code>; returns <code>.Cells(...).Resize(rows, cols).Value</code> or <code>Empty</code> on invalid params. Errors handled via <code>SafeHandleError</code>. <br><strong>Complexity:</strong> O(rows*cols) I/O cost. <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Read single cell, read 3x3 range, invalid sizes produce <code>Empty</code>. <br><strong>Notes:</strong> Caller should handle returned variant shape. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>AtomicWriteFile(fullPath, content)</strong> — <em>atomic file write with multi-tier fallbacks + UTF-8 support</em><br><strong>Purpose:</strong> Write a file atomically with retry/backoff and support for ADODB.Stream UTF-8 when available; fallback to binary <code>Open ... For Binary</code> and FileSystemObject copy. Ensures no partial writes to destination on success path.<br><strong>Signature:</strong> <code>AtomicWriteFile(ByVal fullPath As String, ByVal content As Variant) As Boolean</code> (returns True on success).<br><strong>Behavior (detailed):</strong><br>- Determine folder from <code>fullPath</code> or fallback to <code>GetTempFolder</code>, <code>Environ(&quot;TEMP&quot;)</code>, <code>Application.DefaultFilePath</code>.<br>- Construct unique temporary filename in folder (prefix <code>ifrs_util_</code> + timestamp + random number).<br>- Loop up to <code>MAX_ATOMIC_ATTEMPTS</code> attempts: try to write <code>tmpName</code> using ADODB.Stream if <code>IsADODBStreamAvailable()</code> returns True and content is string; set <code>Charset=&quot;utf-8&quot;</code> and <code>SaveToFile tmpName, 2</code>. If ADODB not available or failing, call private <code>WriteToFileBinary(tmpName, content)</code> which <code>Open ... For Binary</code> + <code>Put</code> the bytes or string. After tmp write, attempt atomic <code>Name tmpName As fullPath</code>. If <code>Name</code> fails attempt <code>Scripting.FileSystemObject</code> copy/replace. On failure, delete tmp and exponentially backoff via <code>SleepMs</code>. After loop return success boolean; on final failure call <code>SafeHandleError</code> with details.<br><strong>Complexity:</strong> I/O bound; best-case single write + rename; worst-case multiple attempts. <br><strong>Side-effects:</strong> Creates one or more temporary files; may write ADODB streams. <br><strong>Invariants:</strong> If function returns True, the destination file exists and contains the written content (barring OS-level corruption). <br><strong>Failure modes:</strong> Lack of writable folder, ADODB unavailable, FSO unavailable, permission errors. Incomplete tmp cleanup attempted. <br><strong>Security:</strong> Content may include sensitive data; file perms are not explicitly set — caller must ensure destination is secure. ADODB usage requires COM privileges. <br><strong>Tests:</strong> Write small string; write binary array; simulate locked destination file to exercise retries; absent temp folder. <br><strong>Notes:</strong> ADODB path preserves UTF-8 when used; otherwise default system codepage used. Consider writing file-permissions or ownership handling if required. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>WriteToFileBinary(path, content)</strong> — <em>private: fallback binary writer</em><br><strong>Purpose:</strong> Low-level writer for binary/string via <code>Open For Binary</code> + <code>Put</code> used when ADODB.Stream not available.<br><strong>Signature:</strong> <code>Private WriteToFileBinary(ByVal path As String, ByVal content As Variant)</code>.<br><strong>Behavior:</strong> Opens file for Binary Write with <code>FreeFile</code>, uses <code>Put</code> to write array or string; closes on success; raises error to caller on failure. <br><strong>Complexity:</strong> O(len(content)). <br><strong>Side-effects:</strong> Writes file at path. <br><strong>Failure modes:</strong> File locked or path invalid — raises error. <br><strong>Tests:</strong> Write array and string variants; validate contents on disk. <br><strong>Notes:</strong> Caller handles error recovery and cleanup. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>AtomicSaveWorkbookAs(wb, fullPath)</strong> — <em>robust workbook SaveAs via copy+move</em><br><strong>Purpose:</strong> Save workbook to destination atomically by <code>SaveCopyAs</code> to temp file then move/copy to destination, with FSO fallback and retry/backoff.<br><strong>Signature:</strong> <code>AtomicSaveWorkbookAs(ByVal wb As Workbook, ByVal fullPath As String) As Boolean</code>.<br><strong>Behavior:</strong> Validate <code>wb</code>; construct tmpFile in temp folder; attempt <code>wb.SaveCopyAs tmpFile</code> (or <code>wb.SaveAs</code> fallback). If FSO available attempt to delete existing dest and <code>CopyFile</code> tmp->dest with retries; if FSO missing attempt <code>Name tmpFile As fullPath</code>. On failure report using <code>SafeHandleError</code>. Returns True on success. <br><strong>Complexity:</strong> I/O bound. <br><strong>Side-effects:</strong> Produces temp workbook file and destination file; deletes tmpFile on success. <br><strong>Invariants:</strong> On True return destination is present and consistent with tmp. <br><strong>Failure modes:</strong> Insufficient permissions, locked target file, absent FSO. <br><strong>Tests:</strong> Save in normal conditions; simulate locked target file to exercise retries. <br><strong>Notes:</strong> This function is safer than direct <code>SaveAs</code> in many contexts; ensure large files have adequate disk space. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>IsPathWritable(fullPath)</strong> — <em>probe if a path/folder is writable</em><br><strong>Purpose:</strong> Determine if a candidate directory is writable by attempting to create and delete a small temp file. Returns boolean. Useful for choosing fallback temp locations and validating user-supplied paths.<br><strong>Signature:</strong> <code>IsPathWritable(ByVal fullPath As String) As Boolean</code>.<br><strong>Behavior:</strong> Determine folder from <code>fullPath</code> or default; choose testFile using <code>EnsureFolderPathEndsWith(folder) &amp; TEMP_PREFIX &amp; &quot;touch_yyyymmdd_HHNNSS.tmp&quot;</code>. Attempt <code>Open For Output</code> and write "test", close and delete. Return True on success. On failure restore file handles and call <code>SafeHandleError</code> if unexpected. <br><strong>Complexity:</strong> O(1) I/O. <br><strong>Side-effects:</strong> Temporary file created and deleted. <br><strong>Failure modes:</strong> Lack of permission returns False. <br><strong>Tests:</strong> Writable folder returns True; read-only folder returns False. <br><strong>Notes:</strong> Uses <code>Open For Output</code> which uses system codepage; test file name unique by timestamp. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>EnsureFolderPathEndsWith(folder)</strong> — <em>ensure path ends with OS path separator</em><br><strong>Purpose:</strong> Return folder unchanged if empty string else ensure trailing <code>Application.PathSeparator</code> appended. Simple helper to standardize path assembly.<br><strong>Signature:</strong> <code>EnsureFolderPathEndsWith(ByVal folder As String) As String</code>.<br><strong>Behavior:</strong> If empty returns <code>&quot;&quot;</code> else append separator if not present. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> <code>C:\temp</code> -> <code>C:\temp\</code> (on Windows). <br><strong>Notes:</strong> Keep OS path separator usage consistent. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GetTempFolder(Optional wb)</strong> — <em>multi-fallback temp folder resolver (Windows/Mac)</em><br><strong>Purpose:</strong> Determine a sensible temp folder using environment variables (<code>TMP</code>, <code>TEMP</code>, <code>TMPDIR</code>), <code>Application.DefaultFilePath</code>, workbook path, or AppleScript on Mac (<code>MacScript</code>). Returns empty string if none found.<br><strong>Signature:</strong> <code>GetTempFolder(Optional ByVal wb As Variant) As String</code>.<br><strong>Behavior:</strong> Checks environment variables in order, then <code>Application.DefaultFilePath</code>, then <code>wb.Path</code> if provided, finally attempts <code>MacScript(&quot;return POSIX path of (path to temporary items folder as string)&quot;)</code> and converts <code>:</code> to <code>/</code>. Catches errors and returns <code>&quot;&quot;</code> on failure. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> MacScript may not be available on all hosts; permissions might hide <code>Application.DefaultFilePath</code>. <br><strong>Tests:</strong> Environment var set returns expected; workbook path fallback returns workbook folder; Mac path conversion correct. <br><strong>Notes:</strong> Important for cross-platform behavior. Consider using <code>Scripting.FileSystemObject.GetSpecialFolder</code> if available for more robust resolution. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>RetryWithBackoffByName(functionName, Optional attempts=3, initialDelayMs=200, Optional lastErrNum As Long)</strong> — <em>invoke macro by name with retry/backoff</em><br><strong>Purpose:</strong> Call another macro by name (<code>Application.Run(functionName)</code>) with exponential backoff and optional attempt limits. Returns True if any attempt returned non-empty or boolean True; else False and returns last error number by reference.<br><strong>Signature:</strong> <code>RetryWithBackoffByName(ByVal functionName As String, Optional ByVal attempts As Long = 3, Optional ByVal initialDelayMs As Long = 200, Optional ByRef lastErrNum As Long) As Boolean</code>.<br><strong>Behavior:</strong> For <code>i = 1..attempts</code> attempt <code>Application.Run(functionName)</code> under <code>On Error Resume Next</code>; if <code>Err.Number=0</code> and <code>$res</code> is not empty or True then return True; else log via <code>SafeLogAudit</code> and <code>SleepMs(delay)</code> doubling delay each iteration. On unhandled exception route errors to <code>SafeHandleError</code> and return False on exhaustion. <br><strong>Complexity:</strong> O(attempts). <br><strong>Side-effects:</strong> Executes external macro which may have arbitrary side-effects; logs attempts. <br><strong>Failure modes:</strong> Called function may have side-effects even when failing — be careful for idempotence. <br><strong>Tests:</strong> Provide function that fails twice then succeeds; ensure returns True. <br><strong>Notes:</strong> Use sparingly; callers must ensure functionName is safe to call multiple times. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SleepMs(ms)</strong> — <em>busy-wait with DoEvents and wrap-around handling</em><br><strong>Purpose:</strong> Small millisecond sleep using <code>Timer</code> and <code>DoEvents</code> that is safe across midnight wrap-around for short delays.<br><strong>Signature:</strong> <code>Private SleepMs(ByVal ms As Long)</code>.<br><strong>Behavior:</strong> If <code>ms &lt;= 0</code> returns; otherwise loop until elapsed time exceeds <code>ms</code>, calling <code>DoEvents</code>. Handles <code>Timer</code> wrap by resetting <code>t0</code>. <br><strong>Complexity:</strong> O(ms) CPU loop with cooperative multitasking via <code>DoEvents</code>. <br><strong>Side-effects:</strong> Allows UI to remain responsive; may re-enter event handlers if they are bound — callers should be careful. <br><strong>Failure modes:</strong> Long sleeps can starve other timers; DoEvents reentrancy risk. <br><strong>Tests:</strong> Sleep small intervals (10ms) and measure approximate elapsed. <br><strong>Notes:</strong> Prefer API-level sleeps when available (not in pure VBA). Keep sleeps short. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Nz(v, Optional alt="")</strong> — <em>null/empty normalizer</em><br><strong>Purpose:</strong> Return <code>alt</code> for <code>Null</code>, <code>Empty</code>, <code>Error</code>, or empty-string values; otherwise return <code>v</code> unchanged. Common VB helper for defensive string/variant handling.<br><strong>Signature:</strong> <code>Nz(ByVal v As Variant, Optional ByVal alt As Variant = &quot;&quot;) As Variant</code>.<br><strong>Behavior:</strong> Checks <code>IsError</code>, <code>IsNull</code>, <code>IsEmpty</code>, and for strings trims and tests zero length to decide to return <code>alt</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Always returns non-empty alt when input invalid. <br><strong>Tests:</strong> Pass Error, Null, Empty, "", numeric value. <br><strong>Notes:</strong> Mirrors VB6/Access <code>Nz</code> semantics. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Coalesce(ParamArray vals())</strong> — <em>first non-empty value chooser</em><br><strong>Purpose:</strong> Return first non-empty/non-null/non-error and for strings non-blank value from provided arguments; otherwise <code>Empty</code>.<br><strong>Signature:</strong> <code>Coalesce(ParamArray vals() As Variant) As Variant</code>.<br><strong>Behavior:</strong> Iterates arguments and returns first that is not Error/Null/Empty and non-empty string. <br><strong>Complexity:</strong> O(n).<br><strong>Tests:</strong> Ensure <code>Coalesce(&quot;&quot;, Null, &quot;x&quot;)</code> → <code>&quot;x&quot;</code>. <br><strong>Notes:</strong> Useful for defaulting. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ToDoubleSafe(v, Optional defaultValue=0#)</strong> — <em>safe numeric cast to Double</em><br><strong>Purpose:</strong> Convert variant to Double if numeric, else return default; swallow errors.<br><strong>Signature:</strong> <code>ToDoubleSafe(ByVal v As Variant, Optional ByVal defaultValue As Double = 0#) As Double</code>.<br><strong>Behavior:</strong> <code>If IsNumeric(v) Then CDbl(v) Else defaultValue</code> with <code>On Error</code> guard. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> "123.45" -> 123.45, "abc" returns default. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ToLongSafe(v, Optional defaultValue=0)</strong> — <em>safe cast to Long</em><br><strong>Purpose/Signature/Behavior/Complexity/Tests:</strong> Same semantics as <code>ToDoubleSafe</code> but returns <code>CLng(v)</code> or <code>defaultValue</code> on failure. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ToDateSafe(v, Optional defaultValue=0)</strong> — <em>safe cast to Date</em><br><strong>Purpose/Signature/Behavior/Complexity/Tests:</strong> Returns <code>CDate(v)</code> if <code>IsDate(v)</code> else <code>defaultValue</code>. <br><strong>Notes:</strong> Avoid ambiguous locale-specific string conversions. Prefer explicit <code>DateSerial</code> when constructing dates. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ReadCustomXMLPart(rootElement)</strong> — <em>resilient read of CustomXMLParts containing a root element</em><br><strong>Purpose:</strong> Return the XML text of the first <code>CustomXMLPart</code> whose xml contains <code>&lt;rootElement</code> (case-insensitive). Useful to persist structured add-in state in workbook CustomXMLParts.<br><strong>Signature:</strong> <code>ReadCustomXMLPart(ByVal rootElement As String) As String</code>.<br><strong>Behavior:</strong> Iterate <code>ThisWorkbook.CustomXMLParts</code>, if <code>InStr(p.xml, &quot;&lt;&quot; &amp; rootElement, vbTextCompare) &gt; 0</code> return <code>p.xml</code>; else return <code>&quot;&quot;</code>. Errors are handled and <code>&quot;&quot;</code> returned. <br><strong>Complexity:</strong> O(m) where m = number of CustomXMLParts. <br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> CustomXMLParts inaccessible or malformed — returns <code>&quot;&quot;</code>. <br><strong>Tests:</strong> Add known part and verify retrieval; missing part returns empty string. <br><strong>Notes:</strong> For robust matching consider XML parsing in future. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GetRootElementNameFromXml(xml)</strong> — <em>private: heuristically extract root element name</em><br><strong>Purpose:</strong> Return the first tag name after <code>&lt;</code> by scanning until space or <code>&gt;</code>; used by <code>AddOrUpdateCustomXMLPart</code> to identify parts. <br><strong>Signature:</strong> <code>Private GetRootElementNameFromXml(ByVal xml As String) As String</code>.<br><strong>Behavior:</strong> Trim input, locate first <code>&lt;</code>, then next space or <code>&gt;</code> and extract substring. Returns empty on failure. <br><strong>Complexity:</strong> O(len(xml)). <br><strong>Notes:</strong> Heuristic; not a full XML parse — safe for simple cases but fragile for prolog/namespace-heavy XML. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>AddOrUpdateCustomXMLPart(xml)</strong> — <em>upsert CustomXMLPart by root element</em><br><strong>Purpose:</strong> Add provided XML into <code>ThisWorkbook.CustomXMLParts</code>, after deleting an existing part with same root element (heuristic string match). Returns boolean success.<br><strong>Signature:</strong> <code>AddOrUpdateCustomXMLPart(ByVal xml As String) As Boolean</code>.<br><strong>Behavior:</strong> Extract root name via <code>GetRootElementNameFromXml</code>; iterate parts and <code>p.Delete</code> if <code>InStr(p.xml, &quot;&lt;&quot; &amp; root)</code> matches. Add new part via <code>ThisWorkbook.CustomXMLParts.Add xml</code>. On error return False and log. <br><strong>Complexity:</strong> O(m) where m = parts count. <br><strong>Side-effects:</strong> Mutates <code>CustomXMLParts</code>. <br><strong>Failure modes:</strong> Malformed XML, platform limitations — function logs and returns False. <br><strong>Security:</strong> Avoid storing secrets in workbook CustomXMLParts unless encrypted. <br><strong>Tests:</strong> Add XML, update with new XML, malformed xml returns False. <br><strong>Notes:</strong> Consider using Unique IDs in XML to be more robust than substring matching. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>StreamImportCsvLines(fullPath, lineHandlerName)</strong> — <em>BOM tolerant CSV reader that dispatches lines to a handler</em><br><strong>Purpose:</strong> Read text file contents into memory (binary read), normalize line endings, remove UTF-8 BOM if present, split into lines and call provided <code>lineHandlerName</code> for each non-empty line. Intended for line-by-line import where handler is an existing macro.<br><strong>Signature:</strong> <code>StreamImportCsvLines(ByVal fullPath As String, ByVal lineHandlerName As String) As Boolean</code>.<br><strong>Behavior:</strong> <code>Open fullPath For Binary Access Read</code>, <code>Input$</code> entire file to <code>allText</code>. Remove UTF-8 BOM (0xEF,0xBB,0xBF) if present. Normalize line endings to <code>vbCrLf</code>. Split into <code>lines = Split(allText, vbCrLf)</code> and for each non-empty line call <code>Application.Run lineHandlerName, ln</code> under <code>On Error Resume Next</code> and log handler errors with <code>SafeLogAudit</code>. Returns True on success, False on file errors. <br><strong>Complexity:</strong> O(file size) memory-bound (reads whole file into memory). <br><strong>Side-effects:</strong> Invokes external handler macro per line (handler may have arbitrary side-effects). <br><strong>Failure modes:</strong> Very large files may blow memory; handler exceptions are logged per-line. <br><strong>Security:</strong> CSV content may contain arbitrary text — handler must sanitize any downstream injection into Excel or filesystem. <br><strong>Tests:</strong> Small CSV with BOM; handler called expected number of times; malformed file errors properly returned. <br><strong>Notes:</strong> For very large files consider streaming processing to avoid memory pressure. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ExportRangeToCsv(rng, fullPath)</strong> — <em>RFC4180-compliant CSV export with atomic move</em><br><strong>Purpose:</strong> Export Range to CSV with RFC4180 escaping (double quotes, quoting fields with quotes/commas/newlines), save to temporary CSV file, then atomically move to destination via <code>AtomicWriteFileMove</code> with retries. Returns boolean success.<br><strong>Signature:</strong> <code>ExportRangeToCsv(ByVal rng As Range, ByVal fullPath As String) As Boolean</code>.<br><strong>Behavior:</strong> Determine destination folder fallback; create <code>tmpFile</code> in folder. Open tmpFile <code>For Output</code> and iterate rows/columns building <code>rowVals</code> where each cell value is <code>CStr(Nz(cellVal,&quot;&quot;))</code>, replace <code>&quot;</code> with <code>&quot;&quot;</code>, and quote if contains <code>,</code> or <code>&quot;</code> or newlines. <code>Print #fnum, rowVals</code> per row. Close file then call <code>AtomicWriteFileMove(tmpFile, fullPath)</code> which attempts rename or FSO copy with retries. On return remove <code>tmpFile</code> and return atomic move success. Errors handled via <code>SafeHandleError</code>. <br><strong>Complexity:</strong> O(cells) write cost. <br><strong>Side-effects:</strong> Creates temp file and destination file. <br><strong>Failure modes:</strong> Disk full, permission denied, large data causing memory/IO delays. <br><strong>Security:</strong> Exports may contain sensitive data; consider prompting user or redaction. <br><strong>Tests:</strong> Range with quotes/commas/newlines produce proper quoting; dest file matches expected CSV; simulated copy failure returns False. <br><strong>Notes:</strong> Uses <code>Print #</code> which writes system line endings; consistent normalization ensured by CSV consumer. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>AtomicWriteFileMove(srcFile, destFile)</strong> — <em>private: robust move with retries</em><br><strong>Purpose:</strong> Move <code>srcFile</code> to <code>destFile</code> using <code>Name</code> (atomic rename) or FSO copy+delete fallback with exponential backoff, up to <code>MAX_ATOMIC_ATTEMPTS</code>.<br><strong>Signature:</strong> <code>Private AtomicWriteFileMove(ByVal srcFile As String, ByVal destFile As String) As Boolean</code>.<br><strong>Behavior:</strong> Loop attempts: try <code>Name</code>, if fails and FSO present do <code>fso.DeleteFile(destFile)</code> then <code>fso.CopyFile srcFile, destFile</code> and delete src on success; <code>SleepMs</code> between attempts; on exhaustion call <code>SafeHandleError</code> and return False. <br><strong>Complexity:</strong> O(attempts) and file-copy cost. <br><strong>Side-effects:</strong> Removes srcFile on success. <br><strong>Failure modes:</strong> Destination locked or permission errors — returns False. <br><strong>Tests:</strong> Move on same filesystem -> rename path; cross-filesystem -> copy path; locked dest -> retries and eventual failure. <br><strong>Notes:</strong> Keep semantics consistent across Windows and Mac filesystems. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>CreateObjectSafe(progId)</strong> — <em>safe COM factory with program-id availability cache</em><br><strong>Purpose:</strong> Create COM object by progId and cache availability in <code>g_comCache</code> to avoid repeated failing <code>CreateObject</code> calls. Returns <code>Nothing</code> if unavailable rather than erroring to caller.<br><strong>Signature:</strong> <code>CreateObjectSafe(ByVal progId As String) As Object</code>.<br><strong>Behavior:</strong> Ensure caches exist; if <code>g_comCache.Exists(progId)</code> and cached value <code>False</code> return Nothing. Else attempt <code>Set obj = CreateObject(progId)</code> under <code>On Error Resume Next</code>. On success mark cache True and return object; on failure mark cache False and return Nothing. <br><strong>Complexity:</strong> O(1) after caching. <br><strong>Side-effects:</strong> Possibly stores boolean in <code>g_comCache</code>. <br><strong>Invariants:</strong> g_comCache(progId) === True/False reflects last known availability; if COM object later becomes available cache must be reset via <code>ResetCaches</code>. <br><strong>Failure modes:</strong> CreateObject can throw; function swallows and caches failure. <br><strong>Security:</strong> Creating COM objects may be blocked by policy; ensure callers use allowed progIds. <br><strong>Tests:</strong> Create common object e.g. <code>Scripting.FileSystemObject</code>; test repeated failures cached. <br><strong>Notes:</strong> Cache reduces noisy error logs when optional COM features absent. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>IsCertutilAvailable()</strong> — <em>detect <code>certutil</code> via WScript.Shell.Exec</em><br><strong>Purpose:</strong> Determine if <code>certutil</code> command is callable on system PATH using <code>WScript.Shell.Exec(&quot;cmd /c certutil -?&quot;)</code> and reading StdOut. Caches tri-state in <code>g_certutilAvailable</code>.<br><strong>Signature:</strong> <code>IsCertutilAvailable() As Boolean</code>.<br><strong>Behavior:</strong> If <code>g_certutilAvailable</code> cached return that. Else create <code>WScript.Shell</code> via <code>CreateObjectSafe</code>; if not available sets cache False. Else <code>Exec</code> the command and wait for <code>execObj.status</code> to finish, then read <code>StdOut.ReadAll</code> and if any text present set cache True. <br><strong>Complexity:</strong> O(1) but spawns process and waits. <br><strong>Side-effects:</strong> Spawns child process; may be blocked by permissions or AV. <br><strong>Failure modes:</strong> <code>WScript.Shell</code> unavailable; <code>Exec</code> returns Nothing; StdOut inaccessible — will set False. <br><strong>Security/Privacy:</strong> Running shell commands may be risky; avoid injecting unsanitized input into shell calls. <br><strong>Tests:</strong> On machine with certutil present assert True; on minimal environment assert False. <br><strong>Notes:</strong> Execution blocks until child terminates; consider timeout for long-running exec. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>UtilitiesSelfTest()</strong> — <em>self-check harness for core utilities</em><br><strong>Purpose:</strong> Run a set of quick smoke tests for critical helpers: numeric conversions, Nz, atomic write to temp folder, named-range cache basic flow. Returns boolean overall success and writes audit log of result.<br><strong>Signature:</strong> <code>UtilitiesSelfTest() As Boolean</code>.<br><strong>Behavior:</strong> Resets caches, asserts <code>ToDoubleSafe(&quot;123.45&quot;)=123.45</code>, <code>ToLongSafe(&quot;42&quot;)=42</code>, <code>Nz(Empty, &quot;x&quot;)=&quot;x&quot;</code>. Attempts <code>AtomicWriteFile</code> to temp path when available and cleans up. Tests named-range set/get in resolved workbook if available and deletes the name afterwards. Logs via <code>SafeLogAudit</code>. On exceptions returns False and logs. <br><strong>Complexity:</strong> Quick; includes file I/O for atomic write. <br><strong>Side-effects:</strong> Creates and deletes a temp file; creates and deletes a named range in the active workbook. <br><strong>Failure modes:</strong> Running in restricted host with no filesystem access or workbook access -> test fails. <br><strong>Tests:</strong> Self-contained: call and assert True in typical environment; failing environments should return False but not raise. <br><strong>Notes:</strong> Useful in CI or pre-flight checks. Keep tests idempotent. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>StrLenSafe(s)</strong> — <em>private: safe length helper</em><br><strong>Purpose:</strong> Return 0 for Null/Empty; otherwise <code>Len(CStr(s))</code>. <br><strong>Signature:</strong> <code>Private StrLenSafe(ByVal s As Variant) As Long</code>.<br><strong>Behavior:</strong> Defensive <code>On Error Resume Next</code> to avoid exceptions on odd types. <br><strong>Complexity:</strong> O(1). <br><strong>Notes:</strong> Internal helper for string checks. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>End-to-end integration notes & recommended tests (concise)</strong><br>- Core cross-cutting invariants: all public functions must not raise (they must call <code>SafeHandleError</code> on unexpected failures) and must be safe to call during deferred init or ribbon callbacks. <br>- Ensure <code>EnsureCaches()</code> is called before using cached helpers; but callers should defensively tolerate <code>g_namedRangeCache</code> or <code>g_comCache</code> being <code>Nothing</code>. <br>- File IO functions are I/O-bound and should be exercised under locked-file and permission-denied scenarios. <br>- Test matrix to run: Windows typical, Windows restricted account (no ADODB), Mac (no <code>cmd</code>/<code>certutil</code>, MacScript available), network-mounted home folders, locked target files, workbook protected and shared, no active workbook. <br>- Security: avoid writing secrets to backups or CustomXMLParts; sanitize audit/error messages. <br>- Performance: large <code>SafeWriteRange</code> calls can be heavy — keep array sizes modest or batch writes. <br>- Maintainability: changing tokenizer/serialization or file move semantics are breaking; keep <code>MAX_ATOMIC_ATTEMPTS</code> and <code>TEMP_PREFIX</code> constants central. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Final summary (one paragraph)</strong><br>The <code>modUtilities</code> module is a defensive, compatibility-focused VBA utility layer providing: deterministic workbook/sheet resolution, robust named-range caching, high-quality atomic file and workbook save primitives (with ADODB/FSO fallbacks), CSV import/export with RFC4180 escaping and BOM handling, safe COM factory caching, environment feature detection, and a small self-test harness. The code favors non-throwing, best-effort operations and conservative fallbacks so UI/ribbon handlers and background jobs remain resilient in locked, limited, or headless Excel host environments. For maintainers: test COM availability permutations, ensure backups handling privacy/retention, and consider introducing explicit cache invalidation hooks or TTL if workbook content changes externally. </td></tr></tbody></table></div><div class="row-count">Rows: 45</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>