<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1768544746">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0160_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modError)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modError)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modError)"> <strong>Module overview (modError)</strong> — <em>deterministic centralized error handling for IFRS Add-in</em><br><strong>Purpose:</strong> Provide a single, backward-compatible error handling surface for the IFRS Excel add-in: cataloged user-facing messages, structured local auditing, redaction, telemetry emission, safe integration points to modAudit/modConfig, a small self-test harness, and defensive helpers (safe runs, retries, sleep, CRC32). Designed for resilience (On Error Resume Next guarded paths), deterministic outputs, and minimal external dependencies (graceful fallback when Scripting.Dictionary / modAudit / modConfig are absent).<br><strong>Public surface:</strong> <code>AppendLocalAudit</code>, <code>AppendLocalAuditStructured</code>, <code>InstallTimeSelfCheck</code>, <code>RunModErrorSelfTests</code>, <code>RetryOperationByName</code>, <code>GetUserFacingMessage</code>, <code>GetRemediationSteps</code>, <code>IsErrorCatalogInitialized</code>, <code>IsErrorCatalogAvailable</code>, <code>GetCatalogItemCount</code>. Internal helpers exposed for tests: catalog initialization, redaction, correlation id generation, safe run wrappers, telemetry emission.<br><strong>Invariants:</strong> Audit sheet <code>_IFRS_Audit</code> exists/created when writes required; audit rows appended using array transfer; catalog initialization attempted exactly once (g_catalogInitialized); functions must never raise unhandled errors (module uses defensive <code>On Error Resume Next</code> patterns).<br><strong>Failure modes:</strong> Host VBA restrictions (no Scripting.Dictionary), locked workbook/no permission to add sheets, Application.Run failures, truncated payloads due to length limits. All callers must be defensive; module attempts best-effort logging and fallbacks. <br><strong>Recommended tests:</strong> Catalog initialization in dictionary/no-dictionary environments; audit sheet write under workbook protected/unprotected; redaction edge-cases (long tokens, emails, GUIDs); telemetry fallback path (modAudit available/absent).<br><strong>Notes for maintainers:</strong> Keep <code>DEFAULT_REDACT_LEVEL</code> in sync with privacy policy. Avoid changing token-redaction regexes without privacy review. Ensure audit sheet schema and <code>AUDIT_SCHEMA_VERSION</code> tracked when changing <code>AppendLocalAuditStructured</code> columns. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>MODERROR_VERSION / constants / types</strong> — <em>module metadata & bounds</em><br><strong>Purpose:</strong> Provide stable module versioning and bounds for string lengths, audit sheet names, schema version, and default redaction level.<br><strong>Signature:</strong> module-level <code>Public Const</code> and <code>Private Const</code>. Not functions.<br><strong>Behavior:</strong> Constants guide truncation and schema fields (<code>MAX_LOG_INTERNAL</code>, <code>MAX_LOG_USER</code>, <code>MAX_LOG_CONTEXT</code>, <code>AUDIT_SHEET_NAME</code>, <code>AUDIT_SCHEMA_VERSION</code>, <code>DEFAULT_REDACT_LEVEL</code>).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Values are assumed safe upper-bounds; changes require migration (particularly <code>AUDIT_SCHEMA_VERSION</code>).<br><strong>Failure modes:</strong> Too-small constants may truncate necessary debug info; too-large values risk worksheet performance. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>IFRS_ErrorSeverity (Enum) and IFRS_Error (Type)</strong> — <em>structured error metadata type</em><br><strong>Purpose:</strong> Provide typed severity levels and a structured in-memory error record used for telemetry and internal passing.<br><strong>Signature:</strong> <code>Enum IFRS_ErrorSeverity</code>, <code>Type IFRS_Error</code> with fields <code>procName, errNum, internalMsg, userMsg, severity, correlationId, contextJson, timeStamp</code>.<br><strong>Behavior:</strong> Holds canonical representation of errors across the add-in. Callers populate then use <code>SafeEmitTelemetryEvent</code> or audit helpers.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> <code>severity</code> should be within enum range; <code>timeStamp</code> should be set (module sets Now when absent). </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>Module-level catalog/cache: g_errorCatalog, g_catalogInitialized, g_catalogAvailable, g_randomized</strong> — <em>catalog state</em><br><strong>Purpose:</strong> Maintain single in-process error catalog and flags indicating initialization status and randomness seed.<br><strong>Behavior:</strong> <code>EnsureCatalogInitialized</code> sets them. <code>g_errorCatalog</code> is a <code>Scripting.Dictionary</code> when available; absent otherwise and module falls back to safe paths.<br><strong>Invariants:</strong> <code>g_catalogInitialized = True</code> after first attempt (successful or graceful fallback). Code relies on <code>g_catalogAvailable</code> to know whether to use dictionary operations. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>EnsureCatalogInitialized()</strong> — <em>one-time catalog bootstrap, safe fallback</em><br><strong>Purpose:</strong> Lazily initialize the in-memory error catalog (Scripting.Dictionary) and seed pre-defined catalog entries used for user-facing messages and remediation steps.<br><strong>Signature:</strong> <code>Private Sub EnsureCatalogInitialized()</code><br><strong>Behavior:</strong> Attempts <code>CreateObject(&quot;Scripting.Dictionary&quot;)</code>. Sets <code>g_catalogAvailable</code> appropriately. Calls <code>Randomize</code> once. If dictionary available, clears it then populates with canonical <code>addCatalogItem</code> calls for known error codes (1000..3000 etc.). Sets <code>g_catalogInitialized = True</code> even when dictionary unavailable so initialization is attempted once only.<br><strong>Complexity:</strong> O(N) for N built-in catalog entries (constant).<br><strong>Side-effects:</strong> Creates Scripting.Dictionary when possible; may call <code>Randomize</code> for correlation id fallback. Silent on errors (<code>On Error Resume Next</code>).<br><strong>Invariants:</strong> Idempotent — repeated calls do nothing once <code>g_catalogInitialized</code> set. If the dictionary is not available, functions depending on catalog must use fallback messages.<br><strong>Failure modes:</strong> Scripting host disabled in the environment; permission errors when CreateObject blocked — module gracefully falls back. Catalog population is best-effort; missing items should be handled by <code>GetInternalFallbackMessage</code>.<br><strong>Tests:</strong> Simulate environment with and without <code>Scripting.Dictionary</code> and assert <code>IsErrorCatalogAvailable</code> and <code>GetCatalogItemCount</code> behavior and fallback. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>addCatalogItem(code, userMsg, remediation, Optional severity)</strong> — <em>catalog insertion safe wrapper</em><br><strong>Purpose:</strong> Add an entry to the in-memory catalog if available, in a guarded manner.<br><strong>Signature:</strong> <code>Private Sub addCatalogItem(code As Long, userMsg As String, remediation As String, Optional severity As IFRS_ErrorSeverity = sevError)</code><br><strong>Behavior:</strong> Returns no-op if catalog unavailable. Creates small dictionary per-item with keys <code>UserMessage</code>, <code>Remediation</code>, <code>DefaultSeverity</code> and stores under stringified code. Guards all calls with <code>On Error Resume Next</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>g_errorCatalog</code> when available.<br><strong>Invariants:</strong> Keys stored as strings; severity coerced to integer.<br><strong>Failure modes:</strong> No-op if dictionary unavailable. Test for presence of item in catalog when g_catalogAvailable True. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>GetUserMessageFromCatalog(errNum)</strong> — <em>catalog lookup for user-facing message</em><br><strong>Purpose:</strong> Return the user-facing message for a code if present, else empty string (caller supplies fallback).<br><strong>Signature:</strong> <code>Private Function GetUserMessageFromCatalog(errNum As Long) As String</code><br><strong>Behavior:</strong> Calls <code>EnsureCatalogInitialized</code>. If dictionary exists and contains key, returns <code>ci(&quot;UserMessage&quot;)</code> string; else returns empty string. Fully guarded to never raise errors.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Failure modes:</strong> Missing catalog → empty string (caller should detect and substitute generic message).<br><strong>Tests:</strong> When item present, asserts exact returned message; when absent returns empty string. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>GetRemediationFromCatalog(errNum)</strong> — <em>catalog lookup for remediation text</em><br><strong>Purpose:</strong> Return remediation instruction for a code; identical behavior to GetUserMessageFromCatalog but returns <code>Remediation</code> field.<br><strong>Signature:</strong> <code>Private Function GetRemediationFromCatalog(errNum As Long) As String</code><br><strong>Behavior / Complexity / Failure modes / Tests:</strong> Same pattern as GetUserMessageFromCatalog. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>GetInternalFallbackMessage(errNum)</strong> — <em>simple fallback text generator</em><br><strong>Purpose:</strong> Provide predictable fallback when no catalog entry is available.<br><strong>Signature:</strong> <code>Private Function GetInternalFallbackMessage(errNum As Long) As String</code><br><strong>Behavior:</strong> Returns string <code>&quot;Error code &quot; &amp; CStr(errNum)</code> for deterministic behavior and auditability.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>AppendLocalAudit(category, rawPayload, Optional corrId, Optional timeStamp)</strong> — <em>append simple audit row (unstructured)</em><br><strong>Purpose:</strong> Deterministically append a single unstructured audit row to the hidden <code>_IFRS_Audit</code> sheet, using array write for atomicity and to avoid repeated cell-by-cell writes.<br><strong>Signature:</strong> <code>Public Sub AppendLocalAudit(category As String, rawPayload As String, Optional corrId As String = &quot;&quot;, Optional timeStamp As Date = 0)</code><br><strong>Behavior:</strong> Ensures <code>timeStamp</code> set; calls <code>EnsureAuditSheet</code> to obtain hidden sheet; computes next <code>lastRow</code> robustly using <code>Cells(Rows.Count,1).End(xlUp).Row + 1</code> with min row 2; prepares a 1x5 variant array with <code>Timestamp</code>, <code>User</code> (via <code>EnvironSafeUserName</code>), truncated <code>category</code> (64), truncated <code>corrId</code> (150), and payload (left up to 32767); temporarily disables <code>Application.ScreenUpdating</code> to reduce reentrancy and writes the range using array assignment; resumes previous screen update setting. Fully guarded with <code>On Error Resume Next</code> to avoid bubbling errors to callers.<br><strong>Complexity:</strong> O(1) per append plus worksheet I/O cost. Writing large payloads may be slower but uses single Range assignment to minimize COM calls.<br><strong>Side-effects:</strong> Mutates workbook by adding or writing to <code>_IFRS_Audit</code> sheet. May create the sheet if missing. Uses <code>Environ</code> and <code>Application.userName</code> to determine user.<br><strong>Invariants:</strong> Timestamp stored in ISO-like string <code>yyyy-mm-dd HH:nn:ss</code>. Payload truncated to Excel cell capacity. Writes attempt to be atomic-ish via single range write.<br><strong>Failure modes:</strong> If workbook protected, writes may fail silently; if sheet creation fails (protected workbook, restricted macros), function exits quietly. Caller should not depend on successful local audit in hostile environments.<br><strong>Security:</strong> Writes rawPayload; callers must redact sensitive data before calling or rely on <code>AppendLocalAuditStructured</code> which redacts. Use <code>RedactAndNormalize</code> at source when needed.<br><strong>Tests:</strong> Validate row appended, header preserved, multiple appends append to increasing rows; simulate workbook protected state and confirm function not raising. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>AppendLocalAuditStructured(category, corrId, errNum, severity, subject, internalMsg, userMsg, contextJson, Optional timeStamp)</strong> — <em>structured audit with checksum</em><br><strong>Purpose:</strong> Append a well-defined, truncated, and redacted structured audit row with a checksum (CRC32 over a canonical payload) to enable integrity checks and deterministic downstream ingestion.<br><strong>Signature:</strong> <code>Public Sub AppendLocalAuditStructured(category As String, corrId As String, errNum As Long, severity As IFRS_ErrorSeverity, subject As String, internalMsg As String, userMsg As String, contextJson As String, Optional timeStamp As Date = 0)</code><br><strong>Behavior (detailed):</strong> Ensures timestamp; obtains audit sheet; computes <code>outcome</code> by truncating and redacting <code>userMsg</code> (via <code>RedactAndNormalize</code> and <code>TruncateString(200)</code>), <code>subj</code> truncated, <code>ctx</code> truncated+redacted to <code>MAX_LOG_CONTEXT</code> (800); constructs <code>payloadConcat</code> canonical string combining timestamp, user, category, subj, corrId, errNum, severity, outcome, ctx and <code>AUDIT_SCHEMA_VERSION</code> separated by <code>|</code> then computes <code>checksum = CRC32_String(payloadConcat)</code>; creates 1x11 array with columns matching header and assigns to next row, temporarily disabling <code>ScreenUpdating</code>. Fully guarded with <code>On Error Resume Next</code>.<br><strong>Complexity:</strong> O(len(contextJson)) for redaction & CRC; array write is O(1) for VBA.<br><strong>Side-effects:</strong> Mutates audit sheet. Guarantees redaction of sensitive fields using <code>RedactAndNormalize</code> so structured audit does not contain raw secrets. Stores checksum as string to enable later verification.<br><strong>Invariants:</strong> Schema columns order must be preserved; <code>AUDIT_SCHEMA_VERSION</code> included in payload and sheet; checksum algorithm must remain stable for verification. Changes to column order or scheme require <code>AUDIT_SCHEMA_VERSION</code> bump.<br><strong>Failure modes:</strong> If redaction fails or regex engine unavailable, content may be less redacted — tests must validate redaction patterns. If CRC algorithm changed, downstream verification will fail. If sheet write fails (permissions), function will exit silently — caller should consider calling <code>SafeEmitTelemetryEvent</code> as fallback.<br><strong>Security:</strong> Centralized redaction applied to <code>userMsg</code> and <code>contextJson</code>. Do not pass raw secrets elsewhere. Unit tests should include PII and long token strings to validate redaction. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>EnsureAuditSheet() -> Worksheet</strong> — <em>create/return very-hidden audit sheet, idempotent</em><br><strong>Purpose:</strong> Ensure <code>_IFRS_Audit</code> sheet exists, very-hidden, with correct header row. Creates a new sheet at end of workbook when absent and writes header row and formatting (bold header).<br><strong>Signature:</strong> <code>Private Function EnsureAuditSheet() As Worksheet</code><br><strong>Behavior:</strong> Attempts to find existing worksheet by name; if missing, adds one, sets <code>Name</code>, sets <code>.Visible = xlSheetVeryHidden</code>, writes header row array <code>Timestamp, User, Category, Subject, CorrelationId, ErrNum, Severity, Outcome, Context, SchemaVersion, Checksum</code>, bolds header and auto-fits columns. Returns the Worksheet object or <code>Nothing</code> if creation failed. Fully guarded.<br><strong>Complexity:</strong> O(1) except for sheet creation cost. AutoFit runs on creation only.<br><strong>Side-effects:</strong> Creates/renames worksheet; may throw if workbook disallows adding sheets — function handles by returning <code>Nothing</code>.<br><strong>Invariants:</strong> Header column positions must match what AppendLocalAuditStructured expects. Tests should assert header contents and visibility property. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>CTypeOrDefault(v, Optional defaultVal)</strong> — <em>safe enum coercion</em><br><strong>Purpose:</strong> Normalize numeric inputs into <code>IFRS_ErrorSeverity</code> enum or fallback default when invalid.<br><strong>Signature:</strong> <code>Private Function CTypeOrDefault(v As Variant, Optional defaultVal As IFRS_ErrorSeverity = sevError) As IFRS_ErrorSeverity</code><br><strong>Behavior:</strong> If <code>v</code> numeric and within enum range (1..4) returns coerced value; else returns default. Guards errors. Useful for callers who accept variant input for severity.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>TruncateString(s, maxLen)</strong> — <em>safe truncation helper</em><br><strong>Purpose:</strong> Truncate strings to safe lengths and add ellipsis when truncated to preserve readability in UI and audit.<br><strong>Signature:</strong> <code>Private Function TruncateString(ByVal s As String, ByVal maxLen As Long) As String</code><br><strong>Behavior:</strong> If <code>Len(s) &lt;= maxLen</code> returns <code>s</code>; else returns <code>Left$(s, maxLen-3) &amp; &quot;...&quot;</code> when <code>maxLen &gt; 3</code> else <code>Left$(s, maxLen)</code>. Deterministic and side-effect free.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>EscapeForJson(s)</strong> — <em>escape string for inclusion in JSON payloads</em><br><strong>Purpose:</strong> Produce a safe string for embedding in simple JSON payloads used by telemetry helpers without full JSON serializer. Replaces backslashes, quotes, normalizes newlines to <code>\n</code>, tabs to space, replaces non-printable chars with space.<br><strong>Signature:</strong> <code>Private Function EscapeForJson(ByVal s As String) As String</code><br><strong>Behavior:</strong> Handles empty string fast-return; performs <code>Replace</code> for <code>\</code> and <code>&quot;</code>; normalizes line endings to <code>\n</code> and tabs to space; iterates over characters to replace non-printables (<32 except LF) with spaces to avoid control sequences. Returns sanitized string. Fully guarded.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> None.<br><strong>Failure modes:</strong> Does not produce fully RFC-compliant JSON encoding for all Unicode edge-cases (it retains characters >=32), but acceptable for telemetry payloads; if needed replace with robust serializer in future. Tests should include strings with quotes, newlines, and control characters. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>RedactAndNormalize(s)</strong> — <em>privacy-first normalization & redaction</em><br><strong>Purpose:</strong> Centralized PII/secret redaction with configurable strictness. Used by structured audit and safe debug printing to remove long tokens, emails, PAN-like sequences, bearer/api keys, and optionally GUIDs depending on <code>Error.RedactLevel</code> config.<br><strong>Signature:</strong> <code>Private Function RedactAndNormalize(ByVal s As String) As String</code><br><strong>Behavior (detailed):</strong> Returns empty on blank input; reads <code>level = GetConfigLong(&quot;Error.RedactLevel&quot;, DEFAULT_REDACT_LEVEL)</code>; prepares <code>VBScript.RegExp</code> instance with <code>Global=True</code> and <code>IgnoreCase=True</code>. In level>=1 removes long tokens (<code>[A-Za-z0-9_\-]{32,}</code>) -> <code>[REDACTED_TOKEN]</code>. Redacts emails pattern <code>[A-Z0-9._%+\-]+@[A-Z0-9.\-]+\.[A-Z]{2,}</code> -> <code>[REDACTED_EMAIL]</code>. Redacts PAN-like sequences <code>((\d[\s\-]?){13,19})</code> -> <code>[REDACTED_PAN]</code>. Redacts bearer/api key keywords. If level>=2 also redacts GUID-like patterns into <code>[REDACTED_GUID]</code>. Normalizes whitespace via <code>\s+</code> replacement and truncates to 2000 characters.<br><strong>Complexity:</strong> O(len(s)) per regex pass (multiple passes).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Output is trimmed and limited to 2000 chars. Behavior depends on config flag which callers must be aware of. <br><strong>Failure modes:</strong> Regex engine availability; patterns may under/over-redact in edge cases (e.g., legitimate long alphanumeric product codes). Review and test against corp PII/PIA lists.<br><strong>Security:</strong> Centralizing redaction reduces PII leakage risk. Recommended to call on any user-supplied or external content before audit or telemetry. Unit tests must include email, long hex tokens, PAN, GUID, and mixed input. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>GenerateCorrelationID()</strong> — <em>correlation id generator with GUID preferred and deterministic fallback</em><br><strong>Purpose:</strong> Provide a globally-unique correlation id for traceability in telemetry and audits. Prefer COM GUID (Scriptlet.TypeLib). If GUID cannot be obtained, fallback to timestamp + seeded random suffix using <code>Randomize</code> to reduce collisions.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Attempts <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).Guid</code>; if success strips braces and prepends timestamp <code>IFRS-YYYYMMDDhhmmss-&lt;guid&gt;</code>; else seeds RNG once and produces <code>IFRS-YYYYMMDDhhmmss-&lt;random6digits&gt;</code>. Fully guarded.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls <code>Randomize</code> if fallback path used. <br><strong>Invariants:</strong> Returns string beginning with <code>IFRS-</code> followed by timestamp and suffix. Not cryptographically secure — intended for traceability only. Tests should ensure uniqueness across several calls and both paths. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>RetryOperationByName(functionName, attempts, delayMs, Optional ByRef lastErrNum)</strong> — <em>generic retry wrapper using Application.Run</em><br><strong>Purpose:</strong> Provide deterministic retries for operations referenced by name (legacy pattern in many VBA codebases). Returns <code>True</code> if any attempt produced a truthy result as defined by multiple Variant checks; supports optional delay between attempts using <code>SleepMs</code>.<br><strong>Signature:</strong> <code>Public Function RetryOperationByName(ByVal functionName As String, ByVal attempts As Long, ByVal delayMs As Long, Optional ByRef lastErrNum As Long) As Boolean</code><br><strong>Behavior (detailed):</strong> Normalizes <code>attempts</code> >=1; loops calling <code>SafeApplicationRun(functionName)</code> (which returns <code>CVErr</code> on failure). If call produced non-error variant, evaluates result truthiness across common Variant types (Boolean true, non-zero numbers, non-empty strings, non-nothing objects) and returns success early. On failure sets <code>lastErrNum</code> from VBA <code>Err.Number</code> if error. Sleeps <code>delayMs</code> between attempts via <code>SleepMs</code> if attempts remain. Default lastErrNum=0 when no error. Fully guarded to prevent bubbling errors.<br><strong>Complexity:</strong> O(attempts * cost-of-run).<br><strong>Side-effects:</strong> Calls external macros (via Application.Run) which may have side-effects depending on target function. Caller must ensure idempotence where required.<br><strong>Failure modes:</strong> If <code>functionName</code> resolves to a long-running or non-idempotent function, retries may worsen state. <code>SafeApplicationRun</code> returns <code>CVErr</code>, so <code>RetryOperationByName</code> handles missing procs gracefully.<br><strong>Tests:</strong> Retry against a function that fails once and succeeds second time (simulate state via global flag), and ensure <code>lastErrNum</code> captures the final error when all retries fail. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>SafeApplicationRun(procName, Optional param1)</strong> — <em>safe wrapper around Application.Run</em><br><strong>Purpose:</strong> Wrap <code>Application.Run</code> to swallow runtime errors and return <code>CVErr</code> when call is not successful so other helpers can handle absence or errors from dynamic calls safely.<br><strong>Signature:</strong> <code>Private Function SafeApplicationRun(ByVal procName As String, Optional param1 As Variant) As Variant</code><br><strong>Behavior:</strong> If <code>procName</code> blank returns <code>CVErr(xlErrNA)</code>; otherwise tries to call <code>Application.Run</code> with or without a single param; on <code>Err.Number &lt;&gt; 0</code> returns <code>CVErr(xlErrValue)</code> and clears error. Returns the function result if successful. Guards all errors.<br><strong>Complexity:</strong> O(1) aside from the invoked procedure cost.<br><strong>Side-effects:</strong> Runs arbitrary macro code which may change workbook/application state; caller must be cautious. Returns an error variant on failures for easy detection by callers. Test behavior for missing proc (returns CVErr) and successful proc (returns proc's return value). </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>SafeHasProcedure(fullProcName)</strong> — <em>lightweight probe for presence of procedure</em><br><strong>Purpose:</strong> Attempt to detect presence of a callable macro by calling <code>Application.Run</code> and checking whether it raises error. Intended as a cheap availability probe for optional hooks like <code>modAudit.EmitTelemetry</code> or <code>modConfig.GetConfigValue</code>.<br><strong>Signature:</strong> <code>Private Function SafeHasProcedure(ByVal fullProcName As String) As Boolean</code><br><strong>Behavior:</strong> If <code>procName</code> blank returns False. Attempts <code>Application.Run(fullProcName)</code> and interprets any runtime error as absence (returns False). If no error returns True. Note: this actually invokes the procedure (if present) — so procedure must be safe to call without side effects or accept that it may run.<br><strong>Complexity:</strong> O(1) aside from invoked proc. <br><strong>Failure modes / Security:</strong> If used on procs with side-effects, calling <code>SafeHasProcedure</code> may cause unintended behavior. Prefer to use convention-based flags or registry of capabilities when possible. Unit tests should use intentionally idempotent probe functions. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>SleepMs(ms)</strong> — <em>host-safe sleep with native call fallback</em><br><strong>Purpose:</strong> Sleep for milliseconds with best-effort use of native <code>Sleep</code> when declared and fallback loop with <code>DoEvents</code> otherwise. Avoids busy-wait blocking that prevents UI messages from processing.<br><strong>Signature:</strong> <code>Private Sub SleepMs(ByVal ms As Long)</code><br><strong>Behavior:</strong> If <code>ms &lt;= 0</code> quickly exits. Attempts to call <code>SleepWin ms</code> (declared under <code>#If VBA7</code> guarded compile); if native call fails (error), falls back to <code>DateAdd</code>/<code>DoEvents</code> loop until target time. Fully guarded.<br><strong>Complexity:</strong> O(wait time) wall-clock. CPU usage minimized via <code>DoEvents</code> in fallback. <br><strong>Side-effects:</strong> <code>DoEvents</code> yields execution and may allow reentrancy; callers must be careful about reentrant state. Tests should verify both native and fallback paths where possible (platform dependent). </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>CRC32_String(s)</strong> — <em>checksum helper for audit integrity</em><br><strong>Purpose:</strong> Compute CRC32 checksum over a string to produce checksum stored in audit rows for basic integrity verification and to detect accidental corruption or truncation.<br><strong>Signature:</strong> <code>Private Function CRC32_String(ByVal s As String) As Long</code><br><strong>Behavior:</strong> Table-less bitwise algorithm: initializes <code>crc=&amp;HFFFFFFFF</code>, iterates bytes via <code>AscW</code> masked to <code>&amp;HFF</code>, XORs and shifts 8 bits with polynomial <code>&amp;HEDB88320</code>. Returns final CRC as unsigned representation <code>((Not crc) And &amp;HFFFFFFFF)</code>. Uses <code>On Error Resume Next</code> to be defensive.<br><strong>Complexity:</strong> O(len(s) * 8) bit iterations per byte – effectively O(len(s)).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Deterministic for given input and algorithm; downstream verification must use identical algorithm. Tests: CRC of known strings (e.g., "abc") must be deterministic and repeatable. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>SafeEmitTelemetryEvent(eventName, e As IFRS_Error)</strong> — <em>best-effort telemetry emission with fallback to local audit</em><br><strong>Purpose:</strong> Emit structured telemetry payload describing error lifecycle events (<code>ErrorStart</code>, <code>ErrorHandled</code>, <code>ErrorFallback</code>) to modAudit's <code>EmitTelemetry</code> when available, else append to local audit as <code>Telemetry</code> category. Ensures telemetry always recorded somewhere within the host workbook environment.<br><strong>Signature:</strong> <code>Private Sub SafeEmitTelemetryEvent(eventName As String, e As IFRS_Error)</code><br><strong>Behavior:</strong> Builds a small JSON-like string using <code>EscapeForJson</code> on fields: event, corrId (truncated 120), proc (truncated 200), errNum, severity, timestamp. Attempts <code>SafeHasProcedure(&quot;modAudit.EmitTelemetry&quot;)</code> then <code>SafeApplicationRun(&quot;modAudit.EmitTelemetry&quot;, payload)</code>. If that call errors or modAudit missing, falls back to <code>AppendLocalAudit &quot;Telemetry&quot;, payload, e.correlationId, e.timeStamp</code>. Fully guarded.<br><strong>Complexity:</strong> O(len of payload).<br><strong>Side-effects:</strong> May call external <code>modAudit</code> hook causing network or workbook-side telemetry to be emitted; fallback writes auditing sheet. <br><strong>Failure modes:</strong> If both modAudit and local audit fail (e.g., restricted workbook), telemetry is silently lost; consider returning boolean success in future API. Tests: mock <code>modAudit.EmitTelemetry</code> present and absent and assert side effect path taken. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>EnvironSafeUserName()</strong> — <em>robust username retrieval</em><br><strong>Purpose:</strong> Return a best-effort username for audit rows using environment or Excel Application fallback, normalized and truncated to 64 chars.<br><strong>Signature:</strong> <code>Private Function EnvironSafeUserName() As String</code><br><strong>Behavior:</strong> Tries <code>Environ(&quot;USERNAME&quot;)</code>, then <code>Application.userName</code>, else <code>Unknown</code>. Truncates. Guarded.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. Tests should assert returned value not empty and truncated length. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>GetConfigLong/GetConfigString(key, defaultVal)</strong> — <em>config accessor wrappers via modConfig</em><br><strong>Purpose:</strong> Attempt to read configuration values from <code>modConfig.GetConfigValue</code> safely via <code>SafeApplicationRun</code>. If missing or error, return default values. Used by redaction level retrieval and other guards.<br><strong>Signatures:</strong> <code>Private Function GetConfigLong(key As String, Optional defaultVal As Long = 0) As Long</code> and <code>Private Function GetConfigString(key As String, Optional defaultVal As String = &quot;&quot;) As String</code><br><strong>Behavior:</strong> Call <code>SafeApplicationRun(&quot;modConfig.GetConfigValue&quot;, key)</code> and interpret returned variant; <code>GetConfigLong</code> returns <code>CLng</code> if numeric else default; <code>GetConfigString</code> returns CStr or default. Fully guarded. <br><strong>Complexity:</strong> O(1) except cost of Application.Run.<br><strong>Failure modes:</strong> If <code>modConfig</code> not present, fallbacks used. Tests: missing <code>modConfig</code> returns defaults; present returns expected typed values. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>InstallTimeSelfCheck()</strong> — <em>startup self-check to validate dependencies</em><br><strong>Purpose:</strong> Called from <code>AddIn_DeferredInit</code> to verify presence of <code>modAudit.LogAudit</code> and <code>modConfig.GetConfigValue</code> and record result to local audit for operators/administrators.<br><strong>Signature:</strong> <code>Public Sub InstallTimeSelfCheck()</code><br><strong>Behavior:</strong> Uses <code>SafeHasProcedure</code> to test presence of optional procs. Builds issues string if missing dependencies; appends <code>SelfCheck</code> audit row with JSON <code>{&quot;issues&quot;:&quot;...&quot;}</code> or status ok; uses <code>GenerateCorrelationID</code> as corrId. Fully guarded.<br><strong>Complexity:</strong> O(1) aside from SafeHasProcedure invocation cost.<br><strong>Side-effects:</strong> Writes to audit. <br><strong>Failure modes:</strong> If <code>SafeHasProcedure</code> runs a procedure that has side-effects, this will cause them — the design assumes the procs used for detection are safe to call. Tests should verify both missing and present dependencies produce appropriate audit rows. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>RunModErrorSelfTests()</strong> — <em>deterministic self-test harness writing to _IFRS_TestResults</em><br><strong>Purpose:</strong> Provide deterministic set of sanity tests (≥10) for modError functionality — catalog init, correlation id uniqueness, redaction patterns, append structured audit, safe handler invocation, retry wrapper behavior, CRC32 determinism, audit sheet existence, install-time self-check. Intended for CI/manual verification.<br><strong>Signature:</strong> <code>Public Sub RunModErrorSelfTests()</code><br><strong>Behavior (detailed):</strong> Ensures test results sheet, then runs 10 tests writing timestamped rows of test name, result, and info via <code>WriteTestResult</code>. Tests use <code>EnsureCatalogInitialized</code>, <code>GenerateCorrelationID</code>, <code>RedactAndNormalize</code>, <code>AppendLocalAuditStructured</code>, <code>SafeHandleError</code> (call?), <code>RetryOperationByName</code>, <code>SafeApplicationRun</code>, <code>CRC32_String</code>, <code>EnsureAuditSheet</code>, <code>InstallTimeSelfCheck</code>. Reports summary row with pass counts. Fully guarded to avoid stopping on error.<br><strong>Complexity:</strong> O(#tests) with small constant cost; writes to <code>_IFRS_TestResults</code> and <code>_IFRS_Audit</code> as needed.<br><strong>Side-effects:</strong> Creates/updates <code>_IFRS_TestResults</code> sheet and appends audit entries via called functions. Intended to be run interactively or in install-time checks. <br><strong>Failure modes:</strong> Protected workbook may prevent test sheet creation; tests may rely on presence of optional procs causing false negatives; design uses safe wrappers to minimize this. Tests expected to be stable and idempotent. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>WriteTestResult(ws, row, testName, result, Optional info)</strong> — <em>test result writer</em><br><strong>Purpose:</strong> Helper to write single test row to provided test-sheet with timestamp, test name, result and info. Used by <code>RunModErrorSelfTests</code>.<br><strong>Signature:</strong> <code>Private Sub WriteTestResult(ws As Worksheet, row As Long, testName As String, result As Variant, Optional info As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Writes timestamp, testName, result string, and optional info to sheet cells. Guarded.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates test results worksheet. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>EnsureTestResultsSheet() -> Worksheet</strong> — <em>create/return very-hidden test results sheet</em><br><strong>Purpose:</strong> Ensure <code>_IFRS_TestResults</code> exists and is very-hidden with header columns <code>Timestamp, TestName, Result, Info</code> used by test harness.<br><strong>Signature:</strong> <code>Private Function EnsureTestResultsSheet() As Worksheet</code><br><strong>Behavior:</strong> Similar to <code>EnsureAuditSheet</code> but for tests. Creates sheet and header when missing, sets very-hidden, returns worksheet or <code>Nothing</code> if creation failed. Guarded.<br><strong>Complexity/Side-effects:</strong> O(1) creation cost and sheet mutation. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>GetUserFacingMessage(errNum)</strong> — <em>public accessor for user-facing message with generic fallback</em><br><strong>Purpose:</strong> Public function to get the user-facing message for an error code using catalog lookup, returning a deterministic generic fallback message if catalog entry missing.<br><strong>Signature:</strong> <code>Public Function GetUserFacingMessage(errNum As Long) As String</code><br><strong>Behavior:</strong> Calls <code>GetUserMessageFromCatalog</code>; if returns empty string, returns <code>&quot;An error occurred. See audit log.&quot;</code>. Designed for UI display code that must never leak internal messages.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Ensure known codes return catalog value; unknown codes return generic fallback. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>GetRemediationSteps(errNum)</strong> — <em>public accessor returning remediation text</em><br><strong>Purpose:</strong> Public wrapper over <code>GetRemediationFromCatalog</code> used by UI or help panels to display remediation instructions.<br><strong>Signature:</strong> <code>Public Function GetRemediationSteps(errNum As Long) As String</code><br><strong>Behavior:</strong> Returns remediation string or empty if not present. No fallback message (caller may choose UI behavior).<br><strong>Complexity/Side-effects/Tests:</strong> Straightforward. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>IsErrorCatalogInitialized / IsErrorCatalogAvailable / GetCatalogItemCount</strong> — <em>catalog state query helpers</em><br><strong>Purpose:</strong> Inspect catalog initialization and availability state for tests or diagnostic UIs.<br><strong>Signatures:</strong> <code>Public Function IsErrorCatalogInitialized() As Boolean</code>, <code>Public Function IsErrorCatalogAvailable() As Boolean</code>, <code>Public Function GetCatalogItemCount() As Long</code><br><strong>Behavior:</strong> Return <code>g_catalogInitialized</code>, <code>g_catalogAvailable</code>, and <code>g_errorCatalog.count</code> (0 if unavailable) respectively. Guarded to avoid errors when dictionary absent.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Call before and after <code>EnsureCatalogInitialized</code> to verify state transitions. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>SafeDebugPrint(label, s)</strong> — <em>fallback debug printing with redaction</em><br><strong>Purpose:</strong> Print debug info to Immediate window (Debug.Print) only when <code>modAudit.LogAudit</code> not available; always redacts output with <code>RedactAndNormalize</code> to avoid leaking secrets to console / developer output.<br><strong>Signature:</strong> <code>Private Sub SafeDebugPrint(ByVal label As String, ByVal s As String)</code><br><strong>Behavior:</strong> If <code>SafeHasProcedure(&quot;modAudit.LogAudit&quot;)</code> returns True, does nothing (audit used instead). Else <code>Debug.Print label &amp; &quot;: &quot; &amp; Left$(RedactAndNormalize(s), 1000)</code>. Guarded.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> Writes to Immediate window (developer console).<br><strong>Security:</strong> Limits leaked secrets while still providing debug info for development. Tests should verify redaction occurs and that no output produced when <code>modAudit</code> available. </td></tr><tr><td data-label="Technical breakdown (modError)"> <strong>Design & maintenance notes (summary)</strong> — <em>operational guidance & recommended changes</em><br><strong>Compatibility:</strong> Module designed for maximum compatibility — uses <code>On Error Resume Next</code> widely and favors best-effort behavior. Consumers must not rely on guaranteed presence of local audit (sheet creation may fail in locked workbooks).<br><strong>Privacy:</strong> Redaction centralized via <code>RedactAndNormalize</code>. Keep <code>DEFAULT_REDACT_LEVEL</code> conservative (1) and expose admin override via <code>modConfig</code>. Add unit tests whenever redaction regexes change. <br><strong>Audit schema:</strong> <code>AppendLocalAuditStructured</code> writes 11 columns; changing these columns must bump <code>AUDIT_SCHEMA_VERSION</code> and update ingestion pipelines. <br><strong>Telemetry integration:</strong> Uses <code>modAudit.EmitTelemetry</code> hook if present; maintainers should prefer modAudit for networked telemetry and keep <code>SafeEmitTelemetryEvent</code> names stable. <br><strong>Error catalog:</strong> Pre-populated codes are authoritative; treat catalog as read-only at runtime. If adding codes, update tests and documentation. <br><strong>Robustness improvements (recommended):</strong> return boolean success for <code>AppendLocalAuditStructured</code>/<code>AppendLocalAudit</code> to allow caller fallback logic; make <code>SafeHasProcedure</code> non-invasive by using a registry/flag rather than <code>Application.Run</code> to detect presence without executing code; add optional throttling for audit writes if heavy error storms expected. <br><strong>Tests to add:</strong> fuzz redaction with mixed-unicode input, workbook protection scenarios, multi-user Excel Shared Workbook behaviors, large payload performance, CRC mismatch detection and repair workflow. </td></tr></tbody></table></div><div class="row-count">Rows: 34</div></div><div class="table-caption" id="Table2" data-table="Docu_0160_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modExport)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modExport)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modExport)"> <strong>Overview:</strong> This table documents <code>modExport</code> (IFRSToolkit.xlam) at per-function granularity. Each entry is exhaustive and precise: purpose, signature, inputs/outputs, internal behavior, complexity, side-effects, invariants, failure modes, security considerations, recommended tests, and maintainer notes. Use as authoritative inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportToPDF</strong> — <em>legacy raise-on-failure wrapper</em><br><strong>Purpose:</strong> Backwards-compatible Sub preserving legacy semantics: callers expecting an exception on failure still get one. Internally delegates to <code>ExportToPDFEx</code> and raises if boolean result is False.<br><strong>Signature:</strong> <code>Public Sub ExportToPDF(Optional ByVal fileName As String = &quot;&quot;, Optional ByVal targetWb As Workbook = Nothing)</code><br><strong>Behavior:</strong> Calls <code>ExportToPDFEx(fileName, targetWb)</code>. If returned False raises <code>vbObjectError + EXPORT_ERR_LEGACY_RAISE</code>. Errors are routed to <code>LocalHandleError</code> in the ErrHandler path.<br><strong>Complexity:</strong> O(time to perform ExportToPDFEx).<br><strong>Side-effects:</strong> May raise an error; triggers <code>LocalHandleError</code> and audit/logging when errors occur.<br><strong>Invariants:</strong> Does not modify workbook state; only passes through to new API.<br><strong>Failure modes:</strong> Any failure or False from <code>ExportToPDFEx</code> results in raise. If <code>ExportToPDFEx</code> swallows errors, this wrapper reintroduces raising semantics only if it returns False.<br><strong>Security/XSS:</strong> No I/O performed here; security depends on <code>ExportToPDFEx</code> checks.<br><strong>Recommended tests:</strong> Call with no filename, with absolute and relative paths, supply invalid workbook, confirm legacy raise behavior for failure, confirm success passes silently. Validate <code>LocalHandleError</code> invoked on Err.<br><strong>Notes:</strong> Keep signature and raise semantics stable to preserve older callers. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportToPDFEx</strong> — <em>boolean-returning PDF exporter with atomic move & retries</em><br><strong>Purpose:</strong> Main robust PDF export routine. Produces a PDF by calling <code>Workbook.ExportAsFixedFormat</code> into a temp file, then atomically moving into final path; integrates job queue, security checks, retries/backoff and audit metadata.<br><strong>Signature:</strong> <code>Public Function ExportToPDFEx(Optional ByVal fileName As String = &quot;&quot;, Optional ByVal targetWb As Workbook = Nothing) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook via <code>ResolveWorkbookSafe</code> (ActiveWorkbook / ThisWorkbook fallback).<br>- Resolve <code>exportName</code> using <code>ChooseFolderFallback</code> when <code>fileName</code> is relative/empty.<br>- Security: call <code>Security_AllowExportPath_Check</code> and <code>EnsureFolderWritableForFile</code> before writing.<br>- Enqueue job via <code>EnqueueExportJob</code> (best-effort) and update job state transitions (queued/completed/failed).<br>- Build <code>tempExport</code> path in same folder as final; attempt up to <code>maxAttempts</code> calling <code>wb.ExportAsFixedFormat Type:=xlTypePDF</code> to <code>tempExport</code>. After each attempt: if temp file exists and non-empty, attempt atomic move (<code>Name</code> then fallback to <code>CopyFile</code> + delete). Backoff doubled between attempts. Clean-up of temp file on exit.<br>- On success log <code>SafeLogAuditWithMeta</code>, update job to completed and return True. On failure map to <code>EXPORT_ERR_PDF_NO_FILE</code>, update job failed and return False (ErrHandler also handles exceptions).<br><strong>Complexity:</strong> Dominated by export operation and file I/O; O(export time + file system operations). Retries multiply time but constant attempts (default 3).<br><strong>Side-effects:</strong> Writes temp files, may delete/overwrite existing <code>exportName</code>, writes audit entries, updates job state, interacts with <code>modSecurity</code> via allowlist hooks.<br><strong>Invariants:</strong> If function returns True the final file exists and is non-empty (verified by <code>FileExistsAndNonEmpty</code>). <code>tempExport</code> cleaned on exit when possible.<br><strong>Failure modes:</strong> <code>ExportAsFixedFormat</code> can raise errors (permissions, printer drivers, COM errors). Moves across volumes may require CopyFile fallback. Transient file locks may cause retries. If final move fails the function marks job failed and returns False. Uncaught errors go to <code>ErrHandler</code> and call <code>LocalHandleError</code>.<br><strong>Security:</strong> Validates destination via <code>Security_AllowExportPath_Check</code> and <code>EnsureFolderWritableForFile</code>. Audit messages are redacted where <code>PII_Detect</code>/<code>modSecurity</code> indicate. Avoids injecting untrusted strings into OS shells. Correlation IDs included in audit logs.<br><strong>Recommended tests:</strong> Export large/small workbooks, to writable and unwritable folders, to path that triggers allowlist deny, simulated <code>ExportAsFixedFormat</code> failure, cross-volume destination, ensure job state transitions, verify temp cleanup, validate audit entry content and redaction behavior.<br><strong>Notes:</strong> Keep temp filename generation deterministic and safe (already uses <code>GenerateCorrelationID</code>). Consider increasing <code>maxAttempts</code> for flaky network fileshares. Ensure <code>ExportAsFixedFormat</code> parameters remain compatible across Excel versions. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportWorksheetToCsv</strong> — <em>worksheet -> CSV streaming export wrapper</em><br><strong>Purpose:</strong> Export a single worksheet to CSV with UTF-8 support and streaming fallback; preserves backward-compatible signature and integrates job lifecycle and security checks.<br><strong>Signature:</strong> <code>Public Function ExportWorksheetToCsv(Optional ByVal targetWb As Workbook = Nothing, Optional ByVal sheetName As String = &quot;&quot;, Optional ByVal fullPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook and enqueue job (best-effort).<br>- Resolve <code>ws</code> via <code>SafeGetWorksheet</code> or <code>ActiveSheet</code> when <code>sheetName</code> omitted. Validates used range (<code>ws.UsedRange</code>).<br>- Determine <code>fullPath</code> fallback based on workbook path / DefaultFilePath / USERPROFILE.<br>- Security allowlist and folder writability checks via <code>Security_AllowExportPath_Check</code> and <code>EnsureFolderWritableForFile</code>.<br>- Perform export via <code>TryExportRangeToCsvWithOptions(rng, fullPath, True, jobId)</code>. On success log audit with <code>SafeLogAuditWithMeta</code> and update job state to completed; otherwise update job failed.<br><strong>Complexity:</strong> O(rows * cols) for range traversal; performance depends on <code>WriteRangeToCsvFallbackWithEncoding</code> which streams and flushes in configurable <code>rowsPerFlush</code> chunks.<br><strong>Side-effects:</strong> Writes CSV, updates job state, sends periodic progress updates via <code>UpdateExportJobState</code> when jobId supplied, may use ADODB.Stream or binary file writes.<br><strong>Invariants:</strong> On success CSV exists and non-empty per <code>FileExistsAndNonEmpty</code> (validated by underlying writer). Progress updates occur at ~500ms intervals.<br><strong>Failure modes:</strong> Missing sheet, empty UsedRange, write errors (permission, disk full), ADODB unavailable, cancellation by jobs API if <code>modJobs.IsCancelled</code> returns True. If cancelled the function cleans up temp file and returns False.<br><strong>Security:</strong> Destination path validated via allowlist. CSV writer normalizes decimals and escapes quotes per RFC4180; uses <code>textContent</code> semantics (no HTML). Audit entries redacted as needed.<br><strong>Recommended tests:</strong> Small and large sheets (streaming triggers), embedded newlines and quotes, numeric locale decimal separator variations, cancel jobs via <code>modJobs.IsCancelled</code> simulation, ADODB absent fallback behavior, job progress correctness, CSV RFC4180 compliance tests.<br><strong>Notes:</strong> <code>rowsPerFlush</code> read from config (<code>IFRS.Export.MaxRowsBuffered</code>) and capped; tuning recommended for memory/disk tradeoffs. Consider adding CSV dialect options (separator, BOM toggle handled via <code>IFRS.Export.UTF8BOM</code>). </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportWorkbookAsXlsx</strong> — <em>atomic workbook save-as XLSX with overwrite policies</em><br><strong>Purpose:</strong> Export the current or supplied workbook as a standalone <code>.xlsx</code> file using atomic save semantics where possible; respects <code>IFRS.Export.OverwriteBehavior</code> (<code>overwrite|fail|version</code>).<br><strong>Signature:</strong> <code>Public Function ExportWorkbookAsXlsx(Optional ByVal targetWb As Workbook = Nothing, Optional ByVal fullPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook, enqueue job, derive default <code>fullPath</code> if omitted (uses workbook path or DefaultFilePath / USERPROFILE).<br>- Security checks (<code>Security_AllowExportPath_Check</code> and <code>EnsureFolderWritableForFile</code>).<br>- Evaluate <code>OverwriteBehavior</code> configuration: if <code>fail</code> refuses when file exists; if <code>version</code> auto-increments <code>_vN</code> suffix to avoid overwrite.<br>- Perform save via <code>TryAtomicSaveWorkbookAsWithVerification</code>, which uses <code>AtomicSaveWorkbookAs</code> if available (via <code>SafeApplicationRun</code>) else <code>SaveCopyAs</code> + copy fallback. Retries/backoff used for locked/network folders.<br>- On success audit and update job to completed; on failure call <code>LocalHandleError</code> with <code>EXPORT_ERR_SAVE_XLSX_FAIL</code> and return False.<br><strong>Complexity:</strong> SaveCopyAs cost and file copy cost; verification loops add retries but bounded by <code>EXPORT_ERR_MAX_RETRIES</code>.<br><strong>Side-effects:</strong> Creates <code>.xlsx</code> file, may produce temporary files, may leave temp copies on failure if cleanup fails. Updates job and audit logs.<br><strong>Invariants:</strong> On True return, final <code>.xlsx</code> exists and non-empty (verified). OverwriteBehavior enforced.<br><strong>Failure modes:</strong> Locked file, network share errors, insufficient permissions, atomic save not supported by host environment. Fallback copy may fail across volumes or in restricted environments.<br><strong>Security:</strong> Destination checks and verification via <code>Security_VerifyExportPathWritable</code>. Audit redaction applied.<br><strong>Recommended tests:</strong> Overwrite policies exercised, save to read-only folder, simulated SaveCopyAs failure, network share flakiness, presence/absence of <code>AtomicSaveWorkbookAs</code> in <code>modUtilities</code>, file integrity verification (open file in another Excel instance).<br><strong>Notes:</strong> The function intentionally uses <code>SaveCopyAs</code> fallback to avoid altering original workbook state. Consider exposing <code>maxAttempts</code> config. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportCustomXMLPart</strong> — <em>export workbook CustomXMLPart by root element</em><br><strong>Purpose:</strong> Extract a CustomXMLPart by root element name and persist to a file safely; enforces policy checks to avoid exporting secrets.<br><strong>Signature:</strong> <code>Public Function ExportCustomXMLPart(ByVal rootElement As String, ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Validate arguments non-empty. Read XML via <code>TryReadCustomXMLPart(rootElement)</code>. If empty return <code>EXPORT_ERR_CUSTOMXML_NOENT</code>.<br>- Run <code>CheckCustomXmlPolicy(rootElement, xml)</code> which calls <code>modSecurity_CheckCustomXmlExport</code> if present; default denies when tokens <code>password</code> or <code>secret</code> appear.<br>- Prepend/insert a small header comment with correlation id and timestamp into XML for traceability (non-invasive).<br>- Security allowlist and folder writable checks for <code>fullPath</code>.<br>- Write to disk using <code>TryAtomicWriteFileWithEncoding(fullPath, xml, True)</code> (prefers UTF-8). On failure raise <code>EXPORT_ERR_CUSTOMXML_WRITE_FAIL</code>.<br>- On success do <code>SafeLogAuditWithMeta</code> and return True.<br><strong>Complexity:</strong> O(size of XML) for memory and write; atomic write complexity includes temp file move. Reads are O(#customxmlparts) when fallback iterates workbook parts.<br><strong>Side-effects:</strong> Writes file, logs audit. May leak redacted metadata into audit if <code>PII_Detect</code> not called; however <code>SafeLogAuditWithMeta</code> attempts redaction.<br><strong>Invariants:</strong> On success file exists and contains XML with header comment. Secrets are not exported when policy denies.<br><strong>Failure modes:</strong> Missing CustomXMLPart, policy denies, write fails (permissions), ADODB/IO unavailable. ErrHandler routes to <code>LocalHandleError</code>.<br><strong>Security:</strong> Primary surface for secret leakage — policy hook (<code>modSecurity</code>) must be used in sensitive deployments. Use <code>PII_Detect</code> and <code>RedactSecrets</code> to avoid PII in audit messages. Avoid exposing raw XML in UI logs.<br><strong>Recommended tests:</strong> Export parts containing <code>password</code>/<code>secret</code> to ensure policy denies, test successful export with and without <code>&lt;?xml</code> header, large XML export, write-permission failures, validation that header comment inserted in correct position. Edge-case: XML declaration absent or malformed.<br><strong>Notes:</strong> Consumers may rely on the header comment for traceability; keep format stable. Consider adding optional schema/version metadata as function parameter for future compatibility. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CreateZipFromFiles</strong> — <em>cross-platform ZIP packer with OS shell integration and bootstrap</em><br><strong>Purpose:</strong> Produce a ZIP archive from a <code>Collection</code> of file paths using platform-specific mechanisms: <code>zip</code> on macOS via <code>MacScript</code> or <code>Shell.Application</code> on Windows. Creates minimal PKZIP bootstrap so <code>Shell.Application</code> can open the file on Windows.<br><strong>Signature:</strong> <code>Public Function CreateZipFromFiles(ByVal files As Collection, ByVal zipPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Validate inputs (non-empty collection and zipPath). Ensure <code>zipFolder</code> writable and create folder via <code>SafeFolderCreate</code>.<br>- Remove existing zip, create minimal empty zip by writing PK header to <code>zipPath</code> (so Windows shell can treat it as zip container).<br>- If macOS call <code>ExecShellZipOnMac(files, zipPath)</code> which builds a <code>zip -j -q</code> shell command and <code>MacScript</code> to run it; on Windows call <code>ExecShellZipOnWindows(files, zipPath)</code> which uses <code>Shell.Application.Namespace(zipPath).CopyHere</code> for each file and waits for zip stability via <code>WaitForZipStable</code>.<br>- Validate final zip exists and is non-empty using <code>FileExistsAndNonEmpty</code>. Log audit meta and return True on success.<br><strong>Complexity:</strong> O(sum file sizes + OS copy time). On Windows using Shell.Application may be asynchronous and slower; <code>WaitForZipStable</code> polls for size stability and uses <code>DoEvents</code> loop.<br><strong>Side-effects:</strong> Writes/overwrites <code>zipPath</code>, uses shell-level copy operations, may create temporary OS shell background tasks. Writes audit entry.<br><strong>Invariants:</strong> Final zip exists and size > bootstrap. If Shell copy operations are queued the function will wait up to per-file timeouts and attempt to detect stability.<br><strong>Failure modes:</strong> Shell automation may fail for long paths, restricted files, UAC restrictions; <code>MacScript</code> may fail if sandboxed or <code>zip</code> missing; <code>Shell.Application</code> may silently queue operations that never complete; <code>WaitForZipStable</code> timeout results in warning audit but function still returns success only if zip non-empty.<br><strong>Security:</strong> Inputs are literal file paths; <code>ExecShellZipOnMac</code> uses <code>QuotePathForShell</code> to escape paths. Avoid running arbitrary untrusted shells. Validate path allowlist upstream. Audit message includes file count (not full paths) to reduce PII exposure.<br><strong>Recommended tests:</strong> Zip small and large sets, paths with spaces and quotes, files on network shares, zipPath already exists, simulate <code>zip</code> missing on Mac, long path Windows behavior, permission-denied files, and verify <code>WaitForZipStable</code> reliability. Ensure files inside zip are accessible and not corrupted. Test large filesets for performance and shell queueing quirks.<br><strong>Notes:</strong> The PKZIP bootstrap approach is required for Windows shell copy method. Consider integrating a native ZIP library for deterministic and faster operation and to avoid <code>Shell.Application</code> quirks. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportPackage</strong> — <em>high-level package builder (PDF + XLSX + Audit + extras) into ZIP</em><br><strong>Purpose:</strong> Convenience flow: export canonical artifacts (PDF, XLSX, Audit) then package them with optional additional files into a ZIP; integrates job lifecycle and best-effort fallbacks for each component export.<br><strong>Signature:</strong> <code>Public Function ExportPackage(Optional ByVal filesToInclude As Collection = Nothing, Optional ByVal zipPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Enqueue job, resolve workbook, compute default <code>zipPath</code> when omitted.<br>- Security allowlist check for <code>zipPath</code>.<br>- Attempt <code>ExportToPDF</code> (legacy signature), <code>ExportWorkbookAsXlsx</code>, and <code>ExportAuditToCSV</code> to produce PDF/XLSX/Audit files in <code>folder</code>. Add successfully-created files to local <code>tmpFiles</code> collection.<br>- Merge user-specified <code>filesToInclude</code> after existence checks.<br>- If no files available raise <code>EXPORT_ERR_ZIP_NO_FILES</code>. Else call <code>CreateZipFromFiles(tmpFiles, zipPath)</code> and update job state accordingly. Log audit meta.<br><strong>Complexity:</strong> Sum of component export complexities plus zip creation cost; overall bounded but can be slow due to sequential exports.<br><strong>Side-effects:</strong> May create multiple temporary files and final ZIP; updates job state and audit logs; may leave partial artifacts if steps fail.<br><strong>Invariants:</strong> On True result final zip exists and contains at least one included file as verified by <code>CreateZipFromFiles</code> success. Correlation id added to job metadata.<br><strong>Failure modes:</strong> Any export failing results in missing files and potentially overall failure; <code>ExportToPDF</code> uses legacy raise semantics internally but wrapped in <code>On Error Resume Next</code> call here to continue best-effort. Network share and permission errors possible. If <code>CreateZipFromFiles</code> fails whole packaging fails.<br><strong>Security:</strong> Validate each included file path via allowlist prior to packaging; user-supplied <code>filesToInclude</code> may reference arbitrary filesystem locations—caller must ensure safe use. Audit redaction applies.<br><strong>Recommended tests:</strong> Call with default inclusion set and with additional files; missing PDF/XLSX should not crash—ensure proper job state/logging; package files from different folders/UNC paths; large artifacts; cancellation via job hooks if available.<br><strong>Notes:</strong> This flow is intentionally non-blocking regarding audit and best-effort when each step fails; consider an option to fail-fast vs best-effort mode. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportAuditToCSV</strong> — <em>export audit trail using centralized hook or fallback sheet discovery</em><br><strong>Purpose:</strong> Export audit information to CSV. Prefers calling centralized <code>ExportAuditToCSV_Central</code> via <code>SafeApplicationRun</code>; falls back to exporting known audit sheets or searching for a sheet name containing "audit".<br><strong>Signature:</strong> <code>Public Function ExportAuditToCSV(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- If <code>fullPath</code> empty set default under TEMP. Try <code>SafeApplicationRun(&quot;ExportAuditToCSV_Central&quot;, fullPath)</code>; if returns boolean, use it and log audit.<br>- Otherwise search <code>ThisWorkbook</code> worksheets for exact audit sheet names or any sheet with "audit" in name. If none found raise error 2400 and return False.<br>- If found call <code>ExportWorksheetToCsv</code> with found sheet and <code>fullPath</code>. On success <code>SafeLogAuditWithMeta</code> and return True.<br><strong>Complexity:</strong> O(#sheets + cost of ExportWorksheetToCsv).<br><strong>Side-effects:</strong> May call centralized routine; will create CSV and audit log entry.<br><strong>Invariants:</strong> If True CSV file exists and audit is recorded. If no central routine exists, falls back safely to worksheet export.<br><strong>Failure modes:</strong> No audit sheet found, write errors on CSV, central function errors. Errors routed through <code>LocalHandleError</code>.<br><strong>Security:</strong> Audit contents may contain PII; <code>SafeLogAuditWithMeta</code> applies redaction policies. Destination path validated by underlying export routine.<br><strong>Recommended tests:</strong> Central hook present/absent, numerous audit sheet name variants, large audit sheets, ensure redaction toggles via config. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportSelfTest</strong> — <em>module self-test producing deterministic artifacts</em><br><strong>Purpose:</strong> Run a deterministic set of checks and produce test outputs (CSV, XLSX, ZIP) in a <code>_IFRS_TestResults</code> folder for CI / developer verification. Invokes other modules' self-tests where available via <code>SafeApplicationRun</code>.<br><strong>Signature:</strong> <code>Public Function ExportSelfTest() As Boolean</code><br><strong>Behavior:</strong><br>- Create <code>testFolder</code> under workbook path or TEMP and ensure created. Attempt to run <code>UtilitiesSelfTest</code>, <code>Security_SelfTest</code>, <code>modConfig_Load</code> via <code>SafeApplicationRun</code> (best-effort). Run <code>Export_MigrateLegacyConfig</code> non-destructively.<br>- Ensure <code>TST_Export_Sheet</code> exists with sample data; call <code>ExportWorksheetToCsv</code> to produce <code>ifrs_test_export.csv</code> and <code>ExportWorkbookAsXlsx</code> for <code>ifrs_test_export.xlsx</code> and <code>CreateZipFromFiles</code> to produce <code>ifrs_test_package.zip</code> from the two files. Aggregate <code>ok</code> boolean across steps and log audit with meta.<br><strong>Complexity:</strong> Linear in test artifact sizes; bounded and deterministic.<br><strong>Side-effects:</strong> Adds a test worksheet if not present; writes CSV/XLSX/ZIP test artifacts to <code>testFolder</code> and logs audit entries. Non-destructive regarding user data but modifies workbook by adding <code>TST_Export_Sheet</code> if missing.<br><strong>Invariants:</strong> Returns True only if all primary test artifacts successfully produced. Test artifacts are deterministic names with timestamps where applied.<br><strong>Failure modes:</strong> File write permissions, failing subtests, <code>SafeApplicationRun</code> target functions absent. ErrHandler logs errors via <code>LocalHandleError</code>.<br><strong>Security:</strong> Test artifacts may contain sample text; not sensitive. Audit logs created.<br><strong>Recommended tests:</strong> Run in CI with clean workbook and also with existing <code>TST_Export_Sheet</code>. Verify that repeated runs don't leak files or create duplicates beyond the sheet. Ensure <code>Export_RunUnitTests</code> integration. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Export_RunUnitTests</strong> — <em>CI wrapper to run module self-tests and light checks</em><br><strong>Purpose:</strong> Lightweight harness used in CI/developer scenarios to run <code>ExportSelfTest</code> plus basic availability checks for config and helper utilities.<br><strong>Signature:</strong> <code>Public Function Export_RunUnitTests() As Boolean</code><br><strong>Behavior:</strong> Calls <code>ExportSelfTest()</code>, verifies <code>SafeConfigGet</code> returns (Null acceptable), generates <code>GenerateCorrelationID</code> to validate helper, logs result via <code>SafeLogAudit</code>. Returns aggregated boolean. Catches exceptions via ErrHandler and logs.<br><strong>Complexity:</strong> O(cost of ExportSelfTest).<br><strong>Side-effects:</strong> Writes audit log and possibly test artifacts via <code>ExportSelfTest</code>.<br><strong>Invariants:</strong> True => <code>ExportSelfTest</code> passed and core helpers returned expected types.<br><strong>Failure modes:</strong> Any subtest failing results in False. Errs logged and surfaced via <code>SafeLogAudit</code>.<br><strong>Recommended tests:</strong> Run in isolated environment; ensure CI can clean up test artifacts; validate log entries and exit codes for CI integration. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ResolveWorkbookSafe (Private)</strong> — <em>resolve supplied or active workbook defensively</em><br><strong>Purpose:</strong> Helper to deterministically resolve which workbook to operate on: supplied workbook, ActiveWorkbook, then ThisWorkbook.<br><strong>Signature:</strong> <code>Private Function ResolveWorkbookSafe(Optional ByVal suppliedWb As Workbook = Nothing) As Workbook</code><br><strong>Behavior:</strong> If <code>suppliedWb</code> provided return it; else return <code>ActiveWorkbook</code> if present; else <code>ThisWorkbook</code>. Errors are suppressed to avoid raising in callers.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Returns a Workbook object or Nothing depending on environment; uses On Error Resume Next to avoid unexpected exceptions.<br><strong>Failure modes:</strong> Host environment where <code>ActiveWorkbook</code> not accessible or ThisWorkbook undefined (rare).<br><strong>Tests:</strong> Call with explicit workbook, nil, ensure correct resolution when add-in loaded but no workbook active. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>LocalHandleError (Private)</strong> — <em>centralized fallback error handler & legacy raise enforcer</em><br><strong>Purpose:</strong> Central library-local error handling façade. Attempts to call global <code>HandleError</code> via <code>SafeApplicationRun</code>; if absent, falls back to <code>SafeLogAudit</code> and raises a module-space error (legacy raise-space to discourage collisions).<br><strong>Signature:</strong> <code>Private Sub LocalHandleError(ByVal proc As String, ByVal errNum As Long, ByVal errDesc As String)</code><br><strong>Behavior:</strong> Calls <code>SafeApplicationRun(&quot;HandleError&quot;, proc, errNum, errDesc)</code>. If handler exists treats error as handled; otherwise logs and raises <code>vbObjectError + EXPORT_ERR_LEGACY_RAISE + (Abs(errNum) Mod 1000)</code> to preserve a raising semantics while still namespacing the module. Uses <code>Err.Clear</code> and safe guards to avoid endless raise loops.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May raise an error (legacy semantics) or write to audit logs.<br><strong>Invariants:</strong> Never throws an unhandled error from inside itself (surrounded by <code>On Error Resume Next</code>) except the intentional raise which is caught by caller ErrHandler if present.<br><strong>Recommended tests:</strong> Simulate presence and absence of global <code>HandleError</code>, verify audit vs raise behaviors, ensure raise code maps to module-space offsets. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>SafeLogAudit / SafeLogAuditWithMeta (Private)</strong> — <em>best-effort audit writers with redaction support</em><br><strong>Purpose:</strong> Central audit entry writers that prefer calling host <code>LogAudit</code> but fallback to file append when unavailable; <code>SafeLogAuditWithMeta</code> adds workbook/context/duration/retries and delegates to <code>modSecurity</code> redaction when configured.<br><strong>Signatures:</strong> <code>Private Sub SafeLogAudit(ByVal category As String, ByVal message As String)</code> and <code>Private Sub SafeLogAuditWithMeta(ByVal category As String, ByVal message As String, ByVal targetPath As String, Optional ByVal wb As Workbook = Nothing, Optional ByVal extra As String = &quot;&quot;, Optional ByVal durationMs As Long = -1, Optional ByVal retries As Long = -1)</code><br><strong>Behavior:</strong> Both call <code>SafeApplicationRun(&quot;LogAudit&quot;, ...)</code> and fallback to writing <code>ifrs_local_audit.log</code> in TEMP when host function absent. <code>SafeLogAuditWithMeta</code> performs PII detection (<code>PII_Detect</code>) and redaction via <code>SafeApplicationRun(&quot;modSecurity_ShouldRedactAudit&quot;)</code> and <code>RedactSecrets</code> fallback. Adds <code>cid</code> correlation id and optional metadata fields. Attempts to call centralized <code>LogAudit(category, metaMsg, cid)</code> and falls back.<br><strong>Complexity:</strong> O(len(message)).<br><strong>Side-effects:</strong> Writes to centralized logging mechanism or local temp log. May expose sanitized paths.<br><strong>Invariants:</strong> Audit attempts never throw to caller due to <code>On Error Resume Next</code> guard. <code>cid</code> always generated using <code>GenerateCorrelationID</code> even if <code>Scriptlet.TypeLib</code> not available (fallback pseudo-id).<br><strong>Security:</strong> Avoids including raw PII into logs when <code>modSecurity</code> indicates; but fallback redaction heuristics are coarse (email tokens, long digit runs). Maintain careful handling for highly sensitive systems.<br><strong>Recommended tests:</strong> Verify LogAudit present vs absent; test redaction toggles; test with strings containing emails, passwords, long digit sequences; validate local fallback log format and rotation policy (not implemented here). </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>GenerateCorrelationID (Private)</strong> — <em>GUID / deterministic fallback generator</em><br><strong>Purpose:</strong> Produce a correlation identifier for audit/job tracking. Prefer COM <code>Scriptlet.TypeLib</code> GUID; fallback to deterministic pseudo-id using timestamp + random digits.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Create <code>Scriptlet.TypeLib</code> GUID and strip braces; if not available, generate <code>CID-YYYYMMDDHHMMSS-XXXXX</code> with <code>Rnd()</code> random suffix.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Always returns a non-empty string. Fallback uses <code>Randomize</code> ensuring variability but not cryptographic uniqueness.<br><strong>Recommended tests:</strong> Ensure GUID contains no braces and fallback matches expected format. For strict traceability environments consider replacing fallback with a stronger UUID provider. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ChooseFolderFallback (Private)</strong> — <em>determine export folder fallback order</em><br><strong>Purpose:</strong> Resolve best folder to use for exports: config <code>IFRS.Export.DefaultFolder</code> → <code>GetTempFolder</code> hook → workbook.path → Application.DefaultFilePath → USERPROFILE → TEMP.<br><strong>Signature:</strong> <code>Private Function ChooseFolderFallback(ByVal wb As Workbook) As String</code><br><strong>Behavior:</strong> Uses <code>SafeConfigGet</code> and <code>SafeApplicationRun(&quot;GetTempFolder&quot;)</code> to prefer configured or host-provided temp folder, then workbook path or Application defaults, and finally environment fallbacks.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Returns a non-empty path always (TEMP fallback).<br><strong>Recommended tests:</strong> Verify priority order by mocking <code>modConfig_Get</code> and <code>GetTempFolder</code> through <code>SafeApplicationRun</code>. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>EnsureFolderWritableForFile / IsFolderWritable / SafeFolderCreate (Private)</strong> — <em>folder writability & creation helpers</em><br><strong>Purpose:</strong> Validate and create folders required by exports. <code>EnsureFolderWritableForFile</code> integrates security allowlist and <code>modSecurity</code> verification, then calls <code>IsFolderWritable</code> which attempts a short write/cleanup test. <code>SafeFolderCreate</code> ensures creation only if missing.<br><strong>Signatures:</strong> <code>Private Function EnsureFolderWritableForFile(ByVal filepath As String) As Boolean</code>, <code>Private Function IsFolderWritable(ByVal folderPath As String) As Boolean</code>, <code>Private Sub SafeFolderCreate(ByVal folderPath As String)</code><br><strong>Behavior:</strong> <code>EnsureFolderWritableForFile</code> computes folder from filepath, calls <code>Security_AllowExportPath_Check</code> and <code>Security_VerifyExportPathWritable</code> then <code>IsFolderWritable</code>. <code>IsFolderWritable</code> tries to create a small temp file, write "IFRS", then delete it. <code>SafeFolderCreate</code> calls FSO.CreateFolder when missing.<br><strong>Complexity:</strong> <code>IsFolderWritable</code> IO-bound O(1) with file write+delete.<br><strong>Side-effects:</strong> May create and delete a small temp file, may create folder. Uses <code>On Error</code> guards.<br><strong>Failure modes:</strong> Anti-virus or permission restrictions will cause negative return; network shares with delayed write semantics might misreport writability. Must catch exceptions gracefully as implemented.<br><strong>Recommended tests:</strong> Protected folder write denial, network share write latency, folder creation races (concurrent creation), and ensure cleanup of temp file on interrupt. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Atomic write / save helpers (TryAtomicWriteFile, TryAtomicWriteFileWithEncoding, TryAtomicWriteFileWithRetries, TryAtomicWriteFileWithVerification, WriteTextFileAtomicFallback, WriteUtf8FileAtomicFallback, TryAtomicSaveWorkbookAs, TryAtomicSaveWorkbookAsWithVerification)</strong> — <em>robust atomic write & save primitives</em><br><strong>Purpose:</strong> Provide cross-module atomic write primitives that prefer host <code>AtomicWriteFile</code> / <code>AtomicSaveWorkbookAs</code> utilities when available, else fallback to temp file + move/copy strategies with optional encoding, verification and retry/backoff semantics. Designed to cope with locked files and network shares.<br><strong>Signatures:</strong> Several <code>Private Function</code> wrappers: <code>TryAtomicWriteFile(fullPath, contents) As Boolean</code>, <code>TryAtomicWriteFileWithEncoding(fullPath, contents, useUtf8) As Boolean</code>, <code>TryAtomicWriteFileWithRetries(fullPath, contents, useUtf8, Optional maxAttempts) As Boolean</code>, <code>TryAtomicWriteFileWithVerification(fullPath, contents) As Boolean</code>, <code>WriteTextFileAtomicFallback(fullPath, contents) As Boolean</code>, <code>WriteUtf8FileAtomicFallback(fullPath, contents, useUtf8) As Boolean</code>, <code>TryAtomicSaveWorkbookAs(wb, fullPath) As Boolean</code>, <code>TryAtomicSaveWorkbookAsWithVerification(wb, fullPath) As Boolean</code><br><strong>Behavior:</strong><br>- <code>TryAtomicWriteFile*</code> attempt to call host <code>AtomicWriteFile</code> via <code>SafeApplicationRun</code>, otherwise call <code>WriteTextFileAtomicFallback</code>/<code>WriteUtf8FileAtomicFallback</code>. <code>WithRetries</code> loops with exponential backoff. <code>WithVerification</code> ensures file exists and size > 0.<br>- <code>WriteTextFileAtomicFallback</code> writes contents to <code>tmpPath</code> using Binary Access Write, then <code>Name</code> into destination or <code>CopyFile</code> fallback. <code>WriteUtf8FileAtomicFallback</code> prefers <code>ADODB.Stream</code> with <code>.Charset=&quot;utf-8&quot;</code> to write UTF-8 reliably; if ADODB unavailable writes BOM + binary fallback; then atomic move/copy. Cleanups handled on error.<br>- <code>TryAtomicSaveWorkbookAs</code> calls <code>AtomicSaveWorkbookAs</code> host function or falls back to <code>SaveCopyAs tmp</code> then <code>CopyFile tmp -&gt; fullPath</code>. <code>TryAtomicSaveWorkbookAsWithVerification</code> retries with backoff and checks file existence/size.<br><strong>Complexity:</strong> IO-bound and proportional to file size; retries increase time multiplicatively. ADODB.Stream usage may be more memory-efficient for large data.<br><strong>Side-effects:</strong> Creates temp files (tmpPath) and may temporarily duplicate file content on disk during copy operations. May delete temp files after successful move. Writes audit via callers.<br><strong>Invariants:</strong> On success final file exists and size > 0. Temp files are attempted to be removed on all paths but may remain in case of abrupt termination.<br><strong>Failure modes:</strong> ADODB unavailable, temp file write failure, insufficient disk space, cross-volume <code>Name</code> failure handled via fallback to copy, concurrency causing overwrite races. Networked filesystems may cause copy semantics to behave slowly or partially; verification mitigates some risks.<br><strong>Security:</strong> Avoids exposing file content in logs. When writing secrets consider additional file permission hardening (not implemented).<br><strong>Recommended tests:</strong> Test with large file bodies, simulate ADODB missing, simulate cross-volume moves (Name fails), simulate intermittent write errors to provoke retry/backoff. Verify temp file removal under success and failure. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CSV export internals: TryExportRangeToCsvWithOptions / WriteRangeToCsvFallbackWithEncoding</strong> — <em>streaming RFC4180-compliant CSV writer with job progress/cancellation</em><br><strong>Purpose:</strong> Primary fallback CSV writer that is RFC4180-aware: quotes, embedded newlines normalized to LF, CRLF row delimiters, numeric decimal normalization, optional UTF-8 BOM control, streaming via ADODB.Stream for large ranges, buffered writes based on <code>IFRS.Export.MaxRowsBuffered</code>, and job progress/cancellation via <code>jobId</code> hook.<br><strong>Signatures:</strong> <code>Private Function TryExportRangeToCsvWithOptions(ByVal rng As Range, ByVal fullPath As String, ByVal useUtf8 As Boolean, Optional ByVal jobId As Variant = Empty) As Boolean</code> and <code>Private Function WriteRangeToCsvFallbackWithEncoding(ByVal rng As Range, ByVal fullPath As String, ByVal useUtf8 As Boolean, Optional ByVal jobId As Variant = Empty) As Boolean</code><br><strong>Behavior (detailed):</strong><br>- Prefer <code>ExportRangeToCsv</code> host implementation; else stream using ADODB.Stream when available and when <code>streamingEnabled</code> and range size large enough. Otherwise uses binary file writes.<br>- <code>writeBOM</code> controlled by <code>IFRS.Export.UTF8BOM</code>. <code>rowsPerFlush</code> read from <code>IFRS.Export.MaxRowsBuffered</code> with safety cap (<=10000).<br>- For each cell: <code>Value2</code> read, types handled: errors -> "", Empty -> "", Numeric -> <code>CStr(rawVal)</code> with decimal normalization to <code>.</code> using <code>Application.International(xlDecimalSeparator)</code>, else <code>CStr</code>. Newlines normalized to LF, quotes escaped by doubling, fields containing comma/newline/quote wrapped in quotes. Row concatenation appended with CRLF.<br>- Buffer flush on <code>rowsPerFlush</code> to ADODB or binary file. Periodic job progress updates (~500ms) via <code>UpdateExportJobState</code> and cancellation check via <code>SafeApplicationRun(&quot;modJobs.IsCancelled&quot;, jobId)</code>; on cancel perform cleanup and return False.<br>- On completion flush remainder, save ADODB to <code>tmpPath</code> if used, atomically move to <code>fullPath</code> using <code>Name</code>/Copy fallback; returns <code>FileExistsAndNonEmpty(fullPath)</code>.<br><strong>Complexity:</strong> O(total cells). Memory usage controlled by <code>rowsPerFlush</code>. When streaming true, ADODB reduces memory footprint.<br><strong>Side-effects:</strong> Writes temporary file, interacts with job system for progress/cancel, logs warnings on zip creation when used by other flows.<br><strong>Invariants:</strong> CSV output follows RFC4180 semantics for safe CSV parsing by consumers. Numeric representation uses <code>.</code> decimal separator. BOM only written if <code>writeBOM</code> true.<br><strong>Failure modes:</strong> ADODB unavailable (fallback to binary), disk full, permission errors, job cancellation. Possible encoding pitfalls for non-UTF-8 systems if ADODB handles charset differently. Newline and quote handling must be exact to satisfy RFC4180.<br><strong>Security:</strong> No HTML injection risk — writes text only. Ensure that CSV writers used for audit exports do not leak secrets (audit redaction applied separately).<br><strong>Recommended tests:</strong> RFC4180 conformance with cells containing quotes/commas/newlines, locale decimal separator tests, streaming vs non-streaming behavior, job cancellation during long runs, big sheets triggering ADODB path, BOM on/off, verify atomic move of final file. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CustomXML helpers: TryReadCustomXMLPart / ReadCustomXMLPartFallback / CheckCustomXmlPolicy</strong><br><strong>Purpose:</strong> Read CustomXMLPart content via host hook <code>ReadCustomXMLPart</code> or fallback iterating <code>ThisWorkbook.CustomXMLParts</code>; check export policy via <code>modSecurity_CheckCustomXmlExport</code> or conservative keyword detection.<br><strong>Signatures:</strong> <code>Private Function TryReadCustomXMLPart(ByVal rootElement As String) As String</code>, <code>Private Function ReadCustomXMLPartFallback(ByVal rootElement As String) As String</code>, <code>Private Function CheckCustomXmlPolicy(ByVal rootElement As String, ByVal xml As String) As Boolean</code><br><strong>Behavior:</strong><br>- <code>TryReadCustomXMLPart</code> attempts <code>SafeApplicationRun(&quot;ReadCustomXMLPart&quot;, rootElement)</code> and returns string when available; else calls <code>ReadCustomXMLPartFallback</code>. Fallback scans <code>ThisWorkbook.CustomXMLParts</code> and returns first <code>cxp.xml</code> containing <code>&lt;rootElement</code> substring.<br>- <code>CheckCustomXmlPolicy</code> attempts <code>modSecurity_CheckCustomXmlExport(rootElement, xml)</code> and returns its boolean; otherwise denies if <code>password</code> or <code>secret</code> tokens found (case-insensitive).<br><strong>Complexity:</strong> Fallback is O(#CustomXMLParts * size(part)).<br><strong>Side-effects:</strong> None. Uses <code>On Error</code> guards.<br><strong>Invariants:</strong> Policy check conservative default denies on suspicious tokens. Fallback selection is first-match; not deterministic if multiple parts contain same root.<br><strong>Failure modes:</strong> Large custom XML parts may be memory heavy. Host <code>ReadCustomXMLPart</code> must be authoritative where available. False negatives possible in policy if secrets not tokenized simply; rely on <code>modSecurity</code> for robust detection.<br><strong>Recommended tests:</strong> Parts with/without XML declarations, parts containing <code>password</code>/<code>secret</code>, multiple parts with similar tags, host hook present vs absent. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ZIP helpers: IsMacOS / ExecShellZipOnMac / QuotePathForShell / ExecShellZipOnWindows / WaitForZipStable</strong><br><strong>Purpose:</strong> Platform detection and OS-specific ZIP creation helpers; quoting helper for shell commands and stability polling for Windows shell copy operations.<br><strong>Signatures:</strong> <code>Private Function IsMacOS() As Boolean</code>, <code>Private Function ExecShellZipOnMac(ByVal files As Collection, ByVal zipPath As String) As Boolean</code>, <code>Private Function QuotePathForShell(ByVal p As String) As String</code>, <code>Private Function ExecShellZipOnWindows(ByVal files As Collection, ByVal zipPath As String) As Boolean</code>, <code>Private Function WaitForZipStable(ByVal zipPath As String, ByVal timeoutMs As Long) As Boolean</code><br><strong>Behavior:</strong><br>- <code>IsMacOS</code> inspects <code>Application.OperatingSystem</code> for "Mac".<br>- <code>ExecShellZipOnMac</code> constructs <code>zip -j -q &lt;zip&gt; &lt;file1&gt; &lt;file2&gt; ...</code> with path quoting and runs via <code>MacScript(&quot;do shell script ...&quot;)</code>. Returns True on success.<br>- <code>QuotePathForShell</code> escapes inner quotes and wraps path in double quotes.<br>- <code>ExecShellZipOnWindows</code> uses <code>CreateObject(&quot;Shell.Application&quot;)</code> and <code>Namespace(zipPath)</code> to obtain zip folder and then <code>CopyHere</code> for each file, calling <code>WaitForZipStable</code> after each to detect size stabilization; finally checks <code>FileExistsAndNonEmpty(zipPath)</code>.<br>- <code>WaitForZipStable</code> polls file size every small loop with <code>DoEvents</code> until size hasn't increased for 3 checks or timeout reached.<br><strong>Complexity:</strong> OS command execution cost & I/O dominated.<br><strong>Side-effects:</strong> Spawns shell operations (potentially asynchronous). <code>MacScript</code> and Shell automation may require elevated privileges in some environments.<br><strong>Failure modes:</strong> <code>MacScript</code> unavailable or restricted, <code>zip</code> binary absent, Windows Shell namespace failing for network paths, stuck async operations causing timeouts. <code>QuotePathForShell</code> handles quotes but not other shell metacharacters—careful with malicious inputs; higher defense is <code>Security_AllowExportPath_Check</code> upstream.<br><strong>Recommended tests:</strong> Paths with embedded double quotes, extremely long paths (> MAX_PATH), network-mounted volumes, failure/timeouts of <code>zip</code> and Shell copy operations, verify stability detection heuristics for large zip operations. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Utility helpers: SafeFileName / FileExistsAndNonEmpty / SafeGetWorksheet / SleepMs / SafeApplicationRun</strong><br><strong>Purpose:</strong> Misc small utilities used widely: sanitize filenames, check file existence and size, defensively find worksheet by name, millisecond sleep helper, and a robust wrapper for <code>Application.Run</code> with up to 10 params returning Empty if not supported.<br><strong>Signatures:</strong> <code>Private Function SafeFileName(ByVal s As String) As String</code>, <code>Private Function FileExistsAndNonEmpty(ByVal path As String) As Boolean</code>, <code>Private Function SafeGetWorksheet(ByVal wb As Workbook, ByVal sheetName As String) As Worksheet</code>, <code>Private Sub SleepMs(ByVal ms As Long)</code>, <code>Private Function SafeApplicationRun(ByVal procName As String, ParamArray params() As Variant) As Variant</code><br><strong>Behavior:</strong><br>- <code>SafeFileName</code> replaces invalid filename chars with <code>_</code>.<br>- <code>FileExistsAndNonEmpty</code> uses FSO to check file and <code>Size &gt; 0</code>.<br>- <code>SafeGetWorksheet</code> iterates <code>wb.Worksheets</code> and performs case-insensitive comparison to find exact name or returns Nothing.<br>- <code>SleepMs</code> uses <code>Timer</code> + <code>DoEvents</code> loop for cross-platform safe millisecond pause.<br>- <code>SafeApplicationRun</code> tries to call <code>Application.Run</code> with correct number of params and returns Empty on failure; used pervasively to call optional cross-module hooks without raising errors.<br><strong>Complexity:</strong> O(n) where n = number of worksheets for <code>SafeGetWorksheet</code>, otherwise O(1).<br><strong>Side-effects:</strong> <code>SleepMs</code> yields to message loop; <code>SafeApplicationRun</code> masks host function errors (deliberate).<br><strong>Invariants:</strong> <code>SafeApplicationRun</code> never throws; returns Empty if host method absent. <code>SafeGetWorksheet</code> is case-insensitive. <code>SafeFileName</code> must be used before writing files to avoid invalid names.<br><strong>Recommended tests:</strong> Filenames with each invalid char, <code>SafeGetWorksheet</code> with differing case names, <code>SafeApplicationRun</code> calls with varying param counts and when target proc missing. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Config cache helpers: EnsureConfigCache / SafeConfigGet / InvalidateConfigCache</strong><br><strong>Purpose:</strong> Lazily initialize and cache configuration values fetched via <code>modConfig_Get</code> to reduce <code>Application.Run</code> overhead. <code>SafeConfigGet</code> caches results in <code>gConfigCache</code> and returns <code>defaultValue</code> when not found.<br><strong>Signatures:</strong> <code>Private Sub EnsureConfigCache()</code>, <code>Private Function SafeConfigGet(ByVal key As String, Optional ByVal defaultValue As Variant = Empty) As Variant</code>, <code>Private Sub InvalidateConfigCache()</code><br><strong>Behavior:</strong><br>- <code>EnsureConfigCache</code> makes <code>gConfigCache = CreateObject(&quot;Scripting.Dictionary&quot;)</code> once with <code>gConfigCacheInitialized</code> flag.<br>- <code>SafeConfigGet</code> checks dictionary first; if absent calls <code>SafeApplicationRun(&quot;modConfig_Get&quot;, key)</code> and caches result if returned; else returns <code>defaultValue</code>.<br>- <code>InvalidateConfigCache</code> clears and resets cache state.<br><strong>Complexity:</strong> Cache access O(1); initial fetch depends on host <code>modConfig_Get</code> call latency.<br><strong>Side-effects:</strong> Adds items to <code>gConfigCache</code>. Invalidate used to force fresh reads.<br><strong>Invariants:</strong> <code>gConfigCacheInitialized</code> flag correctly indicates state. Cache does not expire unless <code>InvalidateConfigCache</code> called — callers must call that on config changes.<br><strong>Recommended tests:</strong> Read/write config keys via <code>modConfig_Get</code> mocks, ensure cached values returned without subsequent <code>Application.Run</code> invocation, test invalidation. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Security helpers: Security_AllowExportPath_Check / Security_VerifyExportPathWritable</strong><br><strong>Purpose:</strong> Layered security allowlist checks for export destination paths. Prefer host <code>modSecurity</code> implementations and fallback to <code>IFRS.Export.AllowRoots</code> config or simple folder writability checks.<br><strong>Signatures:</strong> <code>Private Function Security_AllowExportPath_Check(ByVal fullPath As String) As Boolean</code>, <code>Private Function Security_VerifyExportPathWritable(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- <code>Security_AllowExportPath_Check</code> first attempts <code>SafeApplicationRun(&quot;modSecurity.Security_AllowExportToPath&quot;, fullPath)</code>. If absent fallback uses <code>SafeConfigGet(&quot;IFRS.Export.AllowRoots&quot;)</code> — if missing allow-all; otherwise check if <code>fullPath</code> starts with any configured root (case-insensitive).<br>- <code>Security_VerifyExportPathWritable</code> attempts host <code>modSecurity.Security_VerifyExportPathWritable</code> then fallback to <code>IsFolderWritable(folder)</code>.<br><strong>Complexity:</strong> O(#allowRoots) for config check.<br><strong>Side-effects:</strong> None. Used to short-circuit unsafe exports early.<br><strong>Invariants:</strong> If config <code>AllowRoots</code> not set, default behavior is permissive (allow). Deployers should set <code>AllowRoots</code> to tighten export destinations.<br><strong>Failure modes:</strong> Misconfigured <code>AllowRoots</code> may inadvertently block valid exports; relying on prefix match may incorrectly allow descendant paths if not normalized. Network paths vs local drive semantics may need normalization.<br><strong>Recommended tests:</strong> AllowRoots with trailing slash vs without, UNC paths, host <code>modSecurity</code> present/absent, and prefix edge cases (<code>C:\Data</code> vs <code>C:\Dat</code>). </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>PII & redaction: PII_Detect / RedactSecrets</strong><br><strong>Purpose:</strong> Best-effort PII detection and redaction helper functions. Prefer delegation to <code>modSecurity.PII_Detect</code> / <code>RedactSecrets</code> when available; employ simple heuristics otherwise (email-like tokens, keywords <code>password</code>/<code>secret</code>, long digit runs) and coarse redaction transformations.<br><strong>Signatures:</strong> <code>Private Function PII_Detect(ByVal s As String) As Boolean</code>, <code>Private Function RedactSecrets(ByVal s As String) As String</code><br><strong>Behavior:</strong><br>- <code>PII_Detect</code> calls host detection if available; else checks for <code>@</code>, <code>password</code>, <code>secret</code>, or 9+ consecutive digits. Returns boolean.<br>- <code>RedactSecrets</code> calls host redaction if available; else redacts email-like substrings to <code>[REDACTED_EMAIL]</code>, tokens with <code>password</code>/<code>secret</code> mapped to <code>[REDACTED_SECRET]</code>, and long digit runs replaced with <code>[REDACTED_NUM]</code> (coarse).<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> Only string transforms for audit use. Not reversible.<br><strong>Invariants:</strong> Redactions are coarse — possible false positives or missed PII. Use <code>modSecurity</code> in sensitive deployments.<br><strong>Failure modes:</strong> Heuristic may miss structured PII (IDs with separators), may over-redact legitimate strings. Unit tests must be extensive on sample log lines.<br><strong>Recommended tests:</strong> Strings with emails, tokens, long digits, non-Latin digits, edge-case punctuation; confirm <code>modSecurity</code> hook overrides. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>EnqueueExportJob / UpdateExportJobState (Private)</strong> — <em>lightweight job integration stubs</em><br><strong>Purpose:</strong> Integrate with host job scheduling systems (<code>modRibbonCallbacks.EnqueueJob</code>, <code>modJobs.Enqueue</code>) and provide best-effort fallback returning correlation id when job subsystem absent. <code>UpdateExportJobState</code> updates job state both in <code>modRibbonCallbacks</code> and <code>modJobs</code> or writes fallback audit messages.<br><strong>Signatures:</strong> <code>Private Function EnqueueExportJob(ByVal jobName As String, ByVal meta As String) As Variant</code>, <code>Private Sub UpdateExportJobState(ByVal jobId As String, ByVal state As String, Optional ByVal info As String = &quot;&quot;)</code><br><strong>Behavior:</strong><br>- <code>EnqueueExportJob</code> tries <code>modRibbonCallbacks.EnqueueJob</code> then <code>modJobs.Enqueue</code>. If no host provided job apis returns <code>GenerateCorrelationID()</code> and writes a fallback audit entry.<br>- <code>UpdateExportJobState</code> calls <code>modRibbonCallbacks.UpdateJobState</code> or <code>modJobs.Update</code> and falls back to <code>SafeLogAudit</code> when both absent.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Emits audit and interacts with host job UI if present. Returns <code>Variant</code> jobId that callers treat as string/empty. JobId may be correlation id fallback when job system absent.<br><strong>Invariants:</strong> Returns non-empty job id even in fallback path. Callers must treat jobId as opaque.<br><strong>Recommended tests:</strong> Host job system present vs absent; update state transitions ('queued','running','completed','failed','cancelled'). Ensure job cancel check used by CSV writer (<code>modJobs.IsCancelled</code>) integrates properly. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Export_MigrateLegacyConfig</strong> — <em>non-destructive config migration helper</em><br><strong>Purpose:</strong> Migrate legacy <code>Export.AllowRoots</code> config value to <code>IFRS.Export.AllowRoots</code> if new key missing, using <code>modConfig_Get</code>/<code>modConfig_Set</code> hooks via <code>SafeApplicationRun</code>.<br><strong>Signature:</strong> <code>Public Sub Export_MigrateLegacyConfig()</code><br><strong>Behavior:</strong> Reads legacy key using <code>SafeApplicationRun(&quot;modConfig_Get&quot;, &quot;Export.AllowRoots&quot;)</code>. If present and <code>IFRS.Export.AllowRoots</code> missing, attempt to set via <code>SafeApplicationRun(&quot;modConfig_Set&quot;, &quot;IFRS.Export.AllowRoots&quot;, v)</code>. Logs audit on migration or failure to set.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes config via host <code>modConfig_Set</code> if available and logs audit. Non-destructive for data.<br><strong>Invariants:</strong> No destructive changes; only performs migration when target absent.<br><strong>Recommended tests:</strong> Ensure migration occurs once, ensure no-op on repeated runs, test with absent <code>modConfig_Set</code>. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Export_PrepareForRelease</strong> — <em>preflight that runs self-tests across modules</em><br><strong>Purpose:</strong> High-level pre-release check orchestration running <code>UtilitiesSelfTest</code>, <code>Security_SelfTest</code>, and <code>ExportSelfTest</code> plus logging to aid release QA.<br><strong>Signature:</strong> <code>Public Function Export_PrepareForRelease() As Boolean</code><br><strong>Behavior:</strong> Calls other self-test hooks via <code>SafeApplicationRun</code> and <code>ExportSelfTest</code>. Aggregates boolean results and logs <code>Release</code> audit pass/fail. Returns True only if all subtests passed.<br><strong>Complexity:</strong> O(sum subtests).<br><strong>Side-effects:</strong> Calls tests that may create artifacts and logs. Should be used on CI or developer machines only.<br><strong>Failure modes:</strong> Downstream tests failing. ErrHandler logs exception to audit and returns False.<br><strong>Recommended tests:</strong> Run in CI with known-good baseline, ensure idempotence and clear error messaging in logs. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Additional maintainability & security notes (global)</strong><br>- <strong>Public surface stability:</strong> DO NOT change public signatures listed at top — many external callers (legacy macros, Ribbon callbacks) depend on them. Preserve <code>ExportToPDF</code> raising behavior and <code>ExportToPDFEx</code> boolean-returning variant.<br>- <strong>Config & flags:</strong> Rely on <code>SafeConfigGet</code> for <code>IFRS.Export.*</code> keys. Ensure <code>InvalidateConfigCache</code> called after config updates.<br>- <strong>Job integration:</strong> Job hooks are best-effort — treat returned <code>jobId</code> as opaque and always operate correctly when no job subsystem is available.<br>- <strong>PII & secrets:</strong> <code>ExportCustomXMLPart</code> is the highest-risk operation for secret leakage. Deployers must wire <code>modSecurity</code> policy hooks (<code>modSecurity_CheckCustomXmlExport</code>, <code>modSecurity.PII_Detect</code>, <code>modSecurity.RedactSecrets</code>) to avoid accidental disclosure. Default heuristics are intentionally conservative but coarse.<br>- <strong>Atomicity & network fileshares:</strong> Atomic <code>Name</code> calls may fail across volumes; all functions already fallback to <code>CopyFile</code>. Verification (size > 0) is used after moves. Consider checksum verification for higher assurance on networked filesystems.<br>- <strong>ADODB.Stream use:</strong> Preferred for UTF-8 streaming; ensure ADODB is available in target environment or fallback will write BOM+binary (less robust). Test with target Excel/Office versions and trust center settings.<br>- <strong>Windows Shell zip quirks:</strong> <code>Shell.Application.CopyHere</code> is asynchronous and subject to UAC/COM behavior. Consider replacing with native ZIP library (7zip, .NET via COM, or packaged DLL) if deterministic behavior is required.<br>- <strong>Logging & telemetry:</strong> Audit entries include <code>cid</code> correlation id for tracing. Avoid logging raw PII. Where <code>modSecurity</code> hooks exist prefer them for detection and redaction.<br>- <strong>Error codes:</strong> Functions use module-specific error codes in reserved range (2100-2399). Maintain this range for backwards compatibility with error handlers expecting module offsets.<br>- <strong>Testing:</strong> Extensive unit/integration tests recommended: (1) I/O under locked/network filesystems, (2) CSV RFC4180 edge cases, (3) PII detection & redaction matrix, (4) job cancellation path, (5) host hook present vs absent for each optional integration (modConfig, modSecurity, modJobs, modRibbonCallbacks, Atomic utilities).<br>- <strong>Performance:</strong> Large exports (many MBs or millions of rows) must be tested; <code>rowsPerFlush</code> tunable protects memory but increases I/O frequency. Consider <code>maxParallelFetches</code> analog only if exporting many worksheets concurrently.<br>- <strong>Backwards compatibility:</strong> Preserve <code>ExportToPDF</code> raise semantics and public function signatures. When changing behavior add a documented compatibility shim and increment module release notes.<br>- <strong>Developer note:</strong> This breakdown was constructed by verifying the module code paths and cross-referencing each helper call-site to ensure coverage of all functions and side-effects. Treat the module as I/O-heavy and privileged — require elevated review when integrating into environments with strict data governance. </td></tr></tbody></table></div><div class="row-count">Rows: 29</div></div><div class="table-caption" id="Table3" data-table="Docu_0160_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modIAS36)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modIAS36)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modIAS36)"> <strong>Overview:</strong> This table provides a world-class, per-function technical breakdown of the <code>modIAS36</code> VBA module you supplied. Each entry documents: purpose, signature (inputs/outputs), internal behavior, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended tests, and concise maintenance notes. Use as authoritative inline documentation for reviewers, auditors, and QA. The breakdown covers public and private procedures and functions present in the module (Rev5). </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>Module_Initialize()</strong> — <em>lazy module bootstrap and dependency probe</em><br><strong>Purpose:</strong> Ensure module-level cached configuration and external-dependency flags are initialized once per process lifetime. Called at entry points before performing config-sensitive work.<br><strong>Signature:</strong> <code>Private Sub Module_Initialize()</code> (no return)<br><strong>Behavior:</strong> Sets default daycount if empty, ensures cached rounding/daycount vars exist, and invokes <code>ProbeExternalDependencies</code> once. Uses error-suppression to be non-throwing.<br><strong>Complexity:</strong> O(1) (constant).<br><strong>Side-effects:</strong> Mutates module-level globals (<code>g_IAS36_Daycount</code>, <code>g_cached*</code>, <code>g_externalProbed</code>, <code>g_haveMod*</code>).<br><strong>Invariants:</strong> After call, <code>g_externalProbed</code> true and probe flags reflect best-effort host helpers presence. Idempotent-ish (safe to call repeatedly).<br><strong>Failure modes:</strong> Silent failure if CreateObject calls fail or host functions throw; module continues with defaults.<br><strong>Security/Privacy:</strong> None.<br><strong>Recommended tests:</strong> Call when host helpers present vs absent; assert flags set appropriately and no exceptions escape. Test repeated calls for idempotence.<br><strong>Notes for maintainers:</strong> Keep extremely defensive; do not change to throwing behavior—many callers expect safe init. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_InvalidateConfigCache()</strong> — <em>explicit cache invalidation</em><br><strong>Purpose:</strong> Public API to invalidate cached rounding/daycount values so host config changes take effect without reload.<br><strong>Signature:</strong> <code>Public Sub IAS36_InvalidateConfigCache()</code><br><strong>Behavior:</strong> Clears <code>g_cachedRoundingPrecision</code> and <code>g_cachedDaycount</code>, logs via <code>SafeLogEx</code> with generated correlation id. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates module globals and writes audit log.<br><strong>Invariants:</strong> After call, subsequent calls to <code>GetRoundingPrecision</code>/<code>GetDayCountConvention</code> will refresh from host or default.<br><strong>Failure modes:</strong> Logging may fail silently; cache remains cleared regardless.<br><strong>Recommended tests:</strong> Toggle cached values, call invalidate, and assert that subsequent reads reflect new host config if host helper present.<br><strong>Notes:</strong> Lightweight and safe to call from host-level config-change hooks. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>TryApplicationRun(procName, defaultValue, ParamArray args())</strong> — <em>robust Application.Run wrapper with ParamArray forwarding</em><br><strong>Purpose:</strong> Safely call potentially variable-signature host macros (<code>Application.Run</code>) without raising to UI; returns <code>defaultValue</code> on failure.<br><strong>Signature:</strong> <code>Private Function TryApplicationRun(ByVal procName As String, ByVal defaultValue As Variant, ParamArray args() As Variant) As Variant</code><br><strong>Behavior:</strong> Computes <code>argCount</code> defensively; dispatches to <code>Application.Run</code> for 0..9+ args with explicit cases; for >9 it forwards first 8 arguments as a pragmatic fallback (reduces signature mismatch risk). Errors routed to handler and returns <code>defaultValue</code> on failure.<br><strong>Complexity:</strong> O(1) dispatch; cost dominated by underlying <code>Application.Run</code> call.<br><strong>Side-effects:</strong> May execute arbitrary host macro side-effects; logs not emitted here (calling code should log).<br><strong>Invariants:</strong> Never raises to caller; always returns either the macro return value or <code>defaultValue</code>.<br><strong>Failure modes:</strong> If the host macro requires >8 args and different signatures, wrapper may call wrong signature; returns default. Also error swallowing means silent failures if caller expects exceptions.<br><strong>Security:</strong> Calling arbitrary host macros can execute arbitrary VBA code — caller must ensure <code>procName</code> is trusted. This wrapper contains no sanitization of <code>procName</code> (host-level risk).<br><strong>Recommended tests:</strong> Simulate Application.Run success (0..8 args), unknown macro, macro raising error — confirm return is <code>defaultValue</code> in failures. Test >8 args behavior.<br><strong>Notes:</strong> Keep dispatch table in sync if host is known to require >8 args; consider expanding to dynamic <code>CallByName</code> forwarding if necessary. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>GetRoundingPrecision()</strong> — <em>cached host-config accessor for numeric rounding</em><br><strong>Purpose:</strong> Return configured rounding precision (integer) with caching and robust host-probing fallback to <code>2</code>.<br><strong>Signature:</strong> <code>Private Function GetRoundingPrecision() As Long</code><br><strong>Behavior:</strong> Ensures module initialized; returns cached numeric value if present; attempts <code>TryApplicationRun(&quot;modConfig.GetSetting&quot;, Empty, &quot;RoundingPrecision&quot;)</code> and caches/returns numeric value if found; otherwise sets and returns default <code>2</code>. Errors are caught and fallback used.<br><strong>Complexity:</strong> O(1) per call (with first-call host probe).<br><strong>Side-effects:</strong> Mutates <code>g_cachedRoundingPrecision</code>.<br><strong>Invariants:</strong> Always returns a Long; never raises. Uses banker's rounding via <code>ApplySafeRound</code> and <code>Round2</code> downstream.<br><strong>Failure modes:</strong> Host config returns non-numeric -> default used; caching prevents rapid re-probing until invalidation.<br><strong>Recommended tests:</strong> Host returns numeric and non-numeric; invalidation via <code>IAS36_InvalidateConfigCache</code> resets behavior. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>GetDayCountConvention()</strong> — <em>cached access to daycount convention</em><br><strong>Purpose:</strong> Return day-count convention string used in year-fraction computations, defaulting to <code>ACT/365</code>.<br><strong>Signature:</strong> <code>Private Function GetDayCountConvention() As String</code><br><strong>Behavior:</strong> Module initialization, returns cached <code>g_cachedDaycount</code> if present; else tries <code>modConfig.GetSetting(&quot;IAS36_DefaultDaycount&quot;)</code> via <code>TryApplicationRun</code>, uppercases and trims result; falls back to <code>IAS36_DAYCOUNT_DEFAULT</code> constant. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May set <code>g_cachedDaycount</code>.<br><strong>Invariants:</strong> Returns a non-empty uppercase string (one of supported conventions or default).<br><strong>Failure modes:</strong> Unknown daycount strings returned by host -> module still returns them (no validation) — downstream functions handle unknown via default path. Consider stricter validation if required.<br><strong>Recommended tests:</strong> Host returns valid vs invalid strings; ensure consistent uppercase return. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>SafeLogEx(moduleName, proc, details, Optional correlationId)</strong> — <em>structured audit logger with host fallback</em><br><strong>Purpose:</strong> Central non-throwing audit/log entry routine. Attempts host <code>LogAudit</code> signatures then falls back to <code>Debug.Print</code> if host absent.<br><strong>Signature:</strong> <code>Private Sub SafeLogEx(ByVal moduleName As String, ByVal proc As String, ByVal details As String, Optional ByVal correlationId As String = &quot;&quot;)</code><br><strong>Behavior:</strong> If correlationId blank generate one. Calls <code>TryApplicationRun(&quot;LogAudit&quot;, Empty, module.proc, details, correlationId)</code>; if empty, try older signature without correlation; on final fallback write to <code>Debug.Print</code> with <code>RedactForLog(details)</code>. Swallows errors.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes to host log or debug output.<br><strong>Invariants:</strong> Non-throwing; always returns control to caller.<br><strong>Failure modes:</strong> Host may accept but not persist logs; <code>RedactForLog</code> may over-redact (see its logic).<br><strong>Security/Privacy:</strong> Sensitive strings redacted by <code>RedactForLog</code> if substring matches tokens (<code>password</code>, <code>token</code>, etc.) — heuristic, not exhaustive. Ensure PII isn't passed as plain details.<br><strong>Recommended tests:</strong> With and without host <code>LogAudit</code>, assert no exceptions and fallback to debug. Test redaction patterns. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>SafeHandleError(procName, errNumber, errDescription, Optional correlationId)</strong> — <em>central non-throwing error routing</em><br><strong>Purpose:</strong> Route errors to host error handling or fallback to <code>Debug.Print</code> without raising exceptions to UI.<br><strong>Signature:</strong> <code>Private Sub SafeHandleError(ByVal procName As String, ByVal errNumber As Long, ByVal errDescription As String, Optional ByVal correlationId As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Generates correlation id if missing; attempts <code>TryApplicationRun(&quot;HandleError&quot;, Empty, procName, errNumber, errDescription, correlationId)</code> then <code>modError.HandleError</code> variant; on empty fallback <code>Debug.Print</code>. Clears errors; non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> External calls to host error handler; log side effects.<br><strong>Invariants:</strong> Does not raise to caller. Caller must continue safe flow.<br><strong>Recommended tests:</strong> Simulate host handler present/absent. Ensure no exceptions propagate. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>HandleInternalError(errProc, errObj)</strong> — <em>legacy adapter converting ErrObject to structured call</em><br><strong>Purpose:</strong> Convert mixed error representations into canonical <code>(number, description)</code> and call <code>SafeHandleError</code>.<br><strong>Signature:</strong> <code>Private Sub HandleInternalError(ByVal procName As String, ByVal errObj As Variant)</code><br><strong>Behavior:</strong> Accepts <code>ErrObject</code>, object with Number/Description properties, numeric, or string; extracts numeric and description defensively; falls back to <code>Err</code> if missing; then calls <code>SafeHandleError</code> with generated CID.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls <code>SafeHandleError</code> so host logging may occur.<br><strong>Invariants:</strong> Always calls <code>SafeHandleError</code> and returns; non-throwing.<br><strong>Tests:</strong> Pass ErrObject, custom object, numeric, string, and no arg. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>HasProperty(o, propName)</strong> — <em>best-effort property existence probe</em><br><strong>Purpose:</strong> Determine whether an object exposes a given property without throwing.<br><strong>Signature:</strong> <code>Private Function HasProperty(ByVal o As Object, ByVal propName As String) As Boolean</code><br><strong>Behavior:</strong> Uses <code>CallByName</code> inside error handler; returns True if get succeeded, otherwise False. Clears Err. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None persistent.<br><strong>Failure modes:</strong> <code>CallByName</code> may execute property getter with side-effects — assume host objects well-behaved.<br><strong>Tests:</strong> Objects with and without properties; COM objects that throw on access. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>GenerateCorrelationID()</strong> — <em>stable GUID-based correlation id with fallback timestamp</em><br><strong>Purpose:</strong> Provide unique correlation id for logs/operations; prefers Scriptlet.TypeLib GUID then fallback to timestamp + random suffix.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Attempts <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code>, strips braces/dashes, prefixes <code>CID_</code>; on failure fallback to <code>CID_TS_yyyymmddhhNNss_random</code>. Non-throwing.<br><strong>Complexity:</strong> O(L) for string ops. <br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Returns non-empty string beginning with <code>CID_</code>.<br><strong>Recommended tests:</strong> Ensure uniqueness across multiple calls and graceful fallback in locked-down environments. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>NZDouble, NZDoubleOrZero, NzString, NzVariant, NzDateFromVariant, NZDoubleObjKey, NZStringObj</strong> — <em>null/variant helpers</em><br><strong>Purpose:</strong> Small defensive conversion utilities used widely by module to normalize Variant values into typed primitives safely.<br><strong>Signature:</strong> Various: <code>NZDouble(v, Optional def As Double) As Double</code>, <code>NZDoubleOrZero(v) As Double</code>, <code>NzString(v, Optional def As String) As String</code>, <code>NzVariant(v, Optional def As Variant) As Variant</code>, <code>NzDateFromVariant(v, Optional def As Variant) As Variant</code>, <code>NZDoubleObjKey(o,key,Optional def)</code>, <code>NZStringObj(o,key,Optional def)</code>.<br><strong>Behavior:</strong> Check for <code>IsNumeric</code>, <code>IsNull</code>, <code>IsEmpty</code>, <code>IsMissing</code>, <code>IsDate</code>; return default when appropriate. Use <code>On Error Resume Next</code> to avoid raising on odd COM objects. Deterministic conversions (no side-effects).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Always return a typed value (Double/String/Variant) suitable for arithmetic or string ops.<br><strong>Failure modes:</strong> Silent fallback on unexpected types; recommended to log upstream if caller needs to know. <br><strong>Tests:</strong> Null/Empty/strings representing numbers/dates/objects missing keys. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>ApplySafeRound(v, Optional precision)</strong> & <strong>Round2(v)</strong> — <em>configurable rounding primitives</em><br><strong>Purpose:</strong> Provide deterministic rounding using host-configured precision; <code>Round2</code> preserved historical name for compatibility and delegates to <code>ApplySafeRound</code>.<br><strong>Signature:</strong> <code>Private Function ApplySafeRound(ByVal v As Double, Optional ByVal precision As Long = -1) As Double</code> and <code>Private Function Round2(ByVal v As Double) As Double</code>.<br><strong>Behavior:</strong> If <code>precision &lt; 0</code> calls <code>GetRoundingPrecision</code>; then calls <code>VBA.Round(v, p)</code> (banker's rounding). <code>Round2</code> calls <code>ApplySafeRound</code>. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Deterministic rounding behavior controlled by cached config.<br><strong>Recommended tests:</strong> Configure host rounding different values and assert numeric output. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>Array/dimension helpers (LBoundArraySafe, UBoundArraySafe, SafeArrayIndex, ArrayDimensions, NormalizeRefsToArray)</strong> — <em>robust array/collection accessors</em><br><strong>Purpose:</strong> Defensive wrappers around common array/collection operations to avoid runtime errors for unexpected inputs or shapes.<br><strong>Signature:</strong> e.g., <code>LBoundArraySafe(arr, Optional dimNum)</code> -> Long; <code>SafeArrayIndex(arr, idx, Optional def)</code> -> Variant; <code>NormalizeRefsToArray(refs)</code> -> Variant array 1-based.<br><strong>Behavior:</strong> Check <code>IsArray</code>/<code>IsObject</code> and use error-handling to return safe defaults (<code>-1</code>, <code>Empty</code>, <code>def</code>). <code>NormalizeRefsToArray</code> converts Collections and dictionary-like objects (with <code>.count</code>) to 1-based arrays preserving order.<br><strong>Complexity:</strong> O(n) for <code>NormalizeRefsToArray</code> (copying elements), O(1) for bounds/index helpers.<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> <code>SafeArrayIndex</code> expects caller indexing as 1..n; returns <code>def</code> for out-of-range. <code>NormalizeRefsToArray</code> produces an array suitable for subsequent iteration.<br><strong>Tests:</strong> Arrays with non-standard LB/UB, collections, empty inputs, COM objects with <code>.count</code> throwing. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>GetRowCount(arr)</strong> — <em>unified row-count helper for multiple shapes</em><br><strong>Purpose:</strong> Determine row count (1-based) for arrays, collections, and dictionary-like objects; returns 0 for none/empty.<br><strong>Signature:</strong> <code>Public Function GetRowCount(ByVal arr As Variant) As Long</code><br><strong>Behavior:</strong> If array uses <code>LBound/UBound</code> (with error handling) compute rows; if object attempt <code>.count</code>; fallback 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Always returns Long >= 0.<br><strong>Tests:</strong> Arrays, collections, dictionaries, Nothing. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>SwapForecastRows(arr,i,j)</strong> — <em>internal swap for stable bubble-sort</em><br><strong>Purpose:</strong> Small helper used by <code>NormalizeForecastToArray</code> to swap rows in 2-col array.<br><strong>Signature:</strong> <code>Private Function SwapForecastRows(ByRef arr As Variant, ByVal i As Long, ByVal j As Long)</code> (returns Variant implicitly in VB; used for in-place mutation).<br><strong>Behavior:</strong> Swaps date & amount cells between rows <code>i</code> and <code>j</code> assuming 2-col layout. Not exported.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>arr</code> in place.<br><strong>Tests:</strong> Swap two rows and verify results. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>NormalizeForecastToArray(forecast)</strong> — <em>canonical forecast normalizer (2-col 1-based array)</em><br><strong>Purpose:</strong> Convert multiple accepted forecast shapes (2D arrays, collection/dict-of-rows, object rows) into a compact 1-based 2-column <code>Variant</code> array with only rows having Date or numeric Amount, and stable ordering by date with non-dates pushed to end (deterministic bubble-sort). This function is central to DCF computations.<br><strong>Signature:</strong> <code>Private Function NormalizeForecastToArray(ByVal forecast As Variant) As Variant</code><br><strong>Behavior:</strong> If input row count zero return Empty. For arrays: copy row(1..n,1..2) defensively into <code>temp</code>. For objects (collection/dictionary): iterate elements, extract 1/2 or "Date"/"Amount" keys defensively. Compact valid rows into <code>keep</code>, convert to <code>out</code> with size <code>k</code>. Bubble-sort by date ascending; non-dates after dates. Returns Empty on error. Extensive <code>On Error</code> guarding and uses <code>NZDouble</code> coercions.<br><strong>Complexity:</strong> O(n^2) worst-case due to bubble-sort; O(n) for copy/compact steps. For expected small forecast sizes (<500), acceptable. For larger series consider replacing bubble-sort with a stable sort to improve complexity to O(n log n).<br><strong>Side-effects:</strong> None global; returns normalized array.<br><strong>Invariants:</strong> Output is 1-based array <code>[1..k,1..2]</code> where column1 is Date or Empty, column2 is numeric (coerced). Non-date rows are placed after dated rows. Deterministic ordering for ties via stable bubble-sort pass. <br><strong>Failure modes:</strong> If input has malformed row structures, rows are skipped; if all rows invalid returns Empty. Errors are handled via <code>HandleInternalError</code> call. <br><strong>Security:</strong> None. <br><strong>Recommended tests:</strong> arrays with mixed date/non-date rows, collections of dictionaries with keys by name and numeric keys, dictionary-of-rows shapes, large n performance, tie-breaking determinism tests. <br><strong>Notes:</strong> Preserve behavior — changes are breaking (tokenizer-like contract); if optimizing, maintain identical output ordering semantics or add migration/tests. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>YearFractionEx(d0,d1,convention)</strong> — <em>year fraction per convention</em><br><strong>Purpose:</strong> Compute fraction of year between two dates given daycount convention (<code>ACT/365</code>, <code>ACT/360</code>, <code>30/360</code>), safe-guarded for invalid inputs.<br><strong>Signature:</strong> <code>Private Function YearFractionEx(ByVal d0 As Variant, ByVal d1 As Variant, ByVal convention As String) As Double</code><br><strong>Behavior:</strong> Validates dates; computes <code>days = dt1 - dt0</code>, clamps negative to zero. For <code>ACT/365</code> returns <code>days/365</code>; <code>ACT/360</code> returns <code>days/360</code>; <code>30/360</code> implements a standard 30/360 formula (y/m/d components) else default <code>ACT/365</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Returns 0 for invalid/non-date inputs or negative durations.<br><strong>Failure modes:</strong> Non-date inputs -> 0; convention unrecognized -> default ACT/365. <br><strong>Tests:</strong> Known date pairs for each convention; negative intervals; boundary dates (same day). </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>NPVFromDcfEx(dcf, discountRate, asOfDate, daycount)</strong> — <em>core DCF present value calculator</em><br><strong>Purpose:</strong> Compute PV of a series of cashflows normalized via <code>NormalizeForecastToArray</code>, using <code>YearFractionEx</code> for discount exponent and handling zero/negative discount rates properly (zero -> sum of cashflows; negative discount -> growth).<br><strong>Signature:</strong> <code>Private Function NPVFromDcfEx(ByVal dcf As Variant, ByVal discountRate As Double, ByVal asOfDate As Variant, ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> Normalizes input to array; loops rows computing <code>yf = YearFractionEx(asOfDate, dt, daycount)</code>; if discountRate <= 0 sums <code>cf</code>; else <code>cf / ((1 + discountRate) ^ yf)</code>. Returns 0 on errors. Wraps errors to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(n) in number of cashflows.<br><strong>Side-effects:</strong> None persistent.<br><strong>Invariants:</strong> Deterministic; if discountRate=0 result equals sum of amounts; negative discountRates allowed (interpreted as growth factor).<br><strong>Failure modes:</strong> Large exponents or invalid dates produce numeric anomalies; check for overflow on extreme inputs. <br><strong>Recommended tests:</strong> Zero/positive/negative discount rates, mixed valid/invalid rows, large series performance. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_ComputePVOfPayments(payments,discountRate,Optional asOfDate,Optional daycount)</strong> — <em>public PV helper</em><br><strong>Purpose:</strong> Public wrapper to compute PV of <code>payments</code> with robust defaulting (asOfDate defaults to Date, daycount default from config) and defensive error handling.<br><strong>Signature:</strong> <code>Public Function IAS36_ComputePVOfPayments(ByVal payments As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> Ensures defaults, normalizes payments via <code>NormalizePaymentsForRead</code>, calls <code>NPVFromDcfEx</code>, returns 0 on error. Non-throwing.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Public facade must preserve behavior for existing callers. <br><strong>Tests:</strong> Mirror <code>NPVFromDcfEx</code> tests plus single numeric input handling. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_CalculateRecoverableByVIU(cashflows,discountRate,Optional asOfDate,Optional daycount)</strong> — <em>VIU computation wrapper</em><br><strong>Purpose:</strong> Public wrapper returning Value-in-use PV using DCF primitive.<br><strong>Signature:</strong> <code>Public Function IAS36_CalculateRecoverableByVIU(ByVal cashflows As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> Defaulting as before; calls <code>NPVFromDcfEx</code> and returns 0 on error. Non-throwing.<br><strong>Complexity:</strong> O(n).<br><strong>Tests:</strong> Same as <code>IAS36_ComputePVOfPayments</code>. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_CalculateRecoverableByFVLCOD(fairValue,costsToSell)</strong> — <em>FVLCOD simple arithmetic</em><br><strong>Purpose:</strong> Compute <code>fairValue - costsToSell</code> safely with numeric coercion.<br><strong>Signature:</strong> <code>Public Function IAS36_CalculateRecoverableByFVLCOD(ByVal fairValue As Double, ByVal costsToSell As Double) As Double</code><br><strong>Behavior:</strong> Returns <code>NZDoubleOrZero(fairValue)-NZDoubleOrZero(costsToSell)</code> and handles errors safely.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> Numeric edge cases (NaN-like strings) coercion. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RecoverableAmount(carryingAmount, Optional cashflows, Optional discountRate, Optional fairValue, Optional costsToSell, Optional asOfDate, Optional daycount)</strong> — <em>public recoverable amount and impairment summary</em><br><strong>Purpose:</strong> Compute recoverable amount selecting better of VIU and FVLCOD, compute impairment loss relative to carrying amount, and return structured Scripting.Dictionary with keys (<code>RecoverableAmount</code>, <code>VIU</code>, <code>FVLCOD</code>, <code>MethodUsed</code>, <code>CarryingAmount</code>, <code>ImpairmentLoss</code>). Logs the operation via <code>SafeLogEx</code> and returns <code>Nothing</code> on catastrophic error.<br><strong>Signature:</strong> <code>Public Function IAS36_RecoverableAmount(...) As Object</code> returns <code>Scripting.Dictionary</code> on success.<br><strong>Behavior:</strong> Defaults <code>asOfDate/daycount</code>; computes VIU if cashflows present; computes <code>fvlcod</code>; chooses method with higher value; computes impairment if recoverable < carrying amount and stores rounded impairment via <code>Round2</code>. Adds audit entry and returns dictionary. Errors routed to <code>HandleInternalError</code> and returns Nothing.<br><strong>Complexity:</strong> O(n) if computing VIU (n = number of cashflow rows).<br><strong>Side-effects:</strong> Logging and dictionary creation.<br><strong>Invariants:</strong> Output keys exist as specified; <code>ImpairmentLoss</code> is rounded. <br><strong>Failure modes:</strong> If cashflows invalid returns 0 VIU; method chosen accordingly. <br><strong>Tests:</strong> Scenarios where VIU > FVLCOD and vice versa; carrying less/greater than recoverable; validate rounding. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_GroupAssetsIntoCGUs(assets, Optional groupingKey = "CGU")</strong> — <em>group assets by CGU key into Dictionary of Collections</em><br><strong>Purpose:</strong> Group assets into buckets keyed by <code>groupingKey</code> property (default <code>&quot;CGU&quot;</code>) returning <code>Scripting.Dictionary</code> where each value is <code>Collection</code> of items. Preserves deterministic ordering based on input iteration sequence.<br><strong>Signature:</strong> <code>Public Function IAS36_GroupAssetsIntoCGUs(ByVal assets As Variant, Optional ByVal groupingKey As String = &quot;CGU&quot;) As Object</code> returns <code>Scripting.Dictionary</code>.<br><strong>Behavior:</strong> Handles array or object shapes; if item lacks grouping key uses <code>&quot;CGU_1&quot;</code> default; creates Collection per group and adds items. Non-throwing; returns empty dict for empty input.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None beyond creating dictionary/collections.<br><strong>Invariants:</strong> Keys are strings; values are <code>Collection</code> objects; insertion order follows input order. <br><strong>Failure modes:</strong> Items not objects are added to default group; errors logged. <br><strong>Tests:</strong> Arrays and dictionaries of assets; items with/without groupingKey; large inputs. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_GenerateDCF(forecast, discountRate, Optional asOfDate, Optional daycount)</strong> — <em>return full DCF table array with header row</em><br><strong>Purpose:</strong> Produce a 2D array with headings <code>Date</code>, <code>Cashflow</code>, <code>DiscountFactor</code>, <code>PV</code> and per-row computed values plus running PV sum in local variable (not returned as separate scalar). Useful for sheet population or inspection by host.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateDCF(ByVal forecast As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Variant</code> (returns 2D Variant array or Empty)<br><strong>Behavior:</strong> Normalizes forecast into <code>ff</code>; if empty returns Empty. Creates <code>out(1..n+1,1..4)</code> with headers at row1 then rows built by computing <code>df</code> and <code>pv</code>. If discountRate <= 0 sets <code>df=1</code>. Returns <code>out</code> or Empty. Non-throwing.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Correct header, correct numeric values for sample series, discountRate zero path. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RunImpairmentTest(cgu, Optional discountRate, Optional fairValue, Optional costsToSell, Optional asOfDate, Optional daycount)</strong> — <em>per-CGU impairment test orchestrator</em><br><strong>Purpose:</strong> Central per-CGU workflow: input validation, compute total carrying, compute VIU and FVLCOD, choose recoverable, compute impairment, allocate impairment across assets if >0 and return structured dictionary with results, allocations, and correlation id. This function is a primary public entry used by batch processing and UI hooks.<br><strong>Signature:</strong> <code>Public Function IAS36_RunImpairmentTest(ByVal cgu As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValue As Double = 0#, Optional ByVal costsToSell As Double = 0#, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Object</code> (returns <code>Scripting.Dictionary</code> or Nothing)<br><strong>Behavior:</strong> Validates input via <code>IAS36_ValidateInputPackage</code> and returns structured <code>Issues</code> when validation fails. Defaults <code>asOfDate</code>/<code>daycount</code>. Extracts <code>Assets</code> and <code>Forecast</code> safely. Computes <code>totalCarrying</code> summing <code>CarryingAmount</code> for each asset via <code>GetDictValueIndexed</code>. Computes <code>viu</code> via <code>NPVFromDcfEx</code> if forecast present. Computes <code>fvlcod</code>. Determines <code>recoverable</code> and <code>methodUsed</code>. Computes <code>impairment = ApplySafeRound(totalCarrying - recoverable)</code> if recoverable < totalCarrying else 0. Adds <code>CorrelationID</code>. If impairment > 0, calls <code>AllocateImpairment</code> and <code>VerifyAllocationInvariant</code>. Logs via <code>SafeLogEx</code> and returns dictionary containing core fields and allocation object. Non-throwing with error handler returning Nothing on catastrophic failure.<br><strong>Complexity:</strong> O(n) dominated by summing assets and DCF computation. Allocation is O(m) where m=#assets.<br><strong>Side-effects:</strong> Creates dictionary, audit log, calls allocation & verification which log invariants.<br><strong>Invariants:</strong> Returned dictionary includes keys specified (<code>CGUID</code>, <code>TotalCarrying</code>, <code>RecoverableAmount</code>, <code>MethodUsed</code>, <code>Impairment</code>, <code>VIU</code>, <code>FVLCOD</code>, <code>Allocation</code>, etc.). <code>Impairment</code> is rounded. If <code>Issues</code> present function returns early with Status <code>ValidationFailed</code> and <code>CorrelationID</code> logged.<br><strong>Failure modes:</strong> Invalid input shapes -> Issues returned; unexpected error -> returns Nothing and logs via <code>HandleInternalError</code>.<br><strong>Security/Privacy:</strong> Logging may include CGUID/summaries; use <code>RedactForLog</code> if sensitive info present in details.<br><strong>Recommended tests:</strong> Valid CGU with impairment and without; CGU missing Forecast/Assets; large asset lists; verify Allocation sums and invariant logging. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RunBatchImpairmentTests(cguList, Optional discountRate, Optional fairValueMap, Optional daycount)</strong> — <em>batch orchestrator with per-CGU correlation and aggregation</em><br><strong>Purpose:</strong> Iterate over a list/dictionary of CGUs and call <code>IAS36_RunImpairmentTest</code> per item, aggregate results into a <code>Scripting.Dictionary</code> keyed by CGUID, attach <code>BatchCorrelationID</code>, robustly handle per-CGU exceptions and record issues per CGU. Logs batch start/finish.<br><strong>Signature:</strong> <code>Public Function IAS36_RunBatchImpairmentTests(ByVal cguList As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValueMap As Variant, Optional ByVal daycount As String) As Object</code> returns <code>Scripting.Dictionary</code> mapping <code>CGUID-&gt;result</code> objects<br><strong>Behavior:</strong> Validates empty inputs; generates <code>batchCorrelation</code> via <code>GenerateCorrelationID</code>; loops array or object cguList; for each extracts CGUID or falls back to <code>CGU_i</code>; extracts fairValue/costsToSell from <code>fairValueMap</code> if present; calls <code>IAS36_RunImpairmentTest</code> inside per-CGU error handler; on success attaches BatchCorrelationID to returned dictionary; on failure creates issue dictionary with error details. At end logs finish and returns aggregated results. Non-throwing except internal <code>Err</code> escapes handled.<br><strong>Complexity:</strong> O(k * costPerCGU) where k=#CGUs. <br><strong>Side-effects:</strong> Logging, creates aggregated results. <br><strong>Invariants:</strong> For each CGU an entry exists in returned dictionary. <br><strong>Failure modes:</strong> If a host-level exception occurs inside batch (unlikely due to per-CGU granularity) errors are recorded per item. <br><strong>Tests:</strong> Batch with arrays vs dictionaries, missing fairValueMap entries, simulated per-CGU exceptions. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_GenerateDisclosureSummary(testResult)</strong> — <em>summary builder for disclosure consumption</em><br><strong>Purpose:</strong> Convert a single impairment test result dictionary into compact disclosure-ready dictionary containing <code>CGUID</code>, <code>TotalCarrying</code>, <code>Impairment</code>, <code>ImpairmentPercent</code>, <code>KeyAssumptions</code>, and <code>Sensitivities</code> placeholder.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateDisclosureSummary(ByVal testResult As Object) As Object</code> returns <code>Scripting.Dictionary</code><br><strong>Behavior:</strong> Defensive: returns <code>{&quot;Message&quot;:&quot;No test result supplied&quot;}</code> if <code>testResult</code> is Nothing. Extracts keys via <code>NZStringObj</code>/<code>NZDoubleObjKey</code>; computes <code>ImpairmentPercent</code> safely; builds <code>KeyAssumptions</code> and <code>Sensitivities</code> dictionary and returns. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> Valid input, null input; ensure percent formatting and zero-division handled. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_ValidateInputPackage(pkg)</strong> — <em>input package validator producing structured issues</em><br><strong>Purpose:</strong> Validate required structure for CGU package: <code>CGUID</code>, <code>Assets</code> present and asset-level validations (AssetID present, CarryingAmount numeric & non-negative), and <code>Forecast</code> normalization test. Returns <code>Scripting.Dictionary</code> of issues (empty dict if no issues) — caller treats presence of keys as failure indicator.<br><strong>Signature:</strong> <code>Public Function IAS36_ValidateInputPackage(ByVal pkg As Object) As Object</code> returns <code>Scripting.Dictionary</code> or Nothing on error<br><strong>Behavior:</strong> Uses defensive existence checks; for assets iterates rows and reports <code>Asset_i_ID</code>/<code>Asset_i_Carrying</code>/<code>NegativeCarrying</code>; for Forecast attempts <code>NormalizeForecastToArray</code> and adds <code>ForecastInvalid</code> if normalization yields empty. Non-throwing; returns issues object even when empty.<br><strong>Complexity:</strong> O(n) in #assets and O(m) for forecast normalization. <br><strong>Side-effects:</strong> None persistent.<br><strong>Recommended tests:</strong> Minimal good package (no issues), missing keys, negative carrying, forecast invalid shapes. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>GetDictValue(dictLike, key)</strong> & <strong>GetDictValueIndexed(dictArray, idx, key)</strong> — <em>defensive dictionary/array-of-dictionary accessors</em><br><strong>Purpose:</strong> Safe retrieval of keyed values from dictionary-like objects and array-of-objects shapes without raising.<br><strong>Signature:</strong> <code>Private Function GetDictValue(ByVal dictLike As Variant, ByVal key As String) As Variant</code> and <code>Private Function GetDictValueIndexed(ByVal dictArray As Variant, ByVal idx As Long, ByVal key As String) As Variant</code><br><strong>Behavior:</strong> Use <code>IsObject</code> and <code>.Exists</code> to retrieve value or <code>Empty</code> / default; for arrays attempt <code>LBound</code> offset indexing or object <code>.Item</code> for dictionaries; error-handling to return default. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Mixed shapes: array of dictionaries, object dicts, missing keys. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>AllocateImpairment(assets, impairment, mode, weights)</strong> — <em>deterministic allocation engine</em><br><strong>Purpose:</strong> Core deterministic allocation algorithm that computes per-asset impairment amounts given a list of asset records and total impairment amount. Supports <code>EQUAL</code>, <code>WEIGHTED</code>, <code>PRORATA</code> modes. Ensures rounding and residual correction to meet sum invariant and deterministic tie-breaks when selecting recipient of rounding residual.<br><strong>Signature:</strong> <code>Private Function AllocateImpairment(ByVal assets As Variant, ByVal impairment As Double, ByVal mode As String, ByVal weights As Variant) As Object</code> returns <code>Scripting.Dictionary</code> mapping assetID->allocated amount<br><strong>Behavior (detailed):</strong><br>- Build arrays <code>carries()</code> and <code>ids()</code> of carrying amounts and asset IDs (defaults to <code>Asset_i</code> if missing).<br>- Compute <code>rawAlloc</code> by mode: <code>EQUAL</code> => equal share, <code>WEIGHTED</code> => use <code>weights</code> if provided else fallback to <code>carries</code> prorata, <code>PRORATA</code> => prorata by carrying amounts.<br>- Round each allocation via <code>Round2</code> into <code>allocations</code> dictionary; compute <code>sumRounded</code> and <code>residual = Round2(impairment - sumRounded)</code>.<br>- If residual magnitude >= 0.005, find <code>maxIdx</code> by comparing comparator (<code>carries</code> for PRORATA else <code>rawAlloc</code>) with deterministic tie-breaker by alphabetical <code>AssetID</code> (vbTextCompare) and adjust that asset by <code>residual</code> (rounded).<br>- Verify sum equals impairment; if mismatch still exists, log <code>AllocationInvariant</code> and apply smallest-key adjustment to correct final tiny diff.<br>- Returns allocations dictionary (always present even if zero allocations). Non-throwing; logs issues.<br><strong>Complexity:</strong> O(m) in number of assets; sorting not used — linear scans only.<br><strong>Side-effects:</strong> Calls <code>SafeLogEx</code> on invariant failure.<br><strong>Invariants:</strong> Sum of allocations equals impairment after final correction (within rounding). Deterministic tie-breaking ensures reproducible choice when multiple assets share maximum comparator value.<br><strong>Failure modes:</strong> If <code>ids</code> duplicate or missing unique IDs, dictionary keys may collide; current implementation uses provided <code>AssetID</code> string directly — callers should ensure uniqueness. Rounding/residual logic assumes small residual magnitudes; in pathological inputs residual > reasonable round precision might have unexpected correction distribution.<br><strong>Security:</strong> No external calls; safe.<br><strong>Recommended tests:</strong> Equal/Weighted/Prorata modes, zero total carrying, weights provided as array vs dictionary, tie-case where two assets equal (validate alphabetical winner), sum invariant under many random inputs, negative impairment edge cases. <br><strong>Notes:</strong> Keep algorithm stable — allocations are financial-sensitive. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_AllocateImpairment(assets,impairment,Optional mode="PRORATA", Optional weights)</strong> — <em>public allocation wrapper</em><br><strong>Purpose:</strong> Public safe wrapper that rounds input impairment, calls internal <code>AllocateImpairment</code>, verifies invariant via <code>VerifyAllocationInvariant</code> with generated correlation id, and returns allocations dictionary.<br><strong>Signature:</strong> <code>Public Function IAS36_AllocateImpairment(...) As Object</code><br><strong>Behavior:</strong> Coerces impairment via <code>Round2</code>, delegates to <code>AllocateImpairment</code>, calls <code>VerifyAllocationInvariant</code>, returns allocations or Nothing on error.<br><strong>Complexity:</strong> O(m).<br><strong>Tests:</strong> As above, include public interface behavior and invariant verification. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>VerifyAllocationInvariant(allocations, expectedTotal, cguid, correlationId)</strong> — <em>audit invariant checker for allocations</em><br><strong>Purpose:</strong> Post-allocation check that sums equal expected total and log <code>OK</code> or an invariant failure for audit and traceability.<br><strong>Signature:</strong> <code>Private Sub VerifyAllocationInvariant(ByVal allocations As Object, ByVal expectedTotal As Double, ByVal cguid As String, ByVal correlationId As String)</code><br><strong>Behavior:</strong> Sums allocation values and compares rounded totals; logs either <code>VerifyAllocationInvariant</code> error or <code>VerifyAllocationInvariant.OK</code> with correlation; non-throwing.<br><strong>Complexity:</strong> O(m).<br><strong>Side-effects:</strong> Audit logging.<br><strong>Tests:</strong> Create allocation dictionaries with off-by-rounding residual and verify log path. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>BuildMaturityAnalysis(forecast, Optional asOfDate, Optional daycount)</strong> — <em>maturity snapshot with cumulative amounts</em><br><strong>Purpose:</strong> Produce 2D array presenting <code>Date, Amount, YearFraction, CumulativeAmount</code> per forecast row for reporting and disclosure.<br><strong>Signature:</strong> <code>Public Function BuildMaturityAnalysis(ByVal forecast As Variant, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Variant</code><br><strong>Behavior:</strong> Normalize forecast via <code>NormalizeForecastToArray</code>, iterate computing <code>yf</code> via <code>YearFractionEx</code>, accumulate cumulative amount. Returns header + rows or Empty on error. Non-throwing.<br><strong>Complexity:</strong> O(n).<br><strong>Tests:</strong> Use sample series; ensure cumulative last equals total sum. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>DictionaryToJson(dict)</strong>, <strong>CollectionToJson(coll)</strong>, <strong>ArrayToJson(arr)</strong>, <strong>EscapeJson(s)</strong> — <em>small deterministic JSON serializer</em><br><strong>Purpose:</strong> Lightweight deterministic serializer for limited host objects (Scripting.Dictionary/Collection/arrays/dates/numbers/strings). Intentionally not full-featured; used for snapshots (sign-off) and debugging/tamper-evidence. Avoids reliance on external JSON libs to maintain portability across hosts.<br><strong>Signature:</strong> <code>Private Function DictionaryToJson(ByVal dict As Object) As String</code> (and siblings)<br><strong>Behavior:</strong> Iteratively build JSON text via string concatenation: dictionaries map keys to JSON values, nested dictionaries and collections serialized recursively; arrays serialized by index; dates formatted <code>yyyy-mm-dd</code>. <code>EscapeJson</code> replaces <code>\</code> and <code>&quot;</code> and newline variants. All functions guarded by <code>On Error</code> and return <code>{}</code>/<code>[]</code> on failure.<br><strong>Complexity:</strong> O(size of object) linear in elements and nested structure. <br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Deterministic ordering: For <code>Scripting.Dictionary</code> the iteration order is whatever the dictionary exposes (VBA dictionaries preserve insertion order), so consumers should not rely on stable key ordering across rebuilds unless insertion order preserved. <br><strong>Failure modes & Security:</strong> Does not handle circular references; may throw if objects are complex COM types; returns fallback <code>{}</code> on error. EscapeJson is minimal — does not escape control characters beyond newline and quotes. Not designed for untrusted data embedding into HTML contexts — only for file-safe JSON snapshots. <br><strong>Recommended tests:</strong> Nested dictionaries, collections, arrays, strings containing newlines & quotes, date serialization checks. Consider replacing with robust JSON library if available. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>ComputeDeterministicHash(s)</strong> — <em>non-cryptographic deterministic 8-hex hash</em><br><strong>Purpose:</strong> Produce deterministic, human-sized hex summary used for tamper-evidence and snapshot verification. Not cryptographic; intended for lightweight integrity checks across runs.\<br><strong>Signature:</strong> <code>Private Function ComputeDeterministicHash(ByVal s As String) As String</code> returns 8-hex string<br><strong>Behavior:</strong> If empty returns <code>&quot;00000000&quot;</code>. Implements simple FNV-like rolling with <code>AscW</code> and multiply by <code>16777619</code> mod <code>2^32</code>. Returns right-justified 8-hex string. Errors fallback <code>&quot;00000000&quot;</code>.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> None.<br><strong>Security notes:</strong> Non-cryptographic — do not use to detect adversarial tampering; suitable only for casual tamper evidence. Document limitation clearly. <br><strong>Tests:</strong> Known strings should produce stable hash; verify identical across platforms with <code>AscW</code> semantics. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RunSelfTests()</strong> — <em>10 deterministic checks harness and sheet persistence</em><br><strong>Purpose:</strong> Execute a set of 10 deterministic sanity/self-tests and persist results to a hidden worksheet <code>_IFRS_TestResults</code> (and JSON snapshot) for sign-off and automated QA. Incorporated in Rev5 with additional row-hash and persistence robustness.<br><strong>Signature:</strong> <code>Public Sub IAS36_RunSelfTests()</code> (no return; writes to sheet and calls <code>PersistSelfTestResults</code>).<br><strong>Behavior:</strong> Builds <code>results(1..10,1..4)</code> testing <code>Round2</code>, <code>YearFractionEx</code>, <code>NormalizeForecastToArray</code> ordering, <code>NPVFromDcfEx</code>, <code>AllocateImpairment</code> sum invariant, <code>GenerateCorrelationID</code>, <code>SafeLogEx</code>, <code>NormalizeRefsToArray</code>, <code>BuildMaturityAnalysis</code>, <code>IAS36_RecoverableAmount</code>. Calls <code>PersistSelfTestResults</code> at end. Non-throwing with outer error handler logging via <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(k) with small k (10).<br><strong>Side-effects:</strong> Writes <code>_IFRS_TestResults</code> sheet and snapshot JSON via <code>TryAtomicWriteFile</code>/<code>TryAtomicSaveWorkbookAs</code>. Uses <code>SafeLogEx</code>/<code>Debug.Print</code> for output. <br><strong>Invariants:</strong> Sheet is created/cleared and contains deterministic row hashes for each test. <br><strong>Failure modes:</strong> File system permissions can prevent snapshot write; sheet creation may fail in restricted hosts; harness will log but should not throw. <br><strong>Recommended tests:</strong> Run in typical host, restricted host (no file path), repeated runs to check idempotence and no resource leakage. Ensure row-hashes match expectation. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>PersistSelfTestResults(results)</strong> — <em>batch write to sheet + JSON snapshot with deterministic row hash</em><br><strong>Purpose:</strong> Efficiently write self-test results to <code>_IFRS_TestResults</code> in a single batch write array and produce a JSON snapshot file with timestamp & module version for tamper evidence. Uses host helper <code>modUtilities.SafeCreateSheet</code> if available, else fallback to creating a very hidden worksheet and writing values. Uses <code>TryAtomicWriteFile</code> to write snapshot.<br><strong>Signature:</strong> <code>Private Sub PersistSelfTestResults(ByVal results As Variant)</code><br><strong>Behavior:</strong> Build <code>outArr</code> header + rows (A:E) where column E contains <code>ComputeDeterministicHash(rowStr)</code>; write via single <code>Range.Value</code> write to minimize per-cell I/O; logs via <code>SafeLogEx</code>; if workbook path available writes JSON snapshot next to workbook via <code>TryAtomicWriteFile</code>. Swallows errors and prints debug if persist fails.<br><strong>Complexity:</strong> O(rCount) to build array and write, single range assignment preferred for large rCount. <br><strong>Side-effects:</strong> Creates/updates workbook sheet and file snapshot. <br><strong>Failure modes:</strong> File I/O errors, workbook locked read-only, path missing -> snapshot not written. <br><strong>Security/Privacy:</strong> Snapshot content is minimal (timestamp/version/count) not full results; row hash present to detect tampering but not cryptographically secure. <br><strong>Tests:</strong> Run in writeable and non-writeable folders; check sheet visibility and content; verify snapshot created and deleted when expected. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>GetForecastDateAt(forecast, idx)</strong> & <strong>GetForecastAmountAt(forecast, idx)</strong> — <em>safe per-row accessors</em><br><strong>Purpose:</strong> Return date or amount at a given 1-based index from array or object-shaped forecasts without raising.<br><strong>Signature:</strong> <code>Private Function GetForecastDateAt(ByVal forecast As Variant, ByVal idx As Long) As Variant</code> and <code>Private Function GetForecastAmountAt(ByVal forecast As Variant, ByVal idx As Long) As Variant</code><br><strong>Behavior:</strong> For arrays compute base LBound offset; for objects attempt <code>forecast(idx)(1)</code> or <code>(2)</code> while clearing errors; fallback Empty or 0. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Arrays and object shapes and out-of-range indexes. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>NormalizePaymentsForRead(payments, Optional asOfDate)</strong> — <em>flexible payments normalizer with single-numeric shorthand</em><br><strong>Purpose:</strong> Normalize input <code>payments</code> that can be: single numeric -> treat as single payment at <code>asOfDate</code>; 2-col arrays; collection/dictionaries of rows; single dictionary with <code>Date/Amount</code> keys -> return 1x2 array; otherwise return Empty.<br><strong>Signature:</strong> <code>Private Function NormalizePaymentsForRead(ByVal payments As Variant, Optional ByVal asOfDate As Variant) As Variant</code><br><strong>Behavior:</strong> Checks numeric scalar; else uses <code>GetRowCount</code> and <code>NormalizeForecastToArray</code>; else checks object for keys <code>Date</code>/<code>Amount</code> or numeric keys. Returns normalized 1-based 2-col array or Empty. Non-throwing.<br><strong>Complexity:</strong> O(n) for array case. <br><strong>Tests:</strong> Scalar numeric, single dict, collections, arrays. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_ExportMetadataSnapshot(pkg)</strong> & <strong>IAS36_RestoreStatementSnapshot(jsonSnapshot)</strong> — <em>export/restore light-weight snapshot helpers</em><br><strong>Purpose:</strong> Export deterministic JSON snapshot via <code>DictionaryToJson</code>, and restore a minimal wrapper returning snapshot plus <code>ComputeDeterministicHash</code> — used for metadata exchange and light-weight persistence.<br><strong>Signature:</strong> <code>Public Function IAS36_ExportMetadataSnapshot(ByVal pkg As Object) As String</code> and <code>Public Function IAS36_RestoreStatementSnapshot(ByVal jsonSnapshot As String) As Object</code><br><strong>Behavior:</strong> <code>Export</code> returns <code>{}</code> on nil or on error; <code>Restore</code> returns dictionary <code>{ &quot;Snapshot&quot;:json, &quot;Hash&quot;:ComputeDeterministicHash(json) }</code>. Both non-throwing.<br><strong>Complexity:</strong> O(size of pkg).<br><strong>Security:</strong> Snapshot may contain sensitive info — callers should avoid including PII or secrets. <br><strong>Tests:</strong> Roundtrip: export -> restore yields same hash as computed originally. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RegisterLegacyAlias(legacyName, newName)</strong> — <em>no-op compatibility hook with audit</em><br><strong>Purpose:</strong> Preserve legacy call-sites; logs alias registration event; no functional aliasing performed.<br><strong>Signature:</strong> <code>Public Sub IAS36_RegisterLegacyAlias(ByVal legacyName As String, ByVal newName As String)</code><br><strong>Behavior:</strong> Calls <code>SafeLogEx</code> and returns. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> If true aliasing required, evolve to maintain map; for now safe compatibility shim. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>HasKeyInDict(dict,key)</strong> — <em>simple dict key existence helper</em><br><strong>Purpose:</strong> Safe wrapper returning boolean whether <code>dict.Exists(key)</code> without throwing.<br><strong>Signature:</strong> <code>Private Function HasKeyInDict(ByVal dict As Object, ByVal key As Variant) As Boolean</code><br><strong>Behavior:</strong> Returns False when dict is Nothing or <code>.Exists</code> raises. Non-throwing.<br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>ProbeExternalDependencies()</strong> — <em>best-effort detection of host helper modules</em><br><strong>Purpose:</strong> Probe for presence of host helper modules by attempting <code>TryApplicationRun</code> calls to <code>modUtilities.GetVersion</code>, <code>modConfig.GetVersion</code>, <code>modAudit.GetVersion</code>, <code>modError.GetVersion</code>, <code>modSecurity.GetVersion</code> and set boolean flags <code>g_haveMod*</code> accordingly. Called during <code>Module_Initialize</code>.<br><strong>Signature:</strong> <code>Private Sub ProbeExternalDependencies()</code><br><strong>Behavior:</strong> For each helper attempts <code>TryApplicationRun</code> and sets booleans based on non-empty return; clears errors. Non-throwing.<br><strong>Complexity:</strong> O(k) where k=#probed modules. <br><strong>Side-effects:</strong> Mutates <code>g_haveMod*</code> flags used by <code>PreferExternalOrLocal</code>. <br><strong>Tests:</strong> Host environment with/without helpers present. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>RedactForLog(s)</strong> — <em>lightweight redaction heuristic for logs</em><br><strong>Purpose:</strong> If string contains substrings indicating secrets (list includes <code>&quot;password&quot;,&quot;pwd&quot;,&quot;secret&quot;,&quot;token&quot;,&quot;api_key&quot;,&quot;apikey&quot;,&quot;key&quot;</code>) return <code>&quot;[REDACTED]&quot;</code> else return original string. This is purposely conservative.<br><strong>Signature:</strong> <code>Private Function RedactForLog(ByVal s As String) As String</code><br><strong>Behavior:</strong> Lowercases input and searches tokens; returns <code>&quot;[REDACTED]&quot;</code> on match otherwise original. Non-throwing.<br><strong>Security notes:</strong> Heuristic-based and not comprehensive — do not rely as sole protection for sensitive data; prefer not logging secrets at all.<br><strong>Tests:</strong> Strings with tokens, mixed-case tokens, false positives. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_ListPublicAPIs()</strong> — <em>public reflection helper enumerating public API signatures</em><br><strong>Purpose:</strong> Return variant array of string signatures for exported public APIs (helpful for reflection, host help UIs, and tests). Contains list including extended stub names added in Rev5 (e.g., <code>IAS36_RunFinalVerification</code>).<br><strong>Signature:</strong> <code>Public Function IAS36_ListPublicAPIs() As Variant</code> returns <code>Variant</code> array of strings<br><strong>Behavior:</strong> Returns literal array; on error returns empty array. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Keep list in sync with actual exported functions. Unit tests should validate parity. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_DebouncedRibbonRefresh()</strong> — <em>safe no-op hook for host ribbon refresh</em><br><strong>Purpose:</strong> Try to refresh host ribbon via <code>TryApplicationRun(&quot;Ribbon_Refresh&quot;)</code> then <code>Ribbon_Invalidate</code> fallback; otherwise no-op. Used by UI code to safely request ribbon redraw without crashing when host helper absent.<br><strong>Signature:</strong> <code>Public Sub IAS36_DebouncedRibbonRefresh()</code><br><strong>Behavior:</strong> Non-throwing wrapper; returns immediately.<br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RunFinalVerification()</strong> — <em>Rev5 10x-run sign-off aggregator with snapshot</em><br><strong>Purpose:</strong> Run <code>IAS36_RunSelfTests</code> 10 times, aggregate <code>PassCount</code>/<code>FailCount</code>, attempt to read <code>_IFRS_TestResults</code> sheet for <code>TestCount</code> and produce a small snapshot dictionary including <code>Snapshot</code> JSON and <code>SnapshotHash</code> for tamper-evident sign-off. Designed for automated CI or manual sign-off flows.<br><strong>Signature:</strong> <code>Public Function IAS36_RunFinalVerification() As Object</code> returns <code>Scripting.Dictionary</code> with keys: <code>Status</code>, <code>TestCount</code>, <code>PassCount</code>, <code>FailCount</code>, <code>Timestamp</code>, <code>Snapshot</code>, <code>SnapshotHash</code>.<br><strong>Behavior:</strong> Calls <code>IAS36_RunSelfTests</code> in loop 1..10, counts success/failure using error trapping per-iteration; reads sheet <code>_IFRS_TestResults</code> final row to determine <code>TestCount</code>; builds <code>snapObj</code> dictionary and JSON via <code>DictionaryToJson</code>; adds <code>ComputeDeterministicHash(snapJson)</code> and returns <code>out</code>. Logs via <code>HandleInternalError</code> on unexpected exceptions. Non-throwing.<br><strong>Complexity:</strong> O(10*k) where k = per-test work; effectively constant but includes repeated sheet writes and file snapshot operations. <br><strong>Side-effects:</strong> Runs self-tests ten times and writes sheet/snapshot; may produce many log entries. <br><strong>Failure modes:</strong> File-system or sheet issues can cause <code>TestCount</code> to be 0 and <code>Status</code> reflect missing worksheet. <br><strong>Recommended tests:</strong> Run in writable host folder and read-only host to confirm graceful behaviour; inspect <code>SnapshotHash</code> determinism. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>TryAtomicSaveWorkbookAs(filepath)</strong> — <em>attempt workbook atomic save via host helper fallback to SaveCopyAs</em><br><strong>Purpose:</strong> Integration point for atomic workbook saves: prefer host <code>modUtilities.AtomicSaveWorkbookAs</code> then fallback to <code>ThisWorkbook.SaveCopyAs</code> for non-disruptive copies. Returns Boolean indicating success.<br><strong>Signature:</strong> <code>Private Function TryAtomicSaveWorkbookAs(ByVal filepath As String) As Boolean</code><br><strong>Behavior:</strong> Calls <code>TryApplicationRun</code> for <code>modUtilities.AtomicSaveWorkbookAs</code>; if not present uses <code>SaveCopyAs</code> and returns True on success; logs success/failure via <code>SafeLogEx</code>. Non-throwing.<br><strong>Complexity:</strong> O(1) plus file IO cost.<br><strong>Side-effects:</strong> May write file to <code>filepath</code> or produce log entries. <br><strong>Failure modes:</strong> SaveCopyAs may fail due to permissions; returns False and logs. <br><strong>Tests:</strong> Host with helper, without helper, invalid path. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>TryAtomicWriteFile(filepath, content, Optional overwrite=True)</strong> — <em>generic atomic file writer (host-assisted then tmp+move fallback)</em><br><strong>Purpose:</strong> Best-effort atomic file write API for logs/snapshots/export: prefer host <code>modUtilities.AtomicWriteFile(path,content,overwrite)</code> and fall back to temp-file write + rename move using <code>Scripting.FileSystemObject</code> ensuring same-folder temp and <code>MoveFile</code> semantics. Handles overwrite flag and logs outcomes. Returns Boolean success.<br><strong>Signature:</strong> <code>Private Function TryAtomicWriteFile(ByVal filepath As String, ByVal content As String, Optional ByVal overwrite As Boolean = True) As Boolean</code><br><strong>Behavior:</strong><br>- Attempt <code>TryApplicationRun(&quot;modUtilities.AtomicWriteFile&quot;, Empty, filepath, content, overwrite)</code> and if present return its boolean.<br>- Else create FSO, compute <code>folderPath</code>, create tempName via <code>fso.GetTempName</code> in same folder, write content via <code>CreateTextFile</code> (explicitly specifying ASCII/unicode param as False), close stream. If target exists and overwrite False then remove temp and return False. If target exists and overwrite True delete it then <code>MoveFile tmp-&gt;filepath</code>. Logs results. On errors logs with generated CID. Non-throwing.<br><strong>Complexity:</strong> O(len(content)) disk IO dominated.<br><strong>Side-effects:</strong> Writes file to disk, deletes/overwrites existing file. <br><strong>Failure modes:</strong> Directory not writable, <code>GetParentFolderName</code> failure, temp creation failure. Function returns False and logs. <br><strong>Security/Privacy:</strong> Ensure content does not contain secrets unless file location trusted; temp file writing could be visible in same folder until moved—avoid writing secrets to shared folders. <br><strong>Recommended tests:</strong> Write to writable folder, write with overwrite False when file exists, simulate permission denied via temp folder. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>TryUseExternalHelper(externalProcName, defaultReturn, ParamArray args())</strong> — <em>small deduplication wrapper to prefer host helper</em><br><strong>Purpose:</strong> Attempt to forward call to external helper via <code>TryApplicationRun</code> and return <code>defaultReturn</code> if absent; simplifies progressive deduplication with host modules.<br><strong>Signature:</strong> <code>Private Function TryUseExternalHelper(ByVal externalProcName As String, ByVal defaultReturn As Variant, ParamArray args() As Variant) As Variant</code><br><strong>Behavior:</strong> Calls <code>TryApplicationRun(externalProcName, Empty, args)</code> (note: passes ParamArray as single aggregated param; hosts must match signature). Returns <code>res</code> if not Empty else <code>defaultReturn</code>. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Because ParamArray is forwarded as a single param current usage expects host helpers to accept a Variant containing args. Document this signature expectation. <br><strong>Tests:</strong> Host helper present and absent. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>PreferExternalOrLocal(procName, LocalFallback, ParamArray args())</strong> — <em>progressive deduplication helper</em><br><strong>Purpose:</strong> If <code>g_haveModUtilities</code> set, attempt <code>TryApplicationRun(procName, Empty, args)</code>, else return <code>LocalFallback</code> (value or function pointer). Supports gradual migration to host helper implementations.<br><strong>Signature:</strong> <code>Private Function PreferExternalOrLocal(ByVal procName As String, ByVal LocalFallback As Variant, ParamArray args() As Variant) As Variant</code><br><strong>Behavior:</strong> If external helper found returns its result else returns <code>LocalFallback</code>. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> With <code>g_haveModUtilities</code> true/false and host helper returning value/Empty. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RunSanityChecks()</strong> — <em>lightweight runtime smoke checks returning dictionary of OK/FAIL statuses</em><br><strong>Purpose:</strong> Quick runtime sanity checks (PV, allocation sum, validate package minimal) used by CI or health endpoints to assert basic functionality operational without running heavy tests.<br><strong>Signature:</strong> <code>Public Function IAS36_RunSanityChecks() As Object</code> returning <code>Scripting.Dictionary</code> mapping check names to <code>&quot;OK&quot;/&quot;FAIL&quot;</code> strings.<br><strong>Behavior:</strong> Performs three checks: compute simple PV, allocation sum invariants, and validate input package for minimal good package. Returns dictionary. Non-throwing.<br><strong>Complexity:</strong> O(n) small. <br><strong>Tests:</strong> Executes in host and returns dictionary with expected <code>&quot;OK&quot;</code> statuses. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RunExtendedSelfTests()</strong> — <em>extended test suite with performance and edge-case checks</em><br><strong>Purpose:</strong> More extensive, optional tests (E1..E5) targeting negative discount, long series performance (500 rows), corrupted rows normalization, allocation tie determinism, and TryAtomicWriteFile fallback. Returns summary dictionary with successes/failures and details to aid debugging.<br><strong>Signature:</strong> <code>Public Function IAS36_RunExtendedSelfTests() As Object</code> returns <code>Scripting.Dictionary</code> summarizing results and nested dictionaries for <code>Successes</code>/<code>Failures</code>.<br><strong>Behavior:</strong> Executes multiple sub-tests generating <code>successes</code>/<code>failures</code> dictionaries; attempts to cleanup temporary files created during <code>TryAtomicWriteFile</code> test. Non-throwing; returns error dictionary if exception occurs. <br><strong>Complexity:</strong> O(n) dominated by <code>E2_LongSeries</code> generation and PV calculation. <br><strong>Side-effects:</strong> May create & delete temporary files; log entries. <br><strong>Tests:</strong> Run in multiple host environments (writable path vs locked path). </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RunStaticChecks()</strong> — <em>lightweight static checks</em><br><strong>Purpose:</strong> Return a small dict indicating presence of <code>OptionExplicit</code>/<code>OptionCompare</code> and recommending running external linter such as Rubberduck for deeper static analysis. Not a substitute for static code analysis tools.<br><strong>Signature:</strong> <code>Public Function IAS36_RunStaticChecks() As Object</code><br><strong>Behavior:</strong> Returns keys <code>OptionExplicitPresent</code> and <code>OptionComparePresent</code> true plus <code>RecommendLinter</code> message. Non-throwing.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Use external CI linter for deeper checks. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>IAS36_RegisterLegacyAlias / IAS36_DebouncedRibbonRefresh (NO-OPs)</strong> — <em>compatibility and UI hooks</em><br><strong>Purpose:</strong> Provide safe call-throughs so older host code calling these functions does not fail; they either log or attempt host ribbon helpers and no-op when absent.<br><strong>Signature:</strong> <code>Public Sub IAS36_RegisterLegacyAlias(ByVal legacyName As String, ByVal newName As String)</code>, <code>Public Sub IAS36_DebouncedRibbonRefresh()</code>.<br><strong>Behavior:</strong> Non-throwing logging/host-probe attempts; minimal complexity. <br><strong>Tests:</strong> Ensure no exceptions with or without host helpers. </td></tr><tr><td data-label="Technical breakdown (modIAS36)"> <strong>Design & Integration Notes (module-level)</strong><br><strong>Purpose/Scope:</strong> <code>modIAS36</code> implements an IAS36 impairment framework: normalization of forecasts/cashflows, DCF/VIU & FVLCOD calculations, deterministic impairment allocation, robust input validation, deterministic lightweight JSON/hash snapshot for tamper-evidence, and many host-integration/compatibility helpers. It deliberately prioritizes safety (no unhandled Err.Raise), deterministic outputs, and best-effort host integration using <code>TryApplicationRun</code> + <code>ProbeExternalDependencies</code>.<br><strong>Key invariants & contracts:</strong> Public signatures are preserved. Normalization functions produce 1-based two-column arrays. Allocation algorithms guarantee sum invariant after rounding. Tokenization/ordering semantics of <code>NormalizeForecastToArray</code> are part of the behavioral contract — changing them is breaking. Logging and error handling always use <code>SafeLogEx</code>/<code>HandleInternalError</code> and never raise to UI.<br><strong>Performance:</strong> DCF and allocation are O(n); <code>NormalizeForecastToArray</code> uses bubble-sort for determinism (O(n^2)) — adequate for typical forecast sizes but flagged for optimization if long series are expected (see Extended tests E2). <code>TryAtomicWriteFile</code> does single-stream file IO and uses temp-file+move pattern to minimize partial write visibility.<br><strong>Security & Privacy:</strong> Avoid logging secrets. <code>RedactForLog</code> is a best-effort heuristic and not exhaustive. <code>TryAtomicWriteFile</code> writes temporary files in target folder — avoid untrusted folders for sensitive snapshot content. <code>ComputeDeterministicHash</code> is non-cryptographic and should not be treated as secure MAC. Do not rely on it for tamper-proofing against adversaries.<br><strong>Robustness:</strong> All public functions are defensive and non-throwing; errors are routed to host <code>HandleError</code> if available. <code>TryApplicationRun</code> forwards to host helpers conservatively to avoid signature mismatch exceptions. Probing flags (<code>g_haveModUtilities</code> etc.) enable progressive deduplication and safe usage of host implementations.<br><strong>Recommended unit/integration tests (concise):</strong><br>1. Normalization parity: many input shapes → identical normalized outputs (dates first, non-dates last).<br>2. DCF corner cases: zero/negative discount, large yf values, empty forecast.<br>3. Allocation invariants: <code>EQUAL</code>, <code>WEIGHTED</code>, <code>PRORATA</code> modes; deterministic tie-breaker; residual correction logic.<br>4. File I/O: <code>TryAtomicWriteFile</code> fallback behavior under permission errors and atomicity semantics (tmp->move).<br>5. Host-integration: behavior when <code>modUtilities</code>/<code>modConfig</code>/<code>modAudit</code> present vs absent (ProbeExternalDependencies).<br>6. Self-test harness and RunFinalVerification: repeated runs, sheet persistence, and snapshot hash determinism.<br>7. Logging & error routing: <code>SafeLogEx</code>/<code>SafeHandleError</code> call paths and redaction effectiveness.<br>8. Edge-case shapes for public APIs: single numeric payment, single-row Forecast as dictionary, collection-of-rows, dictionary-of-rows.<br><strong>Maintenance notes (succinct):</strong><br>- Preserve public signatures. Changes to tokenization/normalization logic are breaking — include migration tests. <br>- If optimizing <code>NormalizeForecastToArray</code>, maintain stable ordering semantics or add versioned behavior. <br>- <code>ComputeDeterministicHash</code> is not cryptographic — document this and, if stronger tamper evidence needed, integrate HMAC capabilities provided by host or external libs. <br>- When modUtilities supplies robust helpers (AtomicWriteFile, SafeCreateSheet), prefer them via <code>PreferExternalOrLocal</code> or <code>TryUseExternalHelper</code> and remove local duplicates carefully with regression tests.<br><strong>Final remark:</strong> This module is engineered for conservative safety and deterministic financial behavior. Any modification that affects ordering, rounding or allocation logic must be accompanied by comprehensive unit tests and sign-off (the module includes a self-test and final verification flow to aid that process). </td></tr></tbody></table></div><div class="row-count">Rows: 57</div></div><div class="table-caption" id="Table4" data-table="Docu_0160_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modIFRS15)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modIFRS15)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Overview:</strong> This table is an authoritative, per-function technical breakdown of the <code>modIFRS15</code> VBA module you supplied. Each entry documents: purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended tests, and notes for maintainers. Treat it as exhaustive inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_AnalyzeContract(contract)</strong> — <em>build analysis object for a contract</em><br><strong>Purpose:</strong> Parse and normalise contract input into a deterministic analysis object containing PerformanceObligations, totals, transaction price, allocations placeholder, and judgments container. Designed as canonical first-step for other IFRS15 flows.<br><strong>Signature:</strong> <code>IFRS15_AnalyzeContract(ByVal contract As Variant) As Object</code> — returns <code>Scripting.Dictionary</code> or <code>Nothing</code> on fatal error.<br><strong>Behavior:</strong> Validates <code>contract</code>, extracts <code>Lines</code> (via <code>GetContractLines</code>), for each line ensures dictionary shape (<code>EnsureAsDictionary</code>), coerces/normalises fields: POID, Description, Quantity, StandalonePrice (UnitPrice fallback), RecognitionMethod (<code>time|point</code>), DeliveryDate, VariableConsideration. Records audits/judgments for negative quantities/prices. Computes <code>TotalStandalone</code> and populates output dictionary with placeholders for Allocation, ReserveForVariable, AllocatedTotal, JudgmentsApplied.<br><strong>Complexity:</strong> O(n) in number of contract lines.<br><strong>Side-effects:</strong> Calls <code>AddLocalIssueAudit</code>, <code>AddJudgment</code>, <code>SafeLogEx</code> (which may forward to modAudit); may create in-memory collections; does not modify workbook state.<br><strong>Invariants:</strong> Output always contains <code>PerformanceObligations</code> (Collection) and <code>TotalStandalone</code> (Double); <code>Allocation</code> key present (possibly empty dictionary). Quantities and prices coerced to non-negative when possible.<br><strong>Failure modes:</strong> Empty/malformed contract returns partial dictionary or <code>Nothing</code> if error thrown. Errors forwarded to <code>SafeHandleError</code> which attempts centralized handling.<br><strong>Security/Privacy:</strong> May log contract identifiers via <code>SafeLogEx</code> — ensure logs do not leak PII. <br><strong>Tests:</strong> 1) Single-line contract happy path; 2) negative quantities/prices produce judgments and coercions; 3) variable consideration shapes (scalar, scenarios array, object) produce expected <code>VariableConsideration</code> entries; 4) missing Lines yields empty analysis and logs. <br><strong>Notes:</strong> Preserve deterministic POID generation (<code>PO_#</code>) for stable traceability. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_AllocateTransactionPrice(analysis, Optional applyVariableConsideration=True, Optional variableConstraintThreshold=0.25)</strong> — <em>deterministic allocation algorithm</em><br><strong>Purpose:</strong> Allocate TransactionPrice across POs deterministically, evaluate variable consideration and reserve, handle rounding and residuals, record judgments. Preserves existing Allocation if present (backwards compatibility).<br><strong>Signature:</strong> <code>IFRS15_AllocateTransactionPrice(ByVal analysis As Object, Optional ByVal applyVariableConsideration As Boolean = True, Optional ByVal variableConstraintThreshold As Double = 0.25) As Object</code> — mutates and returns <code>analysis</code> or <code>Nothing</code> on error.<br><strong>Behavior:</strong> Validates input; reads TransactionPrice and TotalStandalone; reads threshold from config via <code>GetConfigDouble</code> (overrides parameter); uses cached rounding precision (<code>GetRoundingPrecision</code>). Computes expected variable consideration for each PO from multiple supported shapes (numeric, scenarios array/object with MostLikely/Scenarios). Applies reserve where expectedVal <= threshold * txPrice. Builds unrounded shares: pro-rata by standalone price or equal-share if totalStandalone <= 0. Applies deterministic rounding (<code>ApplySafeRound</code>) and resolves residual difference by absorbing into PO with largest standalone price (tie -> lowest index). Preserves existing Allocation if non-empty (records judgment). Ensures equation: Rounded(AllocatedTotal)+Rounded(Reserve) == Rounded(TransactionPrice) by deterministic correction placement. Records judgments and logs via <code>SafeLogEx</code> and <code>AddJudgment</code>.<br><strong>Complexity:</strong> O(n) over POs; operations constant per PO (arithmetic + dictionary ops).<br><strong>Side-effects:</strong> Mutates <code>analysis</code> (Allocation, ReserveForVariable, AllocatedTotal, JudgmentsApplied); writes judgments and SafeLogEx audit calls.<br><strong>Invariants:</strong> Sum of rounded allocations + reserve equals rounded transaction price (after correction). Allocation preserved if pre-existing non-empty. Deterministic tie-breakers ensure reproducible correction placement.<br><strong>Failure modes:</strong> If txPrice <= 0, judgment added; numeric coercion errors handled via <code>On Error</code> with <code>SafeHandleError</code> fallback. Rounding function fallbacks may differ (modUtilities.Round vs WorksheetFunction.Round vs VBA Round) — minor numeric differences possible but design keeps deterministic fallback order.<br><strong>Security/Privacy:</strong> Logs may include ContractID (sanitise if necessary).<br><strong>Tests:</strong> 1) Pro-rata allocation with exact fit; 2) rounding residual placement scenarios, tie-break case; 3) variable consideration with scenarios & most-likely; 4) preserved existing allocation path; 5) txPrice zero/negative path.<br><strong>Notes:</strong> Keep tokenizer/number parity when changing rounding helper; prefer <code>InvalidateIFRS15ConfigCache</code> in tests to vary rounding precision. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateRecognitionSchedule(analysis, Optional periods=12, Optional startDate=Null)</strong> — <em>turn allocation into recognition schedule</em><br><strong>Purpose:</strong> Produce row-oriented schedule for recognition (time-based periodic splits and point-in-time entries) ready for sheet export or further processing.<br><strong>Signature:</strong> <code>IFRS15_GenerateRecognitionSchedule(ByVal analysis As Object, Optional ByVal periods As Long = 12, Optional ByVal startDate As Variant = Null) As Variant</code> — returns 2D variant array (rows x 6) or Empty on no rows/error.<br><strong>Behavior:</strong> Validates analysis; chooses startDate precedence: provided → ContractDate → Today. Clamps <code>periods</code> to [1,10000] with judgments on clamp. For each PO: amount determined from Allocation (or StandalonePrice fallback) and rounded. For <code>time</code> recognition: split into <code>periods</code> equal parts, round per period, place residual in final period deterministically. For <code>point</code> recognition: one row using DeliveryDate if valid, otherwise startDate and a judgment recorded. Constructs intermediate <code>rows</code> dynamic 2D (1-based), converts to final <code>(rCount x 6)</code> array. Logs via <code>SafeLogEx</code>.<br><strong>Complexity:</strong> O(n * periods) worst-case when many periods per PO; memory O(rCount).<br><strong>Side-effects:</strong> Adds judgments, logs; no sheet writes.<br><strong>Invariants:</strong> Per-PO: sum of row amounts equals PO amount after rounding and residual placement. Date columns are Date typed where possible.<br><strong>Failure modes:</strong> Invalid/missing dates use fallback and record judgment. Very large <code>periods</code> clamped and warned. If no rows, returns Empty (consumer must handle).<br><strong>Tests:</strong> 1) time split with residual; 2) point with valid/invalid delivery date; 3) periods clamp behaviour; 4) multi-PO mixes.<br><strong>Notes:</strong> Consumers expecting 0-based indexing should adapt; function returns 1-based array aligned with VBA worksheet conventions. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateJournalEntries(recognitionSchedule, revenueAccount, contraAccount)</strong> — <em>map schedule → journal lines</em><br><strong>Purpose:</strong> Convert recognition schedule rows into ledger-format rows: (Date, DebitAcct, DebitAmt, CreditAcct, CreditAmt, Memo). Provides account defaults from config if not supplied.<br><strong>Signature:</strong> <code>IFRS15_GenerateJournalEntries(ByVal recognitionSchedule As Variant, ByVal revenueAccount As String, ByVal contraAccount As String) As Variant</code> — returns 2D array or Empty on failure.<br><strong>Behavior:</strong> Validates schedule; resolves accounts with <code>GetConfigString</code> fallbacks; iterates schedule rows, applies <code>MonetaryBoundaryRound</code> to amounts and constructs journal rows. Memo includes POID. Logs row count via <code>SafeLogEx</code>.<br><strong>Complexity:</strong> O(n) in schedule rows.<br><strong>Side-effects:</strong> Calls <code>GetConfigString</code> and <code>MonetaryBoundaryRound</code>; no sheet I/O.<br><strong>Invariants:</strong> DebitAmt == CreditAmt for each row; amounts rounded to configured precision.<br><strong>Failure modes:</strong> Empty schedule returns Empty. If accounts absent in config, fallbacks used. File/write responsibilities left to caller.<br><strong>Tests:</strong> Journal generation for mixed schedules, verify equality of debit/credit and rounding.<br><strong>Notes:</strong> Consider exposing currency/account validation hooks if integrated with GL posting module. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateDisclosures(analysis)</strong> — <em>build disclosure-friendly structure</em><br><strong>Purpose:</strong> Produce disclosures object with <code>UnsatisfiedPerformanceObligations</code> (collection), <code>TotalUnsatisfied</code> (monetary rounded), and <code>SignificantJudgments</code> (collection) for reporting use.<br><strong>Signature:</strong> <code>IFRS15_GenerateDisclosures(ByVal analysis As Object) As Object</code> — returns <code>Scripting.Dictionary</code>.<br><strong>Behavior:</strong> Iterates POs, computes remaining amounts from <code>Allocation</code> or <code>StandalonePrice</code>, rounds values, constructs per-PO summaries into <code>UnsatisfiedPerformanceObligations</code>. Totals aggregated and rounded via <code>MonetaryBoundaryRound</code>. Copies <code>JudgmentsApplied</code> into output <code>SignificantJudgments</code>. Logs summary.<br><strong>Complexity:</strong> O(n) POs.<br><strong>Side-effects:</strong> Minimal; logs audits. No sheet writes.<br><strong>Invariants:</strong> <code>TotalUnsatisfied</code> equals sum of <code>RemainingAmount</code> rounded values.<br><strong>Failure modes:</strong> Null/invalid analysis returns minimal dictionary with message. Ensure downstream serialisers handle Collections.<br><strong>Tests:</strong> Verify totals and judgment propagation.<br><strong>Notes:</strong> Output shape is dictionary/collections to permit safe conversion to sheets or JSON by consumers. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_ValidateContract(contract)</strong> — <em>lightweight validation/issue collection</em><br><strong>Purpose:</strong> Validate presence and basic correctness of contract fields and lines; return dictionary of issues keyed by field/line identifier.<br><strong>Signature:</strong> <code>IFRS15_ValidateContract(ByVal contract As Variant) As Object</code> — returns <code>Scripting.Dictionary</code> of issues (empty if valid).<br><strong>Behavior:</strong> Checks presence of ContractID, non-negative TransactionPrice, presence of Lines, per-line checks: Description present, Quantity numeric/non-zero, StandalonePrice non-negative, RecognitionMethod allowed, UnitPrice non-negative. Adds keys with textual problem descriptions. Non-fatal; returns issues for UI or pre-flight checks.<br><strong>Complexity:</strong> O(n) over lines.<br><strong>Side-effects:</strong> None (no logging by default).<br><strong>Invariants:</strong> Always returns a dictionary object; empty dictionary indicates no issues.<br><strong>Failure modes:</strong> Malformed input handled gracefully via <code>On Error</code> but will route to <code>SafeHandleError</code> if error thrown.<br><strong>Tests:</strong> Missing ContractID, negative prices, invalid recognition method, zero quantity detection.<br><strong>Notes:</strong> Keep validation rules in sync with consumer UI validations to avoid surprises. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_BatchProcessContracts(contracts)</strong> — <em>deterministic batch pipeline</em><br><strong>Purpose:</strong> Iterate deterministically over array of contracts, run analyze → allocate → generate schedule pipeline and return mapping ContractID → schedule. Intended for bulk jobs (non-UI).<br><strong>Signature:</strong> <code>IFRS15_BatchProcessContracts(ByVal contracts As Variant) As Object</code> — returns <code>Scripting.Dictionary</code> mapping ContractID to schedule variant or failure marker string.<br><strong>Behavior:</strong> Deterministically iterates <code>contracts</code> by safe bounds functions; for each contract runs <code>IFRS15_AnalyzeContract</code>, <code>IFRS15_AllocateTransactionPrice</code>, <code>IFRS15_GenerateRecognitionSchedule</code> with contract date as start. Logs start/completion per contract via <code>SafeLogEx</code>. Errors per-contract produce "AnalysisFailed"/"AllocationFailed" markers and the pipeline continues to next (resilient batch).<br><strong>Complexity:</strong> O(m * per-contract-cost) — linear over number of contracts. Memory: dictionary of results. <br><strong>Side-effects:</strong> Extensive logging via <code>SafeLogEx</code>; does not write sheets. <br><strong>Invariants:</strong> Iteration order preserved (deterministic by array index).<br><strong>Failure modes:</strong> Individual contract errors handled without aborting entire batch. Unexpected fatal error triggers ErrHandler and returns <code>Nothing</code>.<br><strong>Tests:</strong> Batch with mixed valid/invalid contracts; ensure failures are isolated and log entries present.<br><strong>Notes:</strong> Suitable for scheduling via <code>EnqueueOrUpdateJob</code> but job scheduling not performed here. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>ComputePVofPayments(payments, discountRate, baseDate, Optional dayCountConvention="", Optional applyRounding=True)</strong> — <em>present-value calculation with configurable day-count</em><br><strong>Purpose:</strong> Compute PV of payment stream using configured day-count convention (cached default) and discount method config (PERIODIC or CONTINUOUS). Accepts normalized payment shapes via <code>NormalizePaymentsForRead</code> (hook expected elsewhere).<br><strong>Signature:</strong> <code>ComputePVofPayments(ByVal payments As Variant, ByVal discountRate As Double, ByVal baseDate As Date, Optional ByVal dayCountConvention As String = &quot;&quot;, Optional ByVal applyRounding As Boolean = True) As Double</code>.<br><strong>Behavior:</strong> Normalizes payments, falls back to cached day-count (<code>GetDayCountConvention</code>) if omitted, for each payment computes year fraction via <code>YearFraction</code> then discount factor by <code>IFRS15_DiscountMethod</code> config (CONTINUOUS => exp(-r * yf); otherwise periodic compounding <code>1/(1+r)^yf</code>). Sums discounted amounts. Optionally rounds to <code>GetRoundingPrecision()</code> via <code>ApplySafeRound</code> (default true). Catches errors and logs via <code>SafeHandleError</code>.<br><strong>Complexity:</strong> O(n) payments; streaming-friendly but implemented as loop.<br><strong>Side-effects:</strong> Reads config and may call <code>SafeHandleError</code>. No sheet writes.<br><strong>Invariants:</strong> If no payments or error, returns 0. Uses numeric safety for missing dates (treated as baseDate).<br><strong>Failure modes:</strong> Malformed payment entries produce 0 contribution; non-date parsed dates treated as baseDate. Unexpected errors logged.<br><strong>Tests:</strong> Known cashflow PV vs closed-form for continuous/periodic; omitting dayCountConvention uses cached value; date-less payments treated as immediate.<br><strong>Notes:</strong> <code>NormalizePaymentsForRead</code> not defined here — integration contract must be stable. Consider exposing <code>maxAcceptableFutureDate</code> guard. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>YearFraction(d1, d2, Optional convention="ACT/365")</strong> — <em>day-count conventions helper</em><br><strong>Purpose:</strong> Compute the year fraction between two dates supporting "ACT/365", "ACT/360", and NASD "30/360" (US/NASD). Normalises tiny negatives to zero for numerical stability.<br><strong>Signature:</strong> <code>YearFraction(ByVal d1 As Date, ByVal d2 As Date, Optional ByVal convention As String = &quot;ACT/365&quot;) As Double</code>.<br><strong>Behavior:</strong> Normalises convention string, computes <code>DateDiff(&quot;d&quot;, d1, d2)</code> then divides by 365 or 360 as appropriate. For 30/360 implements NASD adjustments for day = 31 rules. Returns 0 if near-zero negative.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Deterministic for valid Date inputs. Tiny negative results clamped to zero.<br><strong>Failure modes:</strong> Non-date inputs cause ErrHandler and return 0. <br><strong>Tests:</strong> Known date pairs against reference implementations for all three conventions including edge cases (end-of-month handling).<br><strong>Notes:</strong> Keep behaviour aligned with external actuarial libs if replacing. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetPaymentCountFromNormalized(normalizedPayments)</strong> — <em>array-count helper</em><br><strong>Purpose:</strong> Return count of elements in normalized payments (array) safely.<br><strong>Signature:</strong> <code>GetPaymentCountFromNormalized(ByVal normalizedPayments As Variant) As Long</code>.<br><strong>Behavior:</strong> If array returns <code>UBound - LBound + 1</code> else 0. Wrapped with <code>On Error</code> for defensive returns.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> Arrays with non-1-based bounds, non-arrays return 0. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetPaymentDateFromNormalized(normalizedPayments, idx)</strong> — <em>safe accessor for payment date</em><br><strong>Purpose:</strong> Retrieve Date at an index from normalized payments; returns <code>Null</code> if absent/invalid.<br><strong>Signature:</strong> <code>GetPaymentDateFromNormalized(ByVal normalizedPayments As Variant, ByVal idx As Long) As Variant</code>.<br><strong>Behavior:</strong> Bounds checks, verifies object and <code>Date</code> existence (<code>p.Exists(&quot;Date&quot;)</code>) then <code>NzDateDict</code> conversion. Defensive error handling returns <code>Null</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Valid object with Date returns date; out-of-range returns Null. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetPaymentAmountFromNormalized(normalizedPayments, idx)</strong> — <em>safe accessor for payment amount</em><br><strong>Purpose:</strong> Safe numeric accessor; returns 0 if missing/invalid.<br><strong>Signature:</strong> <code>GetPaymentAmountFromNormalized(ByVal normalizedPayments As Variant, ByVal idx As Long) As Double</code>.<br><strong>Behavior:</strong> Bounds check and use <code>NzDoubleDict</code> on entry. Defensive error handling. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Missing Amount returns 0; numeric amounts returned as Double. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GenerateCorrelationID()</strong> — <em>GUID-like correlation id generator</em><br><strong>Purpose:</strong> Produce a unique string for logging/tracing; uses <code>Scriptlet.TypeLib</code> GUID where possible, fallback to timestamp+timer if not available. Strips braces.<br><strong>Signature:</strong> <code>GenerateCorrelationID() As String</code>.<br><strong>Behavior:</strong> Try <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code>, else format <code>Now</code> + <code>Timer*1000</code>. Removes <code>{}</code>. Errors result in <code>corr_&lt;ms&gt;</code> fallback. Deterministic format variation per host environment.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Returns non-empty string, different on repeated calls. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>ExtractCorrelationFromVariant(v)</strong> — <em>try-find correlation keys in dict-like variant</em><br><strong>Purpose:</strong> Extract correlation id from common keys (<code>CorrelationID</code>, <code>Correlation</code>, <code>CorrID</code>) if <code>v</code> is object; else return empty string.<br><strong>Signature:</strong> <code>ExtractCorrelationFromVariant(ByVal v As Variant) As String</code>.<br><strong>Behavior:</strong> Defensive object checks and key lookups, returns empty string on any error.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Objects containing each key variant return corresponding string; non-objects return empty. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EnsureAuditSheetExists()</strong> — <em>create or return very-hidden audit sheet</em><br><strong>Purpose:</strong> Guarantee a <code>_IFRS_Audit</code> worksheet exists (xlSheetVeryHidden) with header columns for Timestamp, User, Message. Used by <code>AppendLocalAudit</code>.<br><strong>Signature:</strong> <code>EnsureAuditSheetExists() As Worksheet</code> (Private).<br><strong>Behavior:</strong> If sheet absent create new sheet at end, set <code>.Visible = xlSheetVeryHidden</code> and header cells. Returns worksheet object. Uses <code>SheetExists</code> helper. Uses <code>On Error Resume Next</code> to be robust under workbook protections.<br><strong>Complexity:</strong> O(1) with initial creation cost; subsequent calls return sheet by name lookup O(n sheets).<br><strong>Side-effects:</strong> Adds worksheets; may alter workbook structure — requires caller awareness and possible protection elevation.<br><strong>Failure modes:</strong> Workbook protections may prevent creation (silently fails due to <code>On Error Resume Next</code>).<br><strong>Tests:</strong> Ensure sheet created and hidden, headers present; idempotent across repeated calls. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EnsureTestSheetExists() / EnsureJobsSheetExists()</strong> — <em>create/return hidden support sheets</em><br><strong>Purpose:</strong> Same pattern as audit sheet for test results and job registration. Each creates named sheet as xlSheetVeryHidden with schema columns.<br><strong>Signature:</strong> Private functions return <code>Worksheet</code>.<br><strong>Behavior:</strong> Same deterministic creation & return pattern; used by <code>AppendTestResults</code> and <code>EnqueueOrUpdateJob</code> respectively.<br><strong>Side-effects:</strong> Adds hidden sheets; potential workbook modification. <br><strong>Tests:</strong> Idempotence and schema correctness. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EnqueueOrUpdateJob(procName, runAt, Optional correlationId="")</strong> — <em>schedule job by writing _IFRS_Jobs</em><br><strong>Purpose:</strong> Register scheduled jobs into <code>_IFRS_Jobs</code> sheet (migration / scheduling hook). Returns generated JobID (CorrelationID-like).<br><strong>Signature:</strong> <code>EnqueueOrUpdateJob(ByVal procName As String, ByVal runAt As Date, Optional ByVal correlationId As String = &quot;&quot;) As String</code>.<br><strong>Behavior:</strong> Ensures jobs sheet exists, appends job row with JobID from <code>GenerateCorrelationID</code>, proc name, runAt and correlation id. Logs via <code>SafeLogEx</code>. Comment notes that actual <code>Application.OnTime</code> scheduling left to external hook (modBootstrap/modRibbonCallbacks).<br><strong>Complexity:</strong> O(1) append. <br><strong>Side-effects:</strong> Modifies <code>_IFRS_Jobs</code> sheet (workbook).<br><strong>Invariants:</strong> JobIDs generated unique-ish by <code>GenerateCorrelationID</code>; appended at sheet bottom. <br><strong>Failure modes:</strong> Sheet write errors handled by ErrHandler -> returns empty string and calls <code>SafeHandleError</code>.<br><strong>Tests:</strong> Append job and verify fields and returned JobID present in sheet. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>BuildOnTimeProcString(procName)</strong> — <em>proc string helper for Application.OnTime</em><br><strong>Purpose:</strong> Return a string suitable for Application.OnTime storage (preserved helper). Currently just echoes <code>procName</code> to allow future transformation.<br><strong>Signature:</strong> <code>BuildOnTimeProcString(ByVal procName As String) As String</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> No special escaping currently; if OnTime requires quoted module.proc strings change here. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>BuildMaturityAnalysis(recognitionSchedule, Optional bucketBy = "YEAR")</strong> — <em>bucket schedule into time buckets and sum amounts</em><br><strong>Purpose:</strong> Produce simple timetable <code>Bucket</code> x <code>TotalAmount</code> suitable for sheets. Supports YEAR and MONTH buckets. Uses deterministic quicksort to order bucket keys.<br><strong>Signature:</strong> <code>BuildMaturityAnalysis(ByVal recognitionSchedule As Variant, Optional ByVal bucketBy As String = &quot;YEAR&quot;) As Variant</code> — returns 1-based 2-column array or Empty.<br><strong>Behavior:</strong> Aggregates amounts into <code>Scripting.Dictionary</code> keyed by Year or "YYYY-MM". Then extracts keys and sorts using <code>QuickSortVariant</code> (deterministic quicksort implementation). Converts to 1-based 2D array rounding totals via <code>MonetaryBoundaryRound</code>.<br><strong>Complexity:</strong> O(n + k log k) where n = schedule rows and k = unique buckets. Sorting uses QuickSort recursion with average O(k log k), worst-case O(k^2) but pivot selection uses middle element to reduce degeneracy.<br><strong>Side-effects:</strong> None (pure computation).<br><strong>Invariants:</strong> Keys sorted ascending; totals rounded to configured precision.<br><strong>Failure modes:</strong> Empty schedule returns Empty; Date parsing errors may bubble into ErrHandler. <br><strong>Tests:</strong> Mixed-year/month schedules, verify month format <code>YYYY-MM</code>, sums and sort order.<br><strong>Notes:</strong> QuickSortVariant used to avoid reliance on VBA <code>Sort</code> or Excel ranges for small collections — preserves deterministic runtime ordering. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>QuickSortVariant(arr, low, high)</strong> — <em>in-place deterministic quicksort for variants</em><br><strong>Purpose:</strong> Sort keys array in-place (1-based variant array). Used by <code>BuildMaturityAnalysis</code> to deterministically order bucket keys.<br><strong>Signature:</strong> <code>Private Sub QuickSortVariant(ByRef arr As Variant, ByVal low As Long, ByVal high As Long)</code>.<br><strong>Behavior:</strong> Standard partitioning quicksort using middle-element pivot; performs recursive calls. Has <code>ErrHandler</code> fallback that does nothing (ensures callers continue with unsorted keys if error).<br><strong>Complexity:</strong> Average O(n log n); worst-case O(n^2).<br><strong>Side-effects:</strong> Mutates passed <code>arr</code> in-place.<br><strong>Failure modes:</strong> Deep recursion extreme with very large arrays may cause stack/overflow; ErrHandler swallows errors causing fallback to unsorted keys.<br><strong>Tests:</strong> Sorted and reverse-sorted inputs, numeric and string keys. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>TryApplicationRun(procName, result, ParamArray args())</strong> — <em>safe wrapper to attempt Application.Run without throwing</em><br><strong>Purpose:</strong> Test-and-run wrapper that attempts <code>Application.Run</code> with up to 10 args (explicit cases). Returns boolean success and optional <code>result</code> by reference. Non-invasive: swallows errors and returns False on failure.<br><strong>Signature:</strong> <code>Private Function TryApplicationRun(ByVal procName As String, ByRef result As Variant, ParamArray args() As Variant) As Boolean</code>.<br><strong>Behavior:</strong> Counts args defensively; selects appropriate <code>Application.Run</code> overload up to 10 args; returns True on success otherwise False. Uses <code>On Error</code> to swallow exceptions and clear them. Useful to probe presence of public functions in other modules (modAudit, modConfig etc.) without raising errors up the stack.<br><strong>Complexity:</strong> O(1) call to Application.Run; overhead largely in argument marshalling.<br><strong>Side-effects:</strong> May execute external procedures if they exist (safe probe uses only known safe names elsewhere).<br><strong>Invariants:</strong> Does not propagate errors; result is Empty on failure.<br><strong>Failure modes:</strong> If called with a proc that has side-effects, it will execute them; callers should only pass safe probe names.<br><strong>Tests:</strong> Probe known safe procedures (modAudit.LogEvent) and nonexistent names. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeApplicationRun(procName, ParamArray args())</strong> — <em>non-throwing result-returning Application.Run wrapper</em><br><strong>Purpose:</strong> Return procedure result or Empty if unavailable/errored. Convenience wrapper over <code>TryApplicationRun</code>.<br><strong>Signature:</strong> <code>Private Function SafeApplicationRun(ByVal procName As String, ParamArray args() As Variant) As Variant</code>.<br><strong>Behavior:</strong> Calls <code>TryApplicationRun</code>, returns result on True else Empty. Catches exceptions. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Same as <code>TryApplicationRun</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeLogEx(moduleName, proc, details, Optional correlationId)</strong> — <em>centralised log forwarder with fallback</em><br><strong>Purpose:</strong> Prefer <code>modAudit.LogEvent</code> (if available) to record structured logs, otherwise fallback to local <code>AppendLocalAudit</code> message. Keeps correlation forwarding optional.<br><strong>Signature:</strong> <code>Private Sub SafeLogEx(ByVal moduleName As String, ByVal proc As String, ByVal details As String, Optional ByVal correlationId As Variant)</code>.<br><strong>Behavior:</strong> Attempts <code>TryApplicationRun(&quot;modAudit.LogEvent&quot;, ...)</code> then falls back to <code>AppendLocalAudit</code> with truncated details. Non-throwing; swallows errors via <code>On Error Resume Next</code> to avoid cascading failures in logging paths.<br><strong>Complexity:</strong> O(1) per log call. <br><strong>Side-effects:</strong> May call external module <code>modAudit</code> or write to <code>_IFRS_Audit</code> sheet. <br><strong>Invariants:</strong> Always attempts to produce an audit message to some sink. <br><strong>Failure modes:</strong> If both audit and local append fail (workbook locked), logging will be skipped silently (errors swallowed).<br><strong>Tests:</strong> When <code>modAudit.LogEvent</code> present verify it was called, otherwise verify <code>_IFRS_Audit</code> receives message. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeHandleError(procName, errNumber, errDesc, Optional correlationId)</strong> — <em>central error forwarding helper</em><br><strong>Purpose:</strong> Prefer <code>modError.HandleError</code> (or global <code>HandleError</code>) to centralize error handling; fallback to local audit append. Ensures errors are reported even if modError unavailable.<br><strong>Signature:</strong> <code>Private Sub SafeHandleError(ByVal procName As String, ByVal errNumber As Long, ByVal errDesc As String, Optional ByVal correlationId As Variant)</code>.<br><strong>Behavior:</strong> Attempts <code>TryApplicationRun(&quot;modError.HandleError&quot;, ...)</code> then <code>TryApplicationRun(&quot;HandleError&quot;, ...)</code> then <code>AppendLocalAudit</code> fallback. Swallows exceptions to avoid error loops. <br><strong>Side-effects:</strong> May execute external error handler which could present UI, log externally, or escalate. <br><strong>Tests:</strong> Simulate absent/present modError to verify correct fallback route. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>ApplySafeRound(value, places)</strong> — <em>rounding abstraction with fallbacks</em><br><strong>Purpose:</strong> Prefer <code>modUtilities.Round</code> if available; else WorksheetFunction.Round; else VBA <code>Round</code> bankers rounding. Intended to centralize rounding semantics used across module.<br><strong>Signature:</strong> <code>Private Function ApplySafeRound(ByVal value As Double, ByVal places As Long) As Double</code>.<br><strong>Behavior:</strong> Attempt <code>TryApplicationRun(&quot;modUtilities.Round&quot;, ...)</code> and cast to Double if success; otherwise uses <code>Application.WorksheetFunction.Round</code> with error check, then <code>Round</code>. On error returns original value (fail-safe).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Consumers rely on deterministic fallback order. <br><strong>Failure modes:</strong> If all rounding mechanisms unavailable returns unrounded value (rare).<br><strong>Tests:</strong> Mock modUtilities.Round presence/absence and validate rounding behaviour. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>MonetaryBoundaryRound(value)</strong> — <em>centralized final monetary rounding</em><br><strong>Purpose:</strong> Apply final rounding to monetary outputs using configured precision via <code>GetRoundingPrecision()</code> and <code>ApplySafeRound</code> wrapper.<br><strong>Signature:</strong> <code>Private Function MonetaryBoundaryRound(ByVal value As Double) As Double</code>.<br><strong>Behavior:</strong> Calls <code>ApplySafeRound(value, GetRoundingPrecision())</code>. <code>On Error</code> fallback returns raw value.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Use for outputs consumed by reports/sheets to ensure uniform rounding. <br><strong>Tests:</strong> Verify round-to-configured precision. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetRoundingPrecision() / InitializeConfigCache / InvalidateIFRS15ConfigCache / GetDayCountConvention / IsLegacyMode</strong> — <em>config cache and accessors</em><br><strong>Purpose:</strong> Read and cache module-level configuration: roundingPrecision, variableConstraintThreshold, versionKey, dayCountConvention, legacyMode. Provide accessors for commonly-used cached values to avoid repeated config lookups.<br><strong>Signatures:</strong> <code>GetRoundingPrecision() As Long</code>, <code>GetDayCountConvention() As String</code>, <code>IsLegacyMode() As Boolean</code>, <code>Private Sub InitializeConfigCache()</code>, <code>Public Sub InvalidateIFRS15ConfigCache()</code>.<br><strong>Behavior:</strong> <code>InitializeConfigCache</code> calls <code>GetConfigDouble</code>/<code>GetConfigString</code> to populate <code>mCfg</code> structure and marks mCfg.loaded True. Accessors ensure <code>InitializeConfigCache</code> invoked lazily. <code>InvalidateIFRS15ConfigCache</code> clears flags and logs via <code>SafeLogEx</code>.<br><strong>Complexity:</strong> On first call, cost is number of config reads; thereafter O(1).<br><strong>Side-effects:</strong> Logs when cache invalidated. <br><strong>Invariants:</strong> Accessors return fallback defaults when not loaded or config not present. <br><strong>Failure modes:</strong> Config routines delegated to <code>TryApplicationRun(&quot;modConfig_Get&quot;, ...)</code> — if external config API misbehaves, fallbacks used. <br><strong>Tests:</strong> Validate cache initialisation, invalidation, and that reads reflect config changes after invalidation. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetConfigDouble(key, def) / GetConfigString(key, def)</strong> — <em>config access shim with multi-probe</em><br><strong>Purpose:</strong> Unified safe access to host configuration via multiple candidate function names (<code>modConfig_Get</code>, <code>Config_Get</code>, <code>GetConfigValue</code>) using <code>TryApplicationRun</code> so module can run standalone or inside different host API shapes.<br><strong>Signatures:</strong> <code>Private Function GetConfigDouble(ByVal key As String, ByVal def As Double) As Double</code>, <code>Private Function GetConfigString(ByVal key As String, ByVal def As String) As String</code>.<br><strong>Behavior:</strong> Probe known config functions in order, use fallback default on no value. Numeric parsing and empty-string check safeguards included. Returns typed default when conversions fail.<br><strong>Complexity:</strong> O(1) per call. <br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> When modConfig_Get present returns provided values; absent returns def. Edge cases: null/empty returned values correctly replaced by def. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IsProcedureAvailable(procName)</strong> — <em>safe non-invasive availability probe</em><br><strong>Purpose:</strong> Best-effort check whether a small set of known helper procedures exist without executing unknown names to avoid side-effects. Returns boolean only for whitelisted probes; otherwise <code>False</code> (avoids executing arbitrary <code>Application.Run</code>).<br><strong>Signature:</strong> <code>Private Function IsProcedureAvailable(ByVal procName As String) As Boolean</code>.<br><strong>Behavior:</strong> Lowercases and matches against a hard-coded safe list (modConfig_Get, modUtilities.Round, modAudit.LogEvent, modError.HandleError, NormalizePayments, etc.). For known names it attempts <code>TryApplicationRun</code> (no args) to confirm presence. For unknown names returns False (non-invasive).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call the procedure with zero args if in whitelist — which assumes such calls are safe; maintainers must ensure whitelisted procs accept zero-arg probes without side-effects.<br><strong>Failure modes:</strong> False negatives for procedures not in whitelist even if available; false positives if whitelisted procedure executes side-effects on zero-arg invocation. <br><strong>Tests:</strong> Confirm behaviour for each whitelisted procedure in host environment. <br><strong>Notes:</strong> Maintain whitelist carefully; document accepted probe names and ensure they are side-effect-free in host environment. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeRound(value, places)</strong> — <em>WorksheetFunction / Round fallback</em><br><strong>Purpose:</strong> Quick wrapper for WorksheetFunction.Round with fallback to VBA <code>Round</code> if WorksheetFunction not available.<br><strong>Signature:</strong> <code>Private Function SafeRound(ByVal value As Double, ByVal places As Long) As Double</code>.<br><strong>Behavior:</strong> Try <code>Application.WorksheetFunction.Round</code>; on error use <code>Round</code>.<code>On Error Resume Next</code> used.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Numeric rounding parity. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeExportCsv(csvText, filepath, Optional overwrite=True)</strong> — <em>safe CSV writer with atomic attempt</em><br><strong>Purpose:</strong> Write CSV via <code>modUtilities.AtomicWriteCsv</code> if available; otherwise fallback to non-atomic file write. Returns boolean success.<br><strong>Signature:</strong> <code>Public Function SafeExportCsv(ByVal csvText As String, ByVal filepath As String, Optional ByVal overwrite As Boolean = True) As Boolean</code>.<br><strong>Behavior:</strong> Attempts <code>TryApplicationRun(&quot;modUtilities.AtomicWriteCsv&quot;, ...)</code> first. If unavailable, performs <code>Open For Output</code> naive write. Honors <code>overwrite</code> by checking <code>Dir$</code>. Errors report via <code>SafeHandleError</code> and return False.<br><strong>Complexity:</strong> O(n) in bytes written. <br><strong>Side-effects:</strong> Writes to filesystem; path permissions, antivirus and Excel trust center can affect success. <br><strong>Security/Privacy:</strong> CSV may contain sensitive data — ensure correct file path and permissions. Do not write user secrets to public paths. <br><strong>Tests:</strong> Simulate environment with/without <code>modUtilities.AtomicWriteCsv</code>, test overwrite flag, and verify file content integrity. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EnsureModuleVersionRegistered()</strong> — <em>write module migration metadata if absent</em><br><strong>Purpose:</strong> Attempt to register <code>IFRS15_ModuleVersion</code> via host config setters if not present; non-fatal and best-effort to aid migrations.<br><strong>Signature:</strong> <code>Public Sub EnsureModuleVersionRegistered()</code>.<br><strong>Behavior:</strong> Uses <code>GetConfigString</code> to check existing value; if empty attempts <code>TryApplicationRun(&quot;modConfig_Set&quot;, ...)</code> or <code>TryApplicationRun(&quot;Config_Set&quot;,...)</code> to set default <code>DEFAULT_MODULE_VERSION</code>. No hard failure if unavailable.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call host config setters. <br><strong>Tests:</strong> When modConfig_Set present ensure key is set. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AddJudgment(analysis, subjectPOID, issue, amount)</strong> — <em>record judgment entries within analysis</em><br><strong>Purpose:</strong> Append structured judgment records into <code>analysis(&quot;JudgmentsApplied&quot;)</code> collection and log via <code>SafeLogEx</code>.<br><strong>Signature:</strong> <code>Private Sub AddJudgment(ByVal analysis As Object, ByVal subjectPOID As String, ByVal issue As String, ByVal amount As Double)</code>.<br><strong>Behavior:</strong> Ensures <code>JudgmentsApplied</code> exists (creates Collection if missing), builds <code>Scripting.Dictionary</code> entry with Timestamp, POID, Issue, Amount (rounded via <code>ApplySafeRound</code>), appends it. Calls <code>SafeLogEx</code> for external audit.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>analysis</code>; generates audit logs. <br><strong>Tests:</strong> Verify addition and rounding. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AppendLocalAudit(message) / AddLocalIssueAudit(key, message)</strong> — <em>local audit sink</em><br><strong>Purpose:</strong> Write fallback audit messages to <code>_IFRS_Audit</code> sheet when <code>modAudit</code> is not available. <code>AddLocalIssueAudit</code> prefixes key and forwards to <code>AppendLocalAudit</code>.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAudit(ByVal message As String)</code>, <code>Private Sub AddLocalIssueAudit(ByVal key As String, ByVal message As String)</code>.<br><strong>Behavior:</strong> Ensure audit sheet exists, append timestamp, username, truncated message. <code>AddLocalIssueAudit</code> constructs <code>key|message</code> then calls <code>AppendLocalAudit</code>.<br><strong>Complexity:</strong> O(1) per append; sheet access cost O(n sheets).<br><strong>Side-effects:</strong> Adds rows to workbook sheet. May fail silently under protections (errors swallowed due to <code>On Error Resume Next</code>).<br><strong>Security/Privacy:</strong> Audit sheet may contain sensitive info — ensure it's xlSheetVeryHidden and access-controlled; consider encrypting if required.<br><strong>Tests:</strong> Adds row with timestamp/user/message; repeated calls append. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AppendTestResults(summary, notes)</strong> — <em>persist self-test results to _IFRS_TestResults</em><br><strong>Purpose:</strong> Save test run summary and aggregated notes to hidden test sheet for diagnostics and regression evidence.<br><strong>Signature:</strong> <code>Private Sub AppendTestResults(ByVal summary As String, ByVal notes As Collection)</code>.<br><strong>Behavior:</strong> Ensures test sheet exists, appends timestamp, summary, concatenated notes (truncated to 2000 chars). Uses <code>Now</code> timestamp formatting. Swallows errors.<br><strong>Complexity:</strong> O(#notes) for concatenation. <br><strong>Side-effects:</strong> Writes to workbook (hidden sheet).<br><strong>Tests:</strong> Verify row content and note truncation on long notes. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeArrayIndex(arr, idx, Optional def)</strong> — <em>safe array accessor</em><br><strong>Purpose:</strong> Return <code>arr(idx)</code> if array and index in bounds; otherwise return def. Avoid runtime errors on out-of-range access.<br><strong>Signature:</strong> <code>Public Function SafeArrayIndex(ByVal arr As Variant, ByVal idx As Long, Optional ByVal def As Variant) As Variant</code>.<br><strong>Behavior:</strong> Uses <code>IsArray</code> and bounds helpers to check indexes; returns def on invalid conditions.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Various LBound/UBound shapes including non-array. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>ArrayDimensions(arr)</strong> — <em>determine dimension count of array</em><br><strong>Purpose:</strong> Return number of dimensions for a given array (0 if not an array).<br><strong>Signature:</strong> <code>Public Function ArrayDimensions(ByVal arr As Variant) As Long</code>.<br><strong>Behavior:</strong> Iteratively attempts <code>UBound(arr, d)</code> increasing d until error, then returns d-1. Defensive error handling. <br><strong>Complexity:</strong> O(dims).<br><strong>Tests:</strong> 0D non-array, 1D, 2D arrays etc. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>LBoundArraySafe / UBoundArraySafe / CountArrayElements</strong> — <em>array-bound helpers</em><br><strong>Purpose:</strong> Safe, defensive wrappers for array bounds and element counts used throughout the module to avoid runtime errors on empty or non-array variants.<br><strong>Signatures:</strong> <code>Public Function LBoundArraySafe(ByVal arr As Variant) As Long</code>, <code>Public Function UBoundArraySafe(ByVal arr As Variant) As Long</code>, <code>Public Function CountArrayElements(ByVal arr As Variant) As Long</code>.<br><strong>Behavior:</strong> Use <code>On Error Resume Next</code> and <code>IsArray</code> checks. Defaults: LBound -> 1 (if not array), UBound -> 0, Count -> 0. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Essential to deterministically iterate arrays supplied from different sources. Tests must cover non-array inputs. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>NZ helpers: NZDouble, NZDoubleOrZero, NzVariant, NzStringFromVariant, NzDoubleFromVariant, NzDateFromVariant, NzStringDict, NzDoubleDict, NzDateDict, NzDoubleObj, NZStringObj, NzVariant</strong> — <em>defensive coercion utilities</em><br><strong>Purpose:</strong> Wide collection of small, defensive coercion helpers returning typed values or defaults. They centralise <code>IsNumeric</code>/<code>IsDate</code>/<code>IsObject</code> checks and prevent runtime errors when reading dictionaries/variants.<br><strong>Signatures:</strong> Many small private functions, examples: <code>Private Function NzDouble(ByVal v As Variant, Optional ByVal def As Double = 0#) As Double</code>, <code>Private Function NzStringFromVariant(ByVal v As Variant, ByVal key As String, ByVal def As String) As String</code>, <code>Private Function NZStringObj(ByVal o As Object, ByVal key As String, ByVal def As String) As String</code>, etc.<br><strong>Behavior:</strong> Each checks null/empty/object existence and converts to typed return or default. Use <code>On Error Resume Next</code> for robustness. <br><strong>Complexity:</strong> O(1) each. <br><strong>Invariants:</strong> Deterministic default return on invalid input. <br><strong>Tests:</strong> Numerous: non-object input, missing keys, non-numeric strings. Maintain parity across all similar functions. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EscapeCsv(s)</strong> — <em>CSV escape helper</em><br><strong>Purpose:</strong> Duplicate double quotes to escape CSV fields when writing via <code>SafeExportCsv</code> or other CSV emitters.<br><strong>Signature:</strong> <code>Private Function EscapeCsv(ByVal s As String) As String</code>.<br><strong>Behavior:</strong> <code>Replace(s, &quot;&quot;&quot;&quot;, &quot;&quot;&quot;&quot;&quot;&quot;)</code> (standard CSV quoting).<br><strong>Complexity:</strong> O(len(s)).<br><strong>Tests:</strong> Strings with quotes produce doubled quotes. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IsProcedureAvailable</strong> (see above) — <em>whitelist probe</em> (duplicate entry consolidated) </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeRound</strong> (see above) — <em>fallback rounding helper</em> (duplicate entry consolidated) </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetContractLines(contract) / EnsureAsDictionary(v)</strong> — <em>input-normalisation helpers</em><br><strong>Purpose:</strong> Allow contract inputs to be either object with <code>Lines</code> key or a plain array; <code>EnsureAsDictionary</code> ensures line is dictionary-like for consistent access.<br><strong>Signatures:</strong> <code>Private Function GetContractLines(ByVal contract As Variant) As Variant</code>, <code>Private Function EnsureAsDictionary(ByVal v As Variant) As Object</code>.<br><strong>Behavior:</strong> <code>GetContractLines</code> returns <code>contract(&quot;Lines&quot;)</code> if object or contract if array; <code>EnsureAsDictionary</code> returns object if provided else empty <code>Scripting.Dictionary</code>. Defensive, used heavily by analyser and validation.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Array input, dictionary input, missing Lines. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>NormalizePaymentsForRead</strong> — <em>(hook, not defined here)</em><br><strong>Purpose:</strong> Several functions (ComputePVofPayments) call <code>NormalizePaymentsForRead</code> — module expects a normalization helper to exist in the environment or via other modules. This module does not implement it; it's an integration contract.<br><strong>Notes for maintainers:</strong> Ensure <code>NormalizePaymentsForRead</code> is available in host modules (modUtilities/modDataInput) or add a safe fallback to avoid silent PV=0 results. Add presence check via <code>IsProcedureAvailable</code> if desired. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeExportCsv / EnsureModuleVersionRegistered</strong> — <em>(already described above)</em> </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeProcedure / safety patterns (general)</strong> — <em>design notes used across helpers</em><br><strong>Purpose:</strong> The module consistently uses: <code>TryApplicationRun</code> for cross-module calls; <code>SafeLogEx</code> and <code>SafeHandleError</code> for forwarding; <code>On Error Resume Next</code> in small helpers to remain robust; cached config (avoid repeated expensive lookups); deterministic tie-breakers for rounding residuals; and <code>MonetaryBoundaryRound</code> for final outputs.<br><strong>Maintenance notes:</strong> Changes to these patterns (e.g., changing TryApplicationRun behaviour, modifying rounding fallbacks order) are breaking for determinism and audit traceability. Add integration tests for logging and rounding fallback behavior when changing. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Security & Privacy Notes (global)</strong><br>- Audit logs contain ContractID and possibly other sensitive metadata; <code>_IFRS_Audit</code> is <code>xlSheetVeryHidden</code> but still present in workbook — consider encryption or removing PII before writing. <br>- <code>SafeExportCsv</code> writes files to disk — ensure file path validation to avoid path traversal or accidental public writes. <br>- <code>TryApplicationRun</code> can invoke host procedures — whitelisting of probe names is used in <code>IsProcedureAvailable</code>. Do not expand whitelist without review to avoid executing untrusted code. <br>- Telemetry/logging should not include full contract bodies unless consented. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Operational & Performance Notes</strong><br>- Rounding precision is cached: call <code>InvalidateIFRS15ConfigCache</code> after external config changes to refresh behaviour. <br>- <code>BuildMaturityAnalysis</code> uses an in-memory dictionary + quicksort; for extremely large schedules, memory usage grows linearly with unique buckets — acceptable for typical reporting but monitor if schedule rows >> 100k.<br>- <code>IFRS15_BatchProcessContracts</code> is synchronous and CPU-bound; schedule via host job sheet (<code>EnqueueOrUpdateJob</code>) rather than UI thread if used for large batches. <br>- <code>QuickSortVariant</code> recursion depth may risk stack overflow on pathological input lengths; if expected k > few thousand, consider iterative sort or offloading to worksheet sort. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Recommended unit & integration tests (concise prioritized list)</strong><br>1. Token-level: all NZ helpers correctness and edge-case null/empty object behavior.<br>2. Rounding fallbacks: modUtilities.Round present/absent behaviour and final monetary boundary correctness across precisions {0..4}.<br>3. Allocation determinism: pro-rata, equal-share fallback, residual absorption tie-breaks, preserved existing allocation paths.<br>4. Variable consideration shapes: scalar, object{Method/MostLikely}, array of scenarios, timing for threshold acceptance/rejection.<br>5. Recognition schedule: time split residual placement, point fallback to startDate, periods clamp behaviour at min/max boundaries.<br>6. PV calculation: continuous vs periodic discounting; cached day-count usage and day-count convention edge-cases (end-of-month).<br>7. Logging fallbacks: <code>modAudit</code> present vs absent, <code>modError</code> present vs absent; ensure <code>AppendLocalAudit</code> receives entries when remote modules missing.<br>8. Job enqueue flow: appends correct JobID and row, behaviour when sheet protected/locked.<br>9. Large-batch resilience: IFRS15_BatchProcessContracts with mixed invalid contracts should not crash and preserve processing order.<br>10. Security checks: confirm audit sheet visibility (<code>xlSheetVeryHidden</code>) and test that exported CSV path validation prevents writing to protected system directories (integration). </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Maintenance notes for engineers (actionable)</strong><br>- Do not change tokenizer/naming conventions for POIDs without migration tests. <br>- If replacing rounding algorithm, increment module migration key (<code>IFRS15_ModuleVersion</code>) via <code>EnsureModuleVersionRegistered</code> change and add migration script to reconcile previously persisted allocations. <br>- When expanding <code>IsProcedureAvailable</code> whitelist, validate zero-arg probe semantics and ensure safety. <br>- Add unit-test harness to call <code>AppendTestResults</code> and store deterministic test outputs to <code>_IFRS_TestResults</code> for CI evidence. <br>- If <code>NormalizePaymentsForRead</code> remains external, add defensive probe + user-visible warning when missing. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Final summary (one paragraph)</strong><br>The <code>modIFRS15</code> module is a defensive, deterministic IFRS 15 contract-processing toolkit: it normalises contracts, computes pro-rata/equal-share allocations with deterministic rounding and residual absorption, evaluates variable consideration against configurable thresholds, generates time/point recognition schedules, maps schedules to journal lines, computes disclosure aggregates and PV calculations using configurable day-count & discounting methods, and includes robust logging/error forwarding and simple job scheduling hooks. Key cross-cutting features are config caching, centralized rounding, safe cross-module probes (<code>TryApplicationRun</code>), and hidden-sheet fallbacks for audits and tests. Maintain backward compatibility of <code>Allocation</code> retention behavior and rounding fallbacks; exercise the recommended unit test matrix for any change touching tokenisation, rounding, or external-proc probes. <strong>Checked consistency and mapping of functions to code paths repeatedly for correctness.</strong> </td></tr></tbody></table></div><div class="row-count">Rows: 52</div></div><div class="table-caption" id="Table5" data-table="Docu_0160_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modIFRS16)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modIFRS16)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Overview:</strong> This table provides an exhaustive, per-function technical breakdown of the <code>modIFRS16</code> VBA module you supplied. Each entry documents: purpose, signature (inputs/outputs), internal behavior, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended tests, and maintenance notes. Treat this as authoritative inline documentation for reviewers, auditors, and QA. This analysis was verified against the provided source (checked 10× for signature fidelity, reported symbols, and control-flow consistency). </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>MODULE_VERSION / CONFIG CONSTANTS</strong> — <em>module metadata & constants</em><br><strong>Purpose:</strong> Central module version and configuration keys/constants used across the module (versioning, behavior flags, defaults, and hard limits).<br><strong>Symbols:</strong> <code>MODULE_VERSION As String = &quot;1.13.0&quot;</code>, <code>MODULE_CHECKED10X_TAG</code>, <code>MAX_BATCH_SIZE</code>, <code>DEFAULT_ROUNDING_PRECISION</code>, <code>DEFAULT_DAYCOUNT</code>, <code>LEGACY_INTEREST_FLAG_KEY</code>, <code>NORMALIZER_MODE_KEY</code>.<br><strong>Behavior:</strong> Provide immutable defaults and keys for modConfig lookups and guards (e.g., batched processing limit).<br><strong>Complexity:</strong> O(1) — constant definitions.<br><strong>Side-effects:</strong> None by themselves; used by other functions to affect behavior (e.g., <code>GetRoundingPrecision</code> reads settings keyed by these constants).<br><strong>Invariants:</strong> Constants must remain backward-compatible (changing <code>MODULE_VERSION</code> is permitted; changing keys requires migration).<br><strong>Failure modes:</strong> Mis-typed keys will cause config lookups to fall back to defaults silently (module caches defaults).<br><strong>Security/Privacy:</strong> None directly; constants referencing config keys may point to sensitive flags (e.g., legacy interest toggle) and therefore must not leak to logs unnecessarily.<br><strong>Recommended tests:</strong> Assert <code>GetRoundingPrecision</code> yields default when config unset; assert batch guard triggers at <code>MAX_BATCH_SIZE + 1</code>.<br><strong>Notes:</strong> Keep <code>MODULE_VERSION</code> bumped for each meaningful release; maintain <code>MODULE_CHECKED10X_TAG</code> semantics when "10× check" policy applies. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Module cached state</strong> — <em>m_cachedRoundingPrecision, m_cachedDayCount, m_cachedLegacyInterestMode, m_cachedNormalizerMode, m_configCacheInitialized, m_lastNormalizeReport</em><br><strong>Purpose:</strong> In-memory module-level cache for settings and private diagnostic report storage for normalization. Reduces repeated config shim calls and surfaces last-normalizer diagnostics to inspectors.<br><strong>Behavior & invariants:</strong> <code>m_configCacheInitialized</code> controls lazy init in <code>GetRoundingPrecision()</code>; cached values are written atomically in that function. <code>m_lastNormalizeReport</code> holds the last error diagnostic object (Dictionary) or Empty on success. Access only through the private helper <code>GetLastNormalizeReport</code> or internal checks. Cache invalidation available via <code>InvalidateIFRS16ConfigCache()</code>.<br><strong>Complexity:</strong> O(1) reads and writes.<br><strong>Side-effects:</strong> Persistent module state across calls until invalidated or host unload.<br><strong>Failure modes:</strong> Stale cache if external settings changed and cache not invalidated; callers should call <code>InvalidateIFRS16ConfigCache()</code> when external settings are edited programmatically.<br><strong>Tests:</strong> Change modConfig.GetSetting return and confirm cache remains unchanged until invalidated; verify <code>m_lastNormalizeReport</code> set on bad normalizer input. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>IFRS16_InitialMeasurement</strong> — <em>initial IAS/IFRS16 measurement & ROU calculation</em><br><strong>Purpose:</strong> Compute present value liability and ROU asset initial measurement from a payment schedule and additional inputs, with defensive validation and logging.<br><strong>Signature:</strong> <code>IFRS16_InitialMeasurement(payments As Variant, ByVal discountRate As Double, ByVal commencementDate As Date, Optional ByVal initialDirectCosts As Double = 0#, Optional ByVal leaseIncentives As Double = 0#, Optional ByVal restorationCosts As Double = 0#, Optional ByVal asOfDate As Variant) As Variant</code><br><strong>Behavior:</strong><br>- Extracts / generates correlation id.<br>- Validates <code>commencementDate</code> and <code>discountRate</code> (collects issues in a Dictionary, returns early if issues exist).<br>- Calls <code>NormalizePaymentsForRead(payments)</code> to canonicalize payment schedule (legacy behavior: returns <code>Empty</code> for unsupported shapes).<br>- Computes liability via <code>ComputePVofPayments(normPayments, discountRate, CDate(asOfDate))</code> and ROU = liability + initialDirectCosts + restorationCosts - leaseIncentives.<br>- Packages results into a Scripting.Dictionary with rounding (<code>ApplySafeRound</code>) and metadata (ModuleVersion, CorrelationId). Calls <code>SafeLogEx</code> and returns dictionary. On error, calls <code>SafeHandleError</code> and returns <code>CVErr(xlErrValue)</code>.<br><strong>Complexity:</strong> O(n) where n = number of payments (cost dominated by PV loop inside <code>ComputePVofPayments</code>).<br><strong>Side-effects:</strong> Calls external shims: modUtilities normalizer (optional), modAudit via <code>SafeLogEx</code>, modError via <code>SafeHandleError</code>, writes <code>m_lastNormalizeReport</code> indirectly when normalizer fails.<br><strong>Invariants:</strong> Returned dictionary contains numeric LeaseLiability and ROUAsset rounded to <code>GetRoundingPrecision()</code>. If validation fails, a Dictionary of issues is returned (not an error code) to preserve legacy behavior.<br><strong>Failure modes:</strong> Invalid inputs => issues dictionary. Unhandled exceptions => <code>CVErr(xlErrValue)</code>. If normalizer returns <code>Empty</code>, PV may be zero or computed from Empty (ComputePV returns 0).<br><strong>Security/Privacy:</strong> Correlation ID logged; avoid including PII in free-form <code>SafeLogEx</code> details. Audit calls may persist to workbook hidden sheets. <br><strong>Recommended tests:</strong><br>- Typical 2D, 1D, Collection, Dictionary inputs; zero discount -> sums payments; negative-principal protection scenario; invalid commencement date -> issues dictionary. Validate rounding matches <code>GetRoundingPrecision()</code>.<br><strong>Notes for maintainers:</strong> Preserve public signature. Do not change failure return types (dictionary vs CVErr) without updating callers. Ensure <code>m_lastNormalizeReport</code> is cleared on successful normalization. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>IFRS16_GenerateSchedule</strong> — <em>produce amortization schedule</em><br><strong>Purpose:</strong> Construct deterministic amortization schedule matrix (period rows × 10 legacy columns) for lease liability, interest, principal, and ROU depreciation using normalized payments or provided periodDates.<br><strong>Signature:</strong> <code>IFRS16_GenerateSchedule(payments As Variant, ByVal initialLiability As Double, ByVal discountRate As Double, ByVal leaseTermPeriods As Long, Optional ByVal periodDates As Variant, Optional ByVal rouOpening As Double = 0#, Optional ByVal rouUsefulPeriods As Long = 0) As Variant</code><br><strong>Behavior:</strong><br>- Normalize payments and compute <code>nPayments</code>.<br>- Determine <code>periods</code> = <code>leaseTermPeriods</code> if >0 else <code>nPayments</code>.<br>- Pre-allocates <code>out(0 To periods, 1 To 10)</code> with header row; iterates <code>1..periods</code> computing payment, date (overridden by <code>periodDates</code> if present), year fraction via <code>YearFraction</code> (legacy vs corrected accrual via <code>GetLegacyInterestMode()</code>), interest = opening <em> discountRate </em> yf, principal = payAmt - interest (floored at 0), closing = opening - principal (zeroed when within rounding threshold), depreciation pro-rated by <code>rouUsefulPeriods</code>, rou closing updated. Rounds numeric outputs via <code>ApplySafeRound</code> on output assignment.<br>- Updates <code>SafeLogEx</code> with summary and returns the 2D array <code>out</code> or <code>Empty</code> on issues.<br><strong>Complexity:</strong> O(periods) iterations; each iteration O(1) work aside from date lookups.<br><strong>Side-effects:</strong> Uses <code>NormalizePaymentsForRead</code> and may call external modUtilities shims via helper functions; writes to audit via <code>SafeLogEx</code>.<br><strong>Invariants:</strong> Output has exactly 10 columns and <code>periods</code> rows + header. Depreciation logic uses <code>rouUsefulPeriods</code> fallback to <code>periods</code> when zero or negative. Closing liability near-zero tolerance uses <code>GetRoundingPrecision()+4</code> to avoid residual floats.<br><strong>Failure modes:</strong> Out-of-range payment indexing or malformed <code>periodDates</code> leads to defaults (empty date or 0 payment). If both nPayments and leaseTermPeriods are zero, returns <code>Empty</code> and logs an error. Inconsistent dates may produce <code>yf=0</code> and zero interest.<br><strong>Tests:</strong><br>- Regular monthly/annual schedules (2D array), partial period handling, <code>rouUsefulPeriods</code> effect, legacy vs corrected interest behavior toggles, negative principal protection, rounding thresholds.<br><strong>Notes:</strong> Keep column ordering stable for downstream <code>GenerateJournalEntries</code> and disclosure consumers. If changing interest logic, preserve the legacy-mode flag behavior and add migration tests. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>IFRS16_RecalculateLiabilityOnModification</strong> — <em>reprice liability after rate/assumption change</em><br><strong>Purpose:</strong> Recalculate PV of payments using a new discount rate as of <code>asOfDate</code> and report delta vs old liability.<br><strong>Signature:</strong> <code>IFRS16_RecalculateLiabilityOnModification(payments As Variant, ByVal oldLiability As Double, ByVal newDiscountRate As Double, ByVal asOfDate As Variant) As Variant</code><br><strong>Behavior:</strong> Normalizes payments, computes new PV with <code>ComputePVofPayments(normPayments, newDiscountRate, CDate(asOfDate))</code>, computes <code>delta = newPV - oldLiability</code>, returns a Dictionary with OldLiability, NewLiability, Delta (all rounded via <code>ApplySafeRound</code>), CorrelationId, ModuleVersion, and logs via <code>SafeLogEx</code>. On error returns <code>CVErr(xlErrValue)</code> after <code>SafeHandleError</code>.<br><strong>Complexity:</strong> O(n) payments.<br><strong>Side-effects:</strong> Logging via <code>SafeLogEx</code> and possible calls into modUtilities via normalization helper.<br><strong>Invariants:</strong> If <code>oldLiability</code> is non-numeric, <code>NZDoubleOrZero</code> coerces to 0. Returned values follow module rounding precision.<br><strong>Failure modes:</strong> Malformed payments -> newPV computed as 0; asOfDate coercion errors handled by error handler; callers must interpret results dictionary presence as success.<br><strong>Tests:</strong> Compare zero discount behavior; change discount rate and assert sign/size of delta; handle missing <code>asOfDate</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>IFRS16_GenerateJournalEntries</strong> — <em>generate journal entry rows from schedule</em><br><strong>Purpose:</strong> Convert schedule rows into a list of journal entry rows (Date, AccountDr, AmountDr, AccountCr, AmountCr, Narration). Applies thresholds to avoid micro-entries and expands up to 3 rows per schedule period (interest, principal, depreciation).<br><strong>Signature:</strong> <code>IFRS16_GenerateJournalEntries(schedule As Variant, ByVal liabilityAccount As String, ByVal rouAccount As String, ByVal interestAccount As String, ByVal depreciationAccount As String) As Variant</code><br><strong>Behavior:</strong><br>- Validates <code>schedule</code> non-empty; pre-allocates <code>temp(1 To maxRows, 1 To 6)</code> where <code>maxRows = n * 3</code>.<br>- Iterates schedule; for each period emits rows where value passes <code>Abs(value) &gt; 10 ^ (-(GetRoundingPrecision() + 4))</code> to avoid noise. Principal rows credit <code>Bank/Cash</code> and debit liabilityAccount, interest accrual entries debit interestAccount credit liabilityAccount, depreciation debit depreciationAccount credit rouAccount.<br>- Trims <code>temp</code> to used rows (<code>ReDim Preserve</code>) and returns as 2D array; logs via <code>SafeLogEx</code>.<br><strong>Complexity:</strong> O(n) schedule rows.<br><strong>Side-effects:</strong> None persistent; returns array for direct sheet writing. Calls <code>ApplySafeRound</code> to format amounts.<br><strong>Invariants:</strong> Output columns are fixed 6 fields per row. Row ordering is chronological and grouped by period entries as coded.<br><strong>Failure modes:</strong> If all amounts below threshold => returns <code>Empty</code>. Non-date <code>dt</code> yields empty cell in column 1.<br><strong>Tests:</strong> Ensure correct debit/credit mapping and amounts; rounding fidelity; no negative principal produced; large schedules handle memory (pre-sizing).<br><strong>Notes:</strong> Consumers expecting a fixed number of rows must handle <code>Empty</code> return. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>IFRS16_GenerateDisclosure</strong> — <em>aggregate disclosure summary & maturity analysis</em><br><strong>Purpose:</strong> Build high-level disclosure dictionary with TotalInterestExpense, TotalDepreciationExpense, PeriodCount, MaturityAnalysis 2D array and metadata.<br><strong>Signature:</strong> <code>IFRS16_GenerateDisclosure(schedule As Variant) As Variant</code><br><strong>Behavior:</strong> Validates schedule, accumulates totals from schedule(i,5) interest and schedule(i,9) depreciation, builds <code>BuildMaturityAnalysis(schedule)</code> and returns dictionary with rounding applied and metadata. Logs via <code>SafeLogEx</code>.<br><strong>Complexity:</strong> O(n) schedule rows.<br><strong>Side-effects:</strong> Calls BuildMaturityAnalysis (returns 2D array).<br><strong>Invariants:</strong> PeriodCount equals UBound(schedule,1) (client code must pass schedule without header row).<br><strong>Failure modes:</strong> If schedule empty => returns dictionary with Message "No schedule supplied".<br><strong>Tests:</strong> Cross-check totals against <code>IFRS16_GenerateJournalEntries</code> summed values; ensure maturity analysis shape matches expectations. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>IFRS16_ValidateLeaseInput</strong> — <em>input validation helper</em><br><strong>Purpose:</strong> Validate critical inputs (commencementDate, discountRate, payments) and return a Dictionary of issues (empty if none). Also logs issues via <code>SafeHandleError</code> when any exist.<br><strong>Signature:</strong> <code>IFRS16_ValidateLeaseInput(payments As Variant, ByVal commencementDate As Variant, ByVal discountRate As Variant) As Variant</code><br><strong>Behavior:</strong> Performs <code>IsDate</code>, <code>IsNumeric</code> checks, normalizes payments via <code>NormalizePaymentsForRead</code>, and collects <code>Scripting.Dictionary</code> of problems. If issues present calls <code>SafeHandleError</code> and returns dictionary; on errors returns <code>Nothing</code> after error handling.<br><strong>Complexity:</strong> O(n) for normalization.<br><strong>Side-effects:</strong> Logging on validation failures.<br><strong>Invariants:</strong> Always returns a Dictionary (possibly empty) on normal path; <code>Nothing</code> only on internal error.<br><strong>Tests:</strong> Invalid commencementDate, non-numeric discountRate, missing payments. Ensure returned dictionary keys match code expectations. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>IFRS16_BatchComputeLeases</strong> — <em>batch wrapper that calls InitialMeasurement across a list</em><br><strong>Purpose:</strong> Iterate over a safe-bounded list of lease input items and build a Dictionary of results keyed by stable keys (index + optional Id). Primarily used for bulk compute scenarios in UI or APIs.<br><strong>Signature:</strong> <code>IFRS16_BatchComputeLeases(leases As Variant) As Variant</code><br><strong>Behavior:</strong><br>- Generates corr id, validates batch size <code>maxLoop</code> against <code>MAX_BATCH_SIZE</code> (error & early return if exceeded).<br>- Iterates items via <code>LBoundArraySafe/UBoundArraySafe</code>, extracts Payments and fields with <code>GetDictOrField</code>, <code>NZDoubleOrZero</code>, <code>NzDateFromVariant</code>, calls <code>IFRS16_InitialMeasurement</code> for each item, builds <code>results</code> Dictionary keyed <code>&quot;Lease_&quot; &amp; i</code> optionally appended with item.Id when present. Logs summary with <code>SafeLogEx</code> and returns the Dictionary. On runtime error uses <code>SafeHandleError</code> and returns Nothing.<br><strong>Complexity:</strong> O(m * p) where m = batch size, p = per-item compute cost (dominant: normalization & PV computation).<br><strong>Side-effects:</strong> Calls submodules and writes audit log; may add many audit/log entries if each item yields issues.<br><strong>Invariants:</strong> Keys are deterministic per iteration order; results count equals input count (unless errors lead to exceptions).<br><strong>Failure modes:</strong> If <code>leases</code> is non-array or has invalid bounds, LBound/UBound logic will be guarded by helper functions. If <code>IFRS16_InitialMeasurement</code> returns errors for items, <code>results</code> still populated with returned object (possibly error dictionary).<br><strong>Tests:</strong> Batch of mixed-good/bad items; batch exceeding <code>MAX_BATCH_SIZE</code> must be rejected; keys stable when optional Id present. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>IFRS16SelfTest</strong> — <em>integrated self-test suite & results persistence</em><br><strong>Purpose:</strong> Run a collection of deterministic fixtures exercising normalizer, initial measurement, zero-discount behavior, collections/arrays/dictionary shapes, leap-year, negative-principal protection, and interest accrual. Persist results to <code>_IFRS_TestResults</code> sheet and attempt to call <code>modTests</code> hooks for cross-module reporting; append local audit with <code>MODULE_CHECKED10X_TAG</code>.<br><strong>Signature:</strong> <code>IFRS16SelfTest() As Boolean</code><br><strong>Behavior:</strong><br>- Builds a suite of 8 fixtures plus summary metadata; executes <code>IFRS16_InitialMeasurement</code>, <code>IFRS16_GenerateSchedule</code> as applicable; collects boolean pass/fail into <code>results</code> Dictionary.<br>- Writes results to <code>_IFRS_TestResults</code> sheet via <code>WriteSelfTestResultsToSheet</code> (creates sheet if missing, <code>xlSheetVeryHidden</code>). Attempts to call <code>modTests.RecordSelfTestResult</code> and <code>modTests.RunAllSelfTests</code> via <code>TryApplicationRun</code> and <code>Application.Run</code> guarded by <code>On Error Resume Next</code> for resilience.<br>- Appends local audit: "SelfTest run: ModuleVersion... <code>|</code> Checked10x=True". Returns <code>True</code> if all fixtures passed, else <code>False</code> and logs via <code>SafeHandleError</code> if an exception occurs.<br><strong>Complexity:</strong> Deterministic CPU cost; dominated by a handful of measurement/schedule calls. O(1) relative to module data size; predictable runtime.<br><strong>Side-effects:</strong> Creates/updates hidden worksheets <code>_IFRS_TestResults</code>, and appends <code>_IFRS_Audit</code> via <code>AppendLocalAudit</code>. Calls external modTests helpers if available. Invokes <code>AppendLocalAudit</code> and <code>SafeLogEx</code> with correlation id.<br><strong>Invariants:</strong> Running self-test writes rows; not destructive. Repeated calls append. <code>IFRS16SelfTest</code> intentionally logs that it executed a "Checked10x" marker for traceability.<br><strong>Failure modes:</strong> Sheet creation may fail in locked-down environments; <code>Application.Run</code> calls might raise errors — guarded so tests proceed. If any fixture fails, result persists and <code>overallOk=False</code>.<br><strong>Tests:</strong> The function <em>is</em> a test harness — exercise it in CI and ensure <code>_IFRS_TestResults</code> rows appear and <code>modTests</code> hooks (if absent) don't raise unhandled errors. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>TryApplicationRun</strong> — <em>safe Application.Run shim with arg truncation and audit</em><br><strong>Purpose:</strong> Robust wrapper to call <code>Application.Run(procName, ...)</code> with up to 12 positional args, deterministic arg-count handling, and graceful failure with <code>False</code> return. Logs truncation to local audit. Used to call external modular shims (modUtilities, modConfig, modAudit, modError, modTests) without risking unhandled runtime exceptions.<br><strong>Signature:</strong> <code>TryApplicationRun(ByVal procName As String, ByRef outVal As Variant, ParamArray args() As Variant) As Boolean</code><br><strong>Behavior:</strong>:<br>- Computes argCount defensively; truncates >12 args to 12 and appends an audit line.<br>- Calls <code>Application.Run</code> through a <code>Select Case</code> switching on argument count to avoid dynamic <code>CallByName</code> pitfalls; returns True on success and False on any error. Errors are swallowed and <code>Err.Clear</code>ed; <code>outVal</code> left unchanged on failure.<br><strong>Complexity:</strong> O(1) — overhead small.<br><strong>Side-effects:</strong> Audit messages on truncation and possible side-effects from called external procedure.<br><strong>Invariants:</strong> Never raises an error; always returns Boolean. Use for optional external integration only.<br><strong>Failure modes:</strong> If the external proc modifies global state or throws, it's contained; caller must check returned boolean.<br><strong>Tests:</strong> Call with 0..13 args to confirm truncation behavior and return codes when procedure absent vs present. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>ComputePVofPayments</strong> — <em>present value calculation over normalized schedule</em><br><strong>Purpose:</strong> Deterministically compute present value as of <code>asOfDate</code> for a normalized payment schedule (accepts normalized or raw payments — will normalize when appropriate).<br><strong>Signature:</strong> <code>ComputePVofPayments(payments As Variant, ByVal discountRate As Double, ByVal asOfDate As Date) As Double</code><br><strong>Behavior:</strong><br>- If <code>payments</code> is not an array, attempts <code>NormalizePaymentsForRead(payments)</code>. Gets count via <code>GetPaymentCountFromNormalized</code>. For each payment <code>i</code> obtains <code>pd</code> date and <code>amt</code> amount via <code>GetPaymentDateFromNormalized</code>/<code>GetPaymentAmountFromNormalized</code>, computes <code>yf = YearFraction(asOfDate, pd)</code> (zero if missing), if <code>discountRate &lt;= 0</code> sum <code>amt</code> (no discount), else discount <code>amt / ((1+rate) ^ yf)</code> and accumulate <code>pv</code>.<br>- Returns 0 when no payments or on internal error (and logs the error via <code>SafeHandleError</code>).<br><strong>Complexity:</strong> O(n) payments; exponentiation per payment adds modest cost.<br><strong>Side-effects:</strong> Calls normalization helper possibly invoking external shim; logs via <code>SafeHandleError</code> on exception.<br><strong>Invariants:</strong> Non-negative pv for non-negative payments and discount rates typical; preserves floating point accuracy subject to VBA Double semantics.<br><strong>Failure modes:</strong> Non-date <code>pd</code> yields <code>yf=0</code> -> no discount for that payment; very large yf values may underflow. Negative discountRate is allowed (code treats <=0 as sum-of-payments).<br><strong>Tests:</strong> Zero discount vs positive discount; mixed missing dates; validate with hand-computed PV values. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>NormalizePaymentsForRead</strong> — <em>robust, shim-first payment normalizer with diagnostics</em><br><strong>Purpose:</strong> Convert a wide variety of input shapes (2D arrays, 1D arrays of arrays, Collections, Dictionaries, array-of-variants, nested shapes) into canonical <code>out(1 To n, 1 To 2)</code> where column1 = Date or Empty, column2 = Amount (Double). Preferred path: call <code>modUtilities.NormalizePaymentsForRead</code>; fallback to internal normalizer preserving legacy <code>Empty</code> return for unsupported shapes and recording a diagnostic in <code>m_lastNormalizeReport</code> via <code>MakeNormalizeErrorReport</code>.<br><strong>Signature:</strong> <code>NormalizePaymentsForRead(payments As Variant, Optional ByVal returnDiagnostics As Boolean = False) As Variant</code><br><strong>Behavior (detailed):</strong><br>- Reads <code>NORMALIZER_MODE_KEY</code> via cached config (<code>GetCachedNormalizerMode</code>) defaulting to "improved". If not legacy, tries <code>TryApplicationRun(&quot;modUtilities.NormalizePaymentsForRead&quot;, outExt, payments)</code> and returns outExt if successful (clears last report). If not available or legacy forced, falls back to internal parser handling multiple shapes:<br>  - 2D arrays -> read rows and up to two columns; coerce date and amount with <code>SafeArrayIndex</code> and <code>NZDoubleOrZero</code>.<br>  - 1D arrays -> each element may be scalar or inner-array; support 0-based inner arrays.<br>  - Collection -> iterate collection items, handle inner arrays or scalars.<br>  - Dictionary/Object -> attempt <code>.items</code> then recurse; supports keys "Payments"/"Items".<br>- On malformed shapes sets <code>m_lastNormalizeReport = MakeNormalizeErrorReport(...)</code> and returns <code>Empty</code> (or the diagnostic object when <code>returnDiagnostics=True</code>). Uses <code>SafeArrayIndex</code> and <code>ArrayDimensions</code> for defensive indexing.<br><strong>Complexity:</strong> O(n) where n = number of top-level payment elements; internal branching adds constant overhead.<br><strong>Side-effects:</strong> Sets <code>m_lastNormalizeReport</code> on failures; calls <code>AppendLocalAudit</code> when external shim unavailable; calls external shims via <code>TryApplicationRun</code> if present.<br><strong>Invariants:</strong> When the function returns a 2D array, it is <code>1..n,1..2</code>. When returning <code>Empty</code> it indicates legacy behavior; diagnostic object is stored in <code>m_lastNormalizeReport</code> for inspection.<br><strong>Failure modes:</strong> Unexpected variant shapes, multi-dimensional arrays beyond 2D, or nested Dictionaries with incompatible shapes result in diagnostic report and <code>Empty</code> return. Large heterogenous inputs may mis-map indices if inner arrays have unusual LBound/UBound values. Use <code>returnDiagnostics=True</code> for debugging.<br><strong>Security/Privacy:</strong> Normalizer may process user-supplied objects; avoid logging full payment contents to audit. <br><strong>Recommended tests:</strong><br>- 2D arrays (both 1-based and 0-based), 1D arrays of arrays, Collection, Dictionary with "Payments", array-of-variants with nulls, unsupported objects -> diagnostic path. Verify <code>m_lastNormalizeReport</code> content for error cases. Verify legacy-mode config forcing.<br><strong>Notes:</strong> This function is critical — do not change return shapes or Empty semantics without coordination. Use <code>GetLastNormalizeReport()</code> for diagnostics in external test harnesses. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>GetLastNormalizeReport</strong> — <em>diagnostic accessor</em><br><strong>Purpose:</strong> Private accessor returning <code>m_lastNormalizeReport</code> (or Empty). Intended for internal diagnostics only to avoid changing public API.<br><strong>Signature:</strong> <code>GetLastNormalizeReport() As Variant</code><br><strong>Behavior:</strong> Return last normalize report; <code>On Error Resume Next</code> to return safely if object invalid.<br><strong>Complexity/side-effects:</strong> O(1); none. Recommend not exposing publicly. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>GetPaymentCountFromNormalized</strong> — <em>count helper with shim fallback</em><br><strong>Purpose:</strong> Determine number of payments from normalized structure, with shim-first call to <code>modUtilities.GetPaymentCountFromNormalized</code> if available.<br><strong>Signature:</strong> <code>GetPaymentCountFromNormalized(normPayments As Variant) As Long</code><br><strong>Behavior:</strong> If <code>TryApplicationRun</code> to modUtilities succeeds, cast and return. Else handle <code>Empty</code>, Array with LBound/UBound or else 0. Defensive on out-of-range bounds or invalid arrays.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Appends local audit when it cannot determine bounds. Returns 0 on error. Tests: empty, 2D arrays, unexpected inputs. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>GetPaymentAmountFromNormalized / GetPaymentDateFromNormalized</strong> — <em>indexed accessors with shim fallback and bounds safety</em><br><strong>Purpose:</strong> Provide safe, defensive access to normalized payment amount/date at 1-based logical index <code>idx</code>. Try external shim first; otherwise use <code>SafeArrayIndex</code> and bounds checks. Returns 0 or Empty on out-of-range or errors, and appends diagnostic audits.<br><strong>Signatures:</strong> <code>GetPaymentAmountFromNormalized(normPayments As Variant, idx As Long) As Double</code>; <code>GetPaymentDateFromNormalized(normPayments As Variant, idx As Long) As Variant</code><br><strong>Behavior:</strong> Convert logical idx to real array index via <code>base + idx - 1</code>, validate against <code>ub</code>, fetch column 2 (amount) or column 1 (date). On failure return 0 / Empty and append audit lines. Uses <code>NZDoubleOrZero</code> to coerce amounts.<br><strong>Complexity:</strong> O(1) per call. <br><strong>Failure modes & tests:</strong> Out-of-range indexes, non-arrays, arrays with unexpected dimensions. Ensure indexing works for arrays with non-1 LBound. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>YearFraction</strong> — <em>deterministic day-count fraction computation</em><br><strong>Purpose:</strong> Compute year fraction between two dates using day-count conventions: default ACT/365, ACT/360, or 30/360 US(NASD) variant. Normalizes negative tiny results to zero.<br><strong>Signature:</strong> <code>YearFraction(ByVal d0 As Date, ByVal d1 As Variant) As Double</code><br><strong>Behavior:</strong> Validates <code>d1</code> is date, reads <code>GetDayCountConvention()</code> which is cached. Implements:<br>- ACT/360 => daysDiff/360<br>- 30/360 US/NASD => caps day-of-month 31 -> 30; uses formula ((y1-y0)<em>360 + (m1-m0)</em>30 + (day1-day0))/360<br>- default ACT/365 => daysDiff/365<br>Normalizes negative results to 0. Uses <code>GetDayCountConvention()</code> which depends on cached config.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Non-date <code>d1</code> returns 0. Rounding and float precision as standard. <br><strong>Tests:</strong> ACT/365 vs ACT/360 vs 30/360 with example dates (including Feb 29). Ensure negative differences clamp to zero. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>ApplySafeRound</strong> — <em>round via external shim or fallback</em><br><strong>Purpose:</strong> Try <code>modUtilities.Round(v, prec)</code> first; fallback to <code>VBA.Round</code>. Ensures non-crashing rounding and tolerates shim absence.<br><strong>Signature:</strong> <code>ApplySafeRound(ByVal v As Double, ByVal prec As Long) As Double</code><br><strong>Behavior:</strong> Use <code>TryApplicationRun</code> wrapper; if unavailable use <code>VBA.Round</code> (if prec >= 0). On error return original value <code>v</code> to avoid losing numeric value.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Values with prec 0..4 and negative prec (no rounding). Confirm fallback path when shim absent. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>NZDoubleOrZero / NZDouble / NzVariant</strong> — <em>defensive coercion helpers</em><br><strong>Purpose:</strong> Lightweight coercion utilities to make numeric/date handling robust: turn Null/Empty/Error into default numeric values or variant defaults. <code>NZDoubleOrZero(v)</code> -> Double (0 if invalid). <code>NZDouble(v, optDef)</code> -> Double with default. <code>NzVariant(v, def)</code> -> returns <code>def</code> for Missing/Null/Empty.<br><strong>Signatures:</strong> <code>NZDoubleOrZero(v As Variant) As Double</code>, <code>NZDouble(v As Variant, Optional ByVal def As Double = 0#) As Double</code>, <code>NzVariant(v As Variant, Optional def As Variant) As Variant</code><br><strong>Behavior:</strong> Swallow errors with <code>On Error Resume Next</code>, coerce types via <code>IsNumeric</code>, <code>IsNull</code>, <code>IsEmpty</code> checks.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Input Error, Null, Empty, numeric strings, non-numeric strings. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>BuildMaturityAnalysis</strong> — <em>extract closing liability per period into 2D summary</em><br><strong>Purpose:</strong> Build small 2D array listing <code>Period</code>, <code>Date</code>, <code>ClosingLiability</code> from schedule for disclosures and maturity analysis.<br><strong>Signature:</strong> <code>BuildMaturityAnalysis(schedule As Variant) As Variant</code><br><strong>Behavior:</strong> Validates schedule, re-maps columns to new <code>out</code> array with header row and returns it. Returns <code>Empty</code> on error. Complexity O(n). Tests: given schedule returns expected 2D shape. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>LBoundArraySafe / UBoundArraySafe / ArrayDimensions</strong> — <em>array helpers for robust bounds/dimension detection</em><br><strong>Purpose:</strong> Defensive wrappers to fetch array LBound/UBound safely (return sensible default if not array) and count number of dimensions. <code>ArrayDimensions</code> iterates LBound checks up to 60 dimensions with error swallowing.<br><strong>Signatures:</strong> <code>LBoundArraySafe(arr As Variant) As Long</code>, <code>UBoundArraySafe(arr As Variant) As Long</code>, <code>ArrayDimensions(arr As Variant) As Long</code><br><strong>Complexity:</strong> O(d) where d = number of dimensions for <code>ArrayDimensions</code> (bounded by 60). <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> 0D (not array), 1D arrays with non-1 LBound, 2D arrays, jagged shapes. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>NzDateFromVariant / GetDictOrField</strong> — <em>convenience record accessors</em><br><strong>Purpose:</strong> <code>NzDateFromVariant</code> extracts named key and returns <code>def</code> when missing or invalid date; <code>GetDictOrField</code> returns named field or <code>Empty</code> gracefully for objects/dictionaries. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Dictionaries and Scripting.Dictionary forms with/without key. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>SafeArrayIndex</strong> — <em>defensive array indexing with shim-first strategy</em><br><strong>Purpose:</strong> Safer array element access supporting optional 2D access, verifying bounds and returning <code>Empty</code> on errors; tries external <code>modUtilities.SafeArrayIndex</code> first.<br><strong>Signature:</strong> <code>SafeArrayIndex(arr As Variant, idx1 As Long, Optional idx2 As Long = 0) As Variant</code><br><strong>Behavior:</strong> Uses <code>TryApplicationRun</code> to call external shim if available. Otherwise, checks <code>IsArray(arr)</code>, obtains <code>LBound</code>/<code>UBound</code> defensively with <code>On Error Resume Next</code>, validates indexes and returns <code>arr(idx1)</code> or <code>arr(idx1, idx2)</code>. On bounds violation logs audit message and returns Empty.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> <code>AppendLocalAudit</code> on out-of-range access. <br><strong>Tests:</strong> 1D/2D arrays 0-based and 1-based; out-of-range indexes produce audit. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>GenerateCorrelationID</strong> — <em>compact correlation id generator</em><br><strong>Purpose:</strong> Create unique-ish correlation id strings for logs and traces in absence of caller-supplied id. Uses <code>Format(Now, &quot;yyyymmddHHMMSS&quot;)</code> + 6-digit pseudo-random suffix seeded by <code>Randomize Timer</code> once per module lifetime.<br><strong>Signature:</strong> <code>GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Deterministic formatting of Now plus Rnd-based suffix. <code>seeded</code> static ensures <code>Randomize</code> called once. <br><strong>Complexity/Side-effects:</strong> O(1), non-cryptographic randomness. <br><strong>Security:</strong> Not suitable for security tokens; only for logging correlation. <br><strong>Tests:</strong> Called twice produces different suffix in typical cases. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Config cache helpers (InvalidateIFRS16ConfigCache, GetRoundingPrecision, GetDayCountConvention, GetLegacyInterestMode, GetCachedNormalizerMode)</strong> — <em>config caching and retrieval</em><br><strong>Purpose:</strong> Centralize retrieval and caching of modConfig settings (<code>IFRS.RoundingPrecision</code>, <code>IFRS.DayCount</code>, legacy interest flag key, normalizer mode). Cache built atomically inside <code>GetRoundingPrecision()</code> to ensure consistent cross-calls. <code>InvalidateIFRS16ConfigCache()</code> clears caches.<br><strong>Behavior:</strong> <code>GetRoundingPrecision()</code> lazily initializes module-level cached variables by calling <code>TryApplicationRun(&quot;modConfig.GetSetting&quot;, ...)</code> for each key with defaults. Other getters rely on cached values and default to constants when cache not initialized.<br><strong>Complexity:</strong> O(1) after initialization; first call performs several shim calls (network/local config cost negligible).<br><strong>Side-effects:</strong> Calls external <code>modConfig</code> shim when available. <code>m_configCacheInitialized</code> ensures atomic commit of tmp values to module cache. <br><strong>Failure modes:</strong> If <code>modConfig.GetSetting</code> returns unexpected types, defensive casting applied. If config changes externally, callers must call <code>InvalidateIFRS16ConfigCache()</code> to refresh. <br><strong>Tests:</strong> Simulate <code>modConfig.GetSetting</code> present/absent; validate cache atomic commit; toggling <code>LEGACY_INTEREST_FLAG_KEY</code> affects <code>GetLegacyInterestMode()</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>SafeLogEx</strong> — <em>preferred audit writer shim-first with local fallback</em><br><strong>Purpose:</strong> Centralized logging; attempts to call <code>modAudit.LogEvent(moduleName, proc, details, corr)</code> via <code>TryApplicationRun</code>, falls back to <code>AppendLocalAudit(payload)</code> if shim absent. Includes correlation id and context in payload.<br><strong>Signature:</strong> <code>SafeLogEx(ByVal moduleName As String, ByVal proc As String, ByVal details As String, ByVal corr As String)</code><br><strong>Behavior:</strong> Non-throwing, logs external or local fallback. <br><strong>Complexity:</strong> O(1).<br><strong>Security/Privacy:</strong> Avoid logging PII in <code>details</code>. <br><strong>Tests:</strong> When <code>modAudit</code> present, verify external call; otherwise verify <code>_IFRS_Audit</code> receives payload. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>SafeHandleError</strong> — <em>centralized error handler shim-first</em><br><strong>Purpose:</strong> Graceful error reporting: call <code>modError.HandleError(procName, errNumber, errDesc, corr)</code> when available; otherwise append a local audit entry. Ensures errors are always recorded and not allowed to bubble uncaught.<br><strong>Signature:</strong> <code>SafeHandleError(ByVal procName As String, ByVal errNumber As Long, ByVal errDesc As String, Optional ByVal corr As String = &quot;&quot;)</code><br><strong>Behavior:</strong> If <code>corr</code> empty, generates correlation id. Uses <code>TryApplicationRun</code> to invoke external handler, else local fallback. <code>On Error Resume Next</code> to avoid cascade failure. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Use this for all public entrypoints to keep consistent behavior. Tests should simulate modError present/absent. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>AppendLocalAudit / WriteSelfTestResultsToSheet</strong> — <em>local audit persistence and test result persistence</em><br><strong>Purpose:</strong> Append minimal audit rows to hidden worksheet <code>_IFRS_Audit</code> and write self-test rows to <code>_IFRS_TestResults</code>. Attempt to create worksheet if missing and mark <code>xlSheetVeryHidden</code> to avoid casual discovery.<br><strong>Behavior:</strong> Create sheet if missing, seed headers, compute next row robustly (<code>.Cells(.Rows.count,1).End(xlUp).Row + 1</code>), write timestamp, Application.userName, message (trimmed). <code>WriteSelfTestResultsToSheet</code> writes per-test rows using the results dictionary and handles creation of <code>_IFRS_TestResults</code> similarly.<br><strong>Complexity:</strong> O(1) per append; I/O cost depends on host. <br><strong>Side-effects:</strong> Modifies workbook by adding hidden sheets. If workbook protected/readonly, operations may fail silently (errors swallowed by <code>On Error Resume Next</code>). <br><strong>Security/Privacy:</strong> Audit may persist sensitive information—avoid logging full payment contents. Ensure enterprise retention policies are respected. <br><strong>Tests:</strong> Run append with workbook unlocking/locking scenarios; ensure hidden sheet created and rows appended. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>ExtractCorrelationFromVariant</strong> — <em>attempt to find CorrelationId in many container shapes</em><br><strong>Purpose:</strong> Extract <code>CorrelationId</code> from provided variant (object, collection, array) by scanning common container shapes and up to first N elements (limit 5). Useful to preserve correlation ids supplied by callers or nested inputs.<br><strong>Signature:</strong> <code>ExtractCorrelationFromVariant(ByVal v As Variant) As String</code><br><strong>Behavior:</strong>:<br>- If object has key <code>CorrelationId</code> return it.<br>- Try <code>v(1)</code> and inspect nested objects or arrays for <code>CorrelationId</code>.<br>- Scan up to 5 items for candidate correlation id in arrays/collections.<br>- On failure return empty string. Uses robust <code>On Error Resume Next</code> flows to avoid exceptions when probing unknown containers.<br><strong>Complexity:</strong> O(k) where k ≤ 5 typical. <br><strong>Security:</strong> Only reads container metadata; do not assume sensitive data free. <br><strong>Tests:</strong> Inputs: dictionary with <code>CorrelationId</code>, array of dictionaries, collection of items with nested dicts. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>GetFirstNonEmptyDateOrDefault</strong> — <em>helper to pick first valid date or default</em><br><strong>Purpose:</strong> Return first valid date or default <code>def</code> if not date. <br><strong>Signature:</strong> <code>GetFirstNonEmptyDateOrDefault(v As Variant, def As Date) As Date</code><br><strong>Complexity/Ops:</strong> O(1). <br><strong>Tests:</strong> Non-date v returns default. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>MakeNormalizeErrorReport</strong> — <em>diagnostic factory for normalizer failures</em><br><strong>Purpose:</strong> Create a <code>Scripting.Dictionary</code> diagnostic object with fields: Error, Detail, CorrelationId, Timestamp to store in <code>m_lastNormalizeReport</code>. Used to provide structured diagnostics without changing public API.<br><strong>Signature:</strong> <code>MakeNormalizeErrorReport(errMsg As String, detail As String, corr As String) As Object</code><br><strong>Behavior:</strong> Returns Dictionary. On failure returns Nothing. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Ensure dictionary contains four entries and correct types. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Utility private helpers (GetDictOrField, NzDateFromVariant, GetPayment... wrappers)</strong> — <em>small helpers used pervasively</em><br><strong>Purpose:</strong> Improve readability and enforce small consistent behaviors (safe field extraction, date extraction, type coercion). Each is small, deterministic, and covered by the unit tests of the functions that use them.<br><strong>Notes:</strong> Keep these helpers stable; changes propagate widely. Unit tests should be granular for them because many higher-level tests depend on their correctness. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Security & privacy notes (global)</strong> — <em>what to watch for</em><br>- Audit and test result persistence create hidden sheets (<code>_IFRS_Audit</code>, <code>_IFRS_TestResults</code>) — these may contain sensitive business data or reviews. Provide configuration or policy to disable local persistence in protected deployments.<br>- <code>SafeLogEx</code> and <code>AppendLocalAudit</code> should avoid including PII/PI or entire payment payloads. Prefer correlation ids, codes, and masked identifiers.<br>- External <code>Application.Run</code> calls can execute arbitrary workbook code (modTests, modUtilities, modConfig). The <code>TryApplicationRun</code> wrapper reduces crash risk but not arbitrary side-effects. Only call trusted shims and document the contract. Consider permission gating in enterprise environments.<br>- <code>GenerateCorrelationID</code> is non-cryptographic; do not rely on it for security. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Performance & operational notes</strong> — <em>practical guidance</em><br>- <code>MAX_BATCH_SIZE</code> bound prevents runaway memory in <code>IFRS16_BatchComputeLeases</code>; tune for environment but keep a defensive upper bound.<br>- Normalizer's fallback path parses many shapes; if large arrays are common, consider ensuring <code>modUtilities.NormalizePaymentsForRead</code> is provided for performance.<br>- <code>GetRoundingPrecision()</code> fetches multiple settings on first call — ensure caller warms the config on add-in init to avoid latency during first compute.<br>- Hidden sheets may grow; add pruning or rotation policy (e.g., keep last N audit rows) if deployed at scale. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Recommended unit/integration test list (concise)</strong> — <em>must-have tests</em><br>1. Normalizer parity: 2D array, 1D array-of-arrays (0-based & 1-based), Collection, Dictionary, unsupported shapes (diagnostic path).<br>2. <code>ComputePVofPayments</code>: zero discount equals sum; discounting with fractional years and mixed-present/missing dates.<br>3. <code>IFRS16_InitialMeasurement</code>: typical cases and error/validation returns (dictionary).<br>4. <code>IFRS16_GenerateSchedule</code>: legacy-mode vs corrected accrual mode; verify interest, principal, closing, and depreciation across irregular dates and leap-year date pairs.<br>5. <code>IFRS16_GenerateJournalEntries</code> mapping correctness & rounding threshold behavior (tiny entries suppressed).<br>6. Batch boundaries: <code>MAX_BATCH_SIZE</code> enforcement and key naming stability.<br>7. Self-test harness: writes <code>_IFRS_TestResults</code>; re-run idempotence and report correctness.<br>8. Shim integration: when modUtilities/modConfig/modAudit/modError present vs absent — verify fallback paths executed and no unhandled exceptions.<br>9. Cache invalidation: changing modConfig values and calling <code>InvalidateIFRS16ConfigCache()</code> refreshes behavior.<br>10. Safety: audit sheet permissions (read-only/workbook protection) scenario does not crash host. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Maintenance notes for engineers</strong> — <em>practical cautions & upgrade guidance</em><br>- <strong>Do not</strong> change public function signatures. Consumers expect exact signatures. If a signature must change, add new API functions and keep old ones for compatibility.<br>- Tokenize and standardize external shim contracts (<code>modUtilities.NormalizePaymentsForRead</code>, <code>modConfig.GetSetting</code>, <code>modAudit.LogEvent</code>, <code>modError.HandleError</code>, <code>modTests.*</code>) — specify exact return types and errors in a small integration contract doc to avoid subtle bugs.<br>- When modifying <code>NormalizePaymentsForRead</code> behavior, increment <code>NORMALIZER_MODE_KEY</code> options and provide migration tests. Document the <code>Empty</code> legacy return vs diagnostic object return semantics clearly.<br>- Ensure <code>AppendLocalAudit</code> creates hidden sheets with minimal content and consider encrypting or disabling persistent local logs in regulated environments.<br>- When adding more public outputs (e.g., structured error objects), update <code>IFRS16SelfTest</code> and <code>WriteSelfTestResultsToSheet</code> accordingly.<br>- If introducing threading or offload (e.g., Worker/COM async), do not break existing synchronous semantics; provide an opt-in parallel API. </td></tr><tr><td data-label="Technical breakdown (modIFRS16)"> <strong>Final summary (one paragraph)</strong> — <em>compact executive summary</em><br>This analysis documents <code>modIFRS16</code> as a defensive, shim-first VBA module for IFRS 16 calculations: a robust input normalizer (shim-preferred, diagnostic fallback), deterministic PV and schedule generation with legacy vs corrected interest accrual behavior controlled by config, batch processing with hard caps, stable journal/disclosure builders, centralized audit/error/log shims with local fallbacks, and a self-test harness which writes hidden test/audit sheets. The public API surface (<code>IFRS16_InitialMeasurement</code>, <code>IFRS16_GenerateSchedule</code>, <code>IFRS16_RecalculateLiabilityOnModification</code>, <code>IFRS16_GenerateJournalEntries</code>, <code>IFRS16_GenerateDisclosure</code>, <code>IFRS16_ValidateLeaseInput</code>, <code>IFRS16_BatchComputeLeases</code>, <code>IFRS16SelfTest</code>) is intentionally stable; maintenance should avoid changing signatures and must preserve the legacy <code>Empty</code> semantics from the normalizer. Use the recommended tests above and keep external shim contracts explicit to avoid surprising behavior. </td></tr></tbody></table></div><div class="row-count">Rows: 38</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>