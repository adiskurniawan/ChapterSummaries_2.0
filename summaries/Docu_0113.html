<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1767518006">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li>
<li class="toc-item"><a class="toc-link" href="#Table6">Table 6</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0113_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Section**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Section</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by **Current Plan Overview (Derived from Full Session)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Current Plan Overview (Derived from Full Session)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Section"> <strong>Goal</strong>                   </td><td data-label="Current Plan Overview (Derived from Full Session)"> Restore and enhance full render-pipeline integration after <code>index.html</code> removal — ensuring client button events, <code>/api/render</code> handling, and caption injection all work correctly through <code>html_renderer.py</code> and <code>server.py</code>.                                                                              </td></tr><tr><td data-label="Section"> <strong>Frontend (JS)</strong>          </td><td data-label="Current Plan Overview (Derived from Full Session)"> - Two main scripts: <code>assets/script.list.js</code> and <code>assets/script.core.js</code>. <br>- Both generate consistent <code>client_req_id</code> values. <br>- <code>list.js</code> handles <strong>Load Group</strong>, building group metadata and POSTing to <code>/api/render</code>. <br>- <code>core.js</code> handles <strong>Manual Paste</strong>, posting text to the same endpoint. </td></tr><tr><td data-label="Section"> <strong>Request Flow</strong>           </td><td data-label="Current Plan Overview (Derived from Full Session)"> Both POST requests reach <code>server.py → core_utils.get_request_context() → render_from_text()</code>. <br>- The <code>RequestContext</code> includes <code>client_req_id</code>, <code>action</code>, and <code>source</code>. <br>- If <code>action==&quot;load_group&quot;</code>, <code>allow_caption_injection=True</code>; otherwise <code>False</code>.                                             </td></tr><tr><td data-label="Section"> <strong>Server Role</strong>            </td><td data-label="Current Plan Overview (Derived from Full Session)"> <code>server.py</code> constructs the context, invokes <code>render_from_text</code>, and returns <code>{ html, meta, metadata }</code> as JSON. <br>Server has been safely revised to replace deleted <code>index.html</code> with dynamic <code>html_renderer</code>.                                                                                           </td></tr><tr><td data-label="Section"> <strong>Renderer Role</strong>          </td><td data-label="Current Plan Overview (Derived from Full Session)"> <code>render.core_renderer.py</code> parses captions and tables, sanitizes caption HTML, and injects captions only when <code>allow_caption_injection=True</code>.                                                                                                                                                               </td></tr><tr><td data-label="Section"> <strong>HTML Output</strong>            </td><td data-label="Current Plan Overview (Derived from Full Session)"> When captions are injected, renderer emits <code>&lt;script type=&quot;application/json&quot; data-caption-payload data-table-id=&quot;...&quot;&gt;[...]&lt;/script&gt;</code> alongside each table.                                                                                                                                                 </td></tr><tr><td data-label="Section"> <strong>Client Post-processing</strong> </td><td data-label="Current Plan Overview (Derived from Full Session)"> <code>script.core.js</code> (and possibly <code>script.table.js</code>) detect <code>&lt;script data-caption-payload&gt;</code> tags, parse payload JSON, and call <code>window.PTT.injectCaptions(tableId, captions)</code> if <code>meta.injected=True</code> or <code>metadata.fromList=True</code>.                                                                            </td></tr><tr><td data-label="Section"> <strong>Outstanding Work</strong>       </td><td data-label="Current Plan Overview (Derived from Full Session)"> 1. Refine or stabilize <code>script.core.js</code> (per your next instruction). <br>2. Verify <code>/api/render</code> endpoint returns correct structure (<code>html</code>, <code>meta</code>, <code>metadata</code>). <br>3. End-to-end test caption injection for both <em>load group</em> and <em>manual paste</em> actions.                                               </td></tr><tr><td data-label="Section"> <strong>Confirmed Feasibility</strong>  </td><td data-label="Current Plan Overview (Derived from Full Session)"> The plan remains <strong>fully possible and technically sound</strong> — all components (client, server, renderer) can communicate consistently with only minor stabilization required in <code>script.core.js</code>.                                                                                                             </td></tr></tbody></table></div><div class="row-count">Rows: 9</div></div><div class="table-caption" id="Table2" data-table="Docu_0113_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Section**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Section</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by **Updated Analysis (after preparing full revision plan for  CODE0 )**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Updated Analysis (after preparing full revision plan for  CODE0 )</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Section"> <strong>Objective</strong>           </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> Deliver a fully compatible <code>script.core.js</code> revision that restores client-side save/load functions, synchronizes <code>client_req_id</code> generation, and ensures correct caption injection across both Load Group and Manual Paste workflows.                                                                                                                                                                                                                                  </td></tr><tr><td data-label="Section"> <strong>Frontend Structure</strong>  </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> - <code>script.core.js</code> is the core controller for text conversion, render requests, and post-render injection. <br>- Works in tandem with <code>script.list.js</code>, <code>script.table.js</code>, and <code>html_renderer.py</code>. <br>- Relies on consistent endpoint <code>/api/render</code> for all POST operations.                                                                                                                                                                                          </td></tr><tr><td data-label="Section"> <strong>Interaction Flow</strong>    </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> 1. <strong>Manual Paste</strong> — user pastes text → <code>script.core.js</code> generates <code>client_req_id</code> → POST <code>{ action:&quot;manual_paste&quot; }</code> → waits for <code>/api/render</code> → receives <code>{ html, meta, metadata }</code> → calls <code>processRenderedHtml()</code> → if captions present, calls <code>PTT.injectCaptions()</code>. <br>2. <strong>Load Group</strong> — <code>script.list.js</code> builds metadata → triggers same endpoint → server returns caption-injected HTML with payload scripts → <code>script.core.js</code> processes it identically. </td></tr><tr><td data-label="Section"> <strong>Server Integration</strong>  </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> - <code>/api/render</code> and <code>/convert</code> routes both lead to <code>render_from_text()</code>. <br>- <code>server.py</code> constructs a <code>RequestContext</code> with <code>allow_caption_injection=True</code> for <code>load_group</code>. <br>- Renderer emits caption payloads only when this flag is true.                                                                                                                                                                                                                      </td></tr><tr><td data-label="Section"> <strong>Data Integrity</strong>      </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> - Each POST request uses a unique <code>client_req_id</code> created via shared generator. <br>- Client verifies that returned <code>metadata.client_req_id</code> matches the active request. <br>- Prevents race conditions when multiple render requests overlap.                                                                                                                                                                                                                         </td></tr><tr><td data-label="Section"> <strong>Caption Handling</strong>    </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> - Renderer emits <code>&lt;script type=&quot;application/json&quot; data-caption-payload data-table-id=&quot;...&quot;&gt;[...]&lt;/script&gt;</code> inside HTML when injection is allowed. <br>- Client parses these payloads, converts them to objects, and injects captions via <code>window.PTT.injectCaptions()</code>.                                                                                                                                                                                                </td></tr><tr><td data-label="Section"> <strong>Safety Enhancements</strong> </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> - Centralized error handling for failed fetch responses. <br>- Graceful fallback for missing <code>window.PTT</code> handlers. <br>- Deferred processing to allow DOM insertion before caption injection. <br>- Logging of timing and client_req_id for debugging.                                                                                                                                                                                                                </td></tr><tr><td data-label="Section"> <strong>Compatibility Notes</strong> </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> - The revised script keeps all existing entry points (<code>processRenderedHtml</code>, <code>PasteToTable.processRenderedHtml</code>, event listeners). <br>- No dependencies are removed. <br>- Retains old <code>window._PTT_Q</code> queue mechanism to avoid breaking legacy async order.                                                                                                                                                                                                          </td></tr><tr><td data-label="Section"> <strong>Testing Checklist</strong>   </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> 1. Manual Paste → verify HTML renders without caption payloads. <br>2. Load Group → verify HTML includes caption payload scripts and captions appear below tables. <br>3. Save/Load buttons → verify <code>/api/render</code> returns <code>{ ok:true, html, meta }</code>. <br>4. Network log → ensure matching <code>client_req_id</code> values. <br>5. No console errors in async callbacks.                                                                                                        </td></tr><tr><td data-label="Section"> <strong>Failure Prevention</strong>  </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> - Each POST request guarded by try/catch + async validation. <br>- JSON parse errors for caption payloads handled silently. <br>- Missing endpoints trigger visible error toast but not fatal crash. <br>- Multiple concurrent requests cancel obsolete responses.                                                                                                                                                                                                     </td></tr><tr><td data-label="Section"> <strong>Deployment Order</strong>    </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> 1. Replace <code>script.core.js</code> with the revised version. <br>2. Restart Flask backend with updated <code>server.py</code>. <br>3. Reload browser cache (Ctrl+Shift+R). <br>4. Test Load Group and Manual Paste separately. <br>5. Validate save/load cycle with real data.                                                                                                                                                                                                           </td></tr><tr><td data-label="Section"> <strong>Conclusion</strong>          </td><td data-label="Updated Analysis (after preparing full revision plan for  CODE0 )"> The end-to-end plan is <strong>confirmed viable and production-safe</strong>. <code>script.core.js</code> can be revised fully without breaking the project. Once deployed, button controls and caption injection will function correctly again through synchronized client-server logic.                                                                                                                                                                                                      </td></tr></tbody></table></div><div class="row-count">Rows: 12</div></div><div class="table-caption" id="Table3" data-table="Docu_0113_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Section**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Section</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by **Refined Analysis (longer-range design thinking)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Refined Analysis (longer-range design thinking)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Section"> <strong>Architectural Goal</strong>          </td><td data-label="Refined Analysis (longer-range design thinking)"> Preserve simplicity but future-proof <code>script.core.js</code> to survive renderer or API evolution. The core script should function as a transport controller, not a business-logic container. All heavy logic (conversion, table merging, caption injection) must remain in renderer or modular helpers.                                                                                                                                                                   </td></tr><tr><td data-label="Section"> <strong>State Management Refinement</strong> </td><td data-label="Refined Analysis (longer-range design thinking)"> - Use one global request controller: <code>window.PTTCoreController</code>. It keeps current <code>client_req_id</code>, request timestamps, and a cancel token for obsolete responses. <br>- This controller ensures only the latest request updates DOM. <br>- Replace scattered globals (<code>window._PTT_Q</code>, <code>window._PTT_active</code>) with a structured object to improve maintainability.                                                                                                   </td></tr><tr><td data-label="Section"> <strong>Client-Request Lifecycle</strong>    </td><td data-label="Refined Analysis (longer-range design thinking)"> 1. <strong>Initiation</strong> — Generate <code>client_req_id</code> via <code>makeClientReqId()</code> once per request. <br>2. <strong>Dispatch</strong> — POST payload to <code>/api/render</code>. <br>3. <strong>Response Handling</strong> — Compare response <code>metadata.client_req_id</code> with current active ID. Drop outdated responses automatically. <br>4. <strong>Render Phase</strong> — Insert HTML, then trigger deferred caption injection. <br>5. <strong>Finalize</strong> — Emit an event <code>PTTCore:renderCompleted</code> for cross-module synchronization. </td></tr><tr><td data-label="Section"> <strong>Parallel Request Handling</strong>   </td><td data-label="Refined Analysis (longer-range design thinking)"> - Queueing via promises rather than manual arrays. <br>- Each new request cancels or flags the previous one using an internal counter. <br>- Ensures “Load Group” and “Manual Paste” cannot corrupt each other’s DOM if clicked quickly.                                                                                                                                                                                                                            </td></tr><tr><td data-label="Section"> <strong>Caption Injection Timing</strong>    </td><td data-label="Refined Analysis (longer-range design thinking)"> - Introduce an adaptive delay mechanism (<code>await nextAnimationFrame()</code>) to allow DOM reflow before searching for <code>&lt;script data-caption-payload&gt;</code>. <br>- This removes intermittent race conditions where injection runs before HTML insertion completes.                                                                                                                                                                                                              </td></tr><tr><td data-label="Section"> <strong>Error Recovery</strong>              </td><td data-label="Refined Analysis (longer-range design thinking)"> - Replace silent catch blocks with structured diagnostics: <code>{phase, client_req_id, message}</code> logged via <code>console.info()</code> for traceability. <br>- Maintain non-blocking UI even if <code>/api/render</code> fails — e.g., re-enable paste area and show a non-fatal alert.                                                                                                                                                                                                      </td></tr><tr><td data-label="Section"> <strong>Security Layer</strong>              </td><td data-label="Refined Analysis (longer-range design thinking)"> - Client never executes HTML returned by the server using <code>innerHTML</code> on root containers without sanitization. <br>- Only append known safe markup (tables, captions, payload scripts). <br>- Escape unknown tags in debug logs.                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Section"> <strong>Modularity Improvements</strong>     </td><td data-label="Refined Analysis (longer-range design thinking)"> - Split core logic into: <code>PTTCore.network.js</code> (fetch & retry), <code>PTTCore.render.js</code> (DOM updates + caption injection), and <code>PTTCore.events.js</code> (UI triggers). <br>- This modularity allows targeted upgrades without rewriting entire <code>script.core.js</code>.                                                                                                                                                                                                              </td></tr><tr><td data-label="Section"> <strong>Performance Optimizations</strong>   </td><td data-label="Refined Analysis (longer-range design thinking)"> - Debounce user paste events to prevent rapid redundant POSTs. <br>- Use request batching for consecutive manual pastes within a 250 ms window. <br>- Lazy-load heavy modules like <code>script.table.js</code> only when table markup detected.                                                                                                                                                                                                                               </td></tr><tr><td data-label="Section"> <strong>Backward Compatibility</strong>      </td><td data-label="Refined Analysis (longer-range design thinking)"> - Maintain fallback global names (<code>PasteToTable</code>, <code>processRenderedHtml</code>) for legacy scripts. <br>- All new logic lives under <code>window.PTTCoreController</code>, but exports these aliases to prevent breaking older code.                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="Section"> <strong>Observability Enhancements</strong>  </td><td data-label="Refined Analysis (longer-range design thinking)"> - Add lightweight performance timers: measure server response time, caption injection time, and total render cycle. <br>- Log in console with <code>[PTTCore]</code> prefix for each major event.                                                                                                                                                                                                                                                                              </td></tr><tr><td data-label="Section"> <strong>Testing Improvements</strong>        </td><td data-label="Refined Analysis (longer-range design thinking)"> - Add synthetic tests for concurrent <code>load_group</code> and <code>manual_paste</code> actions. <br>- Include artificial delays to confirm only newest request updates DOM. <br>- Verify consistent behavior across Chromium, Firefox, and mobile browsers.                                                                                                                                                                                                                           </td></tr><tr><td data-label="Section"> <strong>Maintenance Outlook</strong>         </td><td data-label="Refined Analysis (longer-range design thinking)"> The refined structure allows future migration to Fetch API streaming or WebSocket-based live updates with minimal changes. It also isolates DOM and network responsibilities, which simplifies future debugging.                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Section"> <strong>Conclusion</strong>                  </td><td data-label="Refined Analysis (longer-range design thinking)"> After deep review, refinement yields a design that is more deterministic, modular, and secure. It retains full compatibility with the current server and renderer while eliminating timing bugs and ensuring that future upgrades (caption logic or new endpoints) can integrate cleanly without rewriting <code>script.core.js</code>.                                                                                                                                        </td></tr></tbody></table></div><div class="row-count">Rows: 14</div></div><div class="table-caption" id="Table4" data-table="Docu_0113_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Area"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Area</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Summary (exclude code snippets)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Summary (exclude code snippets)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Area"> 1) Server augmentation — placement             </td><td data-label="Summary (exclude code snippets)"> Insert a small augmentation into the <code>/api/render</code> (or <code>/convert</code>) handler <strong>after</strong> <code>html_out, meta = _render_text_with_fallbacks(text)</code> and <strong>before</strong> returning the JSON response. The augmentation: normalize <code>meta</code>, read <code>action</code> and <code>client_req_id</code> from request body or args, detect presence of <code>data-caption-payload</code> in the returned HTML, and set <code>meta.injected = True</code> and <code>meta.fromList = True/False</code> based on the <code>action</code>. Log failures to debug. Purpose: mark responses that contain caption payloads so clients can behave consistently without forcing renderer changes.                                                                                                                                                                                                                                                                       </td></tr><tr><td data-label="Area"> 2) Client replacement / functions — intent     </td><td data-label="Summary (exclude code snippets)"> Replace or merge the conversion / processing portion of <code>assets/script.core.js</code> with a robust implementation that: always posts <code>{ text, action, client_req_id, source }</code> to <code>/api/render</code>; parses JSON or HTML responses; detects <code>&lt;script data-caption-payload ...&gt;</code> tags inside returned HTML fragments; safely extracts/normalizes caption payloads (array/object/captions/caption); injects captions into the DOM using <code>textContent</code> only (no HTML injection); prefers app-provided hooks <code>window.PasteToTable.injectCaptions</code> or <code>window.PTT.injectCaptions</code>; falls back to a safe DOM insertion strategy that creates <code>.table-wrapper</code> and <code>.table-caption</code> elements; supports <code>manual_paste</code> vs <code>load_group</code> via <code>action</code>. Also exposes <code>__tv_do_convert</code>, <code>__tv_do_load_group</code>, and a default <code>PasteToTable.injectCaptions</code> helper for idempotent behavior. </td></tr><tr><td data-label="Area"> 3) Renderer contract (required shape)          </td><td data-label="Summary (exclude code snippets)"> Renderer should place caption payloads adjacent to their tables as <code>&lt;script type=&quot;application/json&quot; data-caption-payload data-table-id=&quot;...&quot;&gt;...&lt;/script&gt;</code>. Key rules: <code>type=&quot;application/json&quot;</code> and <code>data-caption-payload</code> attribute required; prefer <code>data-table-id</code> to identify the target table; payload may be an array or object; client normalizes <code>payload.captions</code>, <code>payload.caption</code>, or raw arrays. When renderer emits these script tags the server augmentation will detect them and set <code>meta.injected</code>.                                                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="Area"> 4) Manual tests — quick curl + browser checks  </td><td data-label="Summary (exclude code snippets)"> A. Manual paste test: POST JSON with <code>text</code>, <code>action: &quot;manual_paste&quot;</code>, <code>client_req_id</code> to <code>/api/render</code>; expect server JSON with <code>html</code> and <code>meta</code> and <code>meta.injected</code> false (unless payloads present). B. Load-group test: POST with <code>action: &quot;load_group&quot;</code> (or source <code>list</code>); if renderer emitted caption scripts expect <code>meta.injected = true</code> and <code>meta.fromList = true</code>. C. Browser verification: after <code>doConvert</code> succeeds, check <code>#tables-viewer</code> contains tables and <code>.table-caption</code> elements exist above tables whose payloads were present. Use console to inspect <code>document.querySelectorAll(&#x27;.table-caption&#x27;)</code>.                                                                                                                                                                                                                                        </td></tr><tr><td data-label="Area"> 5) Minimal end-to-end checklist (order-of-ops) </td><td data-label="Summary (exclude code snippets)"> 1. Add server augmentation to <code>server.py</code> at <code>/api/render</code> (after render output, before return). 2. Replace/merge <code>assets/script.core.js</code> with the provided client logic (or copy the key functions). 3. Ensure renderer emits <code>data-caption-payload</code> script tags adjacent to tables (optional but recommended). 4. Restart Flask server. 5. Run curl tests or use UI paste/list flows. 6. Confirm DOM captions and <code>meta</code> flags behave as expected.                                                                                                                                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="Area"> 6) Expected effects / rationale                </td><td data-label="Summary (exclude code snippets)"> Stabilizes client behavior without forcing immediate renderer changes. Allows clients to safely receive caption payloads in server responses and render them without executing untrusted script. Enables list vs manual flows to be distinguished via <code>action</code> so <code>meta.fromList</code> is accurate. Provides app hooks for custom injection while offering a safe fallback.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </td></tr><tr><td data-label="Area"> 7) Optional next deliverables                  </td><td data-label="Summary (exclude code snippets)"> Offer to produce: a unified patch/diff for <code>server.py</code>; a full file version of <code>script.core.js</code>; a small self-contained HTML test page to validate client-side caption injection without starting the backend.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </td></tr></tbody></table></div><div class="row-count">Rows: 7</div></div><div class="table-caption" id="Table5" data-table="Docu_0113_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Section**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Section</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by **Updated Analysis (based on full session context and cross-verification of frontend–backend integration)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Updated Analysis (based on full session context and cross-verification of frontend–backend integration)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Section"> <strong>Objective</strong>           </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> Deliver a complete, <strong>non-breaking <code>script.core.js</code></strong> that restores stable client-side rendering after <code>index.html</code> removal, ensures consistent <code>/api/render</code> POSTs from manual paste actions, and processes caption injection exactly as Table Viewer v2.1 intended. The result must preserve compatibility with <code>script.list.js</code>, <code>server.py</code>, and <code>core_renderer.py</code>.                                                                                                         </td></tr><tr><td data-label="Section"> <strong>Frontend Structure</strong>  </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> - <code>script.core.js</code> acts as the primary controller for manual conversion requests (user input → render → display). <br>- Shares <code>client_req_id</code> generator logic with <code>script.list.js</code>. <br>- Coordinates with <code>window.PTT</code>, <code>window._PTT_Q</code>, and <code>script.table.js</code> for post-render table initialization and caption injection. <br>- Operates without any dependency on static <code>index.html</code> after migration to Flask dynamic renderer.                                            </td></tr><tr><td data-label="Section"> <strong>Interaction Flow</strong>    </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> 1. User pastes text or markdown → clicks Render. <br>2. Script generates a unique <code>client_req_id</code>, sets <code>action=&quot;manual_paste&quot;</code>. <br>3. POST JSON body to <code>/api/render</code> with <code>{ text, client_req_id, action }</code>. <br>4. Waits for server JSON <code>{ html, meta, metadata }</code>. <br>5. Injects <code>html</code> into the target container (<code>#output-container</code>), then scans for caption payload scripts. <br>6. Converts them to objects, calling <code>window.PTT.injectCaptions(tableId, captions)</code>. </td></tr><tr><td data-label="Section"> <strong>Server Integration</strong>  </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> - <code>server.py</code> routes <code>/api/render</code> → <code>render_from_text()</code>. <br>- For manual paste, sets <code>allow_caption_injection=False</code>; for load group, <code>True</code>. <br>- Renderer (<code>core_renderer.py</code>) emits caption payloads only when allowed. <br>- Returned JSON ensures structured <code>{ html, meta, metadata }</code>. <br>- All keys preserved for backward compatibility.                                                                                                                           </td></tr><tr><td data-label="Section"> <strong>Data Integrity</strong>      </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> - Each request carries a unique <code>client_req_id</code> (via <code>Date.now().toString(36)+Math.random().toString(36).slice(2)</code> or equivalent). <br>- Response validation ensures only the matching <code>client_req_id</code> response updates the DOM. <br>- Prevents race conditions from overlapping async render calls. <br>- Maintains backward support for older PTT injection queue logic.                                                                                                       </td></tr><tr><td data-label="Section"> <strong>Caption Handling</strong>    </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> - Renderer may include JSON payloads in <code>&lt;script type=&quot;application/json&quot; data-caption-payload data-table-id=&quot;...&quot;&gt;[...]&lt;/script&gt;</code>. <br>- <code>script.core.js</code> parses these blocks safely (<code>try/catch</code> JSON parse). <br>- For each payload, calls <code>window.PTT.injectCaptions(tableId, captions)</code> only if that method exists. <br>- Uses deferred injection (<code>setTimeout</code>) to allow DOM stabilization before calling.                                                                  </td></tr><tr><td data-label="Section"> <strong>Safety Enhancements</strong> </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> - Graceful error handling around <code>fetch</code> and JSON parsing. <br>- Loading spinner and disabled button during render to prevent duplicate submissions. <br>- Handles network or parse errors by showing error notification (non-blocking). <br>- If backend returns malformed HTML or missing metadata, skips DOM update to prevent crash. <br>- Safeguards prevent executing untrusted inline scripts beyond caption payloads.                                                    </td></tr><tr><td data-label="Section"> <strong>Compatibility Notes</strong> </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> - Uses existing DOM IDs: <code>#input-textarea</code> for text input, <code>#output-container</code> for results. <br>- Keeps legacy PTT queueing (<code>window._PTT_Q</code>) intact. <br>- No removal of any globals. <br>- No dependency on deprecated <code>index.html</code> event bindings. <br>- Works equally with <code>script.list.js</code> and <code>server.py</code> (Flask).                                                                                                                                                         </td></tr><tr><td data-label="Section"> <strong>Testing Checklist</strong>   </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> 1. Paste markdown manually, click Render → verify HTML output. <br>2. Verify <code>/api/render</code> POST body includes <code>client_req_id</code> and <code>action</code>. <br>3. Network tab → ensure JSON response contains correct structure. <br>4. Confirm no duplicate DOM updates during concurrent requests. <br>5. For load group requests, confirm caption payload scripts exist and captions render correctly below tables. <br>6. Console must be free of uncaught errors.                          </td></tr><tr><td data-label="Section"> <strong>Failure Prevention</strong>  </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> - Each async <code>fetch</code> wrapped in try/catch with <code>response.ok</code> verification. <br>- Caption payload parsing uses <code>try/catch</code> with JSON fallback. <br>- Race conditions handled via response <code>client_req_id</code> check. <br>- DOM operations guarded against null containers. <br>- Unknown server fields ignored instead of causing errors.                                                                                                                                             </td></tr><tr><td data-label="Section"> <strong>Deployment Order</strong>    </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> 1. Backup existing <code>script.core.js</code>. <br>2. Replace with revised file. <br>3. Confirm <code>server.py</code> and <code>core_renderer.py</code> match expected interfaces. <br>4. Restart Flask backend. <br>5. Clear browser cache and reload (<code>Ctrl+Shift+R</code>). <br>6. Test manual paste and group loading flows separately. <br>7. Validate caption injection visually.                                                                                                                               </td></tr><tr><td data-label="Section"> <strong>Conclusion</strong>          </td><td data-label="Updated Analysis (based on full session context and cross-verification of frontend–backend integration)"> After verifying all communication paths and DOM dependencies, the revised <code>script.core.js</code> can be safely delivered. It will restore all manual rendering and caption injection logic without breaking the project. Behavior is consistent with TV2.1 architecture, server responses, and dynamic rendering via Flask. Ready for generation of the full, production-safe file in the next step.                                                                                   </td></tr></tbody></table></div><div class="row-count">Rows: 12</div></div><div class="table-caption" id="Table6" data-table="Docu_0113_06" style="margin-top:2mm;margin-left:3mm;"><strong>Table 6</strong></div>
<div class="table-wrapper" data-table-id="table-6"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Adopted change"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Adopted change</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Risk level"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Risk level</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Why adopted / justification"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Why adopted / justification</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Adopted change"> Logger initialization (add StreamHandler + default INFO)   </td><td data-label="Risk level">        Low </td><td data-label="Why adopted / justification"> Ensures logs appear in typical runtime environments; non-invasive and identical to desired file pattern.                                                                                                                                          </td></tr><tr><td data-label="Adopted change"> <code>render_from_text</code> adapter                                 </td><td data-label="Risk level"> Medium-Low </td><td data-label="Why adopted / justification"> Adds a stable adapter endpoint the server routes can call. It normalizes different renderer return shapes (dict, tuple, string) while falling back safely to escaped HTML. This reduces duplication and keeps existing fallback renderers intact. </td></tr><tr><td data-label="Adopted change"> Embedded <code>_INDEX_HTML_FALLBACK</code> (static HTML)              </td><td data-label="Risk level">     Medium </td><td data-label="Why adopted / justification"> Provides a safe index response when templates/static index missing. It's purely static; no behavioral change to rendering pipeline. Kept as fallback only.                                                                                        </td></tr><tr><td data-label="Adopted change"> <code>/save</code> endpoint (POST)                                    </td><td data-label="Risk level">     Medium </td><td data-label="Why adopted / justification"> Adds minimal server-side save used by client fallback. Includes filename sanitization and safe path checks. Non-destructive and behind a new route.                                                                                               </td></tr><tr><td data-label="Adopted change"> <code>/manifest.json</code> route                                     </td><td data-label="Risk level">        Low </td><td data-label="Why adopted / justification"> Safe convenience route; falls back to static file if present.                                                                                                                                                                                     </td></tr><tr><td data-label="Adopted change"> <code>/assets/&lt;path:filename&gt;</code> route (explicit)                 </td><td data-label="Risk level">        Low </td><td data-label="Why adopted / justification"> Mirrors desired file's explicit asset handler; continues to delegate to Flask static handling and adds clearer logging on misses.                                                                                                                 </td></tr><tr><td data-label="Adopted change"> Using <code>render_from_text</code> in <code>/api/convert</code> & <code>/api/render</code> </td><td data-label="Risk level">     Medium </td><td data-label="Why adopted / justification"> Safer standardization of server-side rendering; falls back gracefully on exceptions.                                                                                                                                                              </td></tr></tbody></table></div><div class="row-count">Rows: 7</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>