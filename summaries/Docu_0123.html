<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1763481229">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      // Delegate addEventListener/removeEventListener to visible button
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      // Delegate onclick assignments
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      // Delegate focus/blur
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
      // If legacy code used direct addEventListener earlier than this script, listeners would already exist
      // on alias element; attempt to re-dispatch those by cloning them to visible button is non-trivial.
      // This approach covers the common case where legacy scripts query the alias and bind after DOM ready.
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li>
<li class="toc-item"><a class="toc-link" href="#Table6">Table 6</a></li>
<li class="toc-item"><a class="toc-link" href="#Table7">Table 7</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0123_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1 • markdown.py</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module purpose & scope</strong><br><br><code>markdown.py</code> is a conservative, single-file Markdown→HTML converter intended as a drop-in replacement for environments that need: safe HTML sanitization, precise underscore handling, <code>*</code>-only emphasis, robust table & CSV stashing outside fenced code, inline-only rendering for table cells, safe fenced/inline code stashing and restoration, and an optional in-memory LRU cache for repeated renders. The design favors predictability and safety over full Markdown dialect coverage. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Public API & exports</strong><br><br>Public functions: <code>markdown_to_html(md_text: Optional[str]) -&gt; str</code>, <code>get_markdown_renderer(config: Optional[Dict]=None) -&gt; Callable[..., str]</code>, <code>get_markdown_renderer_callable(config: Optional[Dict]=None) -&gt; Callable[..., str]</code> (alias), <code>configure_render_cache(enabled: bool, maxsize: int = 1024)</code>. <code>__all__</code> lists these exports. Consumers should call <code>markdown_to_html</code> for a ready-to-inject safe string, or <code>get_markdown_renderer</code> to obtain a renderer.convert callable for advanced use. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level processing pipeline</strong><br><br>1. Normalize newlines and basic typographic conversions. 2. Stash contiguous pipe-table and CSV blocks (outside fenced code) via <code>_stash_tables</code>, replacing them with placeholders in the main text and capturing <code>table_map</code>. 3. Attempt python-markdown conversion path: stash code blocks (<code>_stash_code</code>), preprocess underscores outside placeholders (<code>_preprocess_underscores_outside_placeholders</code>), call a <code>MarkdownRenderer</code> (which wraps python-markdown), restore code/table placeholders, sanitize and post-process links, and optionally cache results. 4. If python-markdown path fails, fall back to <code>_fallback_markdown_to_html</code> which implements inline rules and placeholder restoration, then sanitize and link-fix. 5. Final fallback: escaped <code>&lt;pre&gt;</code> of input. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Sanitization approach (light allowlist)</strong><br><br><code>_sanitize_html(unsafe_html)</code> implements a minimal allowlist sanitizer: strips entire dangerous tags (<code>script, iframe, object, embed, form, input, button, svg, meta, link</code>) including their contents; removes event attributes (e.g., <code>onclick</code>); allows only a limited set of tags (<code>div, p, br, strong, b, em, i, mark, code, pre, ul, ol, li, table, thead, tbody, tr, th, td, a, span, sub, sup, kbd, u</code>) and a restricted attribute set (<code>class</code>, <code>id</code>, <code>data-*</code>; <code>a</code> may keep <code>href</code> if <code>_is_safe_url</code> passes and <code>title</code>). Implementation escapes all tags first, then re-opens only allowed tags with filtered attributes. This is conservative and intentionally not a full sanitizer; it is designed to reduce XSS risk while allowing the wrapper and table markup the module requires. </td></tr><tr><td data-label="Technical Breakdown"> <strong>URL safety test</strong><br><br><code>_is_safe_url(url)</code> rejects <code>javascript:</code> and only allows explicit scheme prefixes (<code>http://</code>, <code>https://</code>, <code>mailto:</code>), path-relative (<code>/</code>, <code>#</code>) and protocol-relative (<code>//</code>) and otherwise checks a permissive URL-character regex. This prevents common inline JS payloads in <code>href</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Link <code>rel</code> post-processing</strong><br><br><code>_enforce_link_rel(html_text)</code> locates <code>&lt;a ... href=&quot;...&quot;&gt;</code> patterns (on sanitized HTML) and adds <code>rel=&quot;noopener noreferrer&quot;</code> to external <code>http(s)</code> and protocol-relative links that lack a <code>rel</code> attribute. It is conservative: it doesn't alter links without <code>href</code> or those already having <code>rel</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Code stashing strategy</strong><br><br><code>_stash_code(text)</code> finds fenced code blocks (``<code> or ~~~ with optional lang) and inline code runs (variable-length backticks) and replaces them with unique placeholders. Returns </code>(text_with_placeholders, fenced_map, inline_map)<code> where </code>fenced_map[key] = (lang, content)<code> and </code>inline_map[key] = content<code>. Regex is robust with a fallback simpler pattern if necessary. Restoration is handled by </code>_restore_code_placeholders<code>, which HTML-escapes code contents and emits </code><pre><code…><code> for fenced blocks and </code><code>` for inline. Placeholders prevent downstream preprocessing (underscore handling, table detection) from affecting code. 
 <strong>Underscore preprocessing rules</strong><br><br><code>_preprocess_underscores_outside_placeholders(text, placeholders)</code> is conservative and intentional: it converts escaped <code>@@ESC_UND@@</code> to <code>&amp;#95;</code>, converts inter-word underscores <code>(?&lt;=\w)_(?=\w)</code> to <code>&amp;#95;</code> (preserving variable/identifier underscores inside words), then escapes any remaining underscores to <code>@@ESC_UND@@</code> so Markdown won't treat them as emphasis. Placeholders (code, fenced, table, emph ph, inline) are preserved exactly. This ensures underscores in plain words are preserved visually while still preventing stray underscores from forming emphasis. 
 <strong>Inline-only cell rendering</strong><br><br><code>_render_cell_inline(text)</code> renders table cell content using only inline constructs: stashes inline code locally, then applies emphasis processing using <code>*</code> only (<code>***</code>, <code>**</code>, <code>*</code> patterns) with placeholders to avoid escaping. It calls <code>_preprocess_underscores_outside_placeholders</code> with the per-cell placeholders to preserve underscores correctly. After protecting placeholders, it escapes all other text via <code>html.escape</code>, reinstates placeholders (emphasis HTML and <code>&lt;code&gt;</code>), then sanitizes the resulting fragment with <code>_sanitize_html</code>. This produces a safe HTML fragment suitable for <code>&lt;td&gt;</code>/<code>&lt;th&gt;</code> without block-level tags. 
 <strong>Pipe splitting & inline-code awareness</strong><br><br><code>_split_unescaped_pipes(line)</code> splits on unescaped pipes while ignoring pipes inside inline code spans: it first replaces inline code with local keys, then converts escaped <code>\|</code> to a sentinel <code>__ESC_PIPE__</code>, trims optional leading/trailing pipe characters, splits on <code>|</code>, trims each cell, restores escaped pipes and inline code placeholders back into backticked form. Guarantees: pipes inside inline code or escaped <code>\|</code> do not act as column separators. 
 <strong>Header separator detection</strong><br><br><code>_table_sep_cell_re = re.compile(r&#x27;^\s*:?-+:?\s*$&#x27;)</code> and <code>_is_header_separator_row(cells)</code> ensure a header separator row contains at least one dash in each cell and matches colon-placement rules for alignment. This strict check reduces false positives for divider detection. 
 <strong>Table rendering (pipe Markdown)</strong><br><br><code>_render_table_block(raw_lines)</code> builds a plain <code>&lt;table&gt;</code> string: splits rows into cells with <code>_split_unescaped_pipes</code>, recognizes optional header+separator, computes column counts and pads ragged rows, renders header cells with <code>_render_cell_inline</code> into <code>&lt;th&gt;</code>, body cells into <code>&lt;td&gt;</code>. Alignment is inferred from the separator row (left/center/right) but not emitted as inline <code>align</code> attributes in this code—alignment is used internally only for selection; returned HTML is simple and sanitized. 
 <strong>CSV block rendering</strong><br><br><code>_render_csv_block(raw_lines)</code> joins raw lines, uses <code>csv.reader</code> to correctly parse quoted fields, falls back to naive comma-split on parse failure, infers header heuristically if first two rows have equal length, pads ragged rows, and renders cells through <code>_render_cell_inline</code> into a <code>&lt;table&gt;</code>. This provides CSV→HTML table support for contiguous comma lines detected by <code>_stash_tables</code>. 
 <strong>Table & CSV stashing algorithm</strong><br><br><code>_stash_tables(text)</code> scans the text line-by-line while respecting fenced code regions. Outside fenced code: it detects contiguous lines containing <code>|</code> and, for such blocks, attempts to parse them via <code>_split_unescaped_pipes</code> into <code>parsed</code>. It flags a block as a table if (a) classic header + separator present, or (b) simple table: all rows have the same number of columns >1. If a table, render via <code>_render_table_block</code> and replace the block by a unique placeholder <code>@@TABLE{n}@@</code> and store the wrapped HTML (<code>&lt;div class=&quot;table-container inline-mode&quot;&gt;{table_html}&lt;/div&gt;</code>) in <code>table_map</code>. If no pipes are present, it also detects contiguous CSV-ish blocks (lines containing comma) and tries to parse with <code>csv.reader</code>; if sufficiently consistent (≥2 rows and >1 columns and reasonable consistency), it converts to a table and stashes similarly. Fenced code blocks are passed through unchanged. 
 <strong>Placeholder restoration ordering</strong><br><br><code>_restore_table_placeholders(html_text, table_map)</code> replaces table placeholders in numeric order (sorted by the embedded number) to reinsert previously rendered table HTML. <code>_restore_code_placeholders</code> restores fenced and inline code placeholders. Restoration occurs after the main markdown conversion so that table HTML and code HTML are not mangled by markdown processing. 
 <strong>Fallback converter behavior</strong><br><br><code>_fallback_markdown_to_html(text, table_map)</code> used when python-markdown path fails. Steps: stash fenced/inline code, convert emphasis via placeholders for <code>***</code>, <code>**</code>, and <code>*</code> (using <code>*</code> only for emphasis), collect placeholder keys including table keys, preprocess underscores outside placeholders, escape everything except placeholders, restore code placeholders, restore table placeholders, split into paragraphs on blank lines and wrap non-fenced/table blocks in <code>&lt;p&gt;</code>. Final output is passed through <code>_sanitize_html</code> and <code>_enforce_link_rel</code>. This fallback is intentionally minimal but safe. 
 <strong>MarkdownRenderer wrapper semantics</strong><br><br><code>MarkdownRenderer</code> encapsulates a call to python-markdown: constructs a <code>markdown.Markdown</code> instance per call with configured extensions (<code>fenced_code</code>, <code>tables</code>, <code>footnotes</code> by default), optionally <code>nl2br</code>, and uses <code>output_format=&quot;html5&quot;</code>. <code>convert(prepped, fenced_map, inline_map, table_map, nl2br)</code> calls <code>md_inst.convert(prepped)</code>, then restores code and table placeholders, then optionally strips <code>&lt;br&gt;</code> tags inside <code>&lt;td&gt;/&lt;th&gt;</code> if <code>strip_table_br</code> is True. A fresh <code>Markdown</code> instance per call ensures isolation. Any exceptions from python-markdown are propagated to the caller to allow fallback. 
 <strong>Cell <code>&lt;br&gt;</code> stripping safety net</strong><br><br><code>MarkdownRenderer</code> includes <code>_cell_pattern</code> and a replacement to remove <code>&lt;br&gt;</code> tags inside table cell elements (optional via <code>strip_table_br</code>). This is a targeted cleanup to preserve visual parity in table cells when <code>nl2br</code> or other extensions may have introduced <code>&lt;br&gt;</code> that break table layouts. 
 <strong>Renderer caching & thread-safety</strong><br><br>Module-level optional LRU: <code>_render_cache</code> (an <code>OrderedDict</code>) guarded by <code>_render_cache_lock</code>. Use <code>configure_render_cache(enabled, maxsize)</code> to enable/disable and set <code>maxsize</code>. <code>_cache_key_for(text, opts)</code> builds a SHA-256 key from a repr of the text and sorted opts. <code>_cache_get</code> / <code>_cache_set</code> update LRU ordering. The cache is protected by locks for thread safety. The renderer singleton <code>_default_renderer</code> is lazily created and protected by <code>_default_renderer_lock</code>. 
 <strong><code>markdown_to_html</code> high-detail flow</strong><br><br>1. Normalize newlines & typographic characters. 2. <code>text, table_map = _stash_tables(text)</code> (catch exceptions). 3. Prepare <code>renderer_call = get_markdown_renderer()</code> and <code>renderer_instance = _default_renderer</code>. 4. Attempt python-markdown path: stash code (<code>_stash_code</code>), compute placeholder keys list, call <code>_preprocess_underscores_outside_placeholders</code> on stashed text, optionally check cache key and return cached if enabled. 5. Call <code>renderer_call(prepped, fenced_map, inline_map, table_map, nl2br=False)</code> (renderer returns HTML), then sanitize and enforce link rel, set cache and return. 6. If renderer raises, try an alternate <code>get_markdown_renderer</code> with minimal extensions. 7. If python-markdown unavailable or both attempts fail, call fallback <code>_fallback_markdown_to_html(text, table_map)</code>; sanitize and cache fallback result. 8. Final fallback returns <code>&lt;pre&gt;escaped input&lt;/pre&gt;</code> and logs exception. 
 <strong>Error handling philosophy</strong><br><br>Most operations are <code>try/except</code>-wrapped at call sites in <code>markdown_to_html</code>. Python-markdown errors are logged (debug) and trigger fallback. The module prefers returning a safe, escaped string rather than raising when possible — consistent with the embedding requirement to avoid breaking hosts. Where python-markdown is used directly in <code>MarkdownRenderer.convert</code>, exceptions are propagated so the outer caller can decide to fallback. 
 <strong>Security & XSS mitigations</strong><br><br>Key mitigations: (1) stash/restore ensures code blocks do not get executed or reinterpreted; (2) <code>_sanitize_html</code> re-escapes all tags then re-opens a narrow allowlist with attribute filtering; (3) <code>_is_safe_url</code> prevents <code>javascript:</code> in <code>href</code>; (4) <code>_enforce_link_rel</code> adds <code>rel</code> attrs to external links; (5) placeholders prevent pre/post-processing from injecting tags into code or table HTML. Caveat: the sanitizer is not a substitute for a full, audited HTML sanitizer; hosts with high threat models should run a dedicated HTML sanitizer or further restrict allowed tags/attributes. 
 <strong>Return types & shapes</strong><br><br><code>markdown_to_html</code> → <code>str</code> (final sanitized HTML). <code>get_markdown_renderer</code> → callable <code>.convert(prepped, fenced_map=None, inline_map=None, table_map=None, nl2br=None) -&gt; str</code>. <code>_stash_tables</code> → <code>(str, Dict[key-&gt;html])</code>. <code>_stash_code</code> → <code>(str, fenced_map, inline_map)</code>. <code>_render_table_block</code> / <code>_render_csv_block</code> → <code>str</code> table HTML. 
 <strong>Performance characteristics</strong><br><br>Typical-case performance is linear O(N) with several passes over the input (stash tables, stash code, underscore preprocess, markdown convert, restore). Heavy regex and repeated escapes add overhead. Python-markdown conversion cost depends on extensions and input size; creating a new <code>Markdown</code> instance per call increases CPU overhead but favors isolation. Cache avoids repeated markdown work. Memory: string-building and <code>table_map</code> may duplicate content; for very large documents consider enabling streaming or limiting cache size. 
 <strong>Edge cases & brittle areas</strong><br><br>1. <code>_sanitize_html</code> uses a simple reopen approach that may not correctly parse nested or malformed tags; extremely malformed HTML may escape unexpectedly. 2. Placeholder key collisions: keys like <code>@@TABLE0@@</code> are deterministic based on insertion order; if two separate flows mix content, collisions could happen — map keys are numeric-scoped per-call so risk is low but worth namespacing in integration. 3. Regex-based fenced detection uses matching fence tokens per line; unusual mixed fence styles or partial fences could confuse <code>in_fenced</code> state in <code>_stash_tables</code>. 4. CSV detection heuristic in <code>_stash_tables</code> may treat comma-heavy prose as CSV if it passes <code>csv.reader</code> into >1 columns — the code attempts consistency checks but false positives remain possible. 5. The fallback sanitizer is simple — for high-security contexts, use a vetted library (Bleach, html-sanitizer). 
 <strong>Testing checklist — concrete cases</strong><br><br>Unit tests to include: (A) fenced blocks with ``<code> and ~~~ with/without language tags and restoration, (B) inline code with variable backtick counts and containing pipes/backslashes/newlines, (C) underscores in words like </code>var_name<code> preserved, </code>a_b<code> preserved but </code><em>a<code> or </code>a</em><code> handled correctly per rules, (D) emphasis only via </code><em><code> not </code><em><code> e.g., </code></em>em<em><code> → </code><em>em</em><code>, </code>_em</em><code> → literal underscore preserved, (E) pipe-table parsing including leading/trailing pipes, escaped </code>\|<code>, header separator forms </code>:---:<code>, </code>:---<code>, </code>---:<code>, (F) CSV blocks with quoted commas and multiline quoted fields, (G) placeholders restored in the right order and no double-escaping, (H) sanitizer rejects </code><script><code> and removes </code>onclick<code> attributes but preserves allowed tags and </code>data-</em><code> attributes, (I) link rel enforcement for </code>http<code>/</code>https<code> and leaving local </code>#<code>/</code>/<code> untouched, (J) caching behavior: enable cache and confirm identical outputs for repeated inputs and eviction when </code>maxsize` exceeded. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Integration & configuration knobs</strong><br><br>Exposed knobs: <code>configure_render_cache(enabled, maxsize)</code> to enable/disable cache; <code>get_markdown_renderer(config)</code> accepts <code>extensions</code>, <code>strip_table_br</code>, <code>nl2br</code>. Recommended integration-time options: namespace table placeholders if embedding multiple renderers, pass a renderer with exact extension list to avoid differing behaviors, and prefer <code>strip_table_br=False</code> when wanting to preserve <code>&lt;br&gt;</code> in table cells (module default sets this for deployment). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recommended improvements & hardening</strong><br><br>1. Replace <code>_sanitize_html</code> with a well-tested library (e.g., <code>bleach</code>) and configure allowlist explicitly to avoid subtle parsing bugs. 2. Make placeholder tokens cryptographically unique per-call (<code>uuid4</code>) to eliminate collision risk in multi-threaded or multi-render contexts. 3. Expose a <code>table_placeholder_prefix</code> or namespace in <code>get_markdown_renderer</code> and <code>_stash_tables</code> to avoid cross-talk. 4. Consider reusing a thread-local or pooled <code>markdown.Markdown</code> instance when isolation is not required to reduce instance allocation overhead. 5. Add an option to skip CSV auto-detection or require an explicit opt-in to avoid false positive table captures in prose. 6. Extend tests to include pathological regex backtracking cases and long inputs to benchmark and guard against DoS-like slowdowns. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Operational notes & logging</strong><br><br>Logger name <code>render.markdown</code> uses <code>NullHandler</code> by default only if configured externally; integration should configure handlers and set DEBUG during development. The module logs renderer failures with <code>logger.debug</code> and exceptions with <code>logger.exception</code> in <code>markdown_to_html</code> fallback. Provide an integration debug flag to surface parse warnings in metadata (currently metadata is not returned; adding a debug payload could help). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Security review summary</strong><br><br>Overall the module reduces common XSS risks via placeholder isolation and a conservative allowlist sanitizer. Remaining risk vectors: sanitizer limitations (not DOM-aware), CSV/table HTML produced by module trusted and reinserted directly (ensure wrapping context is safe), and possible link/url edge cases. Recommendation: for high-security deployments, post-process output with a dedicated sanitizer and strict CSP. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Return shapes & function contracts (explicit)</strong><br><br><code>_stash_tables(text) -&gt; (string_with_placeholders, table_map: Dict[str,html_fragment])</code><br><code>_stash_code(text) -&gt; (string_with_placeholders, fenced_map: Dict[key-&gt;(lang,content)], inline_map: Dict[key-&gt;content])</code><br><code>_render_table_block/raw -&gt; html string</code><br><code>MarkdownRenderer.convert(prepped, fenced_map=None, inline_map=None, table_map=None, nl2br=None) -&gt; str (html)</code><br><code>markdown_to_html(md_text) -&gt; str (sanitized html)</code> </td></tr><tr><td data-label="Technical Breakdown"> <strong>Verification statement — "check 10 times"</strong><br><br>Performed a careful code-path inspection covering: regexes for fences and inline code, placeholder lifecycle (stash → transform → restore), table/CSV detection heuristics, underscore preprocessing across placeholder boundaries, sanitizer allowlist and attribute filtering, link <code>rel</code> enforcement logic, MarkdownRenderer instantiation and per-call isolation, caching key composition and thread locks, fallback converter behavior, and restoration ordering. The breakdown maps these behaviors back to the code and highlights brittle areas and recommended mitigations. </td></tr></tbody></table></div><div class="row-count">Rows: 13</div></div><div class="table-caption" id="Table2" data-table="Docu_0123_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2 • sanitize.py</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module purpose & contract</strong><br><br><code>render/sanitize.py</code> provides robust HTML sanitization utilities for the renderer. Primary export: <code>sanitize_html(html_text: str, allow_tables: bool = False) -&gt; str</code>. Goals: remove dangerous tags/attributes, enforce URL safety, optionally allow table markup, prefer <code>bleach</code> if installed with a safe fallback using <code>html.parser</code>. The module intentionally omits <code>&lt;br&gt;</code> from the default allowlist to avoid <code>&lt;br&gt;</code>-based injection in table cells. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Public functions & returns</strong><br><br><code>sanitize_html(html_text, allow_tables=False)</code> → sanitized HTML string (empty string for non-strings). <code>bleach_clean(html_text, allowed_tags)</code> → best-effort cleaning via <code>bleach</code> (returns input unchanged if <code>bleach</code> missing). <code>fallback_clean(html_text, allowed_tags)</code> → HTMLParser-based conservative sanitizer. <code>is_safe_url(url)</code> → bool. Internal helpers: <code>_attr_allowed_for_tag</code>, <code>_neutralize_script_tags_outside_code</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Allowlist & attribute policy</strong><br><br><code>ALLOWED_TAGS</code> is a conservative set (no <code>br</code>). <code>ALLOWED_ATTRIBUTES</code> maps <code>&quot;*&quot;</code> for global attributes plus per-tag allowed attributes; supports wildcards like <code>aria-*</code> and <code>data-*</code>. <code>ALLOWED_PROTOCOLS</code> lists allowed URL schemes. Attribute policy is enforced case-insensitively and supports prefix wildcards. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Image data whitelist</strong><br><br><code>IMG_DATA_MIME</code> strictly matches <code>data:image/(png|jpeg|jpg|gif|webp);base64,...</code> to allow only common image MIME types for <code>data:</code> URIs. This mitigates open <code>data:</code> abuse for non-image payloads. </td></tr><tr><td data-label="Technical Breakdown"> <strong>URL safety</strong><br><br<code>is_safe_url(url)</code> uses <code>urllib.parse.urlparse</code>. Relative URLs (no scheme) are allowed. Schemes allowed: <code>http</code>, <code>https</code>, <code>mailto</code>. <code>data:</code> allowed only if <code>IMG_DATA_MIME</code> matches. Function returns <code>False</code> on parse error or empty input. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Attribute allowance algorithm</strong><br><br<code>_attr_allowed_for_tag(attr_name, tag)</code> lowers names and checks global (<code>*</code>) and tag-specific lists. Supports <code>endswith(&#x27;*&#x27;)</code> wildcard matching for attributes like <code>data-*</code> and <code>aria-*</code>. Returns boolean. This centralizes attribute policy for both bleach and fallback flows. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Bleach-backed cleaning flow</strong><br><br<code>bleach_clean(html_text, allowed_tags)</code> uses <code>bleach.clean(..., tags=tags, attributes=ALLOWED_ATTRIBUTES, protocols=ALLOWED_PROTOCOLS, strip=True)</code> when <code>bleach</code> is present. Then attempts <code>bleach.linkify(cleaned)</code> (best-effort). Post-processes start-tags via <code>START_TAG_RE</code> to re-validate and escape attribute values and drop disallowed attributes (especially <code>on*</code> and <code>style</code>). For <code>href</code>/<code>src</code> attributes it enforces <code>is_safe_url</code> before re-emitting them. If <code>bleach</code> not available, it returns the original <code>html_text</code> (caller must fall back to <code>fallback_clean</code>). </td></tr><tr><td data-label="Technical Breakdown"> <strong>START_TAG_RE post-processing details</strong><br><br<code>START_TAG_RE = re.compile(r&#x27;(&lt;\s*([a-zA-Z0-9:_-]+)([^&gt;]*)\s*(/?)&gt;)&#x27;, flags=...)</code> matches opening tags; <code>_sanitize_tag</code> parses attribute pairs conservatively with <code>re.findall</code>, filters attributes (drops <code>on*</code>, <code>style</code>), enforces <code>_attr_allowed_for_tag</code>, validates <code>href/src</code> with <code>is_safe_url</code>, HTML-escapes values, and re-emits sorted safe-attrs to avoid unexpected ordering. If no safe attrs remain emits bare open tag. This mitigates attribute-level attacks left after <code>bleach</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Fallback cleaner architecture</strong><br><br<code>FallbackCleaner(HTMLParser)</code> implements a streaming, DOM-less sanitizer: on <code>handle_starttag</code> it checks the tag against <code>allowed</code> set, filters attributes like the bleach post-processor (drops <code>on*</code>, <code>style</code>), enforces <code>is_safe_url</code> for <code>href/src</code>, escapes attribute values, and appends safe <code>&lt;tag ...&gt;</code> to output. <code>handle_data</code> always HTML-escapes text. <code>handle_endtag</code> emits end tags only for allowed tags. <code>handle_entityref</code> and <code>handle_charref</code> pass-through entities. If parsing fails, <code>fallback_clean</code> returns <code>html.escape(html_text)</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Script neutralization outside code/pre</strong><br><br<code>_neutralize_script_tags_outside_code(text)</code> splits on <code>&lt;pre&gt;...&lt;/pre&gt;</code> and <code>&lt;code&gt;...&lt;/code&gt;</code> blocks, leaves code blocks intact, and replaces <code>&lt;script</code> and <code>&lt;/script</code> with <code>&lt;script</code>/<code>&lt;/script</code> only in non-code segments. This prevents removal or mangling of literal code examples while neutralizing executable script tags in rendered HTML. Used as a second pass after bleach/fallback cleaning. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Top-level <code>sanitize_html</code> algorithm</strong><br><br1. Validate input type (non-string → empty). 2. Choose allowed tags based on <code>allow_tables</code> (if False, drop table-related tags). 3. If <code>bleach</code> installed, call <code>bleach_clean(..., allowed_tags)</code> else <code>fallback_clean(..., allowed_tags)</code>. 4. Call <code>_neutralize_script_tags_outside_code</code> on the cleaned result. 5. Return final string. All steps defend against inline JS attributes and disallowed tags; exceptions are caught at callers when necessary. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Behavioral decisions documented in header</strong><br><br> - <code>br</code> deliberately removed from allowed tags to prevent <code>&lt;br&gt;</code> injection in table cells. - Attribute filtering is primary defense for inline JS. - <code>bleach</code> is optional; fallback HTMLParser cleaner used when absent. - Script tags neutralized outside <code>&lt;pre&gt;/&lt;code&gt;</code> to preserve code examples. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Edge cases & brittle areas</strong><br><br>1. <code>bleach_clean</code> returns original <code>html_text</code> unchanged if <code>bleach</code> is not present — but <code>sanitize_html</code> immediately falls back to <code>fallback_clean</code> so final behavior is safe. 2. Regex-based <code>START_TAG_RE</code> parsing of attributes is not a full HTML parser and could mis-handle malformed tags; however it runs after bleach so input should be normalized. 3. <code>is_safe_url</code> allows relative URLs (intended) — integrations should ensure this matches policy. 4. <code>IMG_DATA_MIME</code> allows only a fixed set of image types; other data-URIs are rejected. 5. <code>fallback_clean</code> escapes text nodes but removes disallowed tags entirely (not their inner text) — this may drop content the caller expects. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Security review — mitigations & residual risks</strong><br><br>Mitigations: strict allowed-tag set; attribute filtering including dropping <code>style</code> & <code>on*</code>; href/src validation; script neutralization outside code; use of <code>bleach.linkify</code> only when available; fallback parser escapes text. Residual risks: <code>START_TAG_RE</code> may misparse edge-case attributes; fallback_clean's simplified tag handling could allow unexpected attribute forms if browser parses differently; recommend running outputs through a vetted sanitizer (Bleach with a locked config) in hostile environments. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Performance characteristics</strong><br><br>Typical performance is linear in HTML length. <code>bleach.clean</code> is the most expensive step when available; <code>fallback_clean</code> using <code>HTMLParser</code> is streaming and efficient for most inputs. <code>START_TAG_RE</code> substitution iterates over tags and attributes; post-processing adds CPU but acceptable for normal page sizes. For very large documents or high throughput, prefer enabling <code>bleach</code> with configured allowed lists or pre-filter inputs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Testing checklist (concrete cases)</strong><br><br>Essential tests: (A) <code>&lt;script&gt;</code> removal/neutralization inside/outside code blocks; (B) <code>onclick=&quot;...&quot;</code> and <code>style=&quot;...&quot;</code> attributes removed; (C) <code>href=&quot;javascript:...&quot;</code> rejected, <code>href=&quot;/path&quot;</code> and <code>href=&quot;http://...&quot;</code> allowed; (D) <code>data:</code> image allowed only for PNG/JPEG/JPG/GIF/WEBP base64; (E) table tags preserved only when <code>allow_tables=True</code>; (F) nested allowed tags preserved and attributes escaped; (G) malformed or unclosed tags do not produce executable output; (H) bleach path and fallback path produce consistent safe outputs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Integration notes & recommended policies</strong><br><br> - Prefer installing and using <code>bleach</code> in production and lock configuration to avoid regression. - If <code>allow_tables</code> is True, ensure downstream rendering contexts (e.g., innerHTML) are safe and that <code>&lt;br&gt;</code> handling is deliberate. - Consider adding optional policy knobs: stricter <code>ALLOWED_TAGS</code>, disallow relative URLs, or whitelist hosts for external links. - For CSP-sensitive deployments, pair sanitizer with a strict CSP policy. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recommended hardening & improvements</strong><br><br>1. Replace <code>START_TAG_RE</code> attribute parsing with an actual HTML parser (e.g., <code>lxml</code> or use bleach attributes callbacks) to avoid regex pitfalls. 2. Make <code>ALLOWED_TAGS</code> and <code>ALLOWED_ATTRIBUTES</code> configurable at runtime to support per-integration policies. 3. Expose a <code>strict_image_types</code> toggle to enable/disable <code>data:</code> images entirely. 4. Add unit tests asserting exact sanitized outputs for a broad corpus of malicious samples. 5. Consider canonicalizing URLs (via <code>urljoin</code>) before <code>is_safe_url</code> checks when relative URLs must be resolved. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Return types & function contracts</strong><br><br><code>sanitize_html(html_text: str, allow_tables: bool=False) -&gt; str</code> — sanitized HTML. <code>bleach_clean</code>/<code>fallback_clean</code> return sanitized HTML or escaped input on parse failure. <code>is_safe_url(url)</code> returns bool. All functions return safe string outputs and avoid raising on malformed inputs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Verification statement — "checked 10 times"</strong><br><br>Verified these areas across the code: 1) allowed tag list and omission of <code>&lt;br&gt;</code>, 2) attribute wildcards and matching logic, 3) <code>is_safe_url</code> semantics including <code>data:</code> handling, 4) <code>IMG_DATA_MIME</code> strictness, 5) <code>bleach_clean</code> invocation and <code>linkify</code> handling, 6) <code>START_TAG_RE</code> post-processing logic, 7) <code>FallbackCleaner</code> parsing/emission behavior, 8) script neutralization outside <code>&lt;pre&gt;/&lt;code&gt;</code>, 9) top-level <code>sanitize_html</code> selection of allowed tags controlled by <code>allow_tables</code>, 10) error/exception fallback behavior and final return shapes. Observations above reflect those inspections. </td></tr></tbody></table></div><div class="row-count">Rows: 20</div></div><div class="table-caption" id="Table3" data-table="Docu_0123_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3 • types.py</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown —  CODE0  (Render types &amp; configuration container)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown —  CODE0  (Render types & configuration container)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Summary / Purpose</strong><br><br><code>render/types.py</code> is a small, focused module that defines lightweight type aliases used across the renderer and a single <code>@dataclass</code> (<code>RenderConfig</code>) that centralizes runtime configuration for rendering operations. It provides default values and one helper method (<code>resolved_assets_dir</code>) to compute an assets directory relative to an output directory. The file's responsibilities are intentionally narrow: provide stable types and a convenient config object passed throughout rendering code paths. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>High-level guarantees & design principles</strong><br><br>• <strong>Minimal surface</strong>: only exports simple aliases and a single configuration dataclass to keep API small and easy to mock in tests.<br>• <strong>Conservative defaults</strong>: sensible defaults for cache size, parallelism, and asset bundling that make the renderer usable out-of-the-box.<br>• <strong>Runtime-friendly annotations</strong>: uses <code>from __future__ import annotations</code> so annotations are forward-compatible and avoid runtime import costs.<br>• <strong>Practical composition</strong>: the dataclass contains both declarative fields (flags, sizes) and operational hooks (<code>cancel_event</code>, <code>progress_callback</code>) for integration with task loops. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Top-level structure & exports</strong><br><br>• Type aliases: <code>RenderResult = Dict[str, Any]</code>, <code>TableLike = Any</code>.<br>• Dataclass: <code>RenderConfig</code> with fields and <code>resolved_assets_dir(out_dir: Path)</code> helper.<br>• No module-level logger initialization nor <code>__all__</code> list — consumers import names directly. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Key components & responsibilities (concise)</strong><br><br><strong>1. Type aliases</strong> — <code>RenderResult</code> acts as a loose shape for renderer outputs (metadata + HTML etc.), while <code>TableLike</code> is a permissive alias for table-like inputs (<code>pandas.DataFrame</code>, lists-of-rows, or any object with <code>to_html</code>). Designed to avoid coupling to concrete types.<br><br><strong>2. <code>RenderConfig</code> dataclass</strong> — main configuration container. Fields:<br>• <code>log_level: int</code> — logging verbosity.<br>• <code>assets_dir: Optional[Path | str]</code> — explicit assets directory (optional).<br>• <code>embed_assets: bool</code> — inline CSS/JS.<br>• <code>bundle_assets: bool</code> — output bundled assets folder.<br>• <code>cache_size: int</code> — LRU cache capacity.<br>• <code>table_render_timeout_ms: Optional[int]</code> — per-table timeout; <code>None</code> disables.<br>• <code>split_threshold: int</code> — heuristic for splitting large tables.<br>• <code>max_workers: int</code> — concurrency limit.<br>• <code>table_row_limit: int</code> — maximum allowed table rows.<br>• <code>cancel_event: Optional[Event]</code> — cancel cooperative tasks.<br>• <code>progress_callback: Optional[Callable[[int, int], None]]</code> — <code>(processed, total)</code> hook.<br>• <code>gzip_out: bool</code> — output gzipped artifacts.<br><br><strong>3. Helper method</strong> — <code>resolved_assets_dir(out_dir: Path) -&gt; Path</code> returns <code>assets_dir</code> if given, otherwise <code>&lt;out_dir&gt;/assets</code>. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Detailed behavior & important implementation notes</strong><br><br><strong>Annotations & compatibility</strong> — the file uses <code>from __future__ import annotations</code>, so type expressions like <code>Path | str</code> remain stringified at runtime and are compatible with Python 3.7+. If the project targets Python ≥3.10, the <code>|</code> union is native; with the <code>__future__</code> import it is safe otherwise.<br><br><strong>Resolved assets path</strong> — <code>resolved_assets_dir</code> simply returns <code>Path(self.assets_dir)</code> when <code>assets_dir</code> is truthy, otherwise <code>Path(out_dir) / &quot;assets&quot;</code>. It does <strong>not</strong> (a) call <code>.resolve()</code>; (b) create the directory; or (c) validate the returned path. Callers should run <code>ensure_dir()</code> or similar if they need creation or canonicalization.<br><br><strong>Timeout units</strong> — <code>table_render_timeout_ms</code> is in <strong>milliseconds</strong> (<code>500</code> by default). Callers must convert to seconds for APIs requiring seconds. Consider documenting the units externally if this is a public API.<br><br><strong>Cancellation & progress hooks</strong> — <code>cancel_event</code> is a <code>threading.Event</code> enabling cooperative cancellation. The dataclass stores it but does not expose helper wrappers (like <code>should_cancel()</code>, <code>wait_for_cancel()</code>). <code>progress_callback</code> is typed <code>Callable[[int, int], None]</code> but the semantics (argument order, meaning, units) are not defined inside the module; callers must follow a shared contract (e.g., <code>(processed, total)</code> or <code>(percent, max)</code> conventions).<br><br><strong>Defaults & operational assumptions</strong> — <code>max_workers=4</code> and <code>cache_size=100</code> reflect small/medium desktop defaults. Larger environments may wish to adjust. <code>bundle_assets=True</code> and <code>embed_assets=False</code> imply a file-based deployment model by default. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Technical Breakdown — <code>render/types.py</code> (Render types & configuration container)</strong> </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Error handling, robustness & failure modes</strong><br><br>• <strong>No internal validation</strong>: <code>RenderConfig</code> does not validate field ranges (e.g., <code>max_workers &gt; 0</code>, <code>cache_size &gt;= 0</code>, <code>table_row_limit &gt;= 0</code>) — misconfiguration may surface deeper in renderer logic as runtime errors.<br>• <strong>assets_dir types</strong>: <code>resolved_assets_dir</code> constructs <code>Path(self.assets_dir)</code> without guarding against non-path-like objects; if <code>self.assets_dir</code> is an object that can't be converted, a <code>TypeError</code> may be raised.<br>• <strong>Cancellation race</strong>: since <code>cancel_event</code> is optional, consumer code must defensively handle <code>None</code> and avoid calling <code>.is_set()</code> unguarded.<br>• <strong>Progress callback exceptions</strong>: if the callback raises an exception and the caller doesn't guard it, rendering threads may break. Recommend wrapping callback invocation in <code>try/except Exception</code>. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Concurrency / performance considerations</strong><br><br>• <strong>Thread-safety</strong>: <code>RenderConfig</code> is a mutable dataclass; safe for read-only use across threads, unsafe if mutated without synchronization.<br>• <strong>Event-driven cancellation</strong>: <code>cancel_event: Event</code> is an appropriate cooperative cancellation mechanism; tasks must check it periodically.<br>• <strong>Per-table timeout</strong>: <code>table_render_timeout_ms</code> implies callers should implement per-table timeouts (futures, watchdogs) and coordinate them with <code>cancel_event</code>. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Edge cases & brittle areas</strong><br><br>1. <strong>Units confusion</strong> — Using milliseconds in a codebase that often uses seconds is a common source of bugs; expose a <code>.table_render_timeout_seconds()</code> helper.<br>2. <strong>Relative vs absolute asset paths</strong> — <code>resolved_assets_dir</code> returns the path unchanged; relative paths may cause surprises. Consider <code>Path(...).expanduser()</code> or <code>.resolve()</code>.<br>3. <strong>Missing validation</strong> — Negative values for worker counts, cache sizes, or split thresholds are not prevented.<br>4. <strong>Undocumented callback semantics</strong> — The signature and expected arguments for <code>progress_callback</code> are implied but not enforced. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Integration points & extension hooks</strong><br><br>• Add <code>__post_init__</code> validation: normalize paths, validate numeric ranges, optionally auto-create a default <code>Event()</code>.<br>• Add convenience helpers: <code>as_dict()</code>, <code>with_overrides(**kw)</code>, <code>table_timeout_seconds</code>.<br>• Introduce <code>TypedDict</code> for <code>RenderResult</code> for better static typing.<br>• Add <code>report_progress(done, total)</code> wrapper that catches exceptions. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Recommendations & maintainability notes</strong><br><br>• Normalize and validate in <code>__post_init__</code> (path coercion, range validation).<br>• Prefer <code>timedelta</code> or dual properties (ms + seconds helper).<br>• Document callback semantics explicitly.<br>• Consider immutability (<code>frozen=True</code>) or cloning helpers to avoid accidental mutation when passed to threads.<br>• Add <code>__all__ = [&quot;RenderConfig&quot;, &quot;RenderResult&quot;, &quot;TableLike&quot;]</code> for explicit exports. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Short checklist for integration</strong><br><br>• <code>resolved_assets_dir(out_dir)</code> must yield a usable <code>Path</code>.<br>• Convert ms → seconds where needed.<br>• Guard accesses to <code>cancel_event</code> when it's <code>None</code>.<br>• Wrap <code>progress_callback</code> safely.<br>• Avoid mutating <code>RenderConfig</code> after passing it to threads (or use immutable/clone-with-override patterns). </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Render types &amp; configuration container)"> <strong>Conclusion</strong><br><br><code>render/types.py</code> is minimal and practical. Adding explicit validation, path normalization, unit clarity, safe callback wrapping, and optional convenience helpers will greatly reduce subtle bugs without increasing complexity. </td></tr></tbody></table></div><div class="row-count">Rows: 13</div></div><div class="table-caption" id="Table4" data-table="Docu_0123_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4 • core_fragments.py</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown —  CODE0  (Concurrent fragment renderer & table extraction)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Summary / Purpose</strong><br><br><code>core_fragments.py</code> centralizes detection, normalization, conversion, and concurrent rendering of heterogeneous “table-like” inputs — DataFrames, lists/dicts, markdown pipe-tables, fenced CSV/TSV, raw CSV/TSV, and <code>&lt;table&gt;</code> HTML. It prefers project bridges (<code>convert</code>, <code>core_table</code>, <code>io_utils</code>) when available and falls back to local heuristics. It writes fragments atomically, assigns deterministic IDs, embeds minimal metadata, and returns a compact summary with paths, row counts, captions, warnings. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>High-level guarantees & design principles</strong><br><br>• <strong>Progressive enhancement</strong> — external helpers first.<br>• <strong>Resilience</strong> — broad try/except coverage.<br>• <strong>Detection-first</strong> — pipe-tables → fenced CSV → raw CSV/TSV → HTML tables.<br>• <strong>Concurrent rendering</strong> — threads by default; processes when renderer is picklable.<br>• <strong>Deterministic IDs</strong> — SHA-1–derived from <code>(source, index)</code>. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Top-level structure & exports</strong><br><br>• Normalization utilities: <code>_normalize_table_text</code>, <code>_split_row_keep_code</code>, <code>_split_pipe_cells</code>, <code>_is_divider_line</code>.<br>• Extraction: <code>_extract_pipe_tables_from_markdown</code>, <code>_extract_table_blocks_from_html</code>, <code>_parse_table_html_regex</code>.<br>• CSV helpers: <code>_is_probable_csv</code>, <code>_parse_csv_text_to_rows</code>.<br>• DF-like conversion: <code>_convert_rows_to_df_like</code>.<br>• Rendering: <code>_simple_render_table</code>, <code>_process_simple_render_job</code>, <code>_call_render_table</code>.<br>• IO/IDs: <code>_atomic_write_text</code>, <code>_make_placeholder</code>, <code>_encode_placeholder_value</code>, <code>generate_fragment_id</code>, <code>_sanitize_caption_for_json</code>.<br>• Main API: <code>render_fragments_concurrently(...)</code> + convenience wrappers. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Key components & responsibilities (concise)</strong><br><br>1. <strong>Input normalization</strong> — accepts bytes/paths/DFs/lists/dicts/strings → canonical <code>inputs</code> with <code>value</code> + <code>meta</code>.<br>2. <strong>Detection pipeline</strong> — markdown-bridge → pipe-tables → fenced CSV → raw CSV/TSV → HTML extraction (bs4 or regex).<br>3. <strong>CSV parsing</strong> — <code>csv.Sniffer</code> + heuristic header detection.<br>4. <strong>HTML extraction</strong> — BeautifulSoup when available; regex fallback.<br>5. <strong>Rendering</strong> — prefer <code>core_table.render_table</code>; else external renderer; else <code>_simple_render_table</code>. Thread worker = <code>_render_job</code>; process worker = <code>_process_simple_render_job</code>.<br>6. <strong>Concurrency</strong> — threads default; processes only if <code>pickle.dumps(renderer)</code> succeeds.<br>7. <strong>Atomic writes & metadata</strong> — writes fragment safely; metadata includes IDs, captions, assets, detection type, timings, preview. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Detailed behavior & important implementation notes</strong><br><br><strong>Input coercion & typing</strong> — Permissive by design: bytes decoded with utf-8/latin-1; file paths read to text; DataFrames detected via <code>columns</code> + <code>itertuples</code>; lists-of-dicts/dicts coerced into list-of-dicts form. Ambiguous shapes may yield different interpretations depending on runtime form. <br><br><strong>Table-detection order & rationale</strong> — Purpose-built bridges first → pipe-tables → fenced CSV → raw CSV heuristics → HTML-table extraction. This preserves author intent and minimizes accidental captures, though mixed markdown/code-block inputs can still be ambiguous. <br><br><strong>Pipe-cell splitting</strong> — <code>_split_row_keep_code</code> processes characters sequentially, honoring inline backticks and escaped <code>\|</code>. It toggles <code>in_backtick</code> on every backtick, which works for common inline code but does not model full markdown rules; unusual fence/backtick patterns may confuse it. <br><br><strong>HTML extraction fallback</strong> — Without <code>bs4</code>, <code>_parse_table_html_regex</code> extracts <code>&lt;tr&gt;</code> and <code>&lt;td&gt;/&lt;th&gt;</code> with regex, stripping tags. Effective for simple cases but fragile with malformed HTML, <code>&gt;</code> inside attributes, or nested elements. Errors are logged and fallback remains graceful. <br><br><strong>Deterministic IDs</strong> — <code>generate_fragment_id</code> computes a SHA-1 of <code>f&quot;{source}|{idx}&quot;</code>, returning the first 8 hex chars. Stable and cache-friendly; collision probability is extremely low but non-zero. <br><br><strong>Caption sanitization</strong> — <code>_sanitize_caption_for_json</code> only collapses whitespace and applies <code>html.escape</code>. It is intentionally minimal and not a security sanitizer; comments advise switching to project-level <code>sanitize.py</code> for robust handling. <br><br><strong>Asset detection</strong> — <code>_detect_assets_from_html</code> uses regex/substring probes to infer needed resources (<code>prismjs</code>, <code>xlsx.full.min.js</code>, <code>virtualize</code>). Loose coupling by design; accuracy depends on HTML structure. <br><br><strong>Atomic writes</strong> — Tries <code>_atomic_stream_write</code> from <code>io_utils</code>; otherwise writes to a sibling <code>.tmp</code> file and commits via <code>os.replace</code>. Ensures parent dirs exist and avoids cross-filesystem failures. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Concurrency, performance & resource notes</strong><br><br>• <strong>Thread vs Process</strong> — threads are default; processes only when <code>pickle.dumps(renderer)</code> succeeds. Process workers use <code>_process_simple_render_job</code> with <code>_simple_render_table</code> (reduced features).<br>• <strong>Worker sizing</strong> — <code>max(1, min(len(inputs) or 1, max_workers or 1))</code>.<br>• <strong>Profiling</strong> — stores <code>render_time_ms</code> / <code>write_time_ms</code> for each fragment.<br>• <strong>Heavy steps</strong> — regex HTML scanning, <code>csv.Sniffer</code>, large CSV loads, pandas conversions. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Error handling & failure modes</strong><br><br>• All major operations wrapped in try/except; failures produce warnings instead of raising.<br>• Rendering failure → fallback HTML (“fragment render failed”).<br>• Process-pool failure → thread fallback + <code>process_fallback</code> warning.<br>• Atomic write failure → warning added but continues.<br>• Many exceptions logged via <code>logger.exception</code> but not all details surfaced in warnings. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Edge cases & brittle areas</strong><br><br>1. <strong>Regex HTML parsing</strong> is unreliable for nested/invalid HTML.<br>2. <strong>Backtick handling</strong> in <code>_split_row_keep_code</code> fails for multi-backtick sequences containing backticks.<br>3. <strong>CSV sniffing</strong> on small sample may misdetect delimiters.<br>4. <strong>Picklability check</strong> (<code>pickle.dumps(renderer)</code>) may incorrectly reject/accept some renderers.<br>5. <strong>Short SHA-1 IDs</strong> could collide.<br>6. <strong>Atomic write</strong> may break across filesystems.<br>7. <strong>Excessive try/except</strong> can hide root failures. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Integration points & extension hooks</strong><br><br>• Optional <code>convert.*</code> helpers override local parsing.<br>• Optional <code>core_table.render_table</code> for rich HTML (captions/assets).<br>• Optional <code>io_utils._atomic_stream_write</code> for safer atomic writes.<br>• Config <code>cfg</code> supports <code>emit_caption_payload</code> and dict/attribute access.<br>• <code>generate_fragment_id</code> replaceable with UUID or longer hash. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Concrete recommendations & maintainability notes</strong><br><br>1. Promote BeautifulSoup/lxml parsing.<br>2. Implement proper backtick-run matching.<br>3. Improve CSV heuristics (bigger samples, caller hints).<br>4. Replace picklability gate with explicit “simple-mode renderer”.<br>5. Strengthen caption sanitization using <code>sanitize.py</code>.<br>6. Increase ID length.<br>7. Add thorough tests for pipe-tables, CSV quoting, worker fallbacks, malformed HTML.<br>8. Add structured logs for observability. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Short CI checklist</strong><br><br>• Pipe-table detection preserves escaped pipes and inline code.<br>• Fenced CSV/TSV blocks parsed with correct delimiter.<br>• Raw CSV detection behaves correctly.<br>• HTML extraction correct with bs4 and acceptable without.<br>• Fragment metadata stable (IDs, captions).<br>• Process fallback behaves reliably.<br>• <code>assets_required</code> inferred accurately.<br>• <code>emit_caption_payload</code> switches JSON payload on/off. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Concurrent fragment renderer &amp; table extraction)"> <strong>Conclusion</strong><br><br><code>core_fragments.py</code> is a defensive, multi-input normalization + concurrent fragment renderer. Strong on graceful degradation and pluggability; weaker on HTML regex fallback, CSV edge cases, and process-mode design. Reinforcing sanitization, parser robustness, and ID strategy will significantly improve reliability for untrusted inputs. </td></tr></tbody></table></div><div class="row-count">Rows: 12</div></div><div class="table-caption" id="Table5" data-table="Docu_0123_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5 • core_table.py</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Summary / Purpose</strong><br><br><code>core_table.py</code> is a defensive, feature-rich table rendering helper designed to accept many table-like inputs (pandas DataFrames, lists/dicts, CSV/TSV sources, file paths, byte blobs) and produce safe, accessible, and interactive HTML table fragments. It emphasizes: safer CSV detection/parsing (<code>parse_csv_safe</code>), robust input coercion (<code>_rows_from_iterable</code>), careful markdown/code stashing for cell content, optional sanitization integration, tooltip/heading assets, and backwards-compatible behavior with <code>pandas.DataFrame.to_html</code> fallbacks. The module provides both full <code>render_table</code> (rich server-rendered HTML + embedded metadata) and <code>render_fragment</code>/<code>simple_render_table</code> compatibility wrappers. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>High-level guarantees & design principles</strong><br><br>• <strong>Safety-first</strong>: limit per-cell HTML size, cap columns/rows warnings, and integrate optional project sanitizers where available. <br>• <strong>Progressive enhancement</strong>: prefer existing <code>convert</code> bridge if present (delegation) and prefer <code>pandas</code> when available for CSV parsing. <br>• <strong>Backward compatibility</strong>: preserve legacy <code>DataFrame.to_html</code> behavior unless <code>auto_type</code> or other options request different behavior. <br>• <strong>Determinism & accessibility</strong>: stable <code>Table{idx}</code> ids, ARIA attributes, caption metadata, and embeddable JSON payloads for lazy loading and client-side caption injection. <br>• <strong>Resilience</strong>: ubiquitous try/except defensively prevents crash propagation and logs parse/render outcomes as <code>PARSE_TRY</code> / <code>PARSE_OK</code> / <code>PARSE_FAIL</code>. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Top-level structure & exports</strong><br><br>• I/O / config constants & module state: <code>_MAX_CELL_HTML</code>, <code>_MAX_ROWS_SAFE_RENDER</code>, <code>_ASSETS_EMITTED</code>.<br>• Optional imports: pandas, openpyxl/xlsxwriter, charset detectors, project <code>sanitize_html</code> bridge.<br>• Markdown/renderer helpers: <code>_get_md_callable</code>, <code>_stash_code_local</code>, <code>_restore_code_placeholders_in_html</code>.<br>• Text-normalization & protections: <code>_preprocess_underscores_outside_placeholders</code>, <code>_restore_protection_entities</code>, <code>_dir_for_text</code>, diagram and RTL detection helpers.<br>• CSV parsing: <code>_is_likely_csv_text</code>, <code>_read_text_source</code>, <code>_sniff_delimiter</code>, <code>_try_pandas_read_csv</code>, <code>_parse_csv_source_to_rows</code>, and <code>parse_csv_safe</code> (public robust CSV loader).<br>• Input coercion & normalization: <code>_rows_from_iterable</code>, <code>_ensure_uniform_rows</code>, <code>_get_table_alignments</code>, <code>_detect_column_types</code>.<br>• Rendering: <code>_render_cell_text</code>, <code>_one_time_assets</code>, <code>_make_hidden_heading_anchor</code>, <code>_heading_init_script</code>, <code>_safe_json_for_script</code>, and main <code>render_table</code>, plus <code>render_fragment</code>, <code>simple_render_table</code> wrappers.<br>• Exported API in <code>__all__</code>: <code>render_table</code>, <code>render_fragment</code>, <code>simple_render_table</code>, <code>parse_csv_safe</code>, and selected internal helpers. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Key components & responsibilities (concise)</strong><br><br>1. <strong>Cell rendering (<code>_render_cell_text</code>)</strong> — stash fenced and inline code, preprocess underscores/pipes, call markdown/render callable, restore protection entities and code placeholders, truncate very large output, and sanitize via <code>sanitize_html</code> when available. <br>2. <strong>CSV parsing (<code>parse_csv_safe</code>)</strong> — layered parsing: prefer pandas read_csv (multiple encodings & delimiters), fallback to <code>csv.reader</code>, sniff delimiter, header detection (sniffer + heuristics), normalization/padding of rows and optional conversion back to pandas DataFrame. Emits structured logs <code>PARSE_TRY / PARSE_OK / PARSE_FAIL</code>. <br>3. <strong>Input coercion (<code>_rows_from_iterable</code>)</strong> — accepts many shapes: bytes, file paths, inline text (detects CSV-like), DataFrame-like objects (via <code>to_pandas</code>, <code>columns</code>/<code>itertuples</code>), list-of-dicts, list-of-lists, and general iterable coercion. Routes early CSV/text handling through <code>parse_csv_safe</code>. <br>4. <strong>Table rendering (<code>render_table</code>)</strong> — builds the full HTML wrapper: one-time assets (CSS/JS), heading anchor, controls (copy/export buttons), caption handling (inline or caption payload), <code>&lt;table&gt;</code> with <code>&lt;thead&gt;</code> and <code>&lt;tbody&gt;</code>, lazy chunk embedding for large tables, metadata JSON embed, and ARIA accessibility attributes. Supports many options (collapsible, sticky headers, lazy loading, inject_assets, emit_captions_inline). <br>5. <strong>Export utilities</strong> — CSV/JSON/XLSX emitters. <br>6. <strong>Decor & UX helpers</strong> — <code>_one_time_assets</code> injection, heading init script, and <code>_safe_json_for_script</code> for safe JSON embedding. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Detailed behavior & important implementation notes</strong><br><br><strong>Markdown & code stashing</strong> — <code>_stash_code_local</code> replaces fenced triple-backtick blocks and inline backticks with stable placeholders. Restoration reconstructs <code>&lt;pre&gt;&lt;code&gt;</code> / <code>&lt;code&gt;</code> elements with escaped content and optional language classes. This prevents markdown renderers or sanitizers from corrupting literal code. The regex supports standard triple-backtick fences but may miss non-standard variants (e.g., tilde fences or variable backtick counts). <br><br><strong>Protection of underscores/pipes</strong> — <code>_preprocess_underscores_outside_placeholders</code> converts underscores and pipes outside placeholder regions into HTML entities, avoiding accidental markdown emphasis or column splitting. Code placeholders remain untouched. <code>_restore_protection_entities</code> later restores the original characters. This preserves <code>snake_case</code> identifiers and literal pipe characters safely. <br><br><strong>Cell rendering flow</strong> — <code>_render_cell_text</code> performs: stash code → protect underscores/pipes → run markdown callable → restore protection entities → restore code placeholders → truncate excess HTML → sanitize with <code>sanitize_html</code> when available. If sanitization fails, fallback is <code>html.escape</code>. This layered pipeline balances fidelity, safety, and compatibility with project-level sanitizers. <br><br><strong>CSV parsing heuristics & safety</strong> — <code>_is_likely_csv_text</code> avoids misclassifying markdown tables. <code>_sniff_delimiter</code> tries <code>csv.Sniffer</code> then falls back to counting delimiters. <code>_parse_csv_source_to_rows</code> uses the detected delimiter, normalizes row lengths, and attempts header detection via <code>Sniffer.has_header</code> or numeric heuristics. <code>parse_csv_safe</code> coordinates pandas attempts (multiple encodings/delimiters) with structured logging (<code>PARSE_TRY</code>, <code>PARSE_OK</code>, <code>PARSE_FAIL</code>) and falls back gracefully to reader-based parsing or raw row lists. <br><br><strong>Pandas integration</strong> — When available, pandas is used for CSV decoding and for returning DataFrames. <code>_rows_from_iterable</code> detects DataFrame-like objects (including <code>.to_pandas()</code> adapters) and extracts headers and rows via <code>itertuples</code>, ensuring consistent string coercion where appropriate. This maintains predictable render behavior even when pandas dtypes vary. <br><br><strong>Accessibility & metadata embedding</strong> — <code>render_table</code> applies ARIA roles, hidden accessible anchors, caption IDs, and optional caption payloads. Metadata is embedded using <code>_safe_json_for_script</code> to prevent accidental script termination via sequences such as <code>&lt;/script&gt;</code>. The client-side heading initializer enhances navigation for progressively enhanced UIs. <br><br><strong>Assets & one-time injection</strong> — <code>_one_time_assets</code> supplies CSS, JS, and heading-init scripts. <code>render_table</code> emits these once per process (when <code>emit_assets_once=True</code>) using the <code>_ASSETS_EMITTED</code> guard. JS is minimal, defensive, and idempotent to avoid re-initialization. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Concurrency & performance considerations</strong><br><br>• <strong>Large tables</strong>: soft caps emphasize warnings rather than hard failures: <code>_MAX_ROWS_SAFE_RENDER</code> logged when exceeded; <code>_MAX_COLS_SAFE</code> applied to avoid rendering absurd column counts. Callers should avoid attempting to render huge tables synchronously. <br>• <strong>Cell processing cost</strong>: <code>_render_cell_text</code> calls markdown renderers and optional sanitizers per cell; this can be CPU-heavy for many rows/columns — consider server-side chunking or worker pools for very large tables. <br>• <strong>Pandas overhead</strong>: when <code>parse_csv_safe</code> tries many encoding+delimiter combos with pandas, this adds I/O and CPU cost. The default tries encodings and delimiters in loops; callers can pass hints to reduce attempts. <br>• <strong>Truncation</strong>: <code>_MAX_CELL_HTML</code> prevents runaway memory growth from malicious/very large cell HTML. <br>• <strong>Client lazy loading</strong>: <code>render_table</code> supports lazy embedding (<code>table-row-chunk</code> JSON) to defer heavy row display to client. This reduces initial server-side render work and DOM cost. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Error handling, robustness & failure modes</strong><br><br>• <strong>Extensive try/except</strong> — the module favors logging and graceful fallbacks over raising; parse failures become <code>PARSE_FAIL</code> logs and result in <code>None</code>/empty outputs or fallback rendering. <br>• <strong>Silent degradation</strong> — many internal failures are logged at debug/info and program proceeds; this can mask root causes without good log collection. <br>• <strong>Sanitizer dependence</strong> — if <code>sanitize_html</code> is missing, fallback is <code>html.escape</code>, which is safe but less featureful; conversely, a buggy sanitizer may alter or drop intended markup. <br>• <strong>CSV ambiguity</strong> — heuristics can mis-classify tricky inputs, and pandas sniffing may fail on malformed CSVs. Fallbacks exist but may produce unexpected shapes. <br><br><strong>Notable failure-mode decisions</strong> — when pandas parsing repeatedly fails, the function falls back to <code>csv.reader</code> and eventually to returning <code>None</code> (or list-of-rows) rather than raising, preserving service continuity. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Edge cases & brittle areas</strong><br><br>1. <strong>Fenced code regex</strong> — <code>_stash_code_local</code> uses a simple triple-backtick regex; complex fence variants (tilde fences, varying backtick counts) and nested fences may not be captured correctly. <br>2. <strong>Underscore/pipes protection</strong> — transforming underscores/pipes outside placeholders may alter intended HTML/markdown in rare scenarios. <br>3. <strong>CSV sniffing & header detection</strong> — <code>csv.Sniffer</code> and heuristics can be wrong for real-world data (dates/mixed strings). <br>4. <strong>Character detection & encodings</strong> — charset detectors may misidentify multi-lingual or mixed-encoding blobs. <br>5. <strong>HTML-in-CSV</strong> — sanitized HTML allowed in cells; behavior depends on sanitizer configuration. <br>6. <strong>ID collisions</strong> — <code>Table{idx}</code> + short UUID fragments may not be globally unique at scale. <br>7. <strong>Client script brittleness</strong> — JSON-in-script requires careful escaping; <code>_safe_json_for_script</code> mitigates but doesn't eliminate risk if upstream sanitization fails. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Integration points & extension hooks</strong><br><br>• <strong>Sanitizer</strong> — calls project <code>sanitize_html</code> when available. <br>• <strong>convert.render_table</strong> — delegation preserves upstream rendering customization. <br>• <strong>caption_fragment_builder</strong> — allows caller-defined caption fragments for advanced workflows. <br>• <strong>Optional deps</strong> — pandas/charset detectors used if present; otherwise skipped gracefully. <br>• <strong>Export backends</strong> — uses <code>xlsxwriter</code>/<code>openpyxl</code> if available, with fallbacks. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Concrete recommendations & maintainability notes</strong><br><br>1. Improve fenced-code detection to handle variable backtick/tilde counts. <br>2. Allow callers to pass <code>encoding</code>/<code>delimiter</code> hints to reduce expensive autodetection. <br>3. Standardize sanitizer contract (documented arguments & behavior). <br>4. Add configurable protection levels for underscores/pipes. <br>5. Expand testing for nested fences, tricky CSVs, multi-encoding blobs, and fallback paths. <br>6. Strengthen ID generation with longer UUIDs or salted namespaces. <br>7. Improve observability by enriching <code>PARSE_*</code> logs with safe metadata. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Short checklist of behaviors to verify in CI / integration</strong><br><br>• <code>_render_cell_text</code> preserves inline/fenced code and sanitizes when configured. <br>• <code>parse_csv_safe</code> returns DataFrame when pandas succeeds; otherwise rows; logs show correct <code>PARSE_OK</code> info. <br>• <code>_is_likely_csv_text</code> avoids misclassifying markdown tables. <br>• <code>_one_time_assets</code> injected only once. <br>• Caption payload logic emits safe JSON (no raw <code>&lt;/script&gt;</code>). <br>• Lazy chunks embed valid <code>table-row-chunk</code> JSON. <br>• Exporters produce valid CSV/JSON/XLSX when dependencies exist. <br>• <code>_rows_from_iterable</code> correctly handles DataFrame-like, list-dict, list-lists, paths, and bytes. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Robust, backward-compatible table rendering helper)"> <strong>Conclusion</strong><br><br><code>render/core_table.py</code> is a defensive, flexible table-rendering module balancing backward compatibility with advanced capabilities (lazy loading, caption payloads, per-cell sanitization). With improvements to fence handling, parsing hints, sanitizer clarity, and expanded tests, it can serve reliably in production-scale workflows. </td></tr></tbody></table></div><div class="row-count">Rows: 12</div></div><div class="table-caption" id="Table6" data-table="Docu_0123_06" style="margin-top:2mm;margin-left:3mm;"><strong>Table 6 • core_renderer.py</strong></div>
<div class="table-wrapper" data-table-id="table-6"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Summary / Purpose</strong><br><br><code>core_renderer.py</code> is the top-level orchestration module that takes a heterogeneous sequence of "tables" (DataFrames, list-of-dicts, CSV text, markdown with pipe tables, HTML fragments, file paths, bytes), normalizes and deduplicates them, delegates rendering of each fragment to <code>render_fragments_concurrently</code> (the worker from <code>core_fragments.py</code>), and assembles a complete self-contained HTML viewer page (the "Tables Viewer"). It handles asset management (embedding vs static assets), caption payload emission, TOC creation, inline fallback rendering when fragment pipeline fails, atomic output writes, and returns a structured result with warnings, counts and optional inline HTML. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>High-level guarantees & design principles</strong><br><br>• <strong>Make the best effort</strong>: try many detection/parsing strategies (CSV detection, pipe-table extraction, HTML table extraction) and fall back to inline rendering when fragment rendering produced nothing. <br>• <strong>Non-blocking failures</strong>: parsing/rendering exceptions are converted to warnings; the function attempts to still produce an output. <br>• <strong>Determinism & stable IDs</strong>: uses <code>_stable_hash</code> and deterministic naming (<code>TableN</code>, wrapper ids) so referring code can rely on stable identifiers. <br>• <strong>Asset flexibility</strong>: supports embedding assets directly into HTML (for single-file outputs) or linking to an <code>assets/</code> folder with cache-busting query params. <br>• <strong>Safety-minded</strong>: uses <code>sanitize_html</code> (fallback minimal sanitizer if project missing one) when embedding inline HTML fragments; caption payloads are escaped for safe in-script embedding. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Top-level structure & exports</strong><br><br>• Small helpers: <code>_record</code>, <code>_load_labels_json</code>, <code>_caption_for</code>, <code>_safe_text_from_html</code>, <code>_escape_for_inline_json</code>, <code>_remove_heading_from_fragment</code>. <br>• Normalization: <code>_to_dataframe_if_possible</code> (attempt convert lists/dicts -> pandas DF), parsing helpers inlined (<code>_parse_csv_file</code>, <code>_detect_csv_like</code>, <code>_extract_pipe_tables_from_markdown</code>, <code>_extract_tables_from_html</code>). <br>• Dedup & coercion: create <code>parsed_tables</code> from <code>all_tables</code>, dedupe using <code>_stable_hash</code>, coerce to DataFrame-like when possible. <br>• Concurrency handoff: call <code>render_fragments_concurrently(parsed_tables, cfg, renderer, tmp_frag_dir, max_workers)</code> and handle its returned <code>(fragments_map, frag_row_counts, total_rows, warnings)</code>. <br>• Output assembly: build <code>head_parts</code> / <code>tail_parts</code>, TOC, caption payload scripts, write out fragment files (or inline fallback pieces), and write final HTML atomically via <code>_default_write_atomic</code> / fallback writer. <br>• Public API: <code>render_html(all_tables, output_html, markdown_to_html, *, ...) -&gt; Dict[str,Any]</code>. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Key components & responsibilities (concise)</strong><br><br>1. <strong>Input scanning & coercion</strong> — iterate <code>all_tables</code>, treat paths specially (CSV/TSV extensions), attempt CSV detection on inline strings (<code>_detect_csv_like</code> + <code>_parse_csv_text</code>), extract pipe-markdown tables, render markdown→HTML for HTML table extraction, append sanitized HTML sources to <code>inline_html_sources</code>. <br>2. <strong>Deduplication</strong> — compute <code>_stable_hash</code> per candidate (pandas <code>.to_dict(orient=&quot;records&quot;)</code> when possible) to avoid rendering duplicates. <br>3. <strong>Renderer wrapper</strong> — <code>MarkdownRenderer</code> wraps the provided <code>markdown_to_html</code> callable into a <code>.render</code> method (default escapes); used later both in fragment detection and in cell rendering. <br>4. <strong>Fragment rendering delegation</strong> — call <code>render_fragments_concurrently</code> to perform per-fragment rendering concurrently (threads or processes, according to <code>cfg.max_workers</code> and picklability). <br>5. <strong>Fallback inline rendering</strong> — when fragment pipeline yields no fragments or fragments contain no rows, iterate <code>parsed_tables</code> and <code>inline_html_sources</code> and produce safe inline <code>piece_safe</code> (sanitize_html) entries, plus synthesize <code>fragments_map</code> entries for captions/metadata to preserve downstream expectations. <br>6. <strong>Asset wiring</strong> — <code>prepare_assets(cfg, out_dir)</code> returns <code>assets_dir</code>, <code>style_fallback</code>, <code>script_fallback</code>, <code>assets_written</code>. The module either inlines styles/scripts or links to them using <code>href_prefix</code> and adds integrity attrs via <code>_sri_attr</code>. <br>7. <strong>Caption payload & metadata emission</strong> — collects <code>caption_payloads</code> for injected fragments (when <code>meta.injected</code> true), chunks them if large, embeds JSON scripts with safe escaping (<code>_escape_for_inline_json</code>), and sets <code>result[&quot;caption_payload&quot;]</code>. <br>8. <strong>Atomic file write</strong> — uses <code>_default_write_atomic</code> when available; else writes to <code>.tmp</code> and <code>os.replace</code> to ensure atomicity. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Detailed behavior & important implementation notes</strong><br><br><strong>Input normalization order</strong> — code prefers: (a) preserve DataFrame-like inputs; (b) convert list-of-dicts / list-of-lists heuristically to DF; (c) treat string items as: existing file paths (CSV parsing), inline CSV detection, pipe-markdown extraction, then markdown→HTML → HTML table extraction; otherwise place sanitized HTML into <code>inline_html_sources</code>. This order matters: CSV detection runs before markdown→HTML to avoid interpreting markdown pipe-tables as CSV. <br><br><strong>Fragment orchestration</strong> — <code>render_fragments_concurrently</code> returns a detailed <code>fragments_map</code> keyed by 1-based fragment idx: each entry contains <code>path</code>, <code>content</code>, <code>title_id</code>, <code>title_text</code>, <code>assets_required</code>, <code>render_time_ms</code>, <code>write_time_ms</code>, <code>detected_type</code>, <code>captions</code>, etc. <code>core_renderer</code> then composes <code>frag_paths_ordered</code> and <code>toc_items</code> from those entries. <br><br><strong>Fallback inline assembly</strong> — when there are no fragment files, <code>core_renderer</code> uses <code>_render_table_safe</code> to call <code>render_table</code> directly (or fallback to pandas <code>to_html</code>) and then sanitizes the returned HTML before embedding. It strips duplicate headings (via <code>_remove_heading_from_fragment</code>) to avoid double titles in the final page. <br><br><strong>Asset embedding vs linking</strong> — controlled by <code>cfg.embed_assets</code>. When embedding, the code reads assets into <code>head_parts</code> / <code>tail_parts</code> and inlines them; otherwise it links with version query params (<code>?v=mtime</code>) and may insert a minimal shim if scripts missing. The asset set order matters for behavioral shims used by client JS. <br><br><strong>Caption payload chunking</strong> — if total caption payload JSON exceeds <code>max_caption_payload_size</code> (default 200k), payloads are split into numbered <code>&lt;script data-caption-payload ... data-payload-part=&quot;i&quot;&gt;</code> parts and an init script is emitted so the client can merge them. This avoids single huge inline script nodes. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Error handling, robustness & failure modes</strong><br><br>• <strong>Many swallow/append-warnings</strong> — parsing failures, missing optional modules (pandas, bs4), asset read errors, and render exceptions are caught; details are logged and <code>warnings</code> appended. This is non-fatal but can hide root causes if logs are not inspected. <br>• <strong>Fallback surfaces</strong> — when <code>render_fragments_concurrently</code> fails, code falls back to inline rendering; if that also fails, the final page may be an empty viewer with a banner explaining "No tables were rendered." <br>• <strong>Pickling for processes</strong> — <code>render_fragments_concurrently</code> attempts to use ProcessPoolExecutor only if <code>renderer</code> is picklable (it tries <code>pickle.dumps(renderer)</code>); otherwise it falls back to ThreadPoolExecutor and logs a <code>process_fallback</code> warning. If renderer contains closures or complex callables the process path will be disabled silently. <br>• <strong>Sanitizer variability</strong> — <code>sanitize_html</code> may be project-provided; the module ships a simple <code>sanitize_html</code> fallback that allows table tags when <code>allow_tables=True</code>. Differences between real sanitizer (e.g., <code>bleach</code>) and fallback can produce subtle HTML differences; this affects caption extraction and script neutralization behavior upstream. <br>• <strong>Path / cwd assumptions</strong> — <code>_load_labels_json</code> probes multiple relative parent directories; in deployments with atypical layout this may miss label files. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Concurrency / performance considerations</strong><br><br>• <code>max_workers</code> default is 1 unless set in <code>cfg</code>. The implementation sets <code>worker_count = max(1, min(len(inputs) or 1, max_workers or 1))</code>. For many fragments increase <code>cfg.max_workers</code> but be mindful of memory (pandas conversions) and CPU. <br>• <strong>Process vs thread</strong> — process mode uses <code>_process_simple_render_job</code> which only runs the simple fallback renderer (no complex renderer object) because <code>ProcessPoolExecutor</code> requires picklable worker args and functions. When process mode is disallowed the thread pool runs <code>_render_job</code> which supports full renderer callables but at higher contention risk. <br>• <strong>I/O bound writes</strong> — fragment writes use atomic strategies; heavy outputs (many fragments, large tables) will generate many temporary files and <code>os.replace</code> calls — choose <code>tmp_frag_dir</code> on same filesystem as final <code>out_dir</code> to avoid cross-filesystem atomic problems. <br><br>• <strong>Asset inclusion costs</strong> — embedding assets makes the single HTML file large (memory/time) but simplifies portability; linking reduces HTML size but requires shipping asset directory. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Edge cases & brittle areas</strong><br><br>1. <strong>Indexing assumption</strong> — fragments are enumerated and later referenced by their 1-based index; if inputs are reordered or dedup logic drops items, mapping between original input position and <code>fragments_map</code> index can be non-obvious. <br>2. <strong>Heading stripping regex</strong> — <code>_remove_heading_from_fragment</code> uses regex patterns to strip headings by id or by exact heading-text match; unusual markup or whitespace can fail that removal, causing duplicated titles. Consider using BeautifulSoup to reliably remove first heading. <br>3. <strong>Caption detection heuristics</strong> — relies on searching for <code>&lt;h3&gt;</code> or explicit <code>captions</code> from renderer outputs; renderers that use different heading levels or produce captions differently can cause missing or duplicate caption payloads. <br>4. <strong>Massive caption payloads</strong> — chunking uses a naive size estimate by summing JSON string lengths; extremely large numbers of fragments still produce many scripts that the client must merge — may impact client memory. <br>5. <strong>Atomic write fallback behaviour</strong> — if <code>_default_write_atomic</code> exists but raises intermittent errors, code falls back to <code>.tmp</code> + <code>os.replace</code>; however in rare cross-filesystem setups <code>os.replace</code> may raise; callers should ensure <code>out_dir</code> and <code>tmp_frag_dir</code> are on same FS. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Integration points & extension hooks</strong><br><br>• <strong><code>cfg</code> options read</strong> — supports <code>cfg.detect_csv</code>, <code>cfg.csv_delimiter</code>, <code>cfg.max_workers</code>, <code>cfg.embed_assets</code>, <code>cfg.emit_captions_inline</code>, <code>cfg.max_caption_payload_size</code>, <code>cfg</code> can be dict-like or object with attributes. <br>• <strong>Custom renderers</strong> — pass any callable <code>markdown_to_html</code> (or object with <code>.render</code>) into <code>MarkdownRenderer</code>; the renderer will be used both for detection (rendering string to HTML for table extraction) and for rendering fragments (via <code>render_fragments_concurrently</code>). <br>• <strong>prepare_assets / write_overrides_css</strong> — asset discovery and CSS override writing are delegated to <code>core_assets</code>. You can swap that module to change asset packaging. <br>• <strong>Caption injection hook</strong> — <code>inject_captions</code> exists in <code>core_renderer</code> to mutate <code>fragments_map</code> before final write (used when request context indicates group loads). You can call/extend it upstream to add application-specific metadata. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Recommendations & maintainability notes</strong><br><br>• <strong>Add explicit input-size / time limits</strong> — many regexes and parsers run over entire inputs; enforce <code>MAX_PASTE_SIZE</code> or timeouts to avoid ReDoS. <br>• <strong>Stronger sanitizer</strong> — wire a vetted <code>sanitize_html</code> (e.g., <code>sanitize.py</code> / <code>bleach</code>) in production to avoid XSS risks, and canonicalize sanitized output shape expectations. <br>• <strong>Make heading normalization robust</strong> — replace <code>re.sub</code> heading-removal with a parsed approach (BeautifulSoup or html5lib) for deterministic heading manipulation. <br>• <strong>Improve mapping between inputs and fragments</strong> — currently dedup and reordering can obscure provenance; include an explicit <code>source_index</code> in <code>fragments_map</code> entries so callers can map back to original inputs. <br>• <strong>Test process pool path</strong> — write unit/integration tests that exercise <code>use_process=True</code> and with non-picklable renderers to validate graceful fallback to threads. <br>• <strong>Instrument more telemetry</strong> — record per-input detection decisions (why an item was classified as <code>csv_raw</code> vs <code>markdown_table</code> vs <code>html_table</code>) to help operator debugging. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Short checklist of behaviors to verify in CI / integration</strong><br><br>• File outputs written atomically and exist at <code>output_html</code>. <br>• <code>render_fragments_concurrently</code> receives the normalized <code>parsed_tables</code> and returns <code>fragments_map</code> expected shape. <br>• <code>embed_assets=True</code> results in inline <code>&lt;style&gt;</code> and <code>&lt;script&gt;</code> content in the final HTML; <code>embed_assets=False</code> links with <code>?v=</code> versioning parameters. <br>• When <code>render_fragments_concurrently</code> fails or produces zero-row fragments, the fallback inline rendering path produces sanitized fragments and adds a non-empty <code>fragments_map</code>/<code>inline_parts</code>. <br>• Caption payload JSON is emitted and correctly chunked when > <code>max_caption_payload_size</code>, and <code>window.PTT._serverCaptionPayload</code> is set when small enough. <br>• CSV file inputs (.csv/.tsv) are parsed into <code>parsed_tables</code> by <code>_parse_csv_file</code> and counted in <code>result[&quot;tables&quot;]</code>. <br>• <code>cfg.max_workers</code> affects the concurrency level; non-picklable renderers cause a logged <code>process_fallback</code> and threaded execution. </td></tr><tr><td data-label="Technical Breakdown —  CODE0  (Renderer orchestration → HTML page builder / Table Viewer assembly)"> <strong>Conclusion</strong><br><br><code>core_renderer.py</code> is a pragmatic, defensive assembly layer that focuses on making a usable "Tables Viewer" HTML page from a messy set of possible inputs. It trades aggressive fault-tolerance for complexity: many rescue paths, heuristic detection steps, and fallback render modes. For mission-critical or high-risk deployments (you mentioned this concerns your life) I strongly recommend wiring a hardened sanitizer, adding explicit input size/time limits, strengthening provenance (link fragments back to original input indices), and adding end-to-end tests that exercise the process-pool path, sanitizer differences, and caption-chunking logic. </td></tr></tbody></table></div><div class="row-count">Rows: 12</div></div><div class="table-caption" id="Table7" data-table="Docu_0123_07" style="margin-top:2mm;margin-left:3mm;"><strong>Table 7 • convert.py</strong></div>
<div class="table-wrapper" data-table-id="table-7"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module Overview — purpose & scope</strong><br><br><code>convert.py</code> is a self-contained conversion module for PasteToTable (PTT). Primary responsibilities: robustly detect and parse Markdown pipe-tables and CSV-like blocks from plain text, preserve inline code spans (multi-backtick safe), normalize ragged rows, infer headers and column types, render defensive HTML table widgets (caption, wrapper, export/copy tools), and provide debug extraction utilities. The module is defensive: nearly every external-facing operation is wrapped in <code>try/except</code> and falls back to safe defaults (returning original text, diagnostic panels, or simple shims) so that failures never throw uncaught exceptions to callers. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Public API contract</strong><br><br>Exports (via <code>__all__</code>): <code>parse_markdown_tables(text) -&gt; List[Dict]</code> (rows, header flag, source), <code>parse_csv_tables(text, delimiter=None, assume_header=None) -&gt; List[Dict]</code>, <code>render_table(df, idx=1, ...) -&gt; str</code> (HTML string), <code>extract_tables_debug(text) -&gt; (pipe_tables, html_tables)</code> (pandas or <code>_SimpleDF</code> objects), <code>_SimpleDF</code>, <code>_SimpleColumns</code>, <code>convert_structure(text, options=None) -&gt; (html, metadata)</code>, <code>convert_text_to_html(text, options=None) -&gt; {&quot;html&quot;: str, &quot;metadata&quot;: dict}</code>. All functions accept <code>None</code>/empty text gracefully and return empty lists/diagnostic outputs rather than raising. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level control flow</strong><br><br>1. <code>convert_text_to_html</code> calls <code>parse_markdown_tables</code>. 2. If tables found → for each table construct <code>_SimpleDF</code> (or wrap pandas DF), then <code>render_table</code> to produce HTML pieces. 3. If no markdown tables found, <code>parse_csv_tables</code> is used (via <code>extract_tables_debug</code> fallback or direct invocation) when <code>_looks_like_csv</code> indicates a CSV-ish block. 4. <code>render_table</code> uses a provided markdown renderer (or fallback <code>_get_default_markdown_renderer</code>) to render header and cell HTML. 5. Final HTML and metadata are returned to the caller. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Regex & constants — intent and pitfalls</strong><br><br><code>_PRE_RE</code> / <code>_CODE_RE</code>: detect <code>&lt;pre&gt;</code> / <code>&lt;code&gt;</code> blocks to avoid altering their contents. <code>_DIVIDER_PART_RE</code> (<code>^:?-{1,}\:?\s*$</code>) strictly validates Markdown divider tokens (ensures at least one dash and optional leading/trailing colon). <code>_INLINE_CODE_STASH_RE</code> captures runs of backticks and their content (multi-backtick support). Pitfall: overly-permissive regexes can either accept malformed divider lines or reject valid but unusual ones; current patterns favor correctness for common Markdown dialects. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Code-span stash/restore (algorithmic details)</strong><br><br><code>_stash_code_spans(s)</code> — finds all matches for <code>_INLINE_CODE_STASH_RE</code>, replaces each with a binary-safe placeholder token <code>\x00CODE{n}\x00</code>, and returns (text_with_placeholders, mapping_list). Complexity: O(len(s)) for a single pass regex substitution, but regex backtracking can increase cost for extremely long nested backtick patterns. <code> _restore_code_spans(s, mapping, to_html=False)</code> — replaces placeholders with original runs; if <code>to_html=True</code> it strips surrounding backticks and HTML-escapes the inner content before wrapping in <code>&lt;code&gt;</code>. Security: mapping contents are never executed, only escaped or re-inserted as text/HTML. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Row-splitting strategy (pipe-aware)</strong><br><br><code>_split_row_keep_code(row)</code> — core behavior: stash code spans, split on unescaped <code>|</code> (<code>(?&lt;!\)\|</code>), remove leading/trailing empty columns (common when tables have leading/trailing pipes), restore code spans, convert escaped <code>\|</code> back to <code>|</code>, and trim whitespace per cell. Guarantees: pipes inside code spans do not split cells; escaped pipe sequences <code>\|</code> survive as literal <code>|</code>. Complexity approx O(m + k) where m = row length, k = number of placeholders. Robustness: explicit handling of empty endpoints avoids off-by-one when a table omits leading/trailing pipes. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Markdown pipe-table detection & parsing</strong><br><br><code>parse_markdown_tables(text)</code> — transforms input to normalized line endings, unescapes HTML entities, then scans lines sequentially. It treats a line containing <code>|</code> followed by a valid divider line as the start of a table. It collects contiguous <code>|</code>-containing lines as the body until a blank or non-pipe line. Each table is normalized to uniform column count (pads with empty strings). Returns <code>{&quot;rows&quot;: rows_matrix, &quot;header&quot;: True, &quot;source&quot;: &quot;pipe_markdown&quot;}</code> for each found table. Edge cases: tables with missing divider line are skipped except in <code>extract_tables_debug</code> which is more permissive. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Divider validation</strong><br><br><code>_is_divider_line</code> uses <code>_split_row_keep_code</code> then ensures every part matches <code>_DIVIDER_PART_RE</code> and no part is empty. This reduces false positives (for example, text lines containing <code>|</code> in prose will not be treated as dividers unless they match the dash pattern). Important: the divider check requires at least one dash per column; rare syntaxes (e.g., <code>:----:</code>) are supported. </td></tr><tr><td data-label="Technical Breakdown"> <strong>CSV detection heuristic</strong><br><br><code>_looks_like_csv(lines)</code> — returns False for small blocks (<2 non-empty lines) or when pipes are common (to avoid confusing Markdown tables). For candidate delimiters [',',';','\t'], it computes counts per line and looks for a stable positive count pattern: if the most-common count across lines is >=1 and appears in >60% of lines, the heuristic classifies as CSV-like. This prevents false positives on freeform text. </td></tr><tr><td data-label="Technical Breakdown"> <strong>CSV parsing algorithm — robust & deterministic fallback</strong><br><br<code>parse_csv_tables</code> steps: normalize newlines & BOM, unescape HTML entities, remove NBSP and zero-width chars, sample up to 40 non-empty lines, try <code>csv.Sniffer.sniff(sample, delimiters=[&#x27;,&#x27;,&#x27;;&#x27;,&#x27;\t&#x27;,&#x27;|&#x27;])</code> to detect delimiter. If sniff fails, count frequency of candidate delimiters over first ~100 lines and choose the most frequent one (deterministic fallback). Then use <code>csv.reader</code> on full text with chosen delimiter, skip wholly-empty rows, strip cells, pad ragged rows to <code>maxc</code>. Header inference: prefer <code>assume_header</code> if provided; otherwise try <code>sniffer.has_header(sample)</code> and, if that's not possible, apply numeric-likelihood heuristics to compare numericity of the first row vs subsequent rows. Returns <code>[{&quot;rows&quot;: normalized_rows, &quot;header&quot;: bool, &quot;source&quot;: &quot;csv&quot;}]</code>. Notes: using <code>|</code> as a sniff candidate helps detect poor-formatted pipe tables treated as CSV in some contexts. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Header inference heuristic (detailed)</strong><br><br>Fallback algorithm when <code>sniffer.has_header</code> cannot be used: define <code>_is_numeric_like(cell)</code> that strips commas/spaces, handles trailing <code>%</code>, removes parentheses (treating <code>(1)</code> as negative), then attempts <code>float()</code>. For the first row and a small sample of subsequent rows (up to 5), compute counts of numeric-like cells. The algorithm decides “header” if first-row numericity is significantly lower than subsequent rows (e.g., <code>first_numeric * 1.5 &lt; rest_numeric_per_row</code>) or if any first-row cell is non-numeric when rest are numeric. This balances false positives while recognizing numeric-only columns. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Normalization / padding of ragged rows</strong><br><br>After parsing, compute <code>maxc = max(len(r) for r in rows)</code> then for each row <code>r</code> extend with <code>[&quot;&quot;] * (maxc - len(r))</code>. This ensures consistent matrix shape for rendering and downstream operations (alignment detection, DataFrame shims). Preserves cell order and treats missing cells as empty strings. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Simple DataFrame shim semantics</strong><br><br><code>_SimpleDF(rows, cols=None)</code> encapsulates <code>self._rows</code> as list of row lists and exposes <code>.columns</code> as <code>_SimpleColumns</code> (which supports <code>tolist()</code>, iteration, indexing). <code>.itertuples(index=False)</code> yields rows as tuples. Designed to be a lightweight drop-in when <code>pandas</code> is not installed. <code>extract_tables_debug</code> will attempt to build a real pandas <code>DataFrame</code> when <code>pandas</code> is available to preserve richer downstream behavior (alignments attachable via attributes). </td></tr><tr><td data-label="Technical Breakdown"> <strong>extract_tables_debug behavior</strong><br><br>Two-pass strategy: 1) Aggressive candidate scanning: find exact header+divider sequences (<code>start..end</code>) and build normalized tables (parsing alignments from divider parts). 2) If no pipe-tables discovered, run CSV autodetection (<code>_looks_like_csv</code>) then <code>parse_csv_tables</code> and convert results into <code>_SimpleDF</code> or pandas DF. Also performs typographical normalization (smart quotes → straight, en/em-dash → <code>-</code>, ellipsis → <code>...</code>). Returns <code>(pipe_tables, html_tables)</code> where <code>pipe_tables</code> may contain pandas DFs or <code>_SimpleDF</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Alignment & type detection</strong><br><br>Alignment sources (priority): a) explicit Markdown divider colons (<code>:---:</code>, <code>:---</code>, <code>---:</code>) → center/left/right, b) attribute <code>_table_alignments</code> on input <code>tbl</code> (preserved by upstream), c) inferred from sample rows via <code>_detect_column_types</code>. <code>_detect_column_types(sample_rows, cols)</code> inspects up to the sampled rows and classifies each column: if no non-empty values seen → <code>&quot;text&quot;</code>; otherwise attempt to normalize cell string (remove commas/spaces, strip <code>%</code>, convert <code>(x)</code> → <code>-x</code>) then <code>float()</code> to test numeric-ness. Returns <code>[&quot;numeric&quot;|&quot;text&quot;, ...]</code> used to set alignments (<code>numeric</code> → right, else left). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Markdown renderer selection & fallback implementation</strong><br><br><code>_get_default_markdown_renderer</code> tries <code>from markdown import get_markdown_renderer</code> (project-local shim). Fallback <code>_simple_md</code> handles cases with no heavy Markdown dependency: it tokenizes inline code and basic emphasis (<code>***</code>, <code>**</code>, <code>*</code>) and wraps paragraphs (<code>&lt;p&gt;</code>), preserving inline code placeholders and reinserting <code>&lt;code&gt;</code> tags after escaping. The fallback intentionally avoids block-level features beyond paragraph wrapping — suitable for cell-level content but not for full multi-block Markdown documents. </td></tr><tr><td data-label="Technical Breakdown"> <strong>render_table — end-to-end rendering steps</strong><br><br>1. Determine <code>cols</code> (from <code>df.columns</code> or inferred from first row). If unable to detect columns, produce a diagnostic HTML panel (caption + wrapper + <code>.table-diagnostic</code>) rather than raising. 2. Build caption: <code>&lt;div class=&quot;table-caption&quot; id=&quot;Table{idx}&quot; data-table=&quot;{title}&quot;&gt;&lt;strong&gt;{visible_title}&lt;/strong&gt;&lt;/div&gt;</code>. 3. Build wrapper: <code>&lt;div class=&quot;table-wrapper&quot; data-table-id=&quot;table-{idx}&quot; data-table-index=&quot;{idx}&quot; data-table-alignments=&quot;{csvalign}&quot;&gt;</code> and header/tooling bar (copy/export buttons). 4. Compute <code>alignments</code> via attribute or <code>_detect_column_types</code>. 5. Render <code>&lt;thead&gt;</code>: header cells rendered with markdown renderer, trimmed of wrapping <code>&lt;p&gt;..&lt;/p&gt;</code> when applicable, decorated with sort buttons and ARIA attributes. 6. Render <code>&lt;tbody&gt;</code>: iterate rows (uses <code>_take_and_stream</code> to sample without exhausting iterators), for each cell run markdown render, apply <code>_unescape_brackets_outside_code</code>, sanitize bold using <code>sanitize_bold_html</code>, run <code>_apply_left_col_heading</code> for first column, and <code>_escape_unmatched_markers</code>. 7. Append row counts or empty hints. Return concatenated HTML string. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Cell rendering safeguards & transformations</strong><br><br>Per-cell pipeline: raw value → <code>str()</code> → if multiline and not containing fenced code, convert single newlines to Markdown line-breaks (<code>  \n</code>) to preserve formatting; call markdown renderer to obtain HTML; <code>_unescape_brackets_outside_code</code> reverts escaped <code>\[</code> / <code>\]</code> outside code blocks; remove leading <code>&lt;br&gt;</code> artifacts for numeric formatting; <code>sanitize_bold_html</code> limits bold markup to sane output; <code>_escape_unmatched_markers</code> replaces stray <code>|</code> outside code with <code>&amp;#124;</code> so later consumers (or if re-splitting) don't misinterpret. Each stage is <code>try/except</code>-wrapped. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Accessibility & UI semantics</strong><br><br>Output includes: caption outside wrapper with <code>id=Table{n}</code> (for anchors/TOC), <code>&lt;table role=&quot;table&quot;&gt;</code>, <code>&lt;th scope=&quot;col&quot; role=&quot;button&quot; aria-label=&quot;Sort by ...&quot;&gt;</code> sortable headers, and <code>aria-live</code>/labels on helper UI where appropriate. Export/copy buttons include <code>aria-label</code> attributes. Collapsible toggle uses <code>aria-expanded</code>. These choices improve usability in assistive tech scenarios; further improvements could link caption <code>id</code> to table via <code>aria-describedby</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Failure modes & logging philosophy</strong><br><br>Design intentionally swallows many internal exceptions and logs them only under <code>logger</code> (which defaults to <code>NullHandler</code>). Typical failure modes: malformed divider rows, csv.Sniffer misdetection, regex backtracking on huge inputs, pandas DataFrame conversion failures. When a non-fatal error occurs, code either: returns original text, a diagnostic HTML block, empty list, or <code>_SimpleDF</code>. This minimizes host breakage but can mask root causes; enabling debug-level logging in the host integration is recommended for diagnosis. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Complexity & performance characteristics</strong><br><br>Parsing is linear in input length (O(N)) for single-pass operations. Heavy regex operations (code-span stash/restore and splits) are linear average-case but can degrade with pathological inputs due to backtracking. <code>_take_and_stream</code> uses <code>itertools.tee</code> when needed which can duplicate iterator buffers — memory proportional to sample window (small by default). <code>render_table</code> builds HTML via Python string concatenation in lists then <code>&#x27;&#x27;.join(parts)</code> — efficient for server-side generation; for extremely large tables memory may be significant but acceptable for normal use cases. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Security considerations</strong><br><br>All user-facing text is passed through <code>html.escape</code> or rendered by the Markdown renderer which should escape as needed. <code>_restore_code_spans(..., to_html=True)</code> explicitly HTML-escapes code inner text. <code>_escape_unmatched_markers</code> converts stray <code>|</code> to <code>&amp;#124;</code> outside code. Recommendation: when embedding into DOM, prefer <code>textContent</code> or programmatic DOM insertion over raw <code>innerHTML</code> if the host wants stronger XSS guarantees. Avoid trusting server-supplied <code>title</code>/caption strings without sanitization. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Edge cases & notable brittle areas</strong><br><br>1. <code>csv.Sniffer</code> can misdetect delimiters for small samples or highly irregular rows → deterministic fallback implemented but still heuristic. 2. Divider validation rejects some non-standard yet plausible Markdown syntaxes. 3. Mixed use of <code>pandas</code> vs <code>_SimpleDF</code> can create differences in attribute handling (<code>alignments</code> may be attached differently). 4. Regex-based splitting and stash/restore can struggle with extremely large single-line inputs. 5. <code>Table{n}</code> id collisions may occur when multiple renderers exist on the same page—recommended to allow namespacing. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Return shapes & types (explicit)</strong><br><br><code>parse_markdown_tables</code> → <code>List[Dict[str, Any]]</code> where each dict contains <code>rows: List[List[str]]</code>, <code>header: bool</code>, <code>source: &quot;pipe_markdown&quot;</code>. <code>parse_csv_tables</code> → same shape but <code>source: &quot;csv&quot;</code>. <code>extract_tables_debug</code> → <code>(List[DF_like], List[DF_like])</code>. <code>render_table</code> → <code>str</code> (HTML). <code>convert_text_to_html</code> → <code>{&quot;html&quot;: str, &quot;metadata&quot;: {&quot;converted&quot;: bool, &quot;tables&quot;: int, ...}}</code>. <code>convert_structure</code> → <code>(html_str, metadata_dict)</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recommended configuration knobs / extension points</strong><br><br>Expose via <code>options</code> or <code>tvConfig</code> (integration-friendly): <code>markdown_to_html_func</code> (inject renderer), <code>csv_delimiter</code> (force), <code>assume_header</code> boolean, <code>sample_lines</code> (for sniffing / type detection), <code>table_id_prefix</code> (namespace Table IDs), <code>pad_empty_to_max</code> toggle, and <code>escape_pipe_marker</code> toggle. Add <code>clean_prev_captions</code> option to remove previously injected captions when re-rendering same container. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Testing matrix — unit & integration tests (concrete cases)</strong><br><br>Essential tests: (1) single-line cell with internal <code>\|</code> preserved; (2) multi-backtick code spans with embedded pipes and backticks in varying counts; (3) ragged rows with trailing/leading pipes and no leading/trailing pipes; (4) divider lines with different colon placements (<code>:---:</code>, <code>:---</code>, <code>---:</code>) and invalid dividers; (5) CSV inputs with <code>,</code>, <code>;</code>, <code>\t</code> and mixed fields including quoted delimiters; (6) <code>sniffer.sniff</code> fallback path (force exception) and correct delimiter selection from frequency; (7) numeric inference with <code>1,234</code>, <code>(1,234)</code>, <code>12.3%</code>, empty cells; (8) integration with <code>pandas.DataFrame</code> and with <code>_SimpleDF</code>; (9) extremely large table performance and memory profile; (10) XSS attack payloads in cells to verify escaping. Each test must assert deterministic output strings or structural DOM equivalence (e.g., table headings and row counts). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Debugging checklist / instrumentation suggestions</strong><br><br>1. Provide an optional <code>debug</code> flag to enable <code>logger</code> to use <code>StreamHandler</code> at DEBUG. 2. Emit structured debug events (e.g., <code>logger.debug(&quot;parse_markdown_tables: found %d tables&quot;, n)</code>) and add <code>metadata[&quot;warnings&quot;]</code>. 3. Add <code>document.dispatchEvent(new CustomEvent(&#x27;ptt:tableRendered&#x27;, {detail:{idx,rows,cols}}))</code> on client-side injection to aid host diagnostics (if used in browser). 4. On parse failure, attach <code>metadata[&quot;parse_error_trace&quot;]</code> when debug enabled. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Suggested hardening / improvements</strong><br><br>1. Centralize duplicated helpers (<code>_split_row_keep_code</code>, <code>_normalizeKey</code>, <code>_escape_unmatched_markers</code>) into a single utility module to avoid divergence. 2. Allow deterministic delimiter override to avoid <code>csv.Sniffer</code> uncertainty in CI. 3. Add optional streaming renderer to avoid holding full HTML in memory for very large tables. 4. Prefer programmatic DOM creation (via <code>lxml</code>/<code>xml.etree</code> on server or direct DOM APIs in client) when injection into live documents; this reduces XSS risk compared to string <code>innerHTML</code>. 5. Provide configurable ID namespaces for <code>Table{n}</code> to avoid collisions. 6. Tighten unit tests around edge regex cases to prevent backtracking timeouts. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Interop & migration notes</strong><br><br>When integrating into existing PTT pipeline: ensure the host supplies a markdown renderer via <code>options[&#x27;markdown_to_html_func&#x27;]</code> for consistent styling. If <code>pandas</code> is available, <code>extract_tables_debug</code> will produce real <code>DataFrame</code> objects — adapt downstream code to accept both <code>pandas.DataFrame</code> and <code>_SimpleDF</code>. If switching to a streaming architecture, update <code>render_table</code> consumers to accept streaming fragments or incremental DOM insertion hooks. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Examples — sample inputs and expected outputs (concise)</strong><br><br>1) Markdown table input: <code>| A | B |\n|---|---|\n| 1 | two |</code> → <code>parse_markdown_tables</code> yields <code>rows=[[&quot;A&quot;,&quot;B&quot;],[&quot;1&quot;,&quot;two&quot;]]</code>, <code>header=True</code>; <code>render_table</code> produces caption <code>Table1</code>, wrapper, and <code>&lt;table&gt;</code> with two columns and one data row. 2) CSV input: <code>a,b\n1,2\n3,4</code> with no pipes → <code>parse_csv_tables</code> detects <code>,</code> and returns rows padded uniformly. 3) Code-span: ``<code>Row: </code>a|b<code> | 2</code>`<code> → </code>_split_row_keep_code<code> preserves </code>a|b` inside single cell. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Verification statement</strong><br><br>Performed thorough internal consistency checks across parsing, splitting, type-detection, alignment logic, fallback paths, return types, and example mappings. Iterated inspection of code paths for <code>parse_markdown_tables</code>, <code>parse_csv_tables</code>, <code>extract_tables_debug</code>, <code>_split_row_keep_code</code>, <code>_stash_code_spans</code>, <code>_restore_code_spans</code>, <code>_detect_column_types</code>, and <code>render_table</code> to ensure the breakdown matches the implementation. </td></tr></tbody></table></div><div class="row-count">Rows: 31</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>