<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771304660">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0188_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Project 062 — Year-End Audit Checklist Generator Overview"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Project 062 — Year-End Audit Checklist Generator Overview</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Preface & Intent (expanded):</strong> <br> This expanded specification is the authoritative, implementation-ready expansion of Project 062. It transforms the canonical checklist concept into a reproducible engineering artifact for implementers and auditors. The document provides exhaustive per-row narratives for canonical entities, explicit function-level contracts for every VBA module, Power Query orchestration guidance, conceptual DAX reporting patterns, acceptance criteria, exhaustive testing matrices, observability and alerting guidance, security and privacy controls, archival & retention guidance, migration and change governance, operator runbooks for production operations, deployment and scaling strategies beyond Excel, error code taxonomy, sample fixtures and onboarding scripts. The objective: equip an implementer to build the ChecklistGeneratorWorkbook.xlsm and operate it safely in regulated environments while preserving parity recipes for future migration to server-side implementations. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>High-level objectives (explicit & elaborated):</strong> <br> 1. Provide a single authoritative <code>TasksMaster</code> that aggregates template tasks, ad-hoc requests, owner assignments and evidence pointers; this becomes the single source of truth for gating, dashboards and printed artifacts. <br> 2. Enforce deterministic gating rules that block organizational close unless all critical tasks meet evidence and sign-off requirements; gating rules must be declarative in <code>policySnapshot</code> for traceable changes. <br> 3. Produce printable, versioned checklists and PDF artifacts grouped by owner, department, or gating buckets with canonical naming and manifest hashing to detect tampering. <br> 4. Maintain append-only sign-off registry and evidence metadata with checksums for tamper-evidence and legal admissibility. <br> 5. Provide operational dashboards (Excel/Power BI) summarizing status, missing evidence, overdue items, sign-off rates and run parity markers for audit oversight. <br> 6. Support controlled ad-hoc intake and post-close remediation while preserving chain-of-custody and forensic traceability. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Design principles (detailed):</strong> <br> 1. Single source of truth: <code>TasksMaster</code> produced by PQ is authoritative; all UI, gating and PDF artifacts must derive from this table without local ad-hoc overrides. <br> 2. Deterministic outputs: canonical date format <code>YYYY-MM-DD</code>, deterministic field ordering and hash recipes for manifests and row checksums; any non-deterministic element must be recorded in <code>manifestNotes</code> and <code>AuditLog</code>. <br> 3. Auditability: every mutative action (attach, rebind, sign-off, generate, close, reopen) creates an <code>AuditLog</code> event and influences version manifests; audit entries include correlationId to link multi-step workflows. <br> 4. Least privilege: workbook never stores credentials; evidence URLs are pointers governed by platform access; access controls and redaction policies are enforced at artifact generation time. <br> 5. Reversible & traceable: versioned manifests, append-only registries and immutable sign-off records ensure any change can be traced and forensic bundles produced for legal processes. <br> 6. Fail-safe defaults: gating errs on conservative side — missing evidence or unverified checksums block close by default unless <code>policySnapshot</code> explicitly relaxes. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Scope & boundaries (explicit):</strong> <br> • In scope: Excel <code>.xlsm</code> workbook including PQ queries, structured tables (YearEndTaskTemplate, OwnerAssignments, SupportingDocuments, SignOffEntries, AdhocRequests, AuditLog, ChecklistVersionManifest), VBA modules for PDF generation, reminders, gating enforcement, sign-off recording, dashboards and operator macros. <br> • Out of scope: direct GL postings or automated accounting system mutations; heavy enterprise DMS ingestion beyond accessible URLs & checksums; building external APIs or DMS connectors beyond SharePoint/Outlook automation without a formal integration plan. <br> • Scale guidance: PQ patterns recommended up to several thousand tasks; for 10k+ tasks or multiple concurrent mutators consider moving metadata to a light DWH and exposing server-side APIs; maintain the same canonicalization recipes to preserve parity. <br> • Security boundary: workbook is not an evidence store; it stores metadata pointers and checksums only. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Glossary of core terms (expanded):</strong> <br> • <code>Task</code> — unit of work requiring evidence and/or sign-off; contains lifecycle metadata, owners, due dates and gating attributes. <br> • <code>Evidence</code> — supporting document pointer with checksum, uploader metadata and status flags. <br> • <code>Sign-off</code> — immutable approval event recorded with signer, role, timestamp, and optional cryptographic fingerprint. <br> • <code>Manifest</code> — canonical snapshot of a checklist version; serialized and hashed for tamper detection. <br> • <code>Close</code> — organizational close action that may require multiple manifests and sign-offs; atomic operation guarded by gating logic. <br> • <code>PQ</code> — Power Query transform pipeline responsible for canonical aggregation and validation prior to mutative operations. <br> • <code>AuditLog</code> — append-only event store capturing all mutative operations and important non-mutative events for forensic trace. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Canonical entity: YearEndTaskRow — full narrative and fields (expanded per-field narratives):</strong> <br> Purpose: canonical atomic representation of a checklist task used across PQ, UI and gating. <br> Required fields and semantics: <br> • <code>taskId</code> — stable canonical identifier (GUID or deterministic string). Narrative: must be stable across versions for the same logical task; derive GUID using <code>GenerateGUID()</code> in <code>modUtils</code> at creation. Use deterministic seeding if import requires stable mapping from external template row keys. <br> • <code>taskName</code> — canonical short title (store <code>taskNameRaw</code> and <code>taskNameCanonical</code>). Narrative: <code>taskName</code> limited to 256 characters; <code>taskNameCanonical</code> produced by <code>CanonicalizeText</code>. Include example: "Finalize statutory tax reconciliation". <br> • <code>descriptionRaw</code> — original description preserved for audit. Narrative: preserve original formatting and markup, store in storage column <code>descriptionRaw</code> and never mutate; canonicalization produces <code>descriptionCanonical</code> for matching. <br> • <code>descriptionCanonical</code> — normalized description: Unicode NFKC, trimmed, collapse whitespace, casefold with locale rules. Narrative: used for duplicate detection and heuristic evidence matching; store normalization recipe version as <code>canonicalVersion</code>. <br> • <code>taskSource</code> — <code>template | adhoc</code>. Narrative: indicates origin; <code>adhoc</code> tasks maintain <code>requestedBy</code> metadata. <br> • <code>defaultOwnerId</code> — template owner. Narrative: for templates, indicates preferred owner. <br> • <code>assignedOwnerId</code> — can be reassigned; changes audited. Narrative: must map to <code>OwnerAssignments</code> table; if missing, PQ emits <code>MissingOwner</code> issue. <br> • <code>department</code> — organizational owner; used for grouping and manifest scopes. <br> • <code>priority</code> — <code>P0 | P1 | P2 | P3</code> with documented semantics. Narrative: used by <code>policySnapshot.approvalMatrix</code> and reminders. <br> • <code>gatingCategory</code> — <code>critical | important | optional</code>. Narrative: <code>critical</code> tasks block close unless policy relaxes. <br> • <code>defaultDueOffsetDays</code> — integer days relative to <code>closeDate</code>. Narrative: used for computed due date when explicit due date not present. <br> • <code>explicitDueDate</code> — optional override, validated as ISO <code>YYYY-MM-DD</code>. Narrative: must parse; PQ emits <code>InvalidDateFormat</code> if unparsable. <br> • <code>computedDueDate</code> — computed canonical date used by PQ and UI; authoritative in gating. Narrative: computed in PQ; format <code>YYYY-MM-DD</code>. <br> • <code>evidenceRequirements[]</code> — array of evidence taxonomy keys required. Narrative: applied at gating check; example <code>[&quot;taxReconciliationPDF&quot;,&quot;signedManagerApproval&quot;]</code>. <br> • <code>attachedEvidenceIds[]</code> — evidence pointers attached to this task. Narrative: multiple evidence items may be attached; PQ computes category coverage against <code>evidenceRequirements</code>. <br> • <code>signoffRequired</code> — boolean. Narrative: true for tasks requiring sign-off; gating checks sign-offCount and role requirements. <br> • <code>signOffEntries[]</code> — list of <code>signOffId</code> references. Narrative: used to compute <code>signOffCount</code> and <code>signOffByRoles</code>. <br> • <code>status</code> — <code>Not Started | In Progress | Blocked | Complete | Signed Off</code>. Narrative: status updated by modSignOff and analyst actions; PQ reflects latest value. <br> • <code>comments[]</code> — free-text comments with actor & ts. Narrative: used for evidence notes and manual confirmations; persisted append-only. <br> • <code>taskRowChecksum</code> — <code>sha256:</code> over canonical serialization of stable fields and <code>canonicalVersion</code>. Narrative: used for parity checks; recomputed when persisted or during nightly parity jobs. <br> • <code>lastModifiedBy</code>, <code>lastModifiedTs</code> — audit fields. Narrative: updated on mutative operations. <br> Invariants and rules: <br> 1. <code>taskId</code> must remain stable for the same logical task; replacing a task uses a new <code>taskId</code>. <br> 2. <code>computedDueDate</code> is authoritative in PQ and UI; it must be present for any task included in a manifest. <br> 3. <code>taskRowChecksum</code> computed with canonical ordering: <code>taskId|taskName|assignedOwnerId|gatingCategory|computedDueDate|signoffRequired|canonicalVersion</code>. <br> 4. Changing <code>assignedOwnerId</code> appends an <code>AuditLog</code> event and updates <code>lastModified*</code> fields. <br> 5. Annotate <code>deprecated=true</code> on merged or retired tasks; retain historical rows for forensics. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Canonical entity: SupportingDocument — full narrative and fields (expanded):</strong> <br> Purpose: immutable pointer to a piece of supporting evidence referenced by one or more tasks. <br> Required fields and semantics: <br> • <code>evidenceId</code> — GUID. Narrative: generate at <code>AttachEvidence</code> time using <code>GenerateGUID()</code>; stable thereafter. <br> • <code>title</code> — short human title. Narrative: used for heuristic matching and display. <br> • <code>url</code> or <code>platformRef</code> — pointer to storage (SharePoint, Teams, DMS, local path). Narrative: URLs must be validated for format; PQ may perform HEAD check for reachability if permitted. <br> • <code>uploaderId</code> — user who attached or uploaded. Narrative: persisted for chain of custody. <br> • <code>uploadedTs</code> — UTC timestamp. Narrative: use <code>NowUTC()</code> for consistency. <br> • <code>checksum</code> — <code>sha256</code> of content when available; otherwise null and <code>evidenceStatus=unverified</code>. Narrative: mandatory for critical categories unless <code>policySnapshot</code> relaxes. <br> • <code>evidenceCategory</code> — taxonomy key: e.g., <code>signedForm</code>, <code>reconSchedule</code>, <code>invoice</code>, <code>photoEvidence</code>, <code>policyApproval</code>. Narrative: used to satisfy <code>evidenceRequirements</code> on tasks. <br> • <code>attachedToTaskId</code> — nullable; evidence may be unattached until assigned. Narrative: allowed to exist in evidence pool unattached; PQ attempts heuristic mapping and emits <code>HeuristicEvidenceMatch</code>. <br> • <code>accessPolicy</code> — pointer to retrieval policy or list of roles. Narrative: ensures PDFs and exports respect access constraints. <br> • <code>evidenceRowChecksum</code> — computed over canonical metadata and <code>canonicalVersion</code>. Narrative: provides tamper-evidence on metadata. <br> Invariants: <br> 1. If <code>attachedToTaskId</code> is set, it must reference an existing <code>taskId</code>. <br> 2. Evidence rows are append-only for content; <code>Detach</code> and <code>Rebind</code> operations append audit rows but do not delete historical records; original <code>evidenceId</code> continues to exist for chain-of-custody. <br> 3. Evidence without <code>checksum</code> flagged <code>unverified</code>; for <code>critical</code> tasks policy may require verified checksum. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Canonical entity: SignOffEntry — narrative and fields (expanded):</strong> <br> Purpose: immutable record of a sign-off action satisfying gating requirements. <br> Required fields and semantics: <br> • <code>signOffId</code> — GUID. Narrative: created with <code>RecordSignOff</code> and never mutated. <br> • <code>taskId</code> — associated task. Narrative: must reference an active <code>taskId</code>; sign-offs pre-manifest may be stale depending on <code>policySnapshot</code>. <br> • <code>signedBy</code> — user id. Narrative: validated against <code>OwnerAssignments</code> and <code>policySnapshot</code> before acceptance. <br> • <code>signedRole</code> — <code>owner | approver | manager | compliance</code>. Narrative: <code>policySnapshot.approvalMatrix</code> maps required roles per task priority and gating. <br> • <code>signedTs</code> — UTC. Narrative: signed timestamp used in <code>signoffTimeWindow</code> validation. <br> • <code>approvalRef</code> — external approval token or comment string. Narrative: optional external system token for cross-system reconciliation. <br> • <code>comment</code> — optional text. Narrative: free-text justification or context. <br> • <code>signatureHash</code> — optional cryptographic signature fingerprint if available. Narrative: if present used to increase tamper resistance. <br> • <code>signOffRowChecksum</code> — sha256 canonical hash. Narrative: used for parity and immutability checks. <br> • <code>versionId</code> — checklist version id that sign-off applies to. Narrative: critical for scoping sign-offs to manifests. <br> Rules & invariants: <br> 1. SignOff entries are append-only and cannot be altered; any attempted correction requires a compensating sign-off and audit entry. <br> 2. <code>AttemptClose</code> verifies sign-offs within the version scope unless <code>policySnapshot</code> allows cross-version acceptance and records the decision in AuditLog. <br> 3. Two-person approval policies require recording both sign-off entries with distinct <code>signedBy</code> values and <code>signOffRowChecksum</code>. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Canonical entity: ChecklistVersionManifest — narrative and fields (expanded):</strong> <br> Purpose: tamper-evident snapshot representing a generated printable checklist version and its canonical serialization. <br> Required fields and semantics: <br> • <code>versionId</code> — GUID. Narrative: assigned by <code>GenerateChecklistPDF</code> and used as reference in sign-offs. <br> • <code>generatedBy</code> — operator id. Narrative: operator performing generation; required for audit trail. <br> • <code>generatedTs</code> — UTC. Narrative: timestamp of generation. <br> • <code>scope</code> — <code>All | Owner:&lt;id&gt; | Dept:&lt;name&gt; | Gating:&lt;category&gt;</code>. Narrative: used to derive printable subset and file naming. <br> • <code>taskCount</code> — number of tasks included. Narrative: computed from <code>TasksMaster</code> subset used for manifest. <br> • <code>blockingCount</code> — tasks currently blocking close at generation time. Narrative: included to surface close risk at snapshot time. <br> • <code>manifestCanonicalString</code> — canonical serialization used for hashing. Narrative: includes canonicalVersion and canonicalized task row subset. <br> • <code>manifestHash</code> — <code>sha256:</code> of <code>manifestCanonicalString</code>. Narrative: persisted with PDF and used for nightly parity. <br> • <code>notes</code> — optional operator notes or rationale. <br> • <code>canonicalVersion</code> — recipe identifier used for canonicalization; changes to canonicalVersion must be governed by <code>migrationManifest</code>. <br> Rules and invariants: <br> 1. Manifest must be persisted atomically with the generated PDF artifact; file write must be atomic (write temp file then move). <br> 2. <code>manifestHash</code> used for parity checks; nightly job recomputes and alerts on mismatch. <br> 3. Manifest rows are append-only and used in audit trails. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Canonical entity: AuditLog — narrative and events (expanded):</strong> <br> Purpose: append-only audit table capturing all mutative and important non-mutative events; primary forensic source. <br> Required fields and semantics: <br> • <code>eventId</code> — GUID. <br> • <code>eventType</code> — e.g., <code>fa.checklist.generated</code>, <code>fa.evidence.attached</code>, <code>fa.signoff.recorded</code>, <code>fa.checklist.closed</code>, <code>fa.checklist.closeAttemptBlocked</code>, <code>fa.evidence.rebound</code>, <code>fa.task.merge</code>, <code>fa.reminder.sent</code>. <br> • <code>actorId</code> — user or system id. <br> • <code>timestampUTC</code> — event time. <br> • <code>correlationId</code> — used to connect multi-step workflows; e.g., a Generate→SignOff→Close flow shares correlationId. <br> • <code>details</code> — JSON blob capturing event specifics (minimal but sufficient for replay). <br> • <code>evidenceRefs[]</code> — list of <code>evidenceId</code>s related to the event. <br> • <code>manifestRef</code> — <code>versionId</code> when relevant. <br> Rules & invariants: <br> 1. AuditLog is append-only; entries should not be altered. Implement snapshots and archival for retention requirements. <br> 2. For tamper-evidence, each manifest snapshot packages associated AuditLog events and stores checksum references. <br> 3. Audit entries must include machine-readable error codes and human-readable messages for each mutative operation. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>TasksMaster aggregation — conceptual Power Query recipe (expanded narrative):</strong> <br> Purpose: produce authoritative aggregated task table used by UI, gating, PDFs and dashboards; PQ must include explicit named steps to enable traceability and manual inspection. <br> Conceptual steps: <br> 1. <strong>Sources ingestion:</strong> read <code>YearEndTaskTemplate</code> (sheet/file), <code>OwnerAssignments</code> sheet, <code>SupportingDocuments</code> sheet, <code>AdhocRequests</code> sheet, <code>SignOffEntries</code> sheet, and <code>CloseParameters</code> (closeDate, canonicalVersion, policySnapshotRef). <br> 2. <strong>Normalization step (Canonicalize):</strong> apply text canonicalization (Unicode NFKC → trim → collapse whitespace → casefold; locale-specific overrides) to <code>taskName</code> and <code>descriptionRaw</code>, producing <code>taskNameCanonical</code> and <code>descriptionCanonical</code>. Document step <code>CanonicalizeTextStep</code> and record counts of modified rows. <br> 3. <strong>Date canonicalization & computation:</strong> parse <code>explicitDueDate</code> if present; else compute <code>computedDueDate = Date.AddDays(closeDate, -defaultDueOffsetDays)</code>. Format as <code>YYYY-MM-DD</code>. Record parsing errors to <code>PQ_Issues</code>. <br> 4. <strong>Owner resolution & enrichment:</strong> resolve <code>assignedOwnerId</code> defaulting to <code>defaultOwnerId</code>, then join <code>OwnerAssignments</code> to attach metadata (displayName, email, department, approverId). Emit <code>PQ_Issues</code> when owner missing and include best-match suggestions. <br> 5. <strong>Evidence attach mapping & heuristics:</strong> left-join <code>SupportingDocuments</code> to tasks by <code>attachedToTaskId</code>. For unattached evidence attempt heuristic match (title token overlap, filename tokens, date proximity to computedDueDate) and attach with <code>heuristicMatch=true</code>. For each heuristic match include confidence score and emit <code>PQ_Issues</code>. <br> 6. <strong>Compute task metrics:</strong> <code>evidenceMissing</code> by comparing <code>evidenceRequirements[]</code> with <code>attachedEvidenceIds[]</code> and <code>SupportingDocuments.evidenceCategory</code> coverage (only <code>evidenceStatus = valid</code> counts unless <code>policySnapshot</code> relaxes). <code>daysToDue = computedDueDate - today</code>. <code>overdueFlag = daysToDue &lt; 0</code>. <code>gatingRisk</code> = deterministic function combining <code>priority</code>, <code>overdueFlag</code>, <code>evidenceMissing</code> into <code>Low|Medium|High</code>; include rationale column <code>gatingRiskRationale</code>. <br> 7. <strong>Enrich with sign-off counts:</strong> left-join <code>SignOffEntries</code> to compute <code>signOffCount</code>, <code>lastSignOffTs</code>, <code>signOffByRoles[]</code>, and <code>signOffWithinManifest</code> indicator using <code>versionId</code> mapping. <br> 8. <strong>Produce outputs:</strong> <code>TasksMaster</code> table (canonical), <code>MissingEvidenceReport</code> (task-oriented pivot with missing categories), <code>PQ_Issues</code> (validation items), <code>HeuristicMatches</code> (evidence candidates), and optional <code>pqParityReport</code> if golden fixtures present. <br> PQ considerations & operational notes: <br> • Perform heavy canonicalization in PQ with named step boundaries allowing analysts to inspect intermediate outputs; never perform hash computation requiring binary file reads in PQ — use VBA <code>modUtils</code> for checksum verification. <br> • Avoid per-row custom functions that iterate; prefer table-based joins for performance. <br> • Keep <code>CloseParameters</code> as a single-row config source to allow deterministic reruns for parity testing. <br> • Emit <code>PQ_Issues</code> rows with <code>issueId</code>, <code>issueType</code>, <code>entityRef</code>, <code>severity</code>, <code>details</code>, and <code>suggestedAction</code>. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Power Query validation & issue handling (detailed & prescriptive):</strong> <br> Purpose: surface data quality issues before they impact gating, PDF generation or sign-off. <br> Validation patterns and outputs: <br> 1. <strong>Owner existence:</strong> If <code>assignedOwnerId</code> is null or missing in <code>OwnerAssignments</code>, emit <code>issueType=MissingOwner</code> with suggested owner matches (top 3) using fuzzy matching. Severity: High for <code>gatingCategory=critical</code>. <br> 2. <strong>Duplicate detection:</strong> compute normalized <code>taskKey</code> and similarity scores; if similarity > threshold emit <code>issueType=PossibleDuplicate</code> with pair suggestions and <code>similarityScore</code>. Severity: Medium. <br> 3. <strong>Evidence health:</strong> for each <code>SupportingDocument</code> verify <code>url</code> pattern and optional HEAD reachability (subject to tenant permissions); if <code>checksum</code> absent mark <code>evidenceStatus=unverified</code> and emit <code>issueType=UnverifiedEvidence</code>. Severity: High for <code>evidenceCategory</code> in <code>critical</code> tasks. <br> 4. <strong>Heuristic matches:</strong> when heuristics attached evidence to tasks, emit <code>issueType=HeuristicEvidenceMatch</code> and list <code>confidenceScore</code>; manual confirmation required before <code>heuristicMatchResolved=true</code>. <br> 5. <strong>Date parsing errors:</strong> if <code>explicitDueDate</code> fails ISO parse, emit <code>issueType=InvalidDateFormat</code> and suggested corrected format. Severity: Medium. <br> 6. <strong>Task-level gating inconsistencies:</strong> e.g., <code>signoffRequired = true</code> but <code>priority = P3</code> and <code>gatingCategory = optional</code> — emit <code>issueType=PolicyInconsistency</code>. Severity: Low. <br> 7. <strong>PQ_Issues table:</strong> structured table with <code>issueId</code>, <code>issueType</code>, <code>entityId</code>, <code>details</code>, <code>severity</code>, <code>suggestedAction</code>, <code>createdTs</code>, <code>resolvedBy</code>, <code>resolvedTs</code>. Analysts fix upstream and rerun PQ; PQ must keep a deterministic <code>issuesHash</code> for each run to support parity. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>VBA modules — full function-level contracts and behaviors (complete):</strong> <br> Overview: implement modules with explicit header docs for inputs, outputs, side-effects, audit events, telemetry counters and deterministic error codes. Modules: <code>modChecklist</code>, <code>modEvidence</code>, <code>modSignOff</code>, <code>modGating</code>, <code>modRemind</code>, <code>modAudit</code>, <code>modUtils</code>. Each public function returns structured results (return object or error code + details) and writes <code>AuditLog</code> entries via <code>modAudit.AppendAudit</code>. All modules must validate arguments and return deterministic error codes to support automation and CLI wrappers. All IO operations must use atomic write semantics (write to tmp file then move). All mutative functions must obtain a workbook-level mutex (simple single-author lock implemented in workbook metadata) to prevent concurrent writes in shared workbooks. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Module: modChecklist — exhaustive function-level breakdown (complete):</strong> <br> Purpose: compose printable checklist views, create PDFs, build manifest snapshots and publish version artifacts. <br> Public functions with contracts: <br> 1. <code>GenerateChecklistPDF(scope As String, versionNotes As String, operatorId As String) As variant</code> — returns object <code>{status: &quot;OK&quot;|&quot;ERROR&quot;, versionId: GUID|null, errorCode: String|null, details: String|null}</code>. <br> Inputs: <code>scope</code> (All <code>|</code> Owner:<id> <code>|</code> Dept:<name> <code>|</code> Gating:<category>), <code>versionNotes</code>, <code>operatorId</code>. <br> Outputs: <code>versionId</code> GUID on success. Side effects: creates <code>Checklist_Printable</code> sheet (temporary), computes <code>manifestCanonicalString</code> and <code>manifestHash</code>, saves PDF with filename <code>YE_Checklist_&lt;scope&gt;_&lt;YYYYMMDD&gt;_&lt;manifestHashPrefix&gt;.pdf</code>, persists <code>ChecklistVersionManifest</code> row, emits <code>fa.checklist.generated</code> AuditLog event (via <code>modAudit.AppendAudit</code>). <br> Validation & preconditions: <br> • Ensure PQ <code>TasksMaster</code> is current and contains required fields (<code>taskId</code>, <code>taskName</code>, <code>assignedOwnerId</code>, <code>computedDueDate</code>, <code>gatingCategory</code>, <code>taskRowChecksum</code>). <br> • Validate that all tasks included have <code>assignedOwnerId</code> and <code>computedDueDate</code>. <br> • Run <code>CheckPQIssuesForScope(scope)</code> to determine blocking PQ issues; if severity high, abort and return <code>ERR_CHECKLIST_MISSING_REQUIRED_FIELDS</code> with <code>pqIssuesRef</code>. <br> Post-conditions: <br> • Manifest persisted atomically with PDF and a <code>Checklist_Printable</code> workbook backup created with name <code>YE_Checklist_&lt;scope&gt;_&lt;versionId&gt;.xlsm</code> in staging folder for forensics if configured. <br> Failure & remediation: <br> • File write IO error → retry up to three times with exponential backoff, then persist <code>fa.checklist.generate.io_error</code> with local staging path and return <code>ERR_PDF_WRITE_FAIL</code>. <br> Observability: emit telemetry <code>checklist.generate.durationMs</code>, <code>checklist.generated.count</code>, <code>checklist.generate.failures</code>. <br> Example call: <code>GenerateChecklistPDF(&quot;Owner:U-123&quot;,&quot;Pre-close run&quot;,&quot;alice&quot;)</code> returns <code>{&quot;status&quot;:&quot;OK&quot;,&quot;versionId&quot;:&quot;v-abc-123&quot;,...}</code>. <br> 2. <code>BuildPrintableSheet(versionId As String, scope As String) As boolean</code> — creates worksheet layout using templated layouts, page breaks per owner, inserts manifest header with <code>versionId</code>, <code>generatedBy</code>, <code>generatedTs</code>, <code>manifestHash</code>, and writes per-task rows sorted by <code>gatingCategory</code> then <code>priority</code> then <code>computedDueDate</code>. Returns boolean success and writes <code>fa.checklist.sheetBuilt</code> AuditLog event. <br> 3. <code>ExportPDF(sheetName As String, pdfPath As String) As boolean</code> — wrap Excel <code>ExportAsFixedFormat</code> with atomic write semantics: export to temp PDF, validate file size > 1KB, then move to target path; return <code>True</code> on success; emit <code>fa.checklist.pdfExport</code> or <code>ERR_PDF_WRITE_FAIL</code>. <br> 4. <code>ComputeManifestCanonicalString(versionId As String, taskRows As Variant) As String</code> — deterministic serialization routine invoked by <code>GenerateChecklistPDF</code>; returns canonical UTF-8 string used by <code>ComputeSHA256</code>. Documentation: caller must provide <code>taskRows</code> ordered by canonical order; function escapes field separators and normalizes newline characters. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Module: modEvidence — exhaustive function-level breakdown (complete):</strong> <br> Purpose: evidence lifecycle: attach, rebind, detach, verify and reverify. <br> Public functions: <br> 1. <code>AttachEvidence(taskId As String, evidenceUrl As String, uploaderId As String, Optional localFilePath As String) As variant</code> — returns <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, evidenceId:GUID|null, errorCode:String|null, details:String|null}</code>. <br> Inputs: <code>taskId</code> (nullable for evidence pool), <code>evidenceUrl</code>, <code>uploaderId</code>, optional <code>localFilePath</code> if present to compute checksum. <br> Outputs: <code>evidenceId</code> GUID and writes <code>SupportingDocuments</code> row. Side effects: emits <code>fa.evidence.attached</code> AuditLog event with <code>evidenceId</code>. <br> Validation & logic: <br> • Validate <code>taskId</code> exists unless attaching to a generic evidence pool (support unattached evidence). If <code>taskId</code> missing and <code>mandatoryAttach</code> policy true, return <code>ERR_EVIDENCE_ATTACH_MISSING_TASK</code>. <br> • Validate URL format (basic URI regex). If remote host reachable and supports HEAD, set <code>urlHealth=reachable</code>; if not reachable mark <code>urlHealth=unreachable</code> and set <code>evidenceStatus=invalid</code>. <br> • If <code>localFilePath</code> provided, compute <code>checksum = ComputeSHA256(fileBytes)</code>, set <code>evidenceStatus=valid</code> and store <code>checksum</code>; else <code>checksum=null</code> and <code>evidenceStatus=unverified</code>. <br> • Compute <code>evidenceRowChecksum</code> over canonical metadata and store. <br> Failure modes & remediation: <br> • URL unreachable → persist row with <code>evidenceStatus=invalid</code>, notify uploader via <code>modRemind</code> and append <code>PQ_Issues</code> entry <code>UnverifiedEvidence</code>. <br> • Checksum mismatch when verifying local file vs recorded checksum → set <code>evidenceStatus=invalid</code> and return <code>ERR_EVIDENCE_CHECKSUM_MISMATCH</code>. <br> Observability: <code>evidence.attach.count</code>, <code>evidence.invalidCount</code>, <code>evidence.unverifiedCount</code>. <br> Example: <code>AttachEvidence(&quot;T-100&quot;,&quot;https://sp/....pdf&quot;,&quot;bob&quot;,&quot;C:\tmp\recon.pdf&quot;)</code> returns <code>{status:&quot;OK&quot;,&quot;evidenceId&quot;:&quot;e-111-222&quot;}</code>. <br> 2. <code>RebindEvidence(evidenceId As String, newUrl As String, operatorId As String) As variant</code> — update pointer, record <code>rebindTs</code>, attempt re-verify checksum if file accessible, emit <code>fa.evidence.rebound</code> AuditLog event, return status object. Enforce <code>accessPolicy</code> check for operator authorization. <br> 3. <code>DetachEvidence(evidenceId As String, operatorId As String, reason As String) As boolean</code> — mark evidence as detached (soft-delete), preserve original row and append detachment details in <code>AuditLog</code>; do not physically delete evidenceId row. Return <code>True</code> on success and emit <code>fa.evidence.detached</code>. <br> 4. <code>VerifyEvidence(evidenceId As String) As variant</code> — attempt to fetch or HEAD and compare checksum; update <code>evidenceStatus</code> to <code>valid</code>, <code>invalid</code>, or remain <code>unverified</code>; return <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, evidenceStatus:&quot;valid&quot;|&quot;invalid&quot;|&quot;unverified&quot;, details}</code> and emit <code>fa.evidence.verified</code>. For external DMS where fetch prohibited, <code>VerifyEvidence</code> may delegate to platform verification token and record verification metadata. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Module: modSignOff — exhaustive function-level breakdown (complete):</strong> <br> Purpose: record sign-offs, validate approvers, support two-person approvals, provide queries and enforcement. <br> Public functions: <br> 1. <code>RecordSignOff(taskId As String, signerId As String, signedRole As String, approvalRef As String, comment As String) As variant</code> — returns <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, signOffId:GUID|null, errorCode:String|null, details:String|null}</code>. <br> Inputs: <code>taskId</code>, <code>signerId</code>, <code>signedRole</code>, optional <code>approvalRef</code>, optional <code>comment</code>. <br> Outputs: <code>signOffId</code>. Side effects: append <code>SignOffEntry</code> row, update <code>TasksMaster</code> computed sign-off fields, emit <code>fa.signoff.recorded</code>. <br> Validation logic: <br> • Validate <code>taskId</code> exists. If not return <code>ERR_SIGNOFF_TASK_NOT_FOUND</code>. <br> • Validate signer authorization per <code>policySnapshot.approvalMatrix</code> and <code>OwnerAssignments</code> (e.g., only owner or assigned approver allowed). If unauthorized, write <code>fa.signoff.invalid_attempt</code> and return <code>ERR_SIGNOFF_UNAUTHORIZED</code>. <br> • If two-person approval required (per <code>policySnapshot.twoPersonThresholds</code>) verify there is or will be a second signer with distinct <code>signedBy</code>. If requirement not met, still record the entry but mark <code>signOffPending=true</code> in task metadata and return status indicating <code>RequiresSecondSignOff</code>. <br> • Compute <code>signOffRowChecksum</code> and store immutably. <br> • Update <code>task.status</code> to <code>Signed Off</code> if sign-off fulfills requirements. <br> Queries: <br> • <code>QuerySignOffs(taskId As String) As Variant</code> — returns sign-off rows for UI and audits. <br> Example: <code>RecordSignOff(&quot;T-100&quot;,&quot;alice&quot;,&quot;owner&quot;,&quot;appr-123&quot;,&quot;Verified reconciliations&quot;)</code> returns <code>{status:&quot;OK&quot;,&quot;signOffId&quot;:&quot;s-333-444&quot;}</code>. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Module: modGating — exhaustive function-level breakdown (complete):</strong> <br> Purpose: central evaluation engine for close gating and close orchestration; responsible for <code>AttemptClose</code> and <code>CloseResult</code> semantics. <br> Public functions: <br> 1. <code>AttemptClose(closeDate As String, operatorId As String, Optional overrideApprovalRef As String) As variant</code> — returns structured <code>CloseResult</code> object <code>{status:&quot;CloseSucceeded&quot;|&quot;CloseBlocked&quot;|&quot;Error&quot;, closeId:GUID|null, blockReport:Variant|null, errorCode:String|null, details:String|null}</code>. <br> Input validation & steps: <br> • Refresh <code>TasksMaster</code> from PQ and lock a deterministic <code>manifestVersion</code> for evaluation; record <code>manifestVersion</code> in <code>AuditLog</code>. <br> • Identify all tasks where <code>gatingCategory = &quot;critical&quot;</code> and <code>signoffRequired = true</code>. <br> • For each critical task verify: (a) presence of required sign-offs per <code>policySnapshot.approvalMatrix</code> and <code>twoPersonThresholds</code> within <code>manifestVersion</code> unless policy allows cross-version acceptance, (b) all <code>evidenceRequirements</code> satisfied by <code>SupportingDocuments</code> with <code>evidenceStatus = valid</code> (or <code>unverified</code> only if <code>policySnapshot.evidenceChecksumPolicy</code> allows), (c) no active blocking flags in <code>PQ_Issues</code> for task. <br> Decision logic & outputs: <br> • If any task fails, assemble <code>CloseBlockReport</code> enumerating blocking tasks with <code>taskId</code>, <code>taskName</code>, <code>ownerContact</code>, <code>missingEvidenceCategories</code>, <code>signOffMissingRoles</code>, <code>pqIssuesRefs</code>, severity and remediation suggestions. Emit <code>fa.checklist.closeAttemptBlocked</code> with correlationId and return <code>CloseBlocked</code> with <code>blockReport</code>. <br> • If all pass or <code>overrideApprovalRef</code> is provided and operator authorized per <code>policySnapshot.emergencyRules</code>, create <code>closeEvent</code> with <code>closeId</code>, <code>closedBy</code>, <code>closedTs</code>, mark <code>ChecklistVersionManifest</code> as closed and emit <code>fa.checklist.closed</code>; return <code>CloseSucceeded</code> with <code>closeId</code>. <br> Atomicity & invariants: <br> • Evaluation and closing must be atomic relative to <code>manifestVersion</code>; implement using workbook-level lock and atomic manifest persistence. Either the close event and manifest persistence succeed together or the operation fails and no partial state is left. <br> Failure cases & remediation: <br> • Stale sign-offs (sign-offs created before the manifest version) validated via <code>policySnapshot.signoffTimeWindow</code>; if outside window require re-sign. <br> Observability: <code>close.attempts.count</code>, <code>close.blockCount</code>, <code>close.successCount</code>. <br> Example: <code>AttemptClose(&quot;2026-12-31&quot;,&quot;alice&quot;,Null)</code> -> returns <code>{&quot;status&quot;:&quot;CloseBlocked&quot;,&quot;blockReport&quot;:[...],&quot;errorCode&quot;:&quot;ERR_CLOSE_BLOCKED&quot;}</code> if blocks exist. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Module: modRemind — exhaustive function-level breakdown (complete):</strong> <br> Purpose: reminders and escalations engine for owners and approvers; supports scheduled reminders and ad-hoc sends. <br> Public functions: <br> 1. <code>SendReminder(ownerId As String, taskIds As Variant, templateId As String, operatorId As String) As variant</code> — composes email with task summary, missing evidence list, manifest link and sends via Outlook automation; returns <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, reminderId:GUID|null, details}</code> and emits <code>fa.reminder.sent</code>. Template substitution supports tokens: <code>{OwnerName}</code>, <code>{TaskList}</code>, <code>{ManifestLink}</code>. <br> 2. <code>ScheduleReminders(daysAhead As Integer, operatorId As String) As variant</code> — groups tasks by owner where <code>daysToDue = daysAhead</code> and calls <code>SendReminder</code> per owner; returns aggregated result object, emits <code>fa.reminder.scheduled</code>. Respect tenant email rate limits and PII redaction rules. <br> 3. <code>TriggerEscalation(taskId As String, operatorId As String) As boolean</code> — if <code>daysSinceAssigned &gt; escalationDays</code> create escalation event to <code>assignedOwner.approverId</code>, set <code>TasksMaster.escalationFlag=true</code>, write <code>fa.escalation.created</code> and send escalation email. <br> Operational constraints: email sending must avoid embedding raw sensitive data; include links referencing <code>manifestHash</code> and require user to authenticate to DMS to retrieve evidence. Telemetry: <code>reminder.sent.count</code>, <code>reminder.failure.count</code>, <code>escalation.count</code>. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Module: modAudit — exhaustive function-level breakdown (complete):</strong> <br> Purpose: append-only <code>AuditLog</code> persistence, manifest packaging, export and retention hooks; centralizes audit writes and export for e-discovery. <br> Public functions: <br> 1. <code>AppendAudit(eventType As String, actorId As String, detailsJson As String, evidenceRefs As Variant, manifestRef As String) As variant</code> — returns <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, eventId:GUID|null}</code> and writes <code>AuditLog</code> row to <code>AuditLog</code> sheet/table. <code>detailsJson</code> should be minimal but sufficient for replay; include <code>correlationId</code> when available. <br> 2. <code>ExportAuditManifest(versionId As String, outPath As String) As variant</code> — package audit rows associated with version, related manifests, and referenced evidence metadata; compress into zip and persist to <code>outPath</code> with checksum and signature if available. Return <code>{status:&quot;OK&quot;,&quot;exportPath&quot;:..., &quot;exportHash&quot;:...}</code>. <br> Retention & security: recommend exporting manifests and audit bundles to long-term archive per legal retention; sign/ checksum exports for integrity. Ensure only authorized operators can run exports; audit export events. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Module: modUtils — deterministic primitives & contracts (complete):</strong> <br> Provide deterministic helper functions used across modules. Public functions: <br> 1. <code>ComputeSHA256(inputBytes As Variant) As String</code> — compute sha256 hash of bytes or string using UTF-8 encoding and return hex string prefixed with <code>sha256:</code>. Implementation note: use ADODB.Stream / Windows Crypto API wrappers for binary file hashing. Caller must specify canonicalVersion if hashing includes versioned serialization. <br> 2. <code>CanonicalizeText(input As String, locale As String) As String</code> — apply Unicode NFKC normalization, trim, collapse repeated whitespace to single space, casefold using locale-sensitive rules (e.g., Turkish dotted/dotless <code>i</code> handling), remove non-printing characters and replace smart-quotes with ASCII equivalents. Document exact transformation steps in header doc to preserve parity. <br> 3. <code>FormatDateISO(dateInput) As String</code> — canonical date formatting <code>YYYY-MM-DD</code>, always in UTC for timestamps where relevant. <br> 4. <code>GenerateGUID() As String</code> — deterministic or random GUID generator per host; for deterministic reproduction use seed parameter; otherwise use Windows GUID APIs. <br> 5. <code>NowUTC() As String</code> — current UTC timestamp in <code>YYYY-MM-DDTHH:MM:SSZ</code>. <br> Note: <code>ComputeSHA256</code> must be used for <code>taskRowChecksum</code>, <code>evidenceRowChecksum</code>, <code>signOffRowChecksum</code> and <code>manifestHash</code>; ensure all callers use identical encoding and canonicalVersion parameter. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Canonical manifest generation — detailed recipe (expanded):</strong> <br> Purpose: produce tamper-evident canonical snapshots for each checklist version and close event using deterministic serialization rules. <br> Rules and step-by-step recipe: <br> 1. Manifest must include <code>canonicalVersion</code> as the first field; changing <code>canonicalVersion</code> requires <code>migrationManifest</code>. <br> 2. Use deterministic field ordering per manifest schema (e.g., <code>canonicalVersion|versionId|generatedBy|generatedTs|scope|taskCount|taskRowsCanonical...|manifestNotes</code>). <br> 3. For each task row include a canonicalized subset (Appendix A order) in manifest in canonical order by <code>taskId</code> ascending or by specified stable sort order. Escape <code>|</code> inside fields using explicit escape token <code>\|</code> and normalize newline characters to <code>\n</code>. <br> 4. Serialize as compact UTF-8 bytes without trailing newline. <br> 5. Compute <code>manifestHash = sha256:</code> of the bytes using <code>ComputeSHA256</code>. <br> 6. Persist <code>ChecklistVersionManifest</code> record with <code>manifestHash</code>, <code>manifestCanonicalString</code> (or store as compressed artifact), and link to generated PDF artifact. <br> Parity & verification: nightly parity job re-computes <code>manifestHash</code> for persisted manifests and raises <code>fa.verify.parity.failed</code> if mismatch; include byte-level diff utility to aid forensic investigation. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Approval matrix & policySnapshot semantics (complete & prescriptive):</strong> <br> Purpose: governing rules for who can sign, when two-person approvals are required, and override mechanics. <br> <code>policySnapshot</code> keys and semantics: <br> 1. <code>approvalMatrix</code> — mapping of <code>(priority, gatingCategory)</code> <code>→</code> required roles or counts (e.g., <code>(P0,critical) -&gt; [&quot;owner&quot;,&quot;manager&quot;]</code>). Policy snapshots must be versioned with <code>canonicalVersion</code>. <br> 2. <code>twoPersonThresholds</code> — numeric thresholds and role maps (e.g., any task with estimated financial impact > $X requires <code>owner + manager</code>). <br> 3. <code>signoffTimeWindow</code> — allowable time window for sign-offs relative to manifest generation (e.g., sign-offs must be within ±7 days of <code>generatedTs</code> unless <code>emergencyRules</code> apply). <br> 4. <code>emergencyRules</code> — temporary override mechanics (who can override, required compensating controls, mandatory audit logging). <br> 5. <code>evidenceChecksumPolicy</code> — level (<code>mandatory|recommended|disabled</code>) denoting whether checksum is required for evidence to satisfy gating. <br> Enforcement & change governance: <br> • <code>modSignOff</code> and <code>modGating</code> consult <code>policySnapshot</code> for validation; <code>policySnapshot</code> used for historical validation of older manifests. <br> • Changing <code>policySnapshot</code> must include <code>migrationManifest</code> and recorded approvals; do not retroactively apply stricter policies to previously closed manifests without documented remediation. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Duplicate detection & merge flow (detailed & implementable):</strong> <br> Purpose: avoid redundant tasks and consolidate evidence & sign-offs while preserving forensics. <br> Detection algorithm (conceptual but specific): <br> 1. Normalize <code>taskName</code> and <code>descriptionCanonical</code>. <br> 2. Tokenize into word sets (exclude stopwords), compute Jaccard similarity for token set overlap, and compute normalized Levenshtein distance for short names. Produce <code>similarityScore</code> combining token overlap and edit distance. <br> 3. If <code>similarityScore &gt; configuredThreshold (e.g., 0.8)</code> flag as <code>PossibleDuplicate</code> in <code>PQ_Issues</code>. <br> Merge workflow and rules: <br> 1. Analyst reviews <code>PQ_Issues</code> and calls <code>MergeTasks(primaryTaskId, secondaryTaskIds[], operatorId)</code>. <br> 2. <code>MergeTasks</code> reassigns <code>attachedEvidenceIds</code> and <code>SignOffEntries</code> to <code>primaryTaskId</code>, updates <code>TasksMaster</code> <code>attachedEvidenceIds</code> and <code>signOffEntries</code>, marks <code>secondaryTaskIds</code> as <code>deprecated=true</code>, appends <code>fa.task.merge</code> AuditLog entry with <code>mergedBy</code> and reason. <br> 3. Retain historical rows for forensic trace; do not delete or rewrite past manifest rows. <br> 4. After merge re-run PQ parity tests and compute new <code>taskRowChecksum</code> for <code>primaryTaskId</code>. <br> Operational note: merges must be approved by compliance if tasks are in <code>critical</code> gating and must record rationale. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Ad-hoc task intake & triage (complete & prescriptive):</strong> <br> Purpose: capture unplanned audit items and integrate them into checklist flows with auditability. <br> Intake steps: <br> 1. <code>AdhocRequests</code> table captures <code>adhocId</code>, <code>requestedBy</code>, <code>descriptionRaw</code>, <code>priority</code>, <code>requestedDueDate</code>, <code>rationale</code>, <code>createdTs</code>. <br> 2. Triage analyst reviews and converts into <code>YearEndTaskRow</code> with <code>taskSource = adhoc</code> and assigns <code>assignedOwnerId</code>; conversion function must validate owner and default <code>defaultDueOffsetDays</code>. <br> 3. If urgent, set <code>priority = P0</code> and <code>emergency=true</code> to engage <code>policySnapshot.emergencyRules</code> and notify approvers. <br> 4. <code>AdhocRequests</code> should be surfaced in <code>TasksMaster</code> staging view until accepted and included in a <code>ChecklistVersionManifest</code>. <br> 5. All <code>AdhocRequests</code> and triage decisions appended to <code>AuditLog</code>. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Post-close adjustment & reopen flow (detailed):</strong> <br> Purpose: correct errors discovered after close while preserving audit trail and legal trace, ensuring chain-of-custody. <br> Workflow: <br> 1. Create <code>PostCloseAdjustment</code> task linked to <code>closeEventId</code> with <code>priority</code> and <code>requiredApprovals</code>. <br> 2. Obtain approvals per <code>policySnapshot.twoPersonThresholds</code>; attach new evidence and record sign-offs. <br> 3. <code>ReopenClose(closeId, operatorId, reason, approvals[])</code> process: validate approvals, lock prior manifest, produce <code>reopenEvent</code> in <code>AuditLog</code>, mark prior <code>closeEvent</code> as <code>superseded</code>, create new <code>ChecklistVersionManifest</code> capturing adjustments. <br> 4. After correction and re-signing, run <code>AttemptClose</code> again to produce <code>newCloseEvent</code> with new <code>closeId</code>. <br> Forensics & legal considerations: <br> • Archive both original and superseding manifests and all related <code>AuditLog</code> entries; record <code>supersedingCloseId</code> relation for legal trace. <br> • Provide export tooling to produce zipped forensic bundles for e-discovery including prior manifests, diffs, sign-offs and evidence metadata. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Status dashboard — required views, KPIs and conceptual DAX measures (expanded):</strong> <br> Purpose: operational visibility and audit oversight in Excel and Power BI; provide actionable owner-level views and parity monitoring. <br> Required views: <br> 1. <strong>Overview tiles</strong> — <code>TotalTasks</code>, <code>OpenTasks</code>, <code>CriticalOpen</code>, <code>OverdueTasks</code>, <code>SignOffPending</code> with trend sparkline. <br> 2. <strong>Owner view</strong> — tasks by owner with missing evidence counts, overdue items, and next action. <br> 3. <strong>Department view</strong> — aggregated risk heatmap of <code>gatingRisk</code> across departments with drillthrough to task lists. <br> 4. <strong>Sign-off registry</strong> — filterable table showing sign-offs by signer, date range and task with link to manifest. <br> 5. <strong>Manifest parity view</strong> — list of <code>manifestVersionId</code>s with <code>manifestHash</code>, <code>parityStatus</code>, and <code>parityDiff</code> if mismatch. <br> Conceptual DAX measures (descriptive, no code): <br> • <code>TasksOpen</code> — measure counting tasks where <code>status</code> not in (Complete, Signed Off) used as numerator for other rates. <br> • <code>CriticalOpen</code> — count tasks with <code>gatingCategory = critical</code> and <code>status</code> not Signed Off; used for alerting. <br> • <code>SignOffRate</code> — ratio of tasks with ≥1 sign-off entries to total tasks; produce owner- and department-sliced variants. <br> • <code>AvgDaysToClose</code> — average of <code>closedTs - generatedTs</code> per manifest used for trend and SLA monitoring. <br> • <code>MissingEvidenceCount</code> — aggregated sum across tasks of required evidence categories not satisfied; breakdown by evidenceCategory for targeted remediation. <br> Use these conceptual measures to build trend lines, distribution charts, and owner-level heatmaps; include parity status tile that lists manifests with <code>parityStatus &lt;&gt; OK</code>. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Examples — exhaustive worked scenarios and edge-cases (expanded):</strong> <br> Example A — Critical statutory tax submission (end-to-end): <br> • Task: "Finalize statutory tax reconciliation" — <code>gatingCategory = critical</code>, <code>priority=P0</code>, <code>evidenceRequirements = [taxReconciliationPDF, taxReturnDraft]</code>, <code>signoffRequired = true</code>, <code>defaultDueOffsetDays = 14</code>. <br> • Flow: PQ calculates <code>computedDueDate</code>. Tax lead uploads <code>taxReconciliation.pdf</code> with checksum via <code>AttachEvidence</code>. Tax manager records sign-off via <code>RecordSignOff</code>. <code>AttemptClose</code> validates evidence present and sign-off and allows close. If evidence stored in external DMS without checksum, <code>evidenceStatus</code> remains <code>unverified</code> and <code>AttemptClose</code> blocks until manual verification or rebind with checksum. Include remediation steps for missing checksum and sample <code>AuditLog</code> events. <br> Example B — Fixed asset count with photo evidence: <br> • Task: "Physical asset count — Plant A" — requires <code>assetCountSheet</code> (spreadsheet) and <code>photoEvidence</code> (timestamped photos). PQ performs heuristic matches on photo filenames but flags <code>heuristicMatch</code> in <code>PQ_Issues</code>; analyst confirms attachments. Two sign-offs required: <code>assetManager</code> and <code>inventoryController</code>. Close blocked until both sign-off and photos validated (EXIF timestamp or DMS metadata). Include step-by-step photo verification guidance (check EXIF timestamp, compare against <code>computedDueDate</code>, validate file checksum and uploader). <br> Example C — Duplicate detection and merge: <br> • Two entries detected as duplicates by normalized similarity. Analyst runs <code>MergeTasks(primary, [secondary])</code>, evidence and sign-offs moved to <code>primary</code>. <code>AuditLog</code> written. Prior versions remain for forensic purposes and <code>secondary</code> marked <code>deprecated</code>. Document post-merge parity checks to ensure <code>primary.taskRowChecksum</code> updated and <code>manifestHash</code> recalculated on next generation. <br> Example D — Emergency ad-hoc request during close window: <br> • Ad-hoc identified with <code>priority=P0</code> and <code>emergency=true</code>. <code>policySnapshot.emergencyRules</code> allows a manager override with compensating controls. Analyst invokes <code>GenerateChecklistPDF</code> for the emergency scope, obtains expedited approvals via <code>RecordSignOff</code>, uses <code>AttemptClose</code> with <code>overrideApprovalRef</code> recorded in AuditLog, and <code>modAudit</code> records override rationale. Provide operator checklist for emergency flows including explicit <code>overrideApprovalRef</code> capture and compensating control checklist. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Testing & parity — exhaustive test matrix (expanded and prescriptive):</strong> <br> Unit tests (recommended automated test harness for VBA where feasible and manual verification checklist for PQ): <br> 1. Canonicalization: unicode NFKC normalization tests, Turkish locale <code>I/i</code> rules, whitespace collapse tests, diacritic retention/stripping tests. <br> 2. Date handling: explicitDueDate parsing for valid/invalid formats, computedDueDate logic across leap years, month-ends, and cross-timezone inputs. <br> 3. Hash parity: <code>ComputeSHA256</code> reproducibility tests for sample strings and binary files (assert exact hex output). <br> 4. Evidence verify: checksum matches for sample files, mismatch detection and error conditions. <br> 5. Sign-off validation: authorized signer vs unauthorized attempts; two-person logic and signoffTimeWindow enforcement. <br> Integration tests: <br> 1. End-to-end happy path: template ingest → PQ → GenerateChecklistPDF → AttachEvidence → RecordSignOff → AttemptClose → close success. <br> 2. Blocked paths: missing evidence, missing sign-offs, stale sign-offs pre-manifest. <br> Golden parity tests: <br> 1. Maintain canonical fixtures for <code>manifestHash</code> and <code>taskRowChecksum</code> for representative scenarios; nightly parity job re-computes and raises alerts. <br> 2. Provide <code>fixture_small</code>, <code>fixture_mid</code>, <code>fixture_edge</code> with expected checksums. <br> Performance and concurrency tests: <br> 1. PQ refresh performance for 500, 2k, 10k rows; document refresh times and memory use; recommend DWH for 10k+. <br> 2. PDF generation performance for large scopes; recommended page grouping to avoid Excel timeouts. <br> 3. Macro concurrency: test workbook-level lock behavior under simulated concurrent mutators; recommend single-author model for mutative actions. <br> Security tests: static scan of macros for secrets, ensure workbook does not store credentials, verify <code>SupportingDocuments.url</code> reachability only via HEAD if tenant allows. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Observability & telemetry — metrics and alerts (expanded):</strong> <br> Recommended metrics to capture in monitoring sheet or external sink: <br> 1. <code>tasks.total</code> and <code>tasks.open</code> by priority and <code>gatingCategory</code>. <br> 2. <code>tasks.criticalOpen</code> trending by days to close. <br> 3. <code>evidence.invalidCount</code>, <code>evidence.unverifiedCount</code>, and <code>evidence.attachmentRate</code>. <br> 4. <code>signoffs.count</code>, <code>signoffs.pending</code>, <code>signoffs.rejected</code>. <br> 5. <code>checklist.generated.count</code> and <code>checklist.generate.durationMs</code> distributions. <br> 6. <code>close.attempts</code>, <code>close.blockCount</code>, <code>close.successCount</code> and <code>close.overrideCount</code>. <br> 7. <code>reminders.sent</code> and <code>reminder.failure.count</code>. <br> Suggested alerts and thresholds: <br> • Alert: <code>CriticalOpen &gt; 0</code> within 48 hours of <code>closeDate</code> — severity High. <br> • Alert: <code>evidence.invalidCount</code> spike > configured threshold in 24 hours — severity Medium. <br> • Alert: <code>manifestHash</code> parity failure — severity High and immediate escalation to compliance. <br> • Alert: <code>AttemptClose</code> failure rate > X% in last 7 days — severity Medium. <br> Implementation note: collect metrics in a <code>Telemetry</code> sheet with timestamped entries and push to external BI or monitoring sink if available. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Security & privacy controls — detailed guidance (expanded):</strong> <br> Principles: minimize PII exposure in PDF artifacts and emails; do not persist credentials; restrict workbook modification to authorized roles; digitally sign macros if required. <br> Controls and recommended implementations: <br> 1. Evidence URLs are pointers; retrieval must respect platform access controls; do not embed authentication tokens in <code>url</code> fields. <br> 2. PDFs should not include raw PII unless absolutely necessary; when PII included, ensure PDF stored in secure evidence store and access controlled. Implement <code>redactionMode</code> to redact sensitive columns in distributed PDFs and include <code>evidenceRef</code> for retrieval under access control. <br> 3. AuditLog exports must be signed and checksummed; use organizational signing keys if available. <br> 4. Macro signing and workbook ACL enforcement recommended for production deployments; maintain <code>operators</code> list for mutative actions. <br> 5. Use <code>accessPolicy</code> metadata on <code>SupportingDocument</code> rows to define retrieval roles; enforce in <code>modRemind</code> and PDF generation (redact or omit underlying PII based on operator's role). <br> 6. Ensure backups and archival stores use encrypted-at-rest storage and preserve checksums. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Retention, archival & legal hold guidance (expanded):</strong> <br> Recommendations and implementable steps: <br> 1. Persist <code>ChecklistVersionManifest</code>, <code>SupportingDocuments</code> metadata, and <code>AuditLog</code> to long-term archive in compressed signed bundles according to legal retention rules (e.g., 7-10 years depending on jurisdiction). <br> 2. Store closed version PDFs and <code>manifestHash</code> in evidence store with <code>legalTags</code> and retention metadata; create <code>forensicBundle</code> that contains manifest, AuditLog slices, and evidence metadata for e-discovery. <br> 3. Implement legal hold process to preserve archives beyond retention when required; mark manifests and evidence with <code>legalHold=true</code>. <br> 4. Provide export tooling (<code>modAudit.ExportAuditManifest</code>) to produce zipped forensic bundles including verifiable checksums and optional digital signatures. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Migration & change governance — migrationManifest requirements (detailed):</strong> <br> For template changes or policy changes impacting gating semantics produce a <code>migrationManifest</code> capturing: <br> 1. <code>migrationId</code>, <code>author</code>, <code>createdTs</code>. <br> 2. <code>changeRationale</code>, <code>affectedTaskIdsBeforeAfter</code> (mapping of old -> new), <code>sampleFixtures</code> with before/after expected <code>manifestHash</code>. <br> 3. <code>estimatedAffectedCount</code>, <code>canaryPlan</code> (cohort + KPIs), <code>rollbackPlan</code>, <code>approvals[]</code>. <br> Process and governance: <br> 1. Draft migrationManifest and register in governance system with required approvers. <br> 2. Run canary against small cohort (non-critical) and monitor parity KPIs such as <code>CriticalOpenDeltaPct</code>. <br> 3. If canary passes and approvals recorded, promote change and persist <code>migrationManifest</code> in <code>AuditLog</code>. <br> 4. If fails, rollback per <code>rollbackPlan</code> and document findings and remedial actions. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Operator CLI patterns & macro wrappers (concise examples & return structures):</strong> <br> 1. <code>fa.refresh --operator alice</code> → refresh PQ, write <code>fa.pq.refresh</code> audit event, return <code>{status:&quot;OK&quot;, pqIssuesCount:0}</code>. <br> 2. <code>fa.generateChecklist --scope All --notes &quot;v1&quot; --operator alice</code> → invokes <code>GenerateChecklistPDF</code>, returns <code>{status:&quot;OK&quot;,&quot;versionId&quot;:&quot;v-123&quot;}</code> or error object with <code>errorCode</code>. <br> 3. <code>fa.attachEvidence --task T-123 --url https://... --uploader bob</code> → <code>AttachEvidence</code> returns <code>{status:&quot;OK&quot;,&quot;evidenceId&quot;:&quot;e-111&quot;}</code>. <br> 4. <code>fa.recordSignoff --task T-123 --signedBy bob --approvalRef ap-321</code> → <code>RecordSignOff</code> returns sign-off object or <code>ERR_SIGNOFF_UNAUTHORIZED</code>. <br> 5. <code>fa.attemptClose --closeDate 2026-12-31 --operator alice</code> → <code>AttemptClose</code> returns structured close result. <br> CLI operations return structured JSON-like objects and always write <code>AuditLog</code> entries; macros wrap these calls and present human-friendly prompts for interactive confirmations on high-risk operations such as override approvals. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Deployment & rollout recommendations (prescriptive):</strong> <br> 1. Pilot with one department and up to 500 tasks for 2 cycles; collect PQ refresh times, owner feedback, and parity results. <br> 2. Expand to cross-department run; validate PQ refresh latency and PDF generation time; increase pilot size gradually to 2k tasks. <br> 3. Provide owner onboarding and runbook training materials and record sessions for asynchronous training. <br> 4. Define retention policy and evidence archive strategy before wide rollout; ensure archive storage and signature keys are available. <br> 5. For multi-user environments, enforce single-author model for mutative actions or use a controlled staging server approach with a centralized operator performing closes and manifest persistence. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Scaling beyond Excel — architectural options & parity guidance:</strong> <br> For larger scale or enterprise requirements the following migration path is recommended while preserving canonicalization and manifest hashing recipes: <br> 1. Move metadata sources to a light Data Warehouse (Azure Synapse / BigQuery) for <code>TasksMaster</code> and <code>SupportingDocuments</code> metadata; replace local PQ with scheduled ETL or serverless flows that implement same canonicalization. <br> 2. Use Power BI dataset for dashboards with incremental refresh; keep <code>manifestHash</code> generation consistent in central service. <br> 3. Replace workbook server-side PDF generation from templating engine (e.g., docx → PDF) integrated with evidence store to avoid workbook concurrency issues. <br> 4. Expose API surface for <code>AttachEvidence</code>, <code>RecordSignOff</code>, <code>AttemptClose</code> to centralize governance, concurrency control and role-based authorization. <br> 5. Maintain identical canonicalization and manifest hashing recipes to guarantee parity across environments; include <code>canonicalVersion</code> metadata to detect drift. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Comprehensive examples — long-form scenarios and edge-cases (expanded):</strong> <br> Example E — Cross-department consolidation and merged manifest: <br> • Scenario: two departments run separate checklists and require consolidated corporate-level close. <br> • Flow: each department generates <code>ChecklistVersionManifest</code> with <code>manifestHash</code>. Corporate consolidation script ingests manifests, validates <code>manifestHash</code> parity, and computes a consolidated <code>CorporateManifest</code> that references departmental <code>versionId</code>s and computes consolidated <code>manifestHash</code>. Corporate close requires each departmental <code>closeEvent</code> present and <code>closeEvent.closedTs</code> within corporate policy windows. <br> Edge nuance: departmental manifests may contain duplicated tasks (<code>taskId</code> duplication); consolidation logic must respect <code>taskId</code> uniqueness using canonical <code>taskId</code> deduplication and merge sign-offs without duplicating evidence references. Document algorithm for consolidation used for corporate manifests. <br> Example F — Evidence moved between stores (rebind) during close: <br> • Scenario: evidence migrated from one SharePoint site to another mid-close. <br> • Flow: <code>RebindEvidence(evidenceId, newUrl, operatorId)</code> records rebind event, rechecks checksum; <code>AttemptClose</code> uses updated <code>SupportingDocuments</code> rows. <code>AuditLog</code> records both old and new URL for forensic trace. If checksum mismatches after migration, <code>evidenceStatus</code> marked <code>invalid</code> and <code>AttemptClose</code> blocked until remediation. <br> Example G — Policy change impacts sign-off rules mid-cycle: <br> • Scenario: policy changes require two-person approval for P1 tasks after manifest V1 created. <br> • Flow: <code>migrationManifest</code> required; canary executed on non-critical cohort. For already generated manifests, apply migration only to future manifests or create a documented remediation plan recorded in <code>AuditLog</code> — do not silently change prior manifest semantics. Provide operator guidance to create <code>PostCloseAdjustment</code> tasks if retroactive requirements must be enforced. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Acceptance criteria & release gates (detailed & testable):</strong> <br> 1. Unit tests and integration tests pass for canonicalization, hashing, and key flows; include test harness for <code>ComputeSHA256</code> outputs. <br> 2. Golden parity tests confirm <code>manifestHash</code> reproducibility for canonical fixtures. <br> 3. <code>GenerateChecklistPDF</code> produces PDF and persistent manifest without errors for sample scopes; verify filename and manifestHash prefix. <br> 4. <code>AttemptClose</code> correctly blocks for missing sign-offs/evidence and allows close when requirements met; simulate override flows and confirm <code>AuditLog</code> entries. <br> 5. <code>AuditLog</code> records for each mutative action and <code>AuditLog</code> export validated for integrity (checksum + signature). <br> 6. Security checks passed: no credentials persisted in workbook, sensitive columns redacted in distributed PDFs, macros signed if required. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Operational runbooks — concise procedural checklists (detailed):</strong> <br> Runbook: Pre-close readiness (recommended routine): <br> 1. Refresh PQ and review <code>PQ_Issues</code> <code>→</code> remediate top 10 high-severity issues; log remediation events in <code>AuditLog</code>. <br> 2. Run <code>GenerateChecklistPDF --scope All --notes &quot;pre-close run&quot;</code> and distribute to owners; save local staging backup. <br> 3. Monitor <code>MissingEvidenceReport</code> and escalate top <code>gatingRisk=High</code> items; create follow-up tasks and assign owners. <br> 4. Send reminders at 14, 7, 3 days before close for outstanding items; track reminder responses and delivery failures. <br> 5. Collect sign-offs and verify <code>SignOffRegistry</code> completeness; flag any stale sign-offs for re-sign. <br> 6. Run <code>AttemptClose</code> 48 hours before final close to surface blocks; remediate and rerun until <code>AttemptClose</code> reports <code>CloseSucceeded</code>. <br> Emergency reopen runbook (concise): <br> 1. Create <code>PostCloseAdjustment</code> task with link to <code>closeEventId</code>. <br> 2. Obtain required approvals per <code>policySnapshot.twoPersonThresholds</code>. <br> 3. Run <code>ReopenClose</code> with approvals; document reason in <code>AuditLog</code>. <br> 4. Apply adjustments, re-generate manifest and close again producing <code>supersedingCloseId</code>. <br> 5. Archive both manifests with <code>supersedingCloseId</code> relation recorded. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Error codes & diagnostics (compact taxonomy with guidance):</strong> <br> Purpose: deterministic machine-readable errors across macros and CLI wrappers; each error code accompanied by a human message and <code>auditRef</code> linking to <code>AuditLog</code>. <br> Categories and examples: <br> • <code>ERR_PQ_REFRESH_FAILED</code> — PQ refresh failed; check <code>PQ_Issues</code> and <code>Telemetry</code>. <br> • <code>ERR_CHECKLIST_MISSING_REQUIRED_FIELDS</code> — required fields missing for PDF generation; include <code>missingFields</code> detail. <br> • <code>ERR_EVIDENCE_URL_INVALID</code> — evidence URL format invalid; include example corrected format. <br> • <code>ERR_EVIDENCE_CHECKSUM_MISMATCH</code> — computed checksum differs from recorded; provide evidenceId and computed vs recorded checksums in <code>details</code>. <br> • <code>ERR_SIGNOFF_UNAUTHORIZED</code> — signer not authorized per <code>policySnapshot</code>; include <code>requiredRole</code> and <code>signerRole</code>. <br> • <code>ERR_CLOSE_BLOCKED</code> — close blocked due to missing sign-offs/evidence; attach <code>CloseBlockReportRef</code>. <br> • <code>ERR_MANIFEST_PERSIST_FAIL</code> — manifest persistence failed during close; include IO diagnostic. <br> • <code>ERR_PDF_WRITE_FAIL</code> — PDF export failed; include temp path and IO error. <br> Each error code must be accompanied by human-readable message and <code>auditRef</code> linking to detailed <code>AuditLog</code> row with context and remediation steps. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Sample fixture descriptions (for parity tests — expanded):</strong> <br> Provide three golden fixtures for CI with detailed content and expected checksums: <br> 1. <code>fixture_small</code> — 25 tasks, 10 evidence items, 5 critical tasks with sign-offs; include expected <code>taskRowChecksum</code> and <code>manifestHash</code> sample values. <br> 2. <code>fixture_mid</code> — 500 tasks, mixed priorities, scattered evidence and sign-offs; include <code>pqIssues</code> examples and expected <code>manifestHash</code>. <br> 3. <code>fixture_edge</code> — tasks with locale-sensitive text (Turkish, Arabic), duplicate names, cross-currency evidence references, and mixed date formats; include expected <code>taskRowChecksum</code> and <code>manifestHash</code> values for golden parity checks. <br> Each fixture includes a <code>fixtureManifest.json</code> describing canonicalVersion, <code>closeDate</code>, <code>policySnapshot</code> used and expected hashes for regression testing. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>QA checklist for release (concise & actionable):</strong> <br> 1. PQ refresh completes without <code>PQ_Issues</code> high-severity items for sample fixtures. <br> 2. <code>GenerateChecklistPDF</code> succeeds for All and Owner scopes; PDFs saved with correct filenames and <code>manifestHash</code> recorded in <code>ChecklistVersionManifest</code>. <br> 3. <code>AttachEvidence</code> for local files computes checksum matching expected values in fixtures. <br> 4. <code>RecordSignOff</code> enforces <code>policySnapshot.approvalMatrix</code> and rejects unauthorized signers. <br> 5. <code>AttemptClose</code> blocks for missing evidence/sign-off and succeeds when remediation applied. <br> 6. <code>AuditLog</code> export contains expected events for all steps and export checksum verified. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Onboarding & training outline (concise & structured):</strong> <br> 1. Owner onboarding slide deck — responsibilities, how to attach evidence, sign-off process, and sample screenshots of PDF / reminder emails. <br> 2. Analyst runbook — PQ refresh, <code>PQ_Issues</code> remediation, duplicate merge process, golden fixture parity checks and sample commands. <br> 3. Operator quick reference — <code>GenerateChecklistPDF</code>, <code>SendReminders</code>, <code>AttemptClose</code> steps and error handling with recovery recipes. <br> 4. Compliance training — evidence custody, legal hold procedures, audit export instructions and approvals required for overrides. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Legal & compliance considerations (concise & prescriptive):</strong> <br> 1. Evidence storage must comply with internal retention and data protection policies; verify jurisdictional rules for PII and encryption-at-rest requirements. <br> 2. Audit logs and manifests must be exportable for e-discovery; maintain chain-of-custody metadata and snapshot signatures. <br> 3. Overrides and emergency rules should be time-boxed and documented with compensating controls and recorded in <code>AuditLog</code>. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Appendices — schemas, canonical orders, and templates (detailed):</strong> <br> Appendix A — YearEndTaskRow canonical serialization order for hashing: <code>canonicalVersion|taskId|taskName|assignedOwnerId|gatingCategory|computedDueDate|signoffRequired</code>. <br> Appendix B — SupportingDocument canonical serialization order: <code>canonicalVersion|evidenceId|title|url|uploaderId|uploadedTs|evidenceCategory</code>. <br> Appendix C — SignOffEntry canonical serialization order: <code>canonicalVersion|signOffId|taskId|signedBy|signedTs|versionId</code>. <br> Appendix D — ChecklistVersionManifest canonical field order: <code>canonicalVersion|versionId|generatedBy|generatedTs|scope|taskCount|blockingCount|manifestRowsCompact...|notes</code>. <br> Appendix E — Minimal <code>policySnapshot</code> keys list: <code>approvalMatrix</code>, <code>twoPersonThresholds</code>, <code>signoffTimeWindow</code>, <code>evidenceChecksumPolicy</code>, <code>emergencyRules</code>, <code>canonicalVersion</code>. <br> Appendix F — Example <code>AuditLog</code> schema (compact): <code>eventId,eventType,actorId,timestampUTC,correlationId,detailsJson,evidenceRefs,manifestRef</code>. </td></tr><tr><td data-label="Project 062 — Year-End Audit Checklist Generator Overview"> <strong>Closing operational note (concise):</strong> <br> Deliverables: a production <code>ChecklistGeneratorWorkbook.xlsm</code> (PQ queries, tables, macros), sample data, full runbook, error codes, and templates. <br> Next selectable artifacts I can produce now (pick any/all): <br> 1. Canonical JSON Schema for <code>YearEndTaskRow</code>, <code>SupportingDocument</code>, <code>SignOffEntry</code>, <code>ChecklistVersionManifest</code> with exact field ordering for hashing. <br> 2. Ready-to-paste VBA module stubs for all modules above including public function signatures, header docs and deterministic error codes. <br> 3. Power Query step-by-step transformation narrative mapping named steps and intermediate outputs for <code>TasksMaster</code> aggregation. <br> 4. Conceptual DAX measure list and report wireframes for Power BI (no code). <br> 5. Three golden fixture CSVs (small, mid, edge) with expected checksums for parity tests. <br> Select which artifact(s) to produce and optionally provide sample template data if populated sample sheets required. </td></tr></tbody></table></div><div class="row-count">Rows: 45</div></div><div class="table-caption" id="Table2" data-table="Docu_0188_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modChecklist — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modChecklist — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Preface & Intent (extended):</strong><br>This document is the comprehensive implementation and operational blueprint for <code>modChecklist</code> (Project 062). It expands the canonical checklist concept into a production-ready engineering artifact, suitable for regulated environments. It contains: exhaustive per-row entity narratives, complete function-level contracts for every public function, detailed procedural sequences, atomicity and rollback semantics, deterministic canonical serialization recipes, manifest hashing rules, error-code taxonomy, telemetry specification, conceptual Power Query (PQ) orchestration, conceptual DAX reporting patterns, complete worked examples covering edge cases, governance and migration processes, security & privacy controls, archival & legal-hold guidance, operator runbooks, testing matrices, parity procedures, sample fixtures, and onboarding guidance. The objective: enable an implementer, operator, or auditor to build, operate, test, govern and forensically validate the checklist generator lifecycle end-to-end without ambiguity. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>High-level responsibilities (explicit):</strong><br>1. Provide a single authoritative TasksMaster aggregation (PQ) used as the source of truth for all downstream artifacts and gating decisions.<br>2. Enforce deterministic gating rules via <code>policySnapshot</code> and block organizational close for <code>critical</code> tasks when mandatory evidence or sign-offs are missing.<br>3. Produce printable, versioned checklists and PDF artifacts grouped by scope (owner, department, gating buckets) with canonical filenames and manifest hashing to detect tampering.<br>4. Maintain append-only sign-off registry and evidence metadata with content checksums for chain-of-custody and legal admissibility.<br>5. Provide operational dashboards (Excel/Power BI) summarizing status, missing evidence, overdue items, sign-off rates and manifest parity for compliance oversight.<br>6. Support controlled ad-hoc intake, merges, post-close remediation, and reopen flows while retaining full forensic trails. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Design principles (binding):</strong><br>1. Single source of truth: <code>TasksMaster</code> produced by PQ is authoritative; all UI, gating, and PDF artifacts must derive from this table without local overrides.<br>2. Deterministic outputs: canonical date format <code>YYYY-MM-DD</code>, canonical text normalization, stable field order, and canonical serialization recipes for manifests; any change to recipes must be recorded as a <code>canonicalVersion</code> change with a <code>migrationManifest</code> and approvals.<br>3. Auditability: every mutative action (attach, rebind, sign-off, generate, close, reopen, merge) creates an <code>AuditLog</code> event and includes <code>correlationId</code> linking related events.<br>4. Least privilege: workbook never stores service credentials; evidence fields are pointers with checksums and retrieval is controlled by platform access policies.<br>5. Reversible & traceable: versioned manifests, append-only registries, and immutable sign-off records ensure all changes can be reconstructed and forensically documented.<br>6. Fail-safe defaults: gating rules default to conservative behavior — missing evidence or unverified checksums block close unless <code>policySnapshot</code> explicitly relaxes. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Scope & boundaries (explicit):</strong><br>• In scope: Excel <code>.xlsm</code> workbook including Power Query queries, structured tables (<code>YearEndTaskTemplate</code>, <code>OwnerAssignments</code>, <code>AdhocRequests</code>, <code>SupportingDocuments</code>, <code>SignOffEntries</code>, <code>TasksMaster</code>, <code>ChecklistVersionManifest</code>, <code>AuditLog</code>, <code>Telemetry</code>), VBA module <code>modChecklist</code> plus supporting modules (<code>modEvidence</code>, <code>modSignOff</code>, <code>modAudit</code>, <code>modUtils</code>, <code>modRemind</code>), operator macros, and runbooks. <br>• Out of scope: direct ERP or GL postings, automated accounting system mutations, building external DMS connectors beyond pointers without integration plan, credential management and authentication middleware. <br>• Scale guidance: Excel + PQ pattern recommended for up to several thousand tasks; for sustained scale (10k+ tasks) migrate metadata to a data warehouse and server-side services but preserve canonicalization recipes for parity. <br>• Security boundary: workbook is not an evidentiary content store; it stores metadata pointers and checksums only; full evidence resides in controlled DMS with access policies. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Glossary (essential):</strong><br>• <code>Task</code> — atomic checklist item requiring evidence and/or approvals. <br>• <code>SupportingDocument</code> — metadata pointer to evidence with checksum and access policy. <br>• <code>SignOffEntry</code> — immutable approval event recorded with signer, role, timestamp and (optional) signature fingerprint. <br>• <code>ChecklistVersionManifest</code> — canonical snapshot of a generated checklist including canonicalized task rows and <code>manifestHash</code>. <br>• <code>PQ</code> — Power Query pipeline that produces <code>TasksMaster</code> and validation artifacts. <br>• <code>AuditLog</code> — append-only event table that captures all mutative actions and important system events. <br>• <code>policySnapshot</code> — versioned governance configuration controlling approval matrices, evidence policies, emergency rules and time windows. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Canonical entity: YearEndTaskRow (exhaustive):</strong><br>Purpose: canonical atomic representation of a checklist task used in PQ, UI, manifests and gating logic. <br>Required fields and semantics (full narratives):<br><code>taskId</code> — stable canonical identifier (GUID or deterministic string). Narrative: must be stable across versions for the same logical task; generate via <code>modUtils.GenerateGUID()</code> when creating new tasks. If mapping from external systems is required use a stable seeded GUID mapping strategy and record mapping in <code>AuditLog</code>.<br><code>taskNameRaw</code> — the original text as provided in template or ad-hoc request. Narrative: always preserved for provenance and forensic exports; never mutate. <br><code>taskNameCanonical</code> — normalized textual title used for duplicates and canonicalization. Narrative: apply Unicode NFKC, trim, collapse whitespace, casefold with locale rules (document the locale used), strip non-printing characters and replace smart quotes; store <code>canonicalVersion</code> used for normalization. <br><code>descriptionRaw</code> — original long description preserved for audit. <br><code>descriptionCanonical</code> — normalized description used for fuzzy matching and deduplication heuristics. <br><code>taskSource</code> — <code>template|adhoc</code> — Narrative: indicates origin; <code>adhoc</code> tasks must have <code>requestedBy</code> and <code>requestTs</code>. <br><code>defaultOwnerId</code> — template owner id for suggestion. <br><code>assignedOwnerId</code> — live assignment; changes must append <code>AuditLog</code> entries; implement owner resolution fallback to department default if null. <br><code>department</code> — useful for grouping and manifest scope. <br><code>priority</code> — <code>P0|P1|P2|P3</code> where <code>P0</code> is highest; policy-driven reminders and escalation use priority. <br><code>gatingCategory</code> — <code>critical|important|optional</code> used to block close when required evidence or sign-off missing; default mapping for template tasks must be documented. <br><code>defaultDueOffsetDays</code> — integer used to compute <code>computedDueDate</code> relative to <code>closeDate</code>. <br><code>explicitDueDate</code> — optional override; must be ISO <code>YYYY-MM-DD</code> and validated. <br><code>computedDueDate</code> — authoritative ISO due date used in gating; PQ computes this deterministically from <code>explicitDueDate</code>, <code>defaultDueOffsetDays</code> and <code>CloseParameters.closeDate</code>. <br><code>evidenceRequirements[]</code> — list of required evidence taxonomy keys (e.g., <code>taxReconciliationPDF</code>, <code>signedManagerApproval</code>). Narrative: gating uses these keys to determine missing evidence per task. <br><code>attachedEvidenceIds[]</code> — list of evidence pointers attached to this task; multiple evidence items allowed. <br><code>signoffRequired</code> — boolean; if true, gating checks sign-off count and roles per <code>policySnapshot.approvalMatrix</code>. <br><code>signOffEntries[]</code> — list of <code>signOffId</code> references; used to compute sign-off coverage. <br><code>status</code> — controlled vocabulary <code>Not Started|In Progress|Blocked|Complete|Signed Off</code>; transitions audited in <code>AuditLog</code>. <br><code>comments[]</code> — append-only array with actor and timestamp; used for manual confirmations or notes. <br><code>taskRowChecksum</code> — <code>sha256:</code> of canonicalized selected fields per <code>canonicalVersion</code>; used for parity checks and tamper detection. <br><code>lastModifiedBy</code>, <code>lastModifiedTs</code> — audit metadata. <br>Invariants & rules: <br>1. <code>taskId</code> must not be reused; replacing a logical task requires new <code>taskId</code>. <br>2. <code>computedDueDate</code> is mandatory for any task included in a manifest. <br>3. <code>taskRowChecksum</code> computed using canonical field ordering: <code>taskId|taskNameCanonical|assignedOwnerId|gatingCategory|computedDueDate|signoffRequired|canonicalVersion</code> and stored with <code>sha256:</code> prefix. <br>4. Reassignment of owner appends <code>AuditLog</code> with <code>fa.task.ownerChanged</code> and old/new owner ids. <br>5. Mark merged tasks with <code>deprecated=true</code> and preserve historical rows for forensic traceability. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Canonical entity: SupportingDocument (exhaustive):</strong><br>Purpose: immutable pointer to supporting evidence with provenance metadata. <br>Required fields and semantics:<br><code>evidenceId</code> — GUID generated on attach. <br><code>title</code> — short human title used for UI. <br><code>url</code>/<code>platformRef</code> — pointer to storage location (SharePoint, Teams link, Drive path); do not include credentials. <br><code>uploaderId</code> — user who attached document; recorded for chain-of-custody. <br><code>uploadedTs</code> — UTC timestamp of attachment. <br><code>checksum</code> — <code>sha256:</code> of binary content when available; mandatory for critical evidence unless <code>policySnapshot</code> relaxes. <br><code>evidenceCategory</code> — taxonomy key (e.g., <code>signedForm</code>, <code>invoice</code>, <code>photoEvidence</code>). <br><code>attachedToTaskId</code> — nullable; evidence may be unbound and later heuristically matched to tasks. <br><code>accessPolicy</code> — pointer or enumeration of roles allowed to retrieve content; used to redact PII on distributed PDFs where required. <br><code>evidenceStatus</code> — <code>valid|invalid|unverified</code> depending on checksum and reachability. <br><code>evidenceRowChecksum</code> — sha256 over canonical metadata to detect tampering. <br>Rules & invariants:<br>1. If <code>attachedToTaskId</code> present it must match an existing <code>taskId</code>. <br>2. Evidence rows are append-only for content; <code>Detach</code>/<code>Rebind</code> operations add new audit rows but do not delete original evidence rows; original <code>evidenceId</code> must persist for chain-of-custody. <br>3. Evidence without a checksum remains <code>unverified</code> and may block close for <code>critical</code> tasks according to <code>policySnapshot</code>. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Canonical entity: SignOffEntry (exhaustive):</strong><br>Purpose: immutable approval record used for gating. <br>Required fields and semantics:<br><code>signOffId</code> — GUID generated at sign-off submit. <br><code>taskId</code> — referenced <code>taskId</code>. <br><code>signedBy</code> — user id of signer; must map to an identity in <code>OwnerAssignments</code> or system user directory. <br><code>signedRole</code> — role such as <code>owner|approver|manager|compliance</code> mapped to <code>policySnapshot.approvalMatrix</code>. <br><code>signedTs</code> — UTC timestamp. <br><code>approvalRef</code> — optional external approval token linking to other systems. <br><code>comment</code> — optional textual justification. <br><code>signatureHash</code> — optional cryptographic fingerprint when digital signature used. <br><code>signOffRowChecksum</code> — sha256 over canonicalized sign-off fields. <br><code>versionId</code> — manifest <code>versionId</code> the sign-off applies to (if sign-off scope is manifest-bound). <br>Rules & invariants:<br>1. Sign-off entries are immutable append-only records; corrections require compensating sign-offs and <code>AuditLog</code> entries documenting the reason. <br>2. <code>RecordSignOff</code> validates signer authorization against <code>policySnapshot.approvalMatrix</code> and rejects unauthorized attempts with <code>ERR_SIGNOFF_UNAUTHORIZED</code>. <br>3. Two-person approval policies are enforced by checking for distinct <code>signedBy</code> values and role coverage per policy. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Canonical entity: ChecklistVersionManifest (exhaustive):</strong><br>Purpose: tamper-evident snapshot representing a generated printable checklist version and its canonical serialization. <br>Fields and semantics:<br><code>versionId</code> — GUID assigned at generation. <br><code>generatedBy</code> — operator id performing generation. <br><code>generatedTs</code> — UTC timestamp. <br><code>scope</code> — printable scope descriptor. <br><code>taskCount</code> — number of tasks included. <br><code>blockingCount</code> — count of tasks blocking close at generation time. <br><code>manifestCanonicalString</code> — canonical serialization string (or compressed file pointer). <br><code>manifestHash</code> — <code>sha256:&lt;hex&gt;</code> of canonical bytes (lower-case). <br><code>canonicalVersion</code> — canonicalization recipe id used to produce the canonical string. <br><code>notes</code> — optional operator-provided notes recorded immutably. <br><code>pdfPath</code> — final storage path of generated PDF artifact. <br><code>bundleRef</code> — pointer to forensic zip bundle if created. <br><code>persistTs</code>/<code>persistedBy</code> — manifest persistence metadata. <br><code>rowChecksum</code> — SHA256 over manifest metadata for quick tamper checks. <br>Rules & invariants:<br>1. Manifest must be persisted atomically with the generated PDF: write temp PDF -> compute <code>manifestHash</code> -> atomic move PDF -> append manifest row with <code>pdfPath</code> and <code>manifestHash</code> -> emit AuditLog. <br>2. Manifest rows are append-only and immutable; corrections require creating a new manifest with <code>supersedes</code> relationships recorded in <code>AuditLog</code>. <br>3. <code>manifestHash</code> is the ground truth for nightly parity checks; parity mismatches must be investigated and recorded. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Canonical entity: AuditLog (exhaustive):</strong><br>Purpose: append-only forensic event store capturing mutative operations and relevant non-mutative events. <br>Fields and semantics:<br><code>eventId</code> — GUID. <br><code>eventType</code> — structured event identifier (e.g., <code>fa.checklist.generated</code>, <code>fa.evidence.attached</code>). <br><code>actorId</code> — user or system id performing the action. <br><code>timestampUTC</code> — event time. <br><code>correlationId</code> — GUID linking related events in a workflow (e.g., generation->sign-off->close). <br><code>details</code> — JSON blob capturing minimal replayable details (task ids, evidence ids, manifestRef, errorCode). <br><code>evidenceRefs[]</code> — referenced <code>evidenceId</code>s where applicable. <br><code>manifestRef</code> — referenced <code>versionId</code> for manifest-scoped events. <br>Rules & invariants:<br>1. AuditLog is append-only. <br>2. Audit entries must include both machine-readable <code>errorCode</code> and human-readable <code>message</code> where relevant. <br>3. Audit exports part of forensic bundles must include checksums and signed metadata for evidence. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Canonical manifest generation recipe (authoritative):</strong><br>To achieve tamper-evidence and deterministic parity across implementations the canonical manifest recipe below must be followed exactly: <br>1. Begin manifest canonical string with <code>canonicalVersion</code> as the first line and a single LF (<code>\n</code>). <br>2. Second line is manifest header serialized in exact field order: <code>versionId|generatedBy|generatedTs|scope|taskCount</code> followed by LF. <br>3. For each task produce canonical row fields in this exact order: <code>taskId|taskNameCanonical|assignedOwnerId|gatingCategory|computedDueDate|signoffRequired|taskRowChecksum</code> followed by LF. <br>4. Normalize fields before serialization: Unicode NFKC -> trim -> collapse repeated whitespace -> locale-aware casefold (if recipe requires) -> replace newline with <code>\n</code> literal -> escape <code>|</code> as <code>\u007C</code>. <br>5. Sort task rows deterministically by <code>assignedOwnerId</code> ascending then <code>taskId</code> ascending. <br>6. Use LF-only line endings and encode as UTF-8 bytes without BOM. <br>7. Compute <code>manifestHash = sha256:</code> of the bytes and store <code>sha256:&lt;hexLowerCase&gt;</code> as the authoritative manifest hash. <br>8. Persist <code>manifestCanonicalString</code> or a compressed pointer to it in the manifest row for forensic re-computation. <br>9. Any change to the recipe requires a <code>migrationManifest</code> and approvals. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Power Query (PQ) conceptual orchestration — core recipe (no code):</strong><br>Purpose: PQ produces authoritative <code>TasksMaster</code> table and validation artifacts consumed by <code>modChecklist</code> and other modules. Conceptual pipeline steps (recommended named stages):<br>1. <code>SourceIngest</code> — load <code>YearEndTaskTemplate</code>, <code>OwnerAssignments</code>, <code>AdhocRequests</code>, <code>SupportingDocuments</code>, <code>SignOffEntries</code>, <code>CloseParameters</code>, and <code>policySnapshotRef</code> as single-row config. <br>2. <code>CanonicalizeTextStep</code> — apply Unicode NFKC normalization, trim, collapse whitespace, locale-aware casefold for <code>taskName</code> and <code>description</code>, produce <code>taskNameCanonical</code> and <code>descriptionCanonical</code>. <br>3. <code>DateCanonicalizationStep</code> — parse <code>explicitDueDate</code> into ISO <code>YYYY-MM-DD</code>; compute <code>computedDueDate</code> where missing using <code>closeDate</code> and <code>defaultDueOffsetDays</code>; add <code>daysToDue</code> numeric field. <br>4. <code>OwnerResolutionStep</code> — left-join <code>OwnerAssignments</code> to attach <code>assignedOwnerDisplayName</code>, <code>email</code>, <code>department</code>; produce <code>MissingOwner</code> PQ_Issues if unresolved and provide fuzzy-match suggestions. <br>5. <code>EvidenceAttachStep</code> — left-join <code>SupportingDocuments</code> by <code>attachedToTaskId</code>; for unattached evidence compute heuristics (token overlap, filename tokens, date proximity) and emit <code>HeuristicMatches</code> with confidence score; flag <code>UnverifiedEvidence</code> for missing checksums on critical evidence categories. <br>6. <code>SignOffEnrichmentStep</code> — left-join <code>SignOffEntries</code> to compute <code>signOffCount</code>, <code>signOffByRoles[]</code>, <code>lastSignOffTs</code>, and <code>signOffWithinManifest</code> when <code>versionId</code> present. <br>7. <code>GatingMetricsStep</code> — compute <code>evidenceMissing</code> by comparing <code>evidenceRequirements</code> to attached evidence categories, <code>gatingRisk</code> combining <code>priority</code>, <code>overdueFlag</code>, <code>evidenceMissing</code> into Low/Medium/High and provide <code>gatingRiskRationale</code>. <br>8. <code>Outputs</code> — produce <code>TasksMaster</code> canonical table, <code>PQ_Issues</code>, <code>HeuristicMatches</code>, <code>MissingEvidenceReport</code>, and <code>pqParityReport</code>. <br>Operational notes: <br>• Each PQ step must be a named query step to enable operator inspection and parity testing. <br>• PQ must not compute binary file checksums; <code>modEvidence</code> handles file hashing at attach time. <br>• Keep <code>CloseParameters</code> single-row to enable deterministic reruns by operator. <br>• PQ should emit <code>tasksSnapshotId</code> to support controlled regression testing and parity reproduction for golden fixtures. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Function-level contracts — complete list (public & detailed):</strong><br>All public functions return structured Variants or objects with explicit fields and must append an AuditLog event on success/failure. Each mutative function must obtain the workbook-level lock before performing writes. Public functions: <br>1. <code>GenerateChecklistPDF(scope As String, versionNotes As String, operatorId As String) As Variant</code> — orchestration entry point producing PDF and manifest. <br>2. <code>BuildPrintableSheet(versionId As String, scope As String, tasksSubset As Variant, headerInfo As Variant) As Variant</code> — produce deterministic sheet layout and placeholders. <br>3. <code>ComputeManifestCanonicalString(versionId As String, taskRows As Variant, canonicalVersion As String) As String</code> — deterministic serializer. <br>4. <code>ComputeManifestHash(manifestCanonicalString As String) As String</code> — compute <code>sha256:</code> hex. <br>5. <code>ExportPDF(sheetName As String, tempPdfPath As String) As Variant</code> — Excel export with validation/retries. <br>6. <code>AtomicFileWrite(tempPath As String, destPath As String) As Variant</code> — atomic move and <code>.meta</code> companion write. <br>7. <code>PersistChecklistManifest(manifestObject As Variant, pdfPath As String, operatorId As String) As Variant</code> — append manifest row and persist metadata. <br>8. <code>ValidateForGeneration(scope As String) As Variant</code> — pre-generation checks including PQ freshness and required columns. <br>9. <code>CheckPQIssuesForScope(scope As String) As Variant</code> — surface PQ issues and blocking set. <br>10. <code>GenerateFilename(scope As String, generatedTs As String, manifestHash As String) As String</code> — deterministic filename recipe. <br>11. <code>RollbackPartialGenerate(correlationId As String, details As Variant) As Variant</code> — cleanup routine for failed flows. <br>12. <code>CreateManifestBundle(versionId As String, manifestCanonicalString As String, taskRows As Variant) As Variant</code> — produce signed forensic zip for archive. <br>13. <code>LoadManifestByVersion(versionId As String) As Variant</code> — fetch and parity-validate an existing manifest. <br>14. <code>CheckIdempotency(scope, manifestHash) As Variant</code> — idempotency guard returning existing <code>versionId</code> if present. <br>15. <code>BuildPrintableTemplate(sheetName As String, tasksSubset As Variant, headerInfo As Variant) As Variant</code> — lower-level helper to render templated cells and footers. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: GenerateChecklistPDF (complete):</strong><br>Purpose: orchestrate generation of printable sheet, canonical manifest serialization, hash computation, PDF export, atomic persistence and manifest persistence with audit. <br>Signature & return: <code>GenerateChecklistPDF(scope, versionNotes, operatorId) =&gt; {status:&quot;OK&quot;|&quot;ERROR&quot;, versionId:String|null, manifestHash:String|null, pdfPath:String|null, errorCode:String|null, details:Variant|null}</code>. <br>Preconditions (exhaustive):<br>1. PQ <code>TasksMaster</code> refreshed within <code>CloseParameters.maxPQAgeDays</code>; <code>TasksMaster.lastRefreshTs</code> must be valid. <br>2. <code>ValidateForGeneration(scope)</code> must not return blocking issues unless <code>policySnapshot</code> allows override and <code>overrideApprovalRef</code> provided. <br>3. Workbook-level write lock must be acquired. <br>Behavioral sequence (atomic and precise):<br>1. Create <code>correlationId = modUtils.GenerateGUID()</code> and append <code>fa.checklist.generate.attempt</code> with input metadata. <br>2. Acquire workbook write lock <code>LockAcquire(operatorId, leaseSeconds)</code> and append lock success/failure events. <br>3. Call <code>ValidateForGeneration(scope)</code>. On blocking issues append <code>fa.checklist.generate.failed</code> and return <code>ERR_CHECKLIST_MISSING_REQUIRED_FIELDS</code> with <code>pqIssuesRef</code>. <br>4. Call <code>CheckPQIssuesForScope(scope)</code> and abort on blocking issues. <br>5. Query <code>TasksMaster</code> to compute <code>tasksSubset</code>, <code>taskCount</code>, <code>blockingCount</code> and compute <code>renderOrder</code> deterministic sequence. <br>6. Generate <code>versionId = GenerateGUID()</code> and <code>generatedTs = NowUTC()</code>. <br>7. <code>headerInfo = {versionId, generatedBy: operatorId, generatedTs, scope, canonicalVersion, versionNotes, closeDate}</code>. <br>8. <code>sheetResult = BuildPrintableSheet(versionId, scope, tasksSubset, headerInfo)</code>; handle and rollback on failure with <code>ERR_PRINT_SHEET_COLLISION</code> or <code>ERR_SHEET_LAYOUT_FAIL</code>. <br>9. <code>manifestCanonicalString = ComputeManifestCanonicalString(versionId, tasksSubset, canonicalVersion)</code> and validate non-empty result. <br>10. <code>manifestHash = ComputeManifestHash(manifestCanonicalString)</code>; append telemetry <code>manifest.hash.compute.durationMs</code>. <br>11. Update <code>sheetResult.tempSheet</code> header placeholder for <code>manifestHash</code>. <br>12. <code>pdfTempPath = ExportPDF(sheetResult.tempSheetName, suggestedTempPdfPath)</code> with retry/backoff; on failure call <code>RollbackPartialGenerate(correlationId, details)</code> and return <code>ERR_PDF_WRITE_FAIL</code>. <br>13. <code>finalPdfPath = GenerateFilename(scope, generatedTs, manifestHash)</code> with sanitized scope. <br>14. <code>atomicResult = AtomicFileWrite(pdfTempPath, finalPdfPath)</code> writing <code>.meta</code> alongside; handle <code>ERR_ATOMIC_MOVE_FAIL</code> by quarantining temp and returning error with Audit. <br>15. Build <code>manifestObject</code> and call <code>PersistChecklistManifest(manifestObject, finalPdfPath, operatorId)</code>; on persist failure call <code>RollbackPartialGenerate</code> and return <code>ERR_MANIFEST_PERSIST_FAIL</code>. <br>16. Optionally call <code>CreateManifestBundle(versionId, manifestCanonicalString, tasksSubset)</code> if archive policy enabled; handle <code>ERR_BUNDLE_CREATE_FAIL</code> as non-blocking but log telemetry and <code>fa.checklist.bundleFail</code>. <br>17. Append <code>fa.checklist.generated</code> with payload <code>{versionId, manifestHash, taskCount, blockingCount, pdfPath, correlationId}</code>. <br>18. Release lock <code>LockRelease</code> and return success object with <code>versionId</code> and <code>manifestHash</code>. <br>Failure behavior & telemetry: retries for IO with backoff; <code>checklist.generate.durationMs</code> measured; <code>checklist.generate.failures</code> incremented on any error. <br>Idempotency: if <code>CheckIdempotency</code> finds existing manifest with same <code>manifestHash</code> return <code>ERR_CHECKLIST_ALREADY_GENERATED</code> and existing <code>versionId</code> to avoid duplicates. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: BuildPrintableSheet (complete):</strong><br>Purpose: programmatically build printable layout using deterministic templates and placeholders for metadata, optimized for stable PDF export. <br>Inputs: <code>versionId</code>, <code>scope</code>, <code>tasksSubset</code> (array of canonical rows), <code>headerInfo</code>. <br>Return: <code>{status, tempSheetName, pageCount, rowCount, errorCode, details}</code>. <br>Implementation rules (must follow for deterministic PDF):<br>• Create sheet <code>Checklist_Printable_&lt;versionId&gt;</code>; ensure naming deterministic (avoid timestamps in sheet name). <br>• Insert top header block containing manifest metadata placeholders for <code>versionId</code>, <code>generatedBy</code>, <code>generatedTs</code>, <code>manifestHash</code> (placeholder), <code>scope</code>, <code>taskCount</code>, <code>canonicalVersion</code>, and <code>notes</code>. <br>• Group tasks by <code>assignedOwnerDisplayName</code>; produce owner header rows with contact info; insert manual page-break after each owner (page grouping determinism). <br>• Columns and order fixed: Index, <code>taskId</code> (shortened), <code>taskName</code>, <code>descriptionSnippet</code> (plain truncated to 300 chars), <code>computedDueDate</code> (YYYY-MM-DD), <code>daysToDue</code> (numeric), <code>gatingCategory</code>, <code>priority</code>, <code>evidenceMissingSummary</code>, <code>signOffStatusSummary</code>, <code>lastModifiedBy</code>, <code>lastModifiedTs</code>, <code>commentsIndicator</code> (yes/no). <br>• Use ASCII tokens for visual cues (e.g., <code>[BLOCK]</code> for blocking tasks) to avoid platform-specific glyphs. <br>• Avoid external fonts and images to prevent PDF variability; if logos required embed as pre-approved deterministic objects stored in workbook assets. <br>• Apply print settings from <code>CloseParameters.paperSize</code> and <code>CloseParameters.margins</code>; set <code>PrintArea</code> to content and set <code>FitToPagesWide=1</code> only when necessary and documented. <br>• If <code>redactionMode=true</code> substitute PII columns with <code>&lt;REDACTED&gt;</code> placeholders and append <code>redactionNotes</code> to header; ensure redaction is deterministic and reversible only by authorized operators via audit. <br>• Protect sheet cells optionally to prevent accidental edits during export. <br>• Return <code>pageCount</code> deterministically using row-to-page formula or Excel printer query when available. <br>Errors: <code>ERR_PRINT_SHEET_COLLISION</code>, <code>ERR_SHEET_LAYOUT_FAIL</code>. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: ComputeManifestCanonicalString (complete):</strong><br>Purpose: convert manifest header and ordered task rows into canonical UTF-8 string following exact recipe used for hashing. <br>Inputs: <code>versionId</code>, <code>taskRows</code> (canonical arrays), <code>canonicalVersion</code>. <br>Return: canonical string. <br>Precise serialization recipe (authoritative):<br>1. Start with first line <code>canonicalVersion</code> + LF. <br>2. Second line include header fields in exact order <code>versionId|generatedBy|generatedTs|scope|taskCount</code> + LF. <br>3. For each task in sorted order by <code>assignedOwnerId</code> asc then <code>taskId</code> asc output <code>taskId|taskNameCanonical|assignedOwnerId|gatingCategory|computedDueDate|signoffRequired|taskRowChecksum</code> + LF. <br>4. Field normalization: Unicode NFKC -> trim -> collapse repeated whitespace to single space -> apply locale-specific casefold when required -> replace newline characters with <code>\n</code> literal -> escape <code>|</code> as <code>\u007C</code>. <br>5. Use LF-only line endings and UTF-8 encoding; do not include BOM. <br>6. Validate each <code>taskRowChecksum</code> format and <code>computedDueDate</code> ISO format; on validation failure return <code>ERR_CANONICALIZE_FAIL</code> with offending <code>taskId</code>. <br>Return the canonical string to caller; caller will compute hash. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: ComputeManifestHash (complete):</strong><br>Purpose: compute SHA-256 digest of the canonical UTF-8 bytes and return <code>sha256:</code> hex string. <br>Inputs: canonical string (UTF-8). <br>Return: <code>sha256:&lt;lowercasehex&gt;</code>. <br>Implementation notes: use a robust SHA-256 implementation; ensure consistent UTF-8 encoding and no trailing whitespace differences. <br>Telemetry: record <code>manifest.hash.compute.durationMs</code>. <br>Errors: <code>ERR_HASH_COMPUTE</code> on low-level crypto errors. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: ExportPDF (complete):</strong><br>Purpose: export worksheet to PDF with deterministic settings and validate the artifact. <br>Inputs: <code>sheetName</code>, <code>tempPdfPath</code>. <br>Return: <code>{status, tempPdfPath, pageCount, sizeBytes, errorCode, details}</code>. <br>Behavior & validation rules: <br>• Use Excel <code>ExportAsFixedFormat</code> with explicit <code>Quality</code>, <code>IncludeDocProperties</code>, <code>IgnorePrintAreas=false</code> and print settings from <code>CloseParameters</code>. <br>• Validate output file exists and <code>sizeBytes &gt;= minPdfSizeBytes</code> (configurable; default 1KB). <br>• Optionally inspect first N KB to ensure PDF header present and presence of manifest header text if feasible; if <code>redactionMode=true</code> ensure no PII tokens present in first N pages by scanning textual bytes when feasible. <br>• On COM or IO errors, retry export up to <code>exportRetryCount</code> (default 3) with exponential backoff. <br>• If still failing, return <code>ERR_PDF_WRITE_FAIL</code> and call <code>RollbackPartialGenerate</code>. <br>• If validation heuristics fail (too small or missing header), return <code>ERR_PDF_VALIDATION_FAIL</code> and store temp artifact for forensic review. <br>Telemetry: <code>pdf.export.durationMs</code>, <code>pdf.size.bytes</code>, <code>pdf.export.retryCount</code>. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: AtomicFileWrite (complete):</strong><br>Purpose: atomically move temporary PDF to final destination and create companion <code>.meta</code> file containing manifest metadata. <br>Inputs: <code>tempPath</code>, <code>destPath</code>. <br>Return: <code>{status, destPath, metaPath, errorCode, details}</code>. <br>Atomicity & durability rules: <br>1. Write operation must be atomic: write to a temporary file adjacent to destination and then rename/move atomically (use OS atomic rename where available). <br>2. If <code>destPath</code> exists move it to <code>destPath.bak.&lt;ts&gt;</code> preserving original and append <code>fa.file.replace</code> audit event. <br>3. After moving write <code>destPath.meta.json</code> containing <code>{versionId, manifestHash, generatedBy, generatedTs, correlationId}</code> and compute <code>metaChecksum = sha256:</code> of the metadata. <br>4. Validate <code>destPath</code> size and compute <code>modUtils.ComputeSHA256</code> of the final file to confirm non-zero content. <br>5. On fail due to network or permission issues attempt 3 retries; if still failing move artifact to local quarantine path and append <code>fa.checklist.filePersistFail</code> with diagnostic details. Return <code>ERR_ATOMIC_MOVE_FAIL</code> with actionable diagnostic steps. <br>Security: verify destination storage meets encryption-at-rest and ACL requirements; if secure store unavailable return <code>ERR_MANIFEST_PERSIST_SECURESTORE_UNAVAILABLE</code>. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: PersistChecklistManifest (complete):</strong><br>Purpose: append the manifest to <code>ChecklistVersionManifest</code> table and persist artifact references reliably. <br>Inputs: <code>manifestObject</code> (structured), <code>pdfPath</code>, <code>operatorId</code>. <br>Return: <code>{status, manifestRowId, errorCode, details}</code>. <br>Append semantics & integrity rules: <br>1. Validate <code>ChecklistVersionManifest</code> table schema for required columns: <code>versionId</code>, <code>generatedBy</code>, <code>generatedTs</code>, <code>scope</code>, <code>taskCount</code>, <code>blockingCount</code>, <code>manifestHash</code>, <code>manifestCanonicalStringRef</code> (or compressed pointer), <code>pdfPath</code>, <code>canonicalVersion</code>, <code>persistTs</code>, <code>persistedBy</code>. <br>2. Append new row atomically with <code>persistTs=NowUTC()</code>, <code>persistedBy=operatorId</code>. <br>3. Compute <code>rowChecksum = modUtils.ComputeSHA256(concatenated minimal manifest metadata)</code> and store. <br>4. If append fails attempt two retries; on persistent failure call <code>RollbackPartialGenerate</code> and return <code>ERR_MANIFEST_PERSIST_FAIL</code> with diagnostic AuditLog event. <br>5. Emit <code>fa.checklist.manifestPersisted</code> on success with payload including <code>manifestRowId</code> and <code>versionId</code>. <br>Notes: for very large <code>manifestCanonicalString</code> store externally compressed and persist pointer to external object to avoid workbook bloat. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: ValidateForGeneration (complete):</strong><br>Purpose: pre-generation validator to surface data quality and policy compliance issues that would block manifest generation or close. <br>Inputs: <code>scope</code>. <br>Return: <code>{status:&quot;OK&quot;|&quot;BLOCKING&quot;|&quot;WARN&quot;, issues:[{issueId, severity, entityRef, detail, suggestedAction}]}</code>. <br>Checks (complete): <br>1. PQ freshness: <code>TasksMaster.lastRefreshTs</code> must be within <code>CloseParameters.maxPQAgeDays</code>. <br>2. Required columns present in <code>TasksMaster</code>: <code>taskId</code>, <code>taskNameCanonical</code>, <code>assignedOwnerId</code>, <code>computedDueDate</code>, <code>gatingCategory</code>, <code>taskRowChecksum</code>. <br>3. No tasks in scope with <code>computedDueDate</code> missing or invalid format. <br>4. For <code>critical</code> tasks ensure <code>evidenceRequirements</code> are present in template metadata. <br>5. Validate <code>CloseParameters.paperSize</code>, <code>redactionMode</code>, <code>canonicalVersion</code>. <br>6. <code>policySnapshot</code> presence and age must be within allowed change window. <br>7. Return <code>BLOCKING</code> if any High severity issues detected and <code>policySnapshot</code> does not allow generation in presence of such issues. <br>Output: structured <code>issues</code> with <code>issueId</code> and <code>suggestedAction</code> for operators. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: CheckPQIssuesForScope (complete):</strong><br>Purpose: query <code>PQ_Issues</code> and surface blocking vs non-blocking items relevant to the generation scope. <br>Inputs: <code>scope</code>. <br>Return: <code>{status, blockingIssues[], nonBlockingIssues[]}</code>. <br>Classification rules: <br>• <code>MissingOwner</code> for <code>critical</code> tasks -> High severity -> blocking. <br>• <code>UnverifiedEvidence</code> for <code>critical</code> evidenceCategory -> High severity -> blocking unless <code>policySnapshot.evidenceChecksumPolicy</code> relaxed with documented exception. <br>• <code>InvalidDateFormat</code> -> Medium severity -> blocking if it affects <code>computedDueDate</code>; otherwise flagged for remediation. <br>• <code>PossibleDuplicate</code> -> Low severity -> non-blocking but listed for analyst review. <br>• <code>policySnapshot</code> override table <code>issueSeverityOverrides</code> can alter the blocking behavior; return final classification to caller. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: GenerateFilename (complete):</strong><br>Purpose: deterministic filename generator for PDFs and workbook snapshots to facilitate archival and tamper-evidence. <br>Inputs: <code>scope</code>, <code>generatedTs</code> (ISO date), <code>manifestHash</code>. <br>Return: sanitized filename string. <br>Naming recipe (authoritative): <code>YE_Checklist_&lt;scopeSafe&gt;_&lt;YYYYMMDD&gt;_&lt;manifestHashPrefix&gt;.pdf</code> where <code>manifestHashPrefix</code> is the first 8 hex chars (after removing <code>sha256:</code>). Example: <code>YE_Checklist_Owner-U-123_20260120_4f2ab9d2.pdf</code>. <br>Sanitization: replace spaces with underscores, remove or map file-system reserved chars, limit length to platform safe thresholds (e.g., 255 chars). </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: RollbackPartialGenerate (complete):</strong><br>Purpose: best-effort cleanup when generation fails mid-flow and provide forensic trail of rollback activity. <br>Inputs: <code>correlationId</code>, <code>details</code> (error payload). <br>Return: <code>{status, cleanedCount, orphanedItems:[...], errorCode}</code>. <br>Behavior steps: <br>1. Identify temporary objects (sheets named with correlationId, temp PDF paths, temp staging files) using <code>AuditLog</code> correlationId references and naming conventions. <br>2. Attempt safe deletion; if deletion fails move objects to <code>Quarantine/&lt;correlationId&gt;/</code> and set appropriate ACLs. <br>3. If manifest row partially appended mark <code>persistStatus=&#x27;partial&#x27;</code> and append <code>fa.checklist.manifestPersistFail</code>. <br>4. Append <code>fa.checklist.rollback</code> with summary and <code>correlationId</code>. <br>5. Return summary and escalate if orphaned items remain requiring manual remediation. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: CreateManifestBundle (complete):</strong><br>Purpose: produce signed zipped forensic bundle for archival and e-discovery containing canonical manifest, task CSV snapshot, and relevant AuditLog slices. <br>Inputs: <code>versionId</code>, <code>manifestCanonicalString</code>, <code>taskRows</code> array. <br>Return: <code>{status, bundlePath, bundleHash, errorCode}</code>. <br>Creation steps: <br>1. Serialize <code>manifestCanonicalString</code> to <code>manifest.txt</code> exactly (no additional metadata inside). <br>2. Serialize <code>taskRows</code> to <code>tasks.csv</code> using canonical field ordering as defined in Appendices. <br>3. Export <code>AuditLog</code> entries correlated to <code>correlationId</code>/<code>versionId</code> to <code>audit.jsonl</code> (newline-delimited JSON). <br>4. Compose <code>manifest.metadata.json</code> with <code>versionId</code>, <code>manifestHash</code>, <code>canonicalVersion</code>, <code>generatedBy</code>, <code>generatedTs</code> and sign or compute <code>metadataHash</code>. <br>5. Zip artifacts to <code>&lt;versionId&gt;_bundle.zip</code> and compute <code>bundleHash = sha256:</code> of zip bytes. <br>6. Persist zip to archive store and append <code>fa.checklist.bundleCreated</code> with bundleRef. <br>7. On error return <code>ERR_BUNDLE_CREATE_FAIL</code> and append AuditLog. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Detailed function contract: LoadManifestByVersion (complete):</strong><br>Purpose: retrieve a persisted manifest row, re-compute <code>manifestHash</code> from stored canonical string and report parity. <br>Inputs: <code>versionId</code>. <br>Return: <code>{status, manifestObject, parityOk:Boolean, parityDiff:Variant, errorCode}</code>. <br>Behavior: <br>1. Fetch manifest row and <code>manifestCanonicalString</code> or pointer. <br>2. Recompute <code>manifestHash</code> using <code>ComputeManifestHash</code> and compare to persisted <code>manifestHash</code>. <br>3. If mismatch compute <code>parityDiff</code> - summary list of lines or taskIds differing and append <code>fa.verify.parity.failed</code>. <br>4. Return manifest object, <code>parityOk</code> boolean and <code>parityDiff</code> to operator for triage. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Error codes taxonomy (compact authoritative):</strong><br>• <code>ERR_LOCK_ACQUIRE_FAIL</code> — workbook-level lock not acquired. <br>• <code>ERR_PQ_STALE</code> — <code>TasksMaster</code> stale beyond <code>CloseParameters.maxPQAgeDays</code>. <br>• <code>ERR_CHECKLIST_MISSING_REQUIRED_FIELDS</code> — missing required PQ fields or invalid schema. <br>• <code>ERR_PDF_WRITE_FAIL</code> — ExportPDF failed after retries. <br>• <code>ERR_PDF_VALIDATION_FAIL</code> — exported PDF failed validation heuristics. <br>• <code>ERR_ATOMIC_MOVE_FAIL</code> — atomic move to final path failed. <br>• <code>ERR_MANIFEST_PERSIST_FAIL</code> — append to <code>ChecklistVersionManifest</code> failed. <br>• <code>ERR_CANONICALIZE_FAIL</code> — canonicalization failed for task rows. <br>• <code>ERR_HASH_COMPUTE</code> — hashing primitive failure. <br>• <code>ERR_BUNDLE_CREATE_FAIL</code> — forensic bundle creation failed. <br>• <code>ERR_CHECKLIST_ALREADY_GENERATED</code> — idempotency guard triggered. <br>• <code>ERR_SIGNOFF_UNAUTHORIZED</code> — signer not authorized under <code>policySnapshot</code>. <br>• <code>ERR_PDF_REDACTION_FAIL</code> — redaction detection failed; likely sensitive content present. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Audit events produced by modChecklist (definitive set & payloads):</strong><br>• <code>fa.checklist.generate.attempt</code> — payload: <code>{correlationId, operatorId, scope, versionNotes, timestampUTC}</code>. <br>• <code>fa.checklist.lockAcquireAttempt</code> / <code>fa.checklist.lockAcquireSuccess</code> / <code>fa.checklist.lockAcquireFail</code> — payloads include <code>operatorId</code>, <code>lockToken</code>, <code>correlationId</code>. <br>• <code>fa.checklist.generate.failed</code> — payload: <code>{operatorId, scope, errorCode, correlationId, details}</code>. <br>• <code>fa.checklist.generated</code> — payload: <code>{versionId, manifestHash, taskCount, blockingCount, pdfPath, correlationId}</code>. <br>• <code>fa.checklist.manifestPersisted</code> — payload: <code>{manifestRowId, versionId, manifestHash, persistedBy, correlationId}</code>. <br>• <code>fa.checklist.bundleCreated</code> — payload: <code>{bundlePath, bundleHash, versionId, correlationId}</code>. <br>• <code>fa.checklist.rollback</code> — payload: <code>{correlationId, cleanedItemsCount, orphanedItems, reason}</code>. <br>• <code>fa.checklist.closed</code> — produced by <code>modGating</code> referencing manifest: <code>{closeId, versionId, closedBy, closedTs, correlationId}</code>. <br>All events must include <code>timestampUTC</code> and be appended to <code>AuditLog</code> as immutable records. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Telemetry & observability (detailed instrumentation):</strong><br>All telemetry written to <code>Telemetry</code> sheet with rows <code>{metricName, value, timestampUTC, correlationId, detailsJson}</code>. Required metrics: <br>1. <code>checklist.generate.count</code> — increment per successful generate. <br>2. <code>checklist.generate.durationMs</code> — time from lock acquire to AuditLog append. <br>3. <code>pdf.export.durationMs</code> — time spent in ExportPDF. <br>4. <code>pdf.size.bytes</code> — final PDF size. <br>5. <code>manifest.hash.compute.durationMs</code>. <br>6. <code>manifest.persist.failures.count</code>. <br>7. <code>manifest.parity.mismatch.count</code>. <br>8. <code>checklist.rollback.count</code>. <br>9. <code>checklist.bundle.created.count</code>. <br>Alert thresholds (operator-configurable): <br>• Alert if <code>CriticalOpen</code> tasks > 0 within 48 hours of <code>closeDate</code> — severity High. <br>• Alert if <code>manifest.parity.mismatch.count</code> > 0 — immediate compliance escalation. <br>• Alert on sustained <code>pdf.export.failure.rate</code> exceeding threshold over rolling 24h window. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Concurrency & locking semantics (complete):</strong><br>Single-writer workbook model implemented via <code>WorkbookMeta</code> lock row: fields <code>lockOwner</code>, <code>lockToken</code>, <code>lockTs</code>, <code>leaseSeconds</code>. Rules: <br>1. <code>LockAcquire(operatorId, timeoutSecs)</code> claims lock if no active lock or lease expired; returns <code>lockToken</code> to caller. <br>2. Re-entrant acquire allowed for same <code>operatorId</code> and <code>lockToken</code> within same session. <br>3. <code>LockRelease(operatorId, lockToken)</code> releases lock; unauthorized release attempts are rejected. <br>4. All mutative functions must verify an active lock before performing writes; Export-only operations may run without lock if <code>readOnlyExport=true</code> and <code>manifest</code> persistence is not required. <br>5. Lock acquisition failures return <code>ERR_LOCK_ACQUIRE_FAIL</code> and append <code>fa.checklist.lockAcquireFail</code> with <code>correlationId</code>. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Security & privacy controls (implementable):</strong><br>1. Evidence pointers: store only <code>url</code> or <code>platformRef</code> and avoid embedding tokens or credentials; access enforced by DMS. <br>2. Redaction Mode: implement <code>redactionMode=true</code> path which replaces sensitive columns with <code>&lt;REDACTED&gt;</code> and records <code>redactionNotes</code> in header; redaction is recorded in <code>AuditLog</code>. <br>3. Companion <code>.meta</code> files created next to PDFs must avoid PII and include only <code>versionId</code>, <code>manifestHash</code>, <code>generatedBy</code>, <code>generatedTs</code>, <code>correlationId</code>. <br>4. For production, code-sign macros and restrict workbook modification rights to authorized operators. <br>5. Archive forensic bundles in encrypted-at-rest storage and sign them with organizational signing keys to produce non-repudiable evidence. <br>6. Do not store user credentials in workbook cells or named ranges; integrate with corporate secret management for automation where required. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Retention, archival & legal-hold guidance (explicit):</strong><br>1. Store <code>ChecklistVersionManifest</code> rows, <code>SupportingDocument</code> metadata, and <code>AuditLog</code> slices in long-term archive per legal retention policy (e.g., 7-10 years), using signed zipped forensic bundles. <br>2. Implement <code>legalHold</code> flag that prevents deletion/expiration of manifests, evidence pointers and AuditLog entries until release by legal team. <br>3. Provide <code>CreateManifestBundle</code> to package manifest and related AuditLog/evidence pointers with signatures and <code>bundleHash</code> for e-discovery. <br>4. Maintain chain-of-custody metadata for each evidence attach/rebind/detach event in <code>AuditLog</code>. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Testing & parity strategy (comprehensive):</strong><br>Unit tests (examples):<br>1. Canonicalization tests: Unicode NFKC normalization, Turkish dotted/dotless <code>i</code> behavior, whitespace collapse, newline escapes and <code>|</code> escape behavior across locales. <br>2. Hash tests: verify <code>ComputeManifestHash</code> produces expected <code>sha256:</code> for known canonical strings. <br>3. ExportPDF tests: deterministic page counts for sample printable sheets. <br>Integration tests: <br>1. PQ fixture -> GenerateChecklistPDF -> Persist -> LoadManifestByVersion parity test. <br>2. Failure injection: simulate ExportPDF COM error and verify RollbackPartialGenerate cleans temporary artifacts and leaves audit evidence. <br>Golden parity fixtures: <br>1. <code>fixture_small</code> (25 tasks) expected <code>manifestHash</code>. <br>2. <code>fixture_mid</code> (500 tasks) mixed priorities and heuristics. <br>3. <code>fixture_edge</code> locale-sensitive names, control chars, duplicates and dirty dates with expected <code>manifestHash</code>. <br>Nightly parity job: recompute manifest hashes for persisted manifests and alert when mismatch with <code>fa.verify.parity.failed</code>; create <code>parityDiff</code> summary. <br>Performance tests: PQ refresh times and PDF generation time at scale; for >10k tasks recommend server-side approach. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Duplicate detection & merge flow (detailed):</strong><br>Detection algorithm concept:<br>1. Normalize <code>taskNameCanonical</code> and <code>descriptionCanonical</code>. <br>2. Tokenize and compute Jaccard similarity; compute normalized Levenshtein distance for short names; combine into <code>similarityScore</code>. <br>3. Flag <code>similarityScore &gt;= threshold</code> as <code>PossibleDuplicate</code> and emit <code>PQ_Issues</code>. <br>Merge workflow & rules:<br>1. Analyst reviews duplicates and calls <code>MergeTasks(primaryTaskId, secondaryTaskIds[], operatorId)</code>. <br>2. <code>MergeTasks</code> reassigns <code>attachedEvidenceIds</code> and <code>SignOffEntries</code> to <code>primaryTaskId</code>, updates <code>attachedEvidenceIds</code> on primary and marks <code>secondaryTaskIds.deprecated=true</code>. <br>3. Append <code>fa.task.merge</code> with mapping, <code>mergedBy</code>, <code>justification</code>, and ensure historical rows remain for forensics. <br>4. Recompute <code>taskRowChecksum</code> for primary and run parity checks; record <code>merge</code> event in <code>AuditLog</code>. <br>5. For <code>critical</code> tasks merges require compliance approval recorded in <code>AuditLog</code> before merge. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Ad-hoc intake & triage (operational):</strong><br>1. Capture ad-hoc intake in <code>AdhocRequests</code> table with <code>adhocId</code>, <code>requestedBy</code>, <code>descriptionRaw</code>, <code>priority</code>, <code>requestedDueDate</code>, <code>rationale</code>, <code>createdTs</code>. <br>2. Analyst triages with <code>TriagedToTask(adhocId, taskId, operatorId)</code> which generates new <code>YearEndTaskRow</code> with <code>taskSource=adhoc</code>. <br>3. If <code>priority=P0</code> mark <code>emergency=true</code> and route through <code>policySnapshot.emergencyRules</code> requiring expedited approvals. <br>4. All triage actions appended to <code>AuditLog</code> for traceability. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Post-close adjustments & reopen flow (forensic-preserving):</strong><br>1. When post-close issues found create <code>PostCloseAdjustment</code> tasks linked to <code>closeEventId</code>. <br>2. Obtain approvals per <code>policySnapshot</code> for reopen actions and record sign-offs as <code>SignOffEntry</code> with <code>versionId</code> referencing reopen manifest. <br>3. <code>ReopenClose(closeId, operatorId, approvals[])</code> performs atomic reopen: marks prior <code>closeEvent</code> <code>superseded=true</code>, emits <code>fa.checklist.reopen</code>, creates new manifest capturing adjustments and persists; archive both original and new bundles. <br>4. All reopen operations append comprehensive <code>AuditLog</code> entries and maintain <code>supersedingCloseId</code> links for legal trace. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Status dashboard & conceptual DAX patterns (no snippets):</strong><br>Dataset design & recommended measures (conceptual):<br>• Source tables: <code>TasksMaster</code> (canonical), <code>ChecklistVersionManifest</code> (manifest fact), <code>SignOffEntries</code>, <code>SupportingDocuments</code>, <code>Telemetry</code>. <br>Conceptual measures to create (described, not coded):<br>1. <code>TasksOpen</code> — count of tasks with <code>status</code> not in {Complete, Signed Off}, used as denominator for progress metrics. <br>2. <code>CriticalOpen</code> — filter count of <code>gatingCategory=&#x27;critical&#x27;</code> and not <code>Signed Off</code>; used for alerts. <br>3. <code>SignOffRate</code> — ratio of tasks with required sign-offs present to tasks requiring sign-off; slice by owner and department. <br>4. <code>MissingEvidenceCount</code> — sum of missing evidence categories across tasks; pivotable by evidenceCategory and owner to prioritize remediation. <br>5. <code>AvgDaysToClose</code> — average <code>closedTs - generatedTs</code> across manifests; used for SLA monitoring. <br>6. <code>ManifestParityStatus</code> — flag where recomputed <code>manifestHash</code> != persisted <code>manifestHash</code>; provide drillthrough to <code>parityDiff</code>. <br>Suggested visuals: owner-level heatmap of <code>CriticalOpen</code> by <code>daysToDue</code>, sign-off coverage funnel, missing evidence trend charts, manifest parity table with clickable bundle export links, and telemetry view displaying PDF generation latency distributions. <br>Implementation note: store a denormalized <code>ManifestFact</code> table for efficient DAX and incremental refresh in Power BI. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Exhaustive worked examples & edge cases (expanded narratives):</strong><br>Example 1 — Critical statutory tax reconciliation (complete):<br>• Task: "Finalize statutory tax reconciliation" declared <code>gatingCategory=critical</code>, <code>priority=P0</code>, <code>evidenceRequirements=[taxReconciliationPDF, signedManagerApproval]</code>, <code>signoffRequired=true</code>, <code>defaultDueOffsetDays=14</code>. <br>Flow narrative (end-to-end):<br>1. PQ computes <code>computedDueDate</code>. <br>2. Tax lead attaches file <code>tax_recon_2026.pdf</code> using <code>modEvidence.AttachEvidence(taskId, url, uploaderId, localFilePath)</code>. The module computes <code>checksum = sha256:...</code>, stores evidence row with <code>evidenceStatus=valid</code> and appends <code>fa.evidence.attached</code>. <br>3. Manager records sign-off using <code>modSignOff.RecordSignOff</code> which validates signer against <code>policySnapshot</code> and appends immutable sign-off event with <code>signOffRowChecksum</code>. <br>4. Operator runs <code>GenerateChecklistPDF(&quot;All&quot;,&quot;pre-close run&quot;,&quot;alice&quot;)</code>. <code>ValidateForGeneration</code> passes and <code>CheckPQIssuesForScope</code> returns no blocking items. The module builds printable sheet, computes canonical string and <code>manifestHash</code>, exports PDF, performs <code>AtomicFileWrite</code>, persists manifest and appends <code>fa.checklist.generated</code>. <br>5. <code>modGating.AttemptClose(closeDate, operatorId)</code> validates sign-offs and evidence and marks close succeeded, persisting <code>closeEvent</code> and appending <code>fa.checklist.closed</code>. <br>Edge conditions: if evidence stored in DMS without checksum, <code>evidenceStatus=unverified</code>. <code>AttemptClose</code> will block until manual verification or new evidence with checksum is attached; manual verification recorded as <code>fa.evidence.verified</code> and must reference DMS metadata and operator notes. <br>Example 2 — Physical asset count with photo evidence (complete):<br>• Task requires <code>assetCountSheet</code> and <code>photoEvidence</code> with EXIF <code>DateTimeOriginal</code> within ±48 hours of <code>computedDueDate</code>. Two-person approval required. <br>Flow narrative: <br>1. Field team uploads photos via DMS pointers; <code>modEvidence.AttachEvidence</code> computes <code>checksum</code> and extracts EXIF <code>DateTimeOriginal</code> when allowed by platform; if EXIF missing attempt to read DMS upload timestamp. <br>2. PQ heuristics create <code>HeuristicMatches</code> linking photos to tasks by filename or proximity; analyst confirms and binds evidence. <br>3. Two sign-offs recorded (assets lead and inventory controller) via <code>RecordSignOff</code>. <br>4. <code>AttemptClose</code> enforces two-person sign-off and EXIF verification; if both present returns success. <br>Edge: EXIF stripped due to camera settings — require analyst verification recorded in <code>AuditLog</code> with <code>fa.evidence.verified</code> including reasoning and <code>evidenceRowChecksum</code> to maintain chain-of-custody. <br>Example 3 — Duplicate detection and safe merge (complete):<br>• PQ flags two similar tasks via <code>PossibleDuplicate</code>. <br>Flow: <br>1. Analyst reviews <code>PQ_Issues</code> and initiates <code>MergeTasks(primaryTaskId, [secondaryTaskId], operatorId)</code>. <br>2. System reassigns attached evidence and sign-offs to primary, updates <code>attachedEvidenceIds</code> array, marks <code>secondaryTaskId.deprecated=true</code> and appends <code>fa.task.merge</code> documenting mapping and reason. <br>3. Recompute <code>taskRowChecksum</code> for primary and run parity checks. <br>4. Historical manifests referencing secondary are left unchanged; the merge event is recorded so forensic reconstructions can map old tasks to new primary. <br>Edge: merging critical tasks requires compliance approval recorded in <code>AuditLog</code>; if missing, block merge and surface escalation. <br>Example 4 — Emergency ad-hoc during close window (complete):<br>• Ad-hoc task arises with <code>priority=P0</code> and <code>emergency=true</code>. <br>Flow: <br>1. Analyst triages and creates <code>YearEndTaskRow</code> from <code>AdhocRequests</code> with immediate owner assignment. <br>2. <code>policySnapshot.emergencyRules</code> permits authorized manager to override gating with compensating controls; <code>overrideApprovalRef</code> and supporting evidence recorded. <br>3. Operator runs <code>GenerateChecklistPDF</code> with <code>versionNotes</code> describing override and <code>AuditLog</code> records the exception and compensating controls. <br>4. <code>AttemptClose</code> may accept the override per <code>policySnapshot</code>, but must require recorded compensating controls and additional post-close review steps documented in <code>AuditLog</code>. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Operational runbooks (concise, actionable):</strong><br>Pre-close operator runbook (recommended routine):<br>1. Refresh PQ and inspect <code>PQ_Issues</code>. <br>2. Prioritize and remediate High severity <code>PQ_Issues</code> or record exception approvals in <code>AuditLog</code> (<code>fa.pq.issue.ack</code>). <br>3. Generate pre-close checklists using <code>GenerateChecklistPDF</code> for required scopes (All, owner groups). <br>4. Validate manifest persistence and verify companion <code>.meta</code> file and optional forensic bundle. <br>5. Distribute PDF via secure channels and avoid embedding PII. <br>6. Monitor <code>Telemetry</code> and nightly parity reports; escalate parity mismatches to compliance. <br>Emergency reopen runbook (procedural):<br>1. Create <code>PostCloseAdjustment</code> tasks with root cause and <code>closeEventId</code>. <br>2. Obtain approvals per <code>policySnapshot</code> and record sign-offs. <br>3. Execute <code>ReopenClose</code> via <code>modGating</code> after approvals; persist superseding manifest and archive both versions. <br>4. Append <code>fa.checklist.reopen</code> and notify audit/compliance teams. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Acceptance criteria & release gates (testable):</strong><br>1. Unit tests and integration tests covering canonicalization, hashing, ExportPDF and atomic persistence pass against golden fixtures. <br>2. Golden parity tests reproduce expected <code>manifestHash</code> for supplied fixtures. <br>3. <code>GenerateChecklistPDF</code> succeeds end-to-end for representative scopes and persists manifest and PDF with consistent naming conventions. <br>4. <code>AttemptClose</code> blocks correctly for missing evidence/sign-offs and accepts close once remediated. <br>5. All mutative actions produce <code>AuditLog</code> entries with <code>correlationId</code>. <br>6. Security scan validates no credentials stored in workbook, redaction mode verified and macros signed if required. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Operator diagnostics & remediation mapping (concise):</strong><br><code>ERR_LOCK_ACQUIRE_FAIL</code> — check <code>WorkbookMeta.lockOwner</code>; if stale contact lock owner or use admin override with verification; append <code>fa.checklist.lockAcquireFail</code>. <br><code>ERR_PQ_STALE</code> — re-run PQ refresh and ensure data sources available; check scheduled refresh logs. <br><code>ERR_CHECKLIST_MISSING_REQUIRED_FIELDS</code> — open PQ_Issues, apply suggested actions, fix template or close parameters and rerun PQ. <br><code>ERR_PDF_WRITE_FAIL</code> — test export locally, check Excel COM runtime, disk, antivirus; re-run ExportPDF with debug logs. <br><code>ERR_ATOMIC_MOVE_FAIL</code> — verify network share ACLs and availability; fallback to local staging and coordinate manual copy; append <code>fa.checklist.filePersistFail</code>. <br><code>ERR_MANIFEST_PERSIST_FAIL</code> — workbook protect or schema mismatch; ensure table exists and operator has write permission; restore from backup if required. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Migration & change governance (prescriptive):</strong><br>Any change to canonicalization, field ordering, or hashing recipes must follow <code>migrationManifest</code> procedure: <br>1. Produce <code>migrationManifest</code> capturing <code>migrationId</code>, <code>author</code>, <code>theChange</code>, <code>rationale</code>, <code>affectedFixtures</code>, <code>canaryPlan</code>, <code>rollbackPlan</code> and required approvers. <br>2. Run canary on non-critical cohort and monitor parity deltas, <code>CriticalOpen</code> and <code>manifest.parity.mismatch</code> for regressions. <br>3. If canary passes and approvals recorded in AuditLog promote change to production; otherwise roll back and document findings. <br>4. Maintain backward compatibility for historic manifests by recording <code>canonicalVersion</code> per manifest and storing old recipe references for forensic validation. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Scaling beyond Excel (architectural path):</strong><br>1. Move metadata tables (<code>TasksMaster</code>, <code>SupportingDocuments</code> metadata, <code>SignOffEntries</code>, <code>ChecklistVersionManifest</code>, <code>AuditLog</code>) into a central DWH (e.g., Synapse or BigQuery) and implement server-side ETL implementing identical canonicalization recipes. <br>2. Replace Excel PDF generation with server templating (docx/html -> PDF) that follows the same presentation template and pagination rules. <br>3. Expose <code>AttachEvidence</code>, <code>RecordSignOff</code>, <code>GenerateChecklist</code>, and <code>AttemptClose</code> as authenticated APIs to centralize concurrency, authentication, and telemetry. <br>4. Preserve canonicalization recipes and <code>canonicalVersion</code> to maintain manifest parity across environments and produce nightly parity reports between workbook and server outputs. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Onboarding & training outline (concise):</strong><br>1. Owner onboarding: how to attach evidence (local & DMS pointers), interpret checklists, respond to reminders and complete sign-offs. <br>2. Analyst onboarding: PQ refresh steps, <code>PQ_Issues</code> triage, duplicate detection, <code>MergeTasks</code> workflow and golden fixture verification. <br>3. Operator onboarding: <code>GenerateChecklistPDF</code>, <code>RollbackPartialGenerate</code>, <code>CreateManifestBundle</code>, and emergency override runbooks. <br>4. Compliance training: parity verification, legal-hold processes, forensic bundle extraction and e-discovery workflows. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Appendices (schemas, canonical orders & templates):</strong><br>Appendix A — YearEndTaskRow canonical serialization fields order for hashing: <code>taskId|taskNameCanonical|assignedOwnerId|gatingCategory|computedDueDate|signoffRequired|taskRowChecksum</code>. <br>Appendix B — SupportingDocument canonical order: <code>evidenceId|title|url|uploaderId|uploadedTs|checksum</code>. <br>Appendix C — SignOffEntry canonical order: <code>signOffId|taskId|signedBy|signedRole|signedTs|approvalRef</code>. <br>Appendix D — ChecklistVersionManifest canonical header order: <code>canonicalVersion</code> LF <code>versionId|generatedBy|generatedTs|scope|taskCount</code> LF then task rows. <br>Appendix E — Minimal <code>policySnapshot</code> keys: <code>approvalMatrix</code>, <code>twoPersonThresholds</code>, <code>signoffTimeWindow</code>, <code>evidenceChecksumPolicy</code>, <code>emergencyRules</code>, <code>canonicalVersion</code>. <br>Appendix F — Sample <code>AuditLog</code> schema: <code>eventId,eventType,actorId,timestampUTC,correlationId,detailsJson,evidenceRefs,manifestRef</code>. <br>Appendix G — Suggested <code>Telemetry</code> schema: <code>metricName,value,timestampUTC,correlationId,detailsJson</code>. </td></tr><tr><td data-label="modChecklist — Per-function Expert Technical Breakdown"> <strong>Final operational note (concise):</strong><br><code>modChecklist</code> is an orchestrator of deterministic, auditable, and reversible checklist generation flows. The implementation must preserve canonicalization and manifest hashing recipes, capture append-only audit trails, and support forensic bundle exports. Any change to canonicalization requires <code>migrationManifest</code> governance and recorded approvals. Operators must follow runbooks, parity tests must run nightly, and evidence checksums should be enforced for <code>critical</code> tasks unless explicitly relaxed by approved policy exceptions. </td></tr></tbody></table></div><div class="row-count">Rows: 46</div></div><div class="table-caption" id="Table3" data-table="Docu_0188_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modEvidence — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modEvidence — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Purpose & high-level intent (expanded)</strong> <br> <code>modEvidence</code> is the canonical evidence metadata subsystem used to support Year-End Audit/Checklist workflows. It manages evidence pointers, provenance, cryptographic fixity (checksums), access policy, retainment and legal-hold metadata, verification lifecycle, heuristic candidate matching, bulk ingestion, migration orchestration, archival/forensic export, and the append-only audit trail required for legal defensibility. The module deliberately stores only metadata and checksums inside the workbook; binaries remain in external DMS or local file stores except when compliance-authorized forensic exports include binaries. The system enforces deterministic canonicalization and hashing so manifests and row checksums are reproducible across environments. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Core principles (expanded, actionable)</strong> <br> 1. Single source of truth: <code>SupportingDocuments</code> is authoritative; PQ aggregates and publishes <code>EvidencePool</code> and <code>TasksMaster</code> — consumers (UI, PDF generator, gating) read only PQ outputs.<br> 2. Append-only forensic trail: every state change writes a new metadata row and a corresponding <code>AuditLog</code> event; do not overwrite historical rows.<br> 3. Deterministic canonicalization and hashing: canonicalVersion, field ordering, escaping rules, and encoding are immutable unless a documented migration manifest is applied.<br> 4. Conservative gating: missing or unverified critical evidence blocks closure by default; policySnapshot may define controlled exceptions with recorded compensating controls.<br> 5. Human-in-the-loop heuristics: heuristics surface candidate matches; auto-attach is not permitted without explicit analyst resolution and audit.<br> 6. Least-privilege & redaction: accessPolicy enforces view and export redaction; macros and exports must not embed credentials or tokens. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>SupportingDocuments — canonical schema and detailed field narratives</strong> <br> All fields must be preserved exactly. Each append-only row is the atomic forensic record. Fields and behavior: <br> <code>rowId</code> — GUID unique to the metadata row; used to reference exact row in audit and forensic exports. <br> <code>evidenceId</code> — stable GUID representing the logical evidence item across metadata rows. Generated at first attach. Deterministic mapping allowed for migration. <br> <code>titleRaw</code> — original uploaded filename or user-provided title preserved verbatim. Required for human review and forensics; do not alter programmatically. <br> <code>titleCanonical</code> — result of <code>CanonicalizeText(titleRaw, locale)</code> for tokenization and duplicate detection. Preservation of canonicalVersion used for generation is required. <br> <code>url</code> — canonical pointer to binary: <code>http(s)://</code>, <code>sp://</code>, <code>file://</code>, <code>dms://</code> forms acceptable. <strong>Never</strong> store access tokens or credentials in this field; use <code>platformRefTokenId</code> or secure vault references if needed. <br> <code>platformRef</code> — optional structured reference containing platform type and platform-specific ids; used for resilient rebinds and API calls. Example shape: <code>{platform:&quot;sharepoint&quot;, siteId:&quot;...&quot;, itemId:&quot;...&quot;}</code>. <br> <code>platformMetadata</code> — JSON blob captured verbatim from DMS where available: <code>sizeBytes</code>, <code>lastModifiedTs</code>, <code>mimeType</code>, <code>eTag</code>, <code>platformChecksum</code>. Keep provider keys intact. <br> <code>uploaderId</code> — actor id attaching the evidence; used for chain-of-custody. Validate against OwnerAssignments where possible. <br> <code>uploadedTs</code> — timestamp of this metadata row creation in UTC (<code>YYYY-MM-DDTHH:MM:SSZ</code>). <code>NowUTC()</code> must be used and time zone must be stored consistently. <br> <code>checksum</code> — optional <code>sha256:</code> computed over binary bytes if available; null otherwise. If present, <code>checksumSource</code> indicates origin: <code>local|dmsProvided|recomputed</code>. <br> <code>checksumSource</code> — explains origin of <code>checksum</code>. Use <code>none</code> when checksum absent. <br> <code>computedChecksum</code> — stored after verification runs; records the recomputed checksum computed by <code>VerifyEvidence</code>. Useful for mismatch auditing. <br> <code>evidenceCategory</code> — controlled taxonomy key used to match evidence requirements on tasks. Maintain taxonomy table <code>EvidenceTaxonomy</code>. <br> <code>attachedToTaskId</code> — nullable; the task the evidence is attached to; may be null for orphan evidence. PQ will surface unattached evidence in <code>OrphanEvidence</code>. <br> <code>evidenceStatus</code> — state machine: <code>unverified|valid|invalid|detached</code>. Updated via <code>VerifyEvidence</code> and scheduled health jobs. <br> <code>accessPolicy</code> — policyRef or role set controlling who may view or download content; consulted by <code>modChecklist</code> and <code>modRemind</code> for redaction. <br> <code>rebindTs</code>, <code>reboundBy</code>, <code>previousUrl</code> — recorded when RebindEvidence changes the pointer; previousUrl preserved for chain-of-custody. <br> <code>detachedTs</code>, <code>detachedBy</code>, <code>detachedReason</code> — soft-delete metadata; do not delete rows. <br> <code>retainUntil</code>, <code>legalHold</code> — retention metadata; legalHold true blocks destructive operations and requires legal unfreeze to release. <br> <code>migrationTag</code> — optional source-system reference during migration processes, used to trace migration manifest. <br> <code>rowVersionTs</code> — timestamp of this metadata row; latest state is row with max <code>rowVersionTs</code> for that <code>evidenceId</code>. <br> <code>evidenceRowChecksum</code> — <code>sha256:</code> computed over canonicalized selected metadata fields using canonicalVersion and canonical serialization recipe. This is the tamper-evidence checksum for the metadata row. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Canonical serialization & evidenceRowChecksum recipe (exact)</strong> <br> To preserve reproducibility across clients, the following canonical serialization MUST be implemented identically wherever checksums are computed: <br> 1. Canonical field order used for metadata row checksum: <code>canonicalVersion|evidenceId|titleCanonical|url|platformRef|uploaderId|uploadedTs|checksum|checksumSource|evidenceCategory|attachedToTaskId|rowVersionTs</code>.<br> 2. For textual fields apply <code>CanonicalizeText(value, locale)</code> where required (titleCanonical already canonicalized). <br> 3. For JSON fields (platformRef/platformMetadata) serialize with deterministic ordering: sort keys ascending, canonicalize string values, escape <code>|</code> and newlines. <br> 4. Escape internal <code>|</code> characters in any field with <code>\|</code> and replace newlines with <code>\n</code>. Trim leading and trailing whitespace. <br> 5. Concatenate fields using <code>|</code> separator into UTF-8 bytes (no BOM). <br> 6. Compute SHA-256 over bytes using the agreed crypto provider; represent hex in lower-case and prefix with <code>sha256:</code>. <br> 7. Persist resulting value in <code>evidenceRowChecksum</code>. <br> Changing this recipe requires a documented <code>migrationManifest</code> and re-computation via <code>EvidenceRowChecksumRecompute</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Mutative function conventions (global)</strong> <br> All mutative functions must follow the same operational pattern to be reliable, auditable, and safe: <br> 1. Validate inputs and enforce least-privilege checks; return structured results if validation fails. <br> 2. Acquire workbook-level <code>workbookLock(&quot;evidence&quot;)</code> to avoid concurrent writes in shared workbook environments; if lock acquisition fails, return deterministic retryable error code. <br> 3. Append new metadata rows (append-only), do not overwrite prior rows. <br> 4. Call <code>modAudit.AppendAudit(eventType, actorId, detailsJson, evidenceRefs, manifestRef)</code> with a correlationId whenever part of a larger flow. <br> 5. Release lock and emit telemetry counters. <br> 6. Return structured result: <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, code:String|null, details:String|null, auditRef:String|null, payload:Object|null}</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Per-function full technical contracts (complete)</strong> <br> Each function description below includes purpose, signature (conceptual), preconditions, precise behavior, audit events emitted, telemetry, error codes and remediation guidance, and worked example(s). Functions are intentionally explicit to allow exact VBA stubbing or server implementation with parity. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: AttachEvidence</strong> <br> <strong>Purpose:</strong> create a new metadata row and optionally attach to a task; compute checksum for local file inputs; preserve provenance and emit audit event. <br> <strong>Signature (conceptual):</strong> <code>AttachEvidence(taskId:String|null, evidenceUrl:String, uploaderId:String, Optional localFilePath:String, Optional evidenceCategory:String, Optional title:String, Optional accessPolicy:String, Optional platformMetadataJson:String) -&gt; ResultObject</code> <br> <strong>Preconditions & validation:</strong> <br> 1. Validate <code>uploaderId</code> exists in OwnerAssignments; else return <code>ERR_EVIDENCE_UPLOADER_UNKNOWN</code> with remediation Steps. <br> 2. Validate <code>evidenceUrl</code> uses allowed scheme (<code>http/https/sp/file/dms</code>); otherwise <code>ERR_EVIDENCE_URL_INVALID</code>. <br> 3. If <code>taskId</code> provided, ensure TasksMaster contains the task or <code>allowOrphanEvidence</code> policy true; otherwise <code>ERR_EVIDENCE_ATTACH_TASK_NOT_FOUND</code>. <br> 4. If <code>localFilePath</code> provided ensure file read permissions; otherwise <code>ERR_EVIDENCE_LOCALFILE_NOT_FOUND</code>. <br> <strong>Behavior (step-by-step):</strong> <br> 1. Acquire <code>workbookLock(&quot;evidence&quot;)</code>. <br> 2. Generate <code>evidenceId = GenerateGUID()</code> (or accept supplied mapping for import), <code>rowId = GenerateGUID()</code> and set <code>uploadedTs = NowUTC()</code>. <br> 3. Determine <code>titleRaw</code>: prefer provided <code>title</code>; fallback to basename(localFilePath) if present; otherwise the final segment of <code>evidenceUrl</code>. Compute <code>titleCanonical = CanonicalizeText(titleRaw, locale)</code>. <br> 4. Compute checksum: if <code>localFilePath</code> present and file size <= <code>maxSyncSize</code> read bytes and compute <code>checksum = ComputeEvidenceChecksum(&quot;file&quot;, localFilePath)</code>, set <code>checksumSource = &quot;local&quot;</code>. If size exceeds threshold mark row <code>verificationPending=true</code> and schedule async job; persist row with <code>checksum=null</code> and return <code>ERR_EVIDENCE_TOO_LARGE_FOR_SYNC</code> flag (row still created). If <code>platformMetadataJson</code> contains <code>platformChecksum</code> set <code>checksum</code> and <code>checksumSource=&quot;dmsProvided&quot;</code>. Else <code>checksum=null</code> and <code>checksumSource=&quot;none&quot;</code>. <br> 5. Create the metadata row with all canonicalized fields and compute <code>evidenceRowChecksum</code> using canonicalVersion serialization. <br> 6. Persist row to <code>SupportingDocuments</code> sheet and call <code>modAudit.AppendAudit(&quot;fa.evidence.attached&quot;, uploaderId, detailsJson, [evidenceId], manifestRef)</code>; capture returned <code>auditRef</code>. <br> 7. Trigger <code>EvidenceSearchIndexUpdate(evidenceId)</code> asynchronously and mark PQ refresh indicator if possible. <br> 8. Release lock and return <code>{status:&quot;OK&quot;, payload:{evidenceId,rowId}, auditRef}</code>. <br> <strong>Telemetry:</strong> increment <code>evidence.attach.count</code>; if <code>checksum==null</code> increment <code>evidence.unverified.count</code>. <br> <strong>Error codes & remediation:</strong> <br> • <code>ERR_EVIDENCE_ATTACH_TASK_NOT_FOUND</code> — provide valid task list or enable orphan policy. <br> • <code>ERR_EVIDENCE_LOCALFILE_NOT_FOUND</code> — ensure file exists and accessible; re-run attach. <br> • <code>ERR_EVIDENCE_UPLOADER_UNKNOWN</code> — register uploader or use documented override. <br> • <code>ERR_EVIDENCE_TOO_LARGE_FOR_SYNC</code> — schedule async verification job and return row reference. <br> <strong>Example (detailed):</strong> AttachEvidence("T-204", "https://tenant.sharepoint/site/doc.pdf", "alice", "C:\\temp\\tax_recon.pdf", "taxRecon", null, "role:Tax", '{"sizeBytes":54321,"lastModifiedTs":"2025-01-10T12:00:00Z"}') -> computes local checksum <code>sha256:...</code>, persists metadata row with <code>checksumSource=&quot;local&quot;</code>, emits <code>fa.evidence.attached</code> with <code>correlationId</code>, returns <code>evidenceId</code> and <code>auditRef</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: ComputeEvidenceChecksum (primitive)</strong> <br> <strong>Purpose:</strong> canonical SHA-256 computation over binary bytes or canonicalized strings; the single source of truth for checksums. Implementations across workbook and any server must match precisely. <br> <strong>Signature:</strong> <code>ComputeEvidenceChecksum(inputType:&quot;file&quot;|&quot;bytes&quot;|&quot;string&quot;, inputValue, canonicalization:Boolean=false, canonicalVersion:String) -&gt; {checksum:String|null, errorCode:String|null}</code> <br> <strong>Recipe (strict):</strong> <br> 1. For <code>file</code>: open in binary mode and read full bytes. If file size > <code>maxSyncBytes</code> return <code>ERR_CHECKSUM_TOO_LARGE</code> to schedule async verification. <br> 2. For <code>string</code>: if <code>canonicalization=true</code> apply <code>CanonicalizeText</code>, normalize CRLF and CR to LF, encode as UTF-8 without BOM. <br> 3. For <code>bytes</code>: use raw bytes as provided. <br> 4. Compute SHA-256 using the agreed crypto provider; represent result as lower-case hex prefixed <code>sha256:</code>. <br> <strong>Errors:</strong> <code>ERR_CHECKSUM_IO_ERROR</code>, <code>ERR_CHECKSUM_INVALID_INPUT</code>, <code>ERR_CHECKSUM_TOO_LARGE</code>. <br> <strong>Notes:</strong> Use central implementation; do not rely on environment-only hashing functions with unspecified encoding. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: VerifyEvidence</strong> <br> <strong>Purpose:</strong> perform integrity check that reconciles recorded <code>checksum</code> with recomputed bytes; set <code>evidenceStatus</code> and persist verification metadata. Supports manual on-demand verification and scheduled background reverify. <br> <strong>Signature:</strong> <code>VerifyEvidence(evidenceId:String, operatorId:String, followFetch:Boolean=false, allowPlatformTokenVerify:Boolean=false) -&gt; {status,evidenceStatus,computedChecksum,code,auditRef}</code> <br> <strong>Preconditions & validations:</strong> <br> 1. Evidence row must exist; else <code>ERR_EVIDENCE_NOT_FOUND</code>. <br> 2. Operator must have rights to fetch according to <code>accessPolicy</code>; otherwise <code>ERR_EVIDENCE_UNAUTHORIZED_FETCH</code>. <br> <strong>Behavior (explicit):</strong> <br> 1. Load latest metadata row for <code>evidenceId</code>. <br> 2. If <code>checksum==null</code> and <code>followFetch==false</code> append <code>fa.evidence.verified</code> event indicating <code>unverified</code> and return with <code>evidenceStatus=&quot;unverified&quot;</code>. <br> 3. If <code>followFetch==true</code> retrieve bytes: <br> • For <code>file://</code> path read local bytes (subject to <code>maxSyncBytes</code>). <br> • For <code>http(s)</code> or <code>sp</code> use platform API with tokens; verify operator permission and respect rate limits/timeouts. <br> 4. If fetched bytes exceed <code>maxSyncBytes</code> schedule async verification job and return <code>ERR_EVIDENCE_TOO_LARGE_FOR_SYNC</code> with <code>auditRef</code>. <br> 5. Compute <code>computedChecksum = ComputeEvidenceChecksum(&quot;bytes&quot;, bytes)</code>. <br> 6. Compare to recorded <code>checksum</code>: <br> • If recorded checksum exists and equals computedChecksum set <code>evidenceStatus=&quot;valid&quot;</code>. <br> • If mismatch set <code>evidenceStatus=&quot;invalid&quot;</code> and persist <code>verificationNotes</code> with computed checksum and diagnostic (diff of sizes, eTag mismatch etc.). If category is <code>critical</code> create a high-severity <code>PQ_Issue</code> and alert compliance. <br> 7. Append new metadata row with <code>lastVerificationTs</code>, <code>verifiedBy</code>, <code>computedChecksum</code> and updated <code>evidenceStatus</code> (append-only). Append <code>fa.evidence.verified</code> audit event detailing recorded vs computed checksum and computed evidenceStatus. <br> 8. Release lock and return structured result with <code>auditRef</code>. <br> <strong>Error codes & remediation:</strong> <br> • <code>ERR_EVIDENCE_NOT_FOUND</code> — search by fallback identifiers or reattach. <br> • <code>ERR_EVIDENCE_UNAUTHORIZED_FETCH</code> — request platform token or escalate approvals. <br> • <code>ERR_EVIDENCE_CHECKSUM_MISMATCH</code> — fetch original source, recompute; if mismatch confirmed detach and request reupload and document compensating controls. <br> <strong>Example (detailed):</strong> VerifyEvidence("e-123", "compliance_mgr", true, true) -> fetch remote bytes via SharePoint API using permissions, compute <code>sha256:abc..</code>, compares to recorded <code>sha256:abc..</code>, sets <code>evidenceStatus=&quot;valid&quot;</code>, appends verification metadata and <code>fa.evidence.verified</code>, returns <code>auditRef</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: RebindEvidence</strong> <br> <strong>Purpose:</strong> update pointer URL when binary migrates between stores while preserving old pointers for chain-of-custody; optionally recompute checksum. <br> <strong>Signature:</strong> <code>RebindEvidence(evidenceId:String, newUrl:String, operatorId:String, allowChecksumRecompute:Boolean=false) -&gt; {status,newRowId,code,auditRef}</code> <br> <strong>Preconditions & validations:</strong> <br> 1. <code>evidenceId</code> must exist. <br> 2. Operator must be authorized; <code>legalHold</code> prevents rebind without legal approval. <br> <strong>Behavior:</strong> <br> 1. Acquire lock, append new metadata row with <code>previousUrl</code> set to previous latest row's url, <code>url=newUrl</code>, <code>rebindTs=NowUTC()</code>, <code>reboundBy=operatorId</code>. <br> 2. If <code>allowChecksumRecompute==true</code> and newUrl fetchable compute <code>computedChecksum</code> and set <code>checksumSource=&quot;recomputed&quot;</code> and update <code>checksum</code> in new row; else set <code>checksum=null</code> and <code>evidenceStatus=&quot;unverified&quot;</code>. <br> 3. Compute <code>evidenceRowChecksum</code> for new row and persist. <br> 4. Append <code>fa.evidence.rebound</code> event with old and new URLs, any recomputed checksum and <code>auditRef</code>. <br> 5. Trigger <code>EvidenceSearchIndexUpdate(evidenceId)</code> and PQ refresh marker. <br> <strong>Errors & remediation:</strong> <br> • <code>ERR_EVIDENCE_NOT_FOUND</code> — validate id. <br> • <code>ERR_EVIDENCE_REBIND_UNAUTHORIZED</code> — get approver or run migration manifest with approvals. <br> • <code>ERR_EVIDENCE_REMOTE_FETCH_FAIL</code> — platform network error; schedule retry and record PQ issue. <br> <strong>Example:</strong> RebindEvidence("e-456", "https://tenant-new.sharepoint/site/item.pdf", "ops_admin", True) -> new metadata row appended, recompute succeeded setting <code>checksum=sha256:...</code>, append <code>fa.evidence.rebound</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: DetachEvidence (soft-delete)</strong> <br> <strong>Purpose:</strong> detach an evidence item from tasks without deleting metadata; preserve chain-of-custody and legal compliance. <br> <strong>Signature:</strong> <code>DetachEvidence(evidenceId:String, operatorId:String, reason:String) -&gt; {status,code,auditRef}</code> <br> <strong>Preconditions:</strong> <br> 1. If <code>legalHold==true</code> return <code>ERR_EVIDENCE_LEGAL_HOLD</code>. <br> <strong>Behavior:</strong> <br> 1. Append new metadata row with <code>detached=true</code>, <code>detachedBy=operatorId</code>, <code>detachedTs=NowUTC()</code>, <code>detachedReason=reason</code>, set <code>attachedToTaskId=null</code>. <br> 2. Append <code>fa.evidence.detached</code> audit event with details and link to <code>evidenceId</code>. <br> 3. PQ will treat evidence as detached on next refresh and <code>MissingEvidenceReport</code> will show task needing remedial action. <br> <strong>Errors & remediation:</strong> <br> • <code>ERR_EVIDENCE_LEGAL_HOLD</code> — contact legal. <br> <strong>Example:</strong> DetachEvidence("e-888", "auditor1", "wrong document uploaded by mistake") -> append row with detached flags and <code>fa.evidence.detached</code> audit. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: BulkAttachEvidence (high-throughput ingestion)</strong> <br> <strong>Purpose:</strong> ingest large batches of evidence rows — used for DMS exports, migration imports, mass rebinds — with configurable commit semantics and robust error reporting. <br> <strong>Signature:</strong> <code>BulkAttachEvidence(batchRows:Array, operatorId:String, commitMode:&quot;partial&quot;|&quot;allOrNothing&quot;, maxParallel:Int) -&gt; {summary:{successCount,failCount}, errors:[{index,code,details}], auditRef}</code> <br> <strong>Validation rules & transactional semantics:</strong> <br> 1. Validate all rows upfront. If <code>allOrNothing</code> and any validation error present return <code>ERR_BULK_VALIDATION_FAILED</code> with full error list. <br> 2. If <code>partial</code>, persist valid rows and return errors for invalid ones; preserve chronological ordering and assign new <code>evidenceId</code>/<code>rowId</code> per persisted item. <br> 3. For local files compute checksums in parallel bounded by <code>maxParallel</code>. For remote pointers set <code>checksum=null</code> unless provider metadata contains <code>platformChecksum</code>. <br> 4. Deduplication: detect duplicate incoming rows using <code>sourceId</code> or file hash; handle according to <code>dedupPolicy</code> (skip, merge, or error). <br> 5. Persist rows and emit single batched <code>fa.evidence.bulk_attach</code> audit event listing created evidenceIds for operational efficiency but also create per-row audit references optionally if required by policy. <br> <strong>Observability:</strong> emit <code>evidence.bulk.attach.count</code> and <code>evidence.bulk.attach.failRate</code>. <br> <strong>Errors & remediation:</strong> <br> • <code>ERR_BULK_VALIDATION_FAILED</code> — fix inputs and retry. <br> • <code>ERR_BULK_IO_FAIL</code> — transient IO error; re-run with resume token. <br> <strong>Example:</strong> BulkAttachEvidence([{taskId:"T-1", localFilePath:"C:\\files\\a.pdf", uploaderId:"ingest_bot"}, {...}], "ingest_bot", "partial", 4) -> persists valid rows, returns summary and errors for invalid paths. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: HeuristicEvidenceMatch (explainable matching)</strong> <br> <strong>Purpose:</strong> produce ranked candidate evidence items for a task using deterministic, explainable heuristics; never auto-attach. <br> <strong>Signature:</strong> <code>HeuristicEvidenceMatch(taskId:String, candidatePool:Array|null, thresholds:Object|null) -&gt; {candidates:Array[{evidenceId,confidenceScore,matchRationale}], issueRef}</code> <br> <strong>Heuristic recipe (must align with PQ):</strong> <br> 1. Produce token set A from <code>taskNameCanonical</code> and <code>descriptionCanonical</code> using <code>CanonicalizeText</code> and stop-word removal. <br> 2. For each evidence candidate produce token set B from <code>titleCanonical</code> and filename tokens. <br> 3. Compute <code>tokenOverlap = |A ∩ B| / |A ∪ B|</code>. <br> 4. Compute <code>dateAffinity</code> using EXIF or <code>platformMetadata.lastModifiedTs</code> relative to <code>computedDueDate</code>: <code>dateAffinity = clamp(1 - (abs(daysDiff)/windowDays), 0,1)</code>. <br> 5. Set <code>categoryBoost = 1.0</code> if evidenceCategory matches any required by the task; else 0. <br> 6. <code>uploaderAffinity = 1.0</code> if uploaderId == assignedOwnerId else 0. <br> 7. Confidence score = weighted sum: <code>wToken*tokenOverlap + wDate*dateAffinity + wCategory*categoryBoost + wUploader*uploaderAffinity</code>. Weights come from <code>EvidenceHeuristicConfig</code>. <br> 8. Return sorted list of candidates above <code>minConfidence</code> along with <code>matchRationale</code> (text listing contributing factors and numeric contributions). Persist <code>HeuristicMatches</code> rows and emit <code>PQ_Issue</code> <code>HeuristicEvidenceMatch</code> for analyst triage. <br> <strong>Error:</strong> <code>ERR_HEURISTIC_NO_CANDIDATES</code> if none found above threshold. <br> <strong>Human-in-loop:</strong> use <code>ResolveHeuristicMatch</code> to accept or reject a candidate (both actions append audit events). <br> <strong>Example:</strong> HeuristicEvidenceMatch("T-300") returns top candidate <code>e-201</code> with confidence 0.92 and rationale "tokenOverlap=0.84, dateAffinity=0.95, categoryBoost=1.0". </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: ResolveHeuristicMatch</strong> <br> <strong>Purpose:</strong> finalize a heuristic candidate by attaching it to the task or rejecting it and recording the decision for future heuristics. <br> <strong>Signature:</strong> <code>ResolveHeuristicMatch(evidenceId:String, taskId:String, operatorId:String, action:&quot;attach&quot;|&quot;reject&quot;, comment:String|null) -&gt; {status,auditRef,code}</code> <br> <strong>Behavior:</strong> <br> 1. If <code>action==&quot;attach&quot;</code> perform <code>AttachEvidence</code> or append a new metadata row for existing <code>evidenceId</code> setting <code>attachedToTaskId=taskId</code> and <code>attachedBy=operatorId</code> and <code>attachedTs=NowUTC()</code>. Append <code>fa.evidence.heuristic_attached</code>. <br> 2. If <code>action==&quot;reject&quot;</code> mark <code>HeuristicMatches</code> row <code>heuristicRejected=true</code> with reason and append <code>fa.evidence.heuristic_rejected</code>. <br> 3. Both actions set <code>resolvedBy</code> and <code>resolvedTs</code> and remove candidate from active PQ surfacing. <br> <strong>Example:</strong> ResolveHeuristicMatch("e-201","T-300","analyst1","attach","manager confirmed") -> evidence attached with audit event. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceHealthCheck (scheduled job)</strong> <br> <strong>Purpose:</strong> regular validation of URL reachability, local file presence and checksum parity; generate PQ_Issues for remediation and telemetry. <br> <strong>Signature:</strong> <code>EvidenceHealthCheck(options:{checkRemoteHead:Boolean, sampleRate:Int, categories:Array}, operatorId:String) -&gt; {summary,issueRefs,auditRef}</code> <br> <strong>Behavior:</strong> <br> 1. Iterate through <code>EvidencePool</code> or a sample per <code>sampleRate</code>. For HTTP(S) and <code>sp://</code> URLs perform HEAD to verify availability and HTTP status; map statuses to <code>urlHealth</code> values and create <code>PQ_Issues</code> for unreachable. <br> 2. For entries with <code>checksum</code> present attempt recompute (when allowed) and compare; create <code>PQ_Issues</code> for mismatches. <br> 3. For local <code>file://</code> paths verify existence; create <code>PQ_Issues</code> when missing. <br> 4. Update <code>evidenceStatus</code> if appropriate and emit <code>fa.evidence.healthcheck</code> summarizing counts. Throttle DMS calls and avoid synchronous fetches for huge files. <br> <strong>Operational note:</strong> schedule heavy verification off-hours and surface top failing items to owners via <code>modRemind</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceReverifyScheduled (orchestration)</strong> <br> <strong>Purpose:</strong> orchestrate periodic re-verification of evidence in background with exponential backoff for transient failures and deterministic retry windows; ensure idempotent job tokens. <br> <strong>Signature:</strong> <code>EvidenceReverifyScheduled(scheduleParams:Object, operatorId:String) -&gt; {scheduledJobsCount,nextRunTs,auditRef}</code> <br> <strong>Rules:</strong> <br> 1. Frequencies default: <code>critical</code> every 7 days, <code>important</code> every 14 days, <code>optional</code> every 30 days — configurable via <code>policySnapshot</code>. <br> 2. Use job tokens to avoid duplicate reverify tasks against same <code>evidenceId</code>. <br> 3. On transient failures apply backoff (1m,5m,20m) before final failure; persistent failure results in <code>unverified</code> marking and a <code>PQ_Issue</code>. <br> 4. Append <code>fa.evidence.reverify</code> events for job runs and outcomes. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: ExportEvidenceForensics (for compliance)</strong> <br> <strong>Purpose:</strong> produce signed forensic export bundles containing <code>ChecklistVersionManifest</code>, <code>SupportingDocuments</code> metadata (latest rows), <code>AuditLog</code> slice, <code>checksums.json</code> and optionally binaries; used for legal e-discovery and long-term archives. <br> <strong>Signature:</strong> <code>ExportEvidenceForensics(versionId:String, evidenceIds:Array, operatorId:String, includeBinary:Boolean) -&gt; {status,exportPath,exportHash,auditRef,code}</code> <br> <strong>Authorization & governance:</strong> <br> 1. Require compliance role and multi-approver sign-off when <code>includeBinary==true</code>. Document approvals in <code>detailsJson</code> appended to AuditLog. <br> 2. Compose bundle atomically: create temp zip containing <code>manifest.json</code> (including manifestHash), <code>supportingDocuments.csv</code> (latest metadata rows with evidenceRowChecksum), <code>auditLogSlice.json</code> (all audit events correlated to the manifest), <code>checksums.json</code>. If <code>includeBinary==true</code> fetch binaries into <code>binaries/</code> subfolder using authorized tokens. <br> 3. Compute <code>exportHash = ComputeEvidenceChecksum(&quot;bytes&quot;, zipBytes)</code>, sign manifest if signing key available, create <code>manifest.signature</code>, then atomically move to secure archive; append <code>fa.evidence.forensic_export</code>. <br> <strong>Errors & remediation:</strong> <br> • <code>ERR_EXPORT_UNAUTHORIZED</code> — obtain compliance approvals. <br> • <code>ERR_EXPORT_IO_FAIL</code> — retry using alternate storage and escalate to infra. <br> <strong>Example:</strong> ExportEvidenceForensics("v-2025-12-31","[e-111,e-222]","compliance_mgr",False) -> returns <code>exportPath</code>, <code>exportHash</code>, <code>auditRef</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: ApplyAccessPolicyToEvidence</strong> <br> <strong>Purpose:</strong> update/restrict retrieval policy for evidence and cause downstream redaction in <code>modChecklist</code> and <code>modRemind</code>. <br> <strong>Signature:</strong> <code>ApplyAccessPolicyToEvidence(evidenceId:String, accessPolicy:String, operatorId:String) -&gt; {status,auditRef,code}</code> <br> <strong>Behavior:</strong> <br> 1. Validate accessPolicy exists in <code>AccessPolicy</code> sheet and operator authorized; else <code>ERR_ACCESSPOLICY_UNAUTHORIZED</code>. <br> 2. Append new metadata row with updated <code>accessPolicy</code>. <br> 3. Append <code>fa.evidence.policy.updated</code> with <code>auditRef</code>. <br> 4. PDF/email generators must consult <code>accessPolicy</code>: redact links or include <code>evidenceRef</code> placeholders for unauthorized recipients. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceRowChecksumRecompute</strong> <br> <strong>Purpose:</strong> recompute metadata row checksum deterministically when canonicalVersion or serialization recipe changes; used in migrations and parity checks. <br> <strong>Signature:</strong> <code>EvidenceRowChecksumRecompute(evidenceId:String, canonicalVersion:String, operatorId:String) -&gt; {status,newRowChecksum,auditRef}</code> <br> <strong>Behavior:</strong> <br> 1. Using canonicalVersion apply canonical serialization order and recipe and compute <code>sha256:</code>. <br> 2. Append new metadata row or update new row with recomputed <code>evidenceRowChecksum</code> (append-only). <br> 3. Append <code>fa.evidence.rowchecksum.recomputed</code> and record <code>migrationManifestId</code> where appropriate. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceSearchIndexUpdate</strong> <br> <strong>Purpose:</strong> maintain token index used by heuristics and fast UI search; supports incremental updates and full rebuilds. <br> <strong>Signature:</strong> <code>EvidenceSearchIndexUpdate(evidenceId:String|null, operatorId:String, rebuild:Boolean=false) -&gt; {status,indexVersion,auditRef}</code> <br> <strong>Behavior:</strong> <br> 1. Tokenize <code>titleCanonical</code>, filename tokens, uploaderId and evidenceCategory into <code>EvidenceIndex</code>. <br> 2. If <code>rebuild==true</code> perform full index rebuild (heavy) and update <code>indexVersion</code> — schedule off-hours for large pools. <br> 3. Append <code>fa.evidence.index.updated</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceRetentionMark</strong> <br> <strong>Purpose:</strong> set <code>retainUntil</code> and <code>legalHold</code> metadata for evidence; legal holds block destructive operations. <br> <strong>Signature:</strong> <code>EvidenceRetentionMark(evidenceId:String, retainUntil:Date|null, legalHold:Boolean, operatorId:String) -&gt; {status,auditRef}</code> <br> <strong>Behavior:</strong> append metadata row with retention and hold fields and <code>fa.evidence.retention.updated</code>. Enforce <code>ERR_EVIDENCE_LEGAL_HOLD</code> when attempts occur to detach/archive held evidence. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceArchive</strong> <br> <strong>Purpose:</strong> create signed archive bundles for long-term retention with retention metadata and optional binaries; used post-close. <br> <strong>Signature:</strong> <code>EvidenceArchive(evidenceIds:Array, operatorId:String, includeBinary:Boolean) -&gt; {status,archivePath,archiveHash,auditRef,code}</code> <br> <strong>Behavior:</strong> <br> 1. Validate <code>legalHold</code> and <code>retainUntil</code>. If <code>legalHold</code> true allow archive into legal vault but do not remove evidence until release. <br> 2. Create bundle with metadata, checksums and optionally binaries, compute <code>archiveHash</code>, sign, persist to archive, append <code>fa.evidence.archived</code>. <br> <strong>Errors:</strong> <code>ERR_ARCHIVE_IO_FAIL</code>, <code>ERR_ARCHIVE_LEGAL_HOLD</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceMigration</strong> <br> <strong>Purpose:</strong> orchestrate large-scale rebinds and checksum recomputations during DMS migrations with canary and rollback semantics. <br> <strong>Signature:</strong> <code>EvidenceMigration(migrationPlanJson:String, operatorId:String) -&gt; {status,migratedCount,failedCount,migrationManifestId,auditRef}</code> <br> <strong>Plan required fields (minimum):</strong> <code>sourceMapping[]</code> (oldUrl->newUrl), <code>canarySet[]</code>, <code>checksumPolicy</code> (require recompute?), <code>rollbackPlan</code>, <code>approvals[]</code>. <br> <strong>Workflow (explicit):</strong> <br> 1. Validate plan and required approvals. <br> 2. Run canary subset: perform <code>RebindEvidence</code> and <code>EvidenceRowChecksumRecompute</code> on canary and produce <code>migrationManifest</code> documenting pre/post checksums. <br> 3. If canary passes thresholds proceed in batches; if not, run <code>rollbackPlan</code> and emit <code>fa.evidence.migration.rollback</code>. <br> 4. Emit <code>fa.evidence.migration</code> events for batches and persist <code>migrationManifestId</code> in metadata rows touched. <br> <strong>Errors:</strong> <code>ERR_MIGRATION_VALIDATION_FAIL</code>, <code>ERR_MIGRATION_IO_FAIL</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceFixityCheck (nightly parity)</strong> <br> <strong>Purpose:</strong> nightly recompute of checksums for evidence where <code>checksum</code> present to detect silent corruption or DMS issues; escalate mismatches for critical evidence. <br> <strong>Signature:</strong> <code>EvidenceFixityCheck(runParams:Object, operatorId:String) -&gt; {checkedCount,mismatches,auditRef,issuesRef}</code> <br> <strong>Behavior:</strong> <br> 1. Iterate evidence with <code>checksum != null</code> and <code>evidenceStatus != detached</code>. <br> 2. Attempt to fetch bytes (respecting <code>accessPolicy</code>), compute <code>computedChecksum</code>, compare to recorded <code>checksum</code>. <br> 3. Where mismatch found append <code>PQ_Issues</code> <code>FixityMismatch</code> and <code>fa.evidence.fixity</code>. Escalate critical mismatches immediately. <br> 4. Throttle fetches and schedule heavy work off-hours. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceSearchAndRetrieve (query API)</strong> <br> <strong>Purpose:</strong> authorized read-only query for UI, respecting <code>accessPolicy</code> and performing field-level redaction. <br> <strong>Signature:</strong> <code>EvidenceSearchAndRetrieve(filters:Object, operatorId:String, pageSize:Int, pageToken:String) -&gt; {items:[rows],nextPageToken,totalCount}</code> <br> <strong>Behavior:</strong> <br> 1. Filter latest metadata rows per <code>evidenceId</code>. <br> 2. Apply accessPolicy: redact <code>url</code> for unauthorized operators and return <code>evidenceRef</code> placeholders for secure retrieval flows (tokenized ephemeral retrieval). <br> 3. Paginate and return totals. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Function: EvidenceRowMerge (reassign attachments)</strong> <br> <strong>Purpose:</strong> reassign evidence to a new task as part of dedup/merge workflows while preserving provenance. <br> <strong>Signature:</strong> <code>EvidenceRowMerge(sourceEvidenceIds:Array, targetTaskId:String, operatorId:String, reason:String) -&gt; {status,movedCount,auditRef}</code> <br> <strong>Behavior:</strong> append new metadata rows for each <code>evidenceId</code> with <code>attachedToTaskId=targetTaskId</code>, <code>movedFrom=previousTaskId</code>, <code>movedBy=operatorId</code> and <code>movedReason=reason</code>. Append <code>fa.evidence.reassigned</code>. Do not delete prior rows. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>AuditLog event taxonomy & payload conventions (exhaustive)</strong> <br> Every mutative function must call <code>modAudit.AppendAudit(eventType, actorId, detailsJson, evidenceRefs, manifestRef)</code> with the following minimum event types and required payload shapes: <br> • <code>fa.evidence.attached</code> — <code>{evidenceId, taskId?, uploaderId, uploadedTs, checksumPresent:Boolean, correlationId}</code>.<br> • <code>fa.evidence.verified</code> — <code>{evidenceId, operatorId, result:&quot;valid&quot;|&quot;invalid&quot;|&quot;unverified&quot;, recordedChecksum, computedChecksum, notes, correlationId}</code>.<br> • <code>fa.evidence.rebound</code> — <code>{evidenceId, oldUrl, newUrl, operatorId, checksumChange?}</code>.<br> • <code>fa.evidence.detached</code> — <code>{evidenceId, operatorId, reason}</code>.<br> • <code>fa.evidence.bulk_attach</code> — <code>{operatorId, successCount, failCount, evidenceRefs[]}</code>.<br> • <code>fa.evidence.heuristic_attached</code> — <code>{evidenceId, taskId, operatorId, confidenceScore}</code>.<br> • <code>fa.evidence.heuristic_rejected</code> — <code>{evidenceId, taskId, operatorId, confidenceScore, reason}</code>.<br> • <code>fa.evidence.fixity</code> — <code>{checkedCount, mismatches:[{evidenceId, recordedChecksum, computedChecksum}]}</code>.<br> • <code>fa.evidence.forensic_export</code> — <code>{exportPath, exportHash, operatorId, versionId}</code>.<br> • <code>fa.evidence.archived</code> — <code>{archivePath, archiveHash, operatorId}</code>. <br> Audit events must include <code>timestampUTC</code> and <code>correlationId</code> for multi-step flows. Include minimal structured fields to facilitate automated replay and forensic bundle assembly. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Error codes — exhaustive list and operator remediation patterns</strong> <br> All functions must return an <code>errorCode</code> and human <code>details</code> with remediation steps and an <code>auditRef</code> pointing to the audit row that recorded the failure. Core codes and remediations: <br> 1. <code>ERR_EVIDENCE_ATTACH_TASK_NOT_FOUND</code> — supply valid <code>taskId</code> or set <code>allowOrphanEvidence</code> policy; re-run <code>AttachEvidence</code>.<br> 2. <code>ERR_EVIDENCE_LOCALFILE_NOT_FOUND</code> — confirm path and access, unlock file if locked, re-run attach.<br> 3. <code>ERR_EVIDENCE_UPLOADER_UNKNOWN</code> — register uploader or apply override documented in <code>policySnapshot</code>.<br> 4. <code>ERR_EVIDENCE_URL_INVALID</code> — correct URL format or use <code>platformRef</code> mapping.<br> 5. <code>ERR_EVIDENCE_NOT_FOUND</code> — search by title/hash or re-ingest evidence.<br> 6. <code>ERR_EVIDENCE_CHECKSUM_MISMATCH</code> — fetch source bytes locally, recompute checksum, if mismatch detach and request reupload; create <code>PostCloseAdjustment</code> if previously used in closed manifest.<br> 7. <code>ERR_EVIDENCE_REBIND_UNAUTHORIZED</code> — request approver or include in migration manifest approvals.<br> 8. <code>ERR_EVIDENCE_LEGAL_HOLD</code> — contact legal; do not detach or delete.<br> 9. <code>ERR_EVIDENCE_REMOTE_NO_FETCH</code> — request platform verification token or DMS admin support; mark evidence <code>unverified</code> until resolved.<br> 10. <code>ERR_EXPORT_UNAUTHORIZED</code> — obtain compliance approval and multi-approver sign-off.<br> 11. <code>ERR_ARCHIVE_IO_FAIL</code> — retry to alternate store and escalate to infra.<br> 12. <code>ERR_HEURISTIC_NO_CANDIDATES</code> — expand search window or manual resolution.<br> 13. <code>ERR_CHECKSUM_IO_ERROR</code> — check file permissions and retry. <br> Provide suggested remediation steps in <code>details</code> for every error code; include the <code>auditRef</code> so operators can jump to the audit record for deeper context. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Telemetry & observability (metrics, suggested thresholds, alerts)</strong> <br> Capture telemetry in <code>Telemetry</code> sheet and optionally push to metrics systems. Recommended metrics: <br> • Counters: <code>evidence.attach.count</code>, <code>evidence.unverified.count</code>, <code>evidence.invalid.count</code>, <code>evidence.fixity.mismatch.count</code>, <code>evidence.bulk.attach.count</code>, <code>evidence.forensic.export.count</code>, <code>evidence.rebind.count</code>, <code>evidence.detached.count</code>.<br> • Timers/histograms: <code>computeChecksum.durationMs</code>, <code>verify.durationMs</code>, <code>export.durationMs</code>.<br> • Gauges: <code>evidencePool.size</code>, <code>orphanEvidence.count</code>, <code>indexVersion</code>. <br> Suggested alerts (example thresholds): <br> • High: any <code>evidence.fixity.mismatch.count &gt; 0</code> for <code>critical</code> categories — immediate compliance alert. <br> • Medium: <code>evidence.unverified.count</code> increases > 25% within 24 hours during close cycle — owner outreach required. <br> • Medium: <code>evidence.bulk.attach.failRate &gt; 5%</code> over 24h — inspect ingestion pipeline. <br> Include alert playbooks linking to the top failing evidence <code>evidenceId</code>s and <code>auditRef</code>s to speed triage. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Power Query (PQ) orchestration — conceptual design, named steps, outputs (no code)</strong> <br> PQ must be the canonical aggregator that produces <code>TasksMaster</code>, <code>EvidencePool</code> and issue lists for gating. PQ must <strong>not</strong> perform binary fetches or checksums; those are performed by <code>modEvidence</code>. Named-step responsibilities (conceptual): <br> 1. <code>Source_SupportingDocuments</code> — read raw <code>SupportingDocuments</code> table; preserve rowVersionTs and migrationTags. <br> 2. <code>CanonicalizeTitles</code> — apply same canonicalization recipe as <code>modUtils.CanonicalizeText</code> to <code>titleRaw</code> producing <code>titleCanonical</code>; record counts changed. <br> 3. <code>LatestEvidenceRows</code> — group by <code>evidenceId</code> and take row with max <code>rowVersionTs</code> to produce <code>EvidencePool</code>. <br> 4. <code>ParsePlatformMetadata</code> — expand <code>platformMetadata</code> JSON for size, lastModified, eTag; produce columns for heuristics. <br> 5. <code>AttachEvidenceLeftJoin</code> — left-join <code>LatestEvidenceRows</code> to <code>TasksMaster</code> via <code>attachedToTaskId</code> producing <code>attachedEvidenceIds[]</code> per task and <code>OrphanEvidence</code>. <br> 6. <code>HeuristicCandidates</code> — compute token-based candidate matches mirroring modEvidence heuristics to produce <code>HeuristicMatches</code> with <code>confidenceScore</code>. <br> 7. <code>IssueDetection</code> — generate <code>PQ_Issues</code> for <code>UnverifiedEvidence</code>, <code>InvalidChecksum</code>, <code>EvidenceMissingOnDisk</code>, <code>MissingOwner</code>, <code>HeuristicEvidenceMatch</code>. Each PQ_Issue includes <code>issueId</code>, <code>issueType</code>, <code>entityRef</code>, <code>severity</code>, <code>details</code>, <code>suggestedAction</code>. <br> 8. <code>ComputeTaskMetrics</code> — compute <code>evidenceMissing</code> by checking required categories, compute <code>daysToDue</code>, <code>overdueFlag</code>, <code>gatingRisk</code>. <br> 9. <code>EmitOutputs</code> — persist <code>TasksMaster</code>, <code>EvidencePool</code>, <code>HeuristicMatches</code>, <code>PQ_Issues</code>, <code>MissingEvidenceReport</code> and store <code>pqRunTs</code> and <code>pqRunHash</code>. <br> PQ constraints and operational notes: do not fetch binary content in PQ; create stable named-step boundaries and include <code>pqRunHash</code> and <code>pqRunTs</code> in outputs to allow parity checks; keep step names stable across canonicalVersion updates and document changes in <code>manifestNotes</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX reporting patterns (no snippets) — KPIs & visual patterns</strong> <br> The dataset originates from PQ outputs. DAX measures are conceptual descriptions for Power BI/Excel: <br> Key measures (conceptual): <br> 1. <code>TotalEvidence</code> — distinct count of <code>evidenceId</code> in EvidencePool. <br> 2. <code>UnverifiedEvidenceCount</code> — count where latest <code>evidenceStatus=&quot;unverified&quot;</code>. <br> 3. <code>InvalidEvidenceCount</code> — count where latest <code>evidenceStatus=&quot;invalid&quot;</code>. <br> 4. <code>EvidencePerTask</code> — average attachments per task = TotalEvidence / TasksWithAttachments. <br> 5. <code>FixityMismatchRate</code> — mismatches / evidenceWithChecksum in selected period. <br> 6. <code>SignOffCoverage</code> — percent of tasks with required sign-offs by <code>policySnapshot</code>. <br> 7. <code>CriticalOpen</code> — count of tasks with <code>gatingCategory=&quot;critical&quot;</code> and not closed. <br> Visual patterns and dashboards: <br> • Executive overview page: top-level tiles for <code>CriticalOpen</code>, <code>UnverifiedEvidenceCount</code>, <code>FixityMismatchRate</code>, <code>CloseReadiness%</code>. <br> • Owner dashboard: heatmap owner vs <code>CriticalOpen</code> and <code>UnverifiedEvidence</code> with drill-through to tasks and evidence. <br> • Parity/Forensics page: list of manifests with <code>manifestHash</code>, <code>parityStatus</code>, <code>forensicExport</code> link and evidence mismatches with <code>auditRef</code>. <br> • Evidence explorer: table of <code>EvidencePool</code> with latest metadata; apply row-level security to respect <code>accessPolicy</code> and redact <code>url</code> for unauthorized viewers. <br> Modeling notes: always filter to the latest metadata row per <code>evidenceId</code> (max <code>rowVersionTs</code>) when computing measures; treat <code>accessPolicy</code> field as security filter for user contexts. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Testing matrix, golden fixtures, and acceptance criteria</strong> <br> Testing tiers: unit, integration, system, performance, security & parity. Provide deterministic fixtures and CI harness to validate hashing and PQ parity. <br> Unit test examples: <br> 1. <code>ComputeEvidenceChecksum</code> determinism: known byte arrays -> exact <code>sha256:</code> hex. <br> 2. <code>CanonicalizeText</code> locale tests (Turkish dotted/dotless i, combining diacritics, whitespace normalization). <br> 3. <code>AttachEvidence</code> local: attach test file -> checksum computed and <code>fa.evidence.attached</code> emitted. <br> 4. <code>VerifyEvidence</code> mismatch: modify attached file -> verify detects mismatch and emits PQ issue. <br> Integration tests: <br> 1. End-to-end happy path: PQ ingest -> AttachEvidence -> GenerateChecklistPDF -> VerifyEvidence -> RecordSignOff -> AttemptClose -> CloseSucceeded. <br> 2. Failure path: PQ <code>UnverifiedEvidence</code> blocks close; run reminders; attach evidence; verify; re-run AttemptClose succeeds. <br> Golden fixtures: provide <code>fixture_small</code>, <code>fixture_mid</code>, <code>fixture_edge</code> CSVs including <code>SupportingDocuments</code> and <code>ChecklistVersionManifest</code> sample values with expected <code>evidenceRowChecksum</code> and <code>manifestHash</code> for canonicalVersion v1. <br> Acceptance gates (release): <br> 1. All unit tests pass. <br> 2. PQ parity tests match <code>pqRunHash</code> for golden fixtures. <br> 3. Security review confirms no credentials persisted; macros signed. <br> 4. Bulk attach and nightly fixity run meet performance SLAs. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Operational runbooks (concise, executable steps)</strong> <br> Pre-close daily evidence routine (recommended): <br> 1. Refresh PQ; open <code>PQ_Issues</code> filtered to <code>UnverifiedEvidence</code>, <code>InvalidChecksum</code>, <code>MissingOwner</code>. <br> 2. Run <code>EvidenceHealthCheck</code> for <code>critical</code> categories; triage unreachable items and escalate. <br> 3. Run targeted <code>VerifyEvidence</code> for any items with policy-specified urgency (owner-approved). <br> 4. Generate <code>ChecklistPDF</code> for owners and distribute using <code>modRemind</code>. <br> 5. Confirm sign-offs and rerun <code>AttemptClose</code> in dry-run mode for staging. <br> Emergency rebind runbook: <br> 1. Obtain <code>overrideApprovalRef</code> under <code>policySnapshot.emergencyRules</code>; record approver identity in AuditLog. <br> 2. Run <code>RebindEvidence(evidenceId,newUrl,operatorId,allowChecksumRecompute=true)</code>. <br> 3. Export forensic bundle via <code>ExportEvidenceForensics</code> and store in compliance archive; append <code>fa.evidence.forensic_export</code>. <br> Post-close remediation: <br> 1. Create <code>PostCloseAdjustment</code> record referencing <code>closeId</code>. <br> 2. Attach new evidence and record sign-offs according to <code>policySnapshot</code>. <br> 3. If re-open required request approvals and produce superseding manifest; preserve both manifests and appended <code>fa.checklist.reopen</code> event. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Security, privacy & compliance controls (implementation)</strong> <br> Controls to implement before production: <br> 1. Never store tokens or credentials in <code>url</code> or <code>SupportingDocuments</code>; store secrets in secure key vault referenced by <code>platformRefTokenId</code>. <br> 2. Macro signing and workbook ACLs mandatory for production <code>.xlsm</code> deployments. <br> 3. Forensic exports and archives encrypted-at-rest and signed using organizational keys. <br> 4. AccessPolicy enforcement: retrieval functions and PDF/email engines must redact links for recipients without required roles; provide <code>evidenceRef</code> placeholders for secure retrieval. <br> 5. Legal hold enforcement: <code>legalHold</code> flags block detach/archive; only legal role may release. <br> 6. Compliance approval gating for exports with binaries and retention exceptions. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Retention, archival & e-discovery guidance (operational)</strong> <br> 1. On each close, produce signed forensic bundle containing <code>manifest.json</code>, <code>supportingDocuments.csv</code>, <code>auditLogSlice.json</code>, <code>checksums.json</code>. Persist to secure archive with <code>archiveHash</code> and <code>retainUntil</code>. <br> 2. Legal holds: maintain <code>LegalHoldQueue</code> and prevent destructive actions for held items; record release approvals in AuditLog. <br> 3. Deletion after retention: require multi-approver <code>deletionApprovals[]</code> and append <code>deletionManifest</code> to AuditLog. <br> 4. Provide secure retrieval workflow for evidence as part of e-discovery with logged access and per-retrieval signed tokens. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Migration manifest & governance (must-follow)</strong> <br> Any change to canonicalization, hashing, evidence taxonomy, or policySnapshot must be governed. Required migration manifest items: <br> 1. <code>migrationId</code>, <code>author</code>, <code>createdTs</code>, <code>approvals[]</code> with approver identities and timestamp. <br> 2. <code>canonicalVersionBefore</code>, <code>canonicalVersionAfter</code>, <code>changeRationale</code>. <br> 3. <code>affectedTables</code>, <code>affectedRecords</code> sampling and canary plan. <br> 4. <code>beforeAfterSampleChecksums</code> demonstrating parity. <br> 5. <code>rollbackPlan</code> with explicit steps and thresholds that trigger rollback. <br> 6. Signed <code>migrationManifest</code> persisted in AuditLog. <br> Execution: run canary, validate parity, then staged batch migration; if thresholds exceeded trigger rollback and emit <code>fa.evidence.migration.rollback</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Operator CLI/macro patterns (practical)</strong> <br> Macro examples (conceptual wrapper names, structured outputs): <br> 1. <code>fa.attachEvidence --task T-123 --file C:\tmp\file.pdf --uploader alice</code> -> calls <code>AttachEvidence</code>, returns JSON result with <code>evidenceId</code> and <code>auditRef</code> and human-friendly summary printing errors when present. <br> 2. <code>fa.verifyEvidence --evidence e-111 --operator compliance_mgr --followFetch</code> -> runs <code>VerifyEvidence</code> and prints status and <code>auditRef</code>. <br> 3. <code>fa.bulkAttach --batch batch1.csv --operator ingest_bot --commit partial</code> -> runs <code>BulkAttachEvidence</code> returning summary. <br> 4. <code>fa.exportForensic --version v-2025-12-31 --evidence e-111,e-222 --operator compliance_mgr</code> -> runs <code>ExportEvidenceForensics</code> and returns <code>exportPath</code>, <code>exportHash</code>, <code>auditRef</code>. <br> Macros MUST present <code>errorCode</code> and remediation steps when failures occur and always include <code>auditRef</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Examples — extended end-to-end scenarios with edge cases and remediation</strong> <br> Example 1 — Statutory Tax Reconciliation (full, with remediation): <br> 1. Task <code>T-100</code> created with <code>evidenceRequirements = [taxReconPDF,signedManagerApproval]</code>, gatingCategory=critical. <br> 2. Accountant Alice runs <code>AttachEvidence</code> with local file -> computed checksum stored, <code>fa.evidence.attached</code> logged. <br> 3. Manager Bob attaches signed approval; <code>AttachEvidence</code> sets <code>evidenceCategory=signedForm</code>. <br> 4. PQ aggregates latest evidence rows; <code>TasksMaster</code> shows all required evidence attached. <br> 5. Manager records <code>RecordSignOff</code> via <code>modSignOff</code>. <br> 6. <code>AttemptClose</code> validates critical evidence and sign-off — close succeeds and <code>ChecklistVersionManifest</code> and <code>fa.checklist.closed</code> emitted. <br> Edge-case: If evidence came from DMS without provider checksum, <code>checksum=null</code> => <code>AttemptClose</code> blocks. Remediation: request DMS admin to provide platformChecksum or analyst to fetch and reupload locally to provide checksum; record compensating controls if using emergency override and log <code>overrideApprovalRef</code>. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Example 2 — Photo-based asset verification with EXIF and heuristics (explicit)</strong> <br> 1. Field team uploads photos to DMS with filenames and EXIF timestamps. <code>AttachEvidence</code> records pointer rows with <code>checksum=null</code> and <code>platformMetadata</code> including lastModified. <br> 2. PQ <code>HeuristicCandidates</code> suggests photos for asset task by token overlap and date proximity. <code>HeuristicMatches</code> rows created. <br> 3. Analyst resolves candidate via <code>ResolveHeuristicMatch(..., action=&#x27;attach&#x27;)</code>. <br> 4. Analyst runs <code>VerifyEvidence</code> which fetches image bytes, reads EXIF timestamp for corroboration, computes checksum and sets <code>evidenceStatus=&#x27;valid&#x27;</code>. <br> 5. Two-person approval required per <code>policySnapshot</code>; after second sign-off <code>AttemptClose</code> allows closure. <br> Remediation for mismatch: if recomputed checksum differs from provider checksum, create PQ fixity issue, escalate to DMS admin, and if necessary request reupload and attach local checksum. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Example 3 — DMS migration with canary and rollback (procedural)</strong> <br> 1. Create <code>migrationPlan</code> mapping oldUrls->newUrls, include <code>canarySet</code> of 50 items and <code>checksumPolicy</code> require recompute. <br> 2. Run <code>EvidenceMigration</code> on canary: <code>RebindEvidence</code> each item and recompute <code>evidenceRowChecksum</code> via <code>EvidenceRowChecksumRecompute</code> — produce <code>migrationManifest</code> with before/after checksums. <br> 3. If mismatches > threshold abort migration and run <code>rollbackPlan</code> and append <code>fa.evidence.migration.rollback</code>. <br> 4. If pass, proceed in batches and archive <code>migrationManifest</code> and <code>fa.evidence.migration</code> events for audit. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Acceptance criteria & release checklist (detailed)</strong> <br> Before production release ensure: <br> 1. Unit tests: <code>ComputeEvidenceChecksum</code>, <code>CanonicalizeText</code>, <code>AttachEvidence</code>, <code>VerifyEvidence</code>, <code>RebindEvidence</code> pass using golden fixture inputs. <br> 2. PQ parity: ingestion of fixtures produces expected <code>pqRunHash</code> and outputs. <br> 3. PDF generation: <code>GenerateChecklistPDF</code> produces manifest with <code>manifestHash</code> matching golden fixture expected value. <br> 4. Security review: confirm no credentials stored; macro signing and workbook ACLs configured. <br> 5. Performance: <code>BulkAttachEvidence</code> and nightly <code>EvidenceFixityCheck</code> meet SLAs. <br> 6. Operational runbooks accepted by operations and legal sign-off obtained for export/archive flows. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Deliverables available on request (pick one or more)</strong> <br> 1. Canonical JSON Schema for <code>SupportingDocument</code> and <code>evidenceRow</code> with exact serialization order and sample values for golden fixtures. <br> 2. Ready-to-paste VBA function stubs for every function above including deterministic return object contract and error codes (no implementation). <br> 3. Power Query named-step mapping document with narrative descriptions of each step and debugging suggestions. <br> 4. Three golden fixture CSVs (<code>fixture_small</code>,<code>fixture_mid</code>,<code>fixture_edge</code>) with sample rows and expected <code>evidenceRowChecksum</code> placeholders and manifest stubs for parity testing. <br> Indicate which artifact(s) you want produced next and they will be delivered as the follow-up output. </td></tr><tr><td data-label="modEvidence — Per-function Expert Technical Breakdown"> <strong>Final operational note (succinct, prescriptive)</strong> <br> Implement the canonicalization and checksum recipes exactly; preserve append-only metadata rows and audit events; ensure PQ is the only aggregator for UI and gating; require compliance approvals for exports/binaries; apply migration governance when changing canonicalization or hashing. Use the contracts in this document to create deterministic VBA stubs or server endpoints with parity across environments. </td></tr></tbody></table></div><div class="row-count">Rows: 43</div></div><div class="table-caption" id="Table4" data-table="Docu_0188_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modSignOff — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modSignOff — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Preface & intent (expanded):</strong> <br> This artifact transforms <code>modSignOff</code> from a conceptual module into a compliance-grade engineering blueprint. It defines every public function, preconditions, postconditions, side-effects, deterministic error codes, telemetry, audit events and retention behavior. The specification is intentionally prescriptive: canonicalization and checksum recipes are normative; changing them requires a documented <code>migrationManifest</code>. The module must be append-only, auditable, and deterministic; all mutative operations write an <code>AuditLog</code> entry with <code>correlationId</code> and comply with <code>policySnapshot</code> rules. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>High-level responsibilities (expanded):</strong> <br> 1. Record immutable sign-off entries for checklist tasks and persist authoritative metadata for legal admissibility. <br> 2. Validate signers and roles deterministically against <code>policySnapshot</code> and <code>OwnerAssignments</code>, supporting delegation and external approval tokens. <br> 3. Enforce two-person and sign-off time-window policies; flag and manage stale or cross-version sign-offs per policy. <br> 4. Compute and store per-row <code>signOffRowChecksum</code> using canonical serialization; support nightly parity verification. <br> 5. Provide read-back functions and bulk import/export flows with idempotency and forensic packaging capabilities. <br> 6. Support revocation/compensation via append-only revocation records; preserve chain-of-custody. <br> 7. Integrate with PQ for enrichment and reporting, and supply conceptual DAX measures for dashboards and alerting. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Scope & boundaries (expanded):</strong> <br> • In scope: all sign-off lifecycle operations, PQ view orchestration, audit export packaging, operator runbooks, error codes and diagnostics, and retention guidance. <br> • Out of scope: direct enforcement of IdP authentication flows beyond verifying identity assertions or tokens; storage of binary evidence contents (only metadata and checksums stored). <br> • Security boundary: workbook stores sign-off metadata and checksums only; evidence contents remain in external DMS with <code>SupportingDocuments.url</code> pointers. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Canonical SignOffEntry schema (detailed per-field narratives):</strong> <br> The canonical <code>SignOffEntry</code> row must include the following fields and semantics. Implementers must preserve field names exactly for PQ and checksum reproducibility. <br> <code>signOffId</code> — GUID. Narrative: generated by <code>modUtils.GenerateGUID()</code> at creation and never reused. This field is the stable identifier used across all audit artifacts. <br> <code>taskId</code> — foreign key to <code>YearEndTaskRow.taskId</code>. Narrative: mandatory for sign-offs attached to tasks; if a sign-off references a non-existent <code>taskId</code> operation must return <code>ERR_SIGNOFF_TASK_NOT_FOUND</code> and write a <code>fa.signoff.invalid_attempt</code> audit event. <br> <code>signedBy</code> — canonical user id (e.g., <code>U-ALICE</code> or <code>alice@org</code>). Narrative: must map to <code>OwnerAssignments.userId</code>. For external systems, a mapping table <code>ExternalUserMap</code> is used; unmapped signers must be rejected or queue for analyst reconciliation. <br> <code>signedRole</code> — canonical token (<code>owner|approver|manager|compliance|external</code>). Narrative: must be validated against <code>policySnapshot.roleSet</code>. Variants and synonyms must be normalized during validation. <br> <code>signedTs</code> — UTC timestamp <code>YYYY-MM-DDTHH:MM:SSZ</code>. Narrative: assigned by <code>modUtils.NowUTC()</code> at record time or taken from import if validated and permitted by policy. <br> <code>versionId</code> — <code>ChecklistVersionManifest.versionId</code> (nullable). Narrative: recommended to scope sign-offs to the manifest they apply to; if null, sign-off is considered cross-version and subject to <code>policySnapshot</code> cross-version rules. <br> <code>approvalRef</code> — optional opaque token for external approvals. Narrative: must be short pointer or hashed token; never store bearer tokens or credentials. <br> <code>comment</code> — free text (max 2000 chars). Narrative: preserved for audit; canonicalized before hashing. <br> <code>status</code> — <code>active | revoked | corrected | pending</code>. Narrative: default <code>active</code>; revocation does not delete original rows—revocation is stored as separate append entry. <br> <code>createdBy</code> — operator id that recorded the row. Narrative: can differ from <code>signedBy</code> when administrative recording occurs; must be stored for chain-of-custody. <br> <code>createdTs</code> — timestamp when row persisted. Narrative: use <code>modUtils.NowUTC()</code> and record the exact write time. <br> <code>signOffRowChecksum</code> — <code>sha256:</code> hex of canonical serialization (see recipe). Narrative: used for parity and tamper detection; recomputed in nightly parity processes and compared to stored value; mismatch emits <code>fa.verify.parity.failed</code>. <br> <code>correlationId</code> — workflow id to join multi-step activities (optional). Narrative: useful for correlating <code>RecordSignOff</code> with <code>GenerateChecklistPDF</code>, <code>AttemptClose</code>, or external approval flows. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Canonical serialization and checksum recipe (normative):</strong> <br> Purpose: produce deterministic bytes to compute <code>sha256</code> checksums. Implement exactly as specified. Changing recipe requires <code>migrationManifest</code>. Steps: <br> 1. Prepend <code>canonicalVersion</code> (string) — this must be included in every signature to allow versioned canonicalization. <br> 2. Field order (exact): <code>canonicalVersion|signOffId|taskId|signedBy|signedRole|signedTs|versionId|approvalRef|comment</code>. <br> 3. For textual fields apply <code>modUtils.CanonicalizeText</code> semantics: Unicode NFKC normalization, trim leading/trailing whitespace, collapse internal repeated whitespace to single spaces, normalize smart quotes and similar punctuation to ASCII equivalents, remove control characters, and casefold per locale rules (document locale used). <br> 4. For date/time fields apply <code>modUtils.FormatDateISO</code> to ensure <code>YYYY-MM-DDTHH:MM:SSZ</code> in UTC. <br> 5. Escape <code>|</code> characters inside fields as <code>\|</code>. Convert newline characters to <code>\n</code>. <br> 6. Concatenate fields with ASCII pipe <code>|</code> separators, encode bytes UTF-8, compute SHA-256, output lower-case hex and prefix with <code>sha256:</code>. <br> 7. Persist result into <code>signOffRowChecksum</code>. <br> Note: the canonicalization function must be identical across <code>modSignOff</code>, nightly parity jobs, and any server migrations to maintain manifest parity. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Deterministic error code taxonomy (reference & guidance):</strong> <br> 1. <code>ERR_SIGNOFF_TASK_NOT_FOUND</code> — <code>taskId</code> missing. <br> 2. <code>ERR_SIGNOFF_INVALID_ROLE</code> — <code>signedRole</code> not recognized in <code>policySnapshot.roleSet</code>. <br> 3. <code>ERR_SIGNOFF_UNAUTHORIZED</code> — signer lacks required role, delegation, or external token validation. <br> 4. <code>ERR_SIGNOFF_TIMEWINDOW_VIOLATION</code> — sign-off outside allowed <code>policySnapshot.signoffTimeWindow</code>. <br> 5. <code>ERR_SIGNOFF_DUPLICATE</code> — idempotency/externalId conflict or exact duplicate. <br> 6. <code>ERR_SIGNOFF_IO_FAIL</code> — workbook write failures after retries. <br> 7. <code>ERR_SIGNOFF_CHECKSUM_FAIL</code> — hashing/canonicalization failure. <br> 8. <code>ERR_SIGNOFF_REVOKE_PROHIBITED</code> — unauthorized revoke attempt. <br> 9. <code>ERR_SIGNOFF_IMPORT_INVALID</code> — invalid import row. <br> 10. <code>ERR_SIGNOFF_EXPORT_FAIL</code> — export/write failure. <br> 11. <code>ERR_SIGNOFF_MERGE_CONFLICT</code> — merge invariants violated. <br> Each error must be returned as structured object <code>{status:&quot;ERROR&quot;, errorCode:&quot;...&quot;, details:&quot;...&quot;, auditRef:&quot;&lt;eventId&gt;&quot;}</code> and every error scenario must write an <code>AuditLog</code> event with details for forensic trace. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Public API surface — function list & short summary (each expanded later):</strong> <br> 1. <code>RecordSignOff</code> — record validated sign-off (atomic, append-only). <br> 2. <code>ValidateSigner</code> — performs all policy and delegation checks deterministically. <br> 3. <code>ComputeSignOffRowChecksum</code> — canonical serialization and SHA-256 recipe. <br> 4. <code>QuerySignOffs</code> — filtered read-back with optional checksum validation and pagination. <br> 5. <code>GetTaskSignOffStatus</code> — computes coverage, missing roles, pending states for gating decisions. <br> 6. <code>RequireTwoPersonApproval</code> — deterministic evaluator for two-person rules. <br> 7. <code>RevokeSignOff</code> — append-only revocation record with authorization checks. <br> 8. <code>ExportSignOffRegistry</code> — produce signed, checksummed forensic bundles. <br> 9. <code>ReconcileSignOffsFromImport</code> — idempotent bulk import with validation. <br> 10. <code>ResolveStaleSignOffs</code> — detect & flag stale sign-offs outside windows. <br> 11. <code>NotifyPendingApprovers</code> — integration point for <code>modRemind</code>. <br> 12. <code>MergeSignOffs</code> — deterministic consolidation of duplicate sign-offs. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: RecordSignOff — full contract and operational flow (comprehensive):</strong> <br> <strong>Signature (conceptual):</strong> <code>RecordSignOff(taskId, signerId, signedRole, Optional approvalRef, Optional comment, Optional operatorId, Optional correlationId) -&gt; ResultObject</code> <br> <strong>Return structure:</strong> <code>{status:&quot;OK&quot;|&quot;ERROR&quot;, signOffId:GUID|null, signOffRowChecksum:String|null, auditRef:String, details:Object|null}</code> <br> <strong>Stepwise preconditions and validations (must be followed in order):</strong> <br> 1. Obtain workbook-level mutative lock (simple named mutex) to prevent concurrent writes. <br> 2. Verify <code>TasksMaster</code> PQ snapshot freshness or accept explicit operator override; if PQ stale return <code>ERR_PQ_STALE</code> with guidance to refresh PQ and link to <code>pqRunId</code>. <br> 3. Validate <code>taskId</code> exists; if not return <code>ERR_SIGNOFF_TASK_NOT_FOUND</code>. <br> 4. Validate <code>signedRole</code> exists in <code>policySnapshot.roleSet</code>; if not return <code>ERR_SIGNOFF_INVALID_ROLE</code>. <br> 5. Call <code>ValidateSigner(signerId, taskId, signedRole, policySnapshot)</code>; if unauthorized return <code>ERR_SIGNOFF_UNAUTHORIZED</code> with <code>reason</code> detail. <br> 6. Time-window check: confirm sign-off falls within <code>policySnapshot.signoffTimeWindow</code> relative to manifest <code>generatedTs</code> or <code>computedDueDate</code>; if outside window, return <code>ERR_SIGNOFF_TIMEWINDOW_VIOLATION</code> unless <code>policySnapshot.emergencyRules</code> authorizes override with recorded <code>overrideApprovalRef</code>. <br> <strong>Atomic append sequence (must be atomic or rolled back):</strong> <br> 1. Create <code>signOffId = modUtils.GenerateGUID()</code>. <br> 2. Set <code>signedTs = modUtils.NowUTC()</code> (or use supplied <code>signedTs</code> for imports, validated). <br> 3. Build sign-off canonical fields and compute <code>signOffRowChecksum = ComputeSignOffRowChecksum(row, canonicalVersion)</code>. <br> 4. Append to <code>SignOffEntries</code> table using atomic write sequence (write to staging sheet then move into live table). <br> 5. Update incremental task-level caches if enabled (e.g., update <code>TasksMaster.signOffCount</code> and <code>lastSignOffTs</code> for immediate UI responsiveness), or mark <code>TasksMaster</code> for PQ re-evaluation. <br> 6. Append <code>AuditLog</code> event <code>fa.signoff.recorded</code> via <code>modAudit.AppendAudit</code> with details: <code>signOffId</code>, <code>taskId</code>, <code>signedBy</code>, <code>signedRole</code>, <code>signedTs</code>, <code>versionId</code>, <code>correlationId</code>, and <code>operatorId</code>. <br> 7. Emit telemetry: <code>signoff.recorded.count</code> and <code>signoff.record.durationMs</code>. <br> <strong>Failure handling & retries:</strong> <br> • For IO errors, retry 3 times with exponential backoff (e.g., 200ms, 1s, 5s); if still failing append <code>fa.signoff.record.write_failed</code> and return <code>ERR_SIGNOFF_IO_FAIL</code>. <br> • If checksum compute fails unexpectedly, return <code>ERR_SIGNOFF_CHECKSUM_FAIL</code> and append <code>fa.signoff.checksum_failed</code> with raw canonical string included in secure diagnostics. <br> <strong>Postconditions:</strong> <br> • SignOffEntry persisted with <code>signOffRowChecksum</code>. <br> • <code>AuditLog</code> contains corresponding <code>fa.signoff.recorded</code> event with <code>auditRef</code>. <br> • Return object includes <code>signOffId</code>, <code>signOffRowChecksum</code>, and <code>auditRef</code>. <br> <strong>Examples:</strong> <br> • Happy path: <code>RecordSignOff(&quot;T-100&quot;,&quot;U-ALICE&quot;,&quot;owner&quot;,&quot;&quot;,&quot;Approved the reconciliation&quot;,&quot;alice&quot;,&quot;corr-2026-01&quot;)</code> returns <code>{status:&quot;OK&quot;, signOffId:&quot;s-0001&quot;, signOffRowChecksum:&quot;sha256:...&quot;, auditRef:&quot;ev-1000&quot;}</code>. <br> • Unauthorized: junior analyst attempts to sign as manager → returns <code>{status:&quot;ERROR&quot;, errorCode:&quot;ERR_SIGNOFF_UNAUTHORIZED&quot;, details:&quot;Signer lacks manager role&quot;, auditRef:&quot;ev-1001&quot;}</code>. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: ValidateSigner — full policy mapping & deterministic checks (complete):</strong> <br> <strong>Signature:</strong> <code>ValidateSigner(signerId, taskId, signedRole, policySnapshot) -&gt; {authorized:Bool, reason:String|null, delegated:Boolean, delegationRef:String|null}</code> <br> <strong>Detailed checks & steps (must be deterministic and logged):</strong> <br> 1. Resolve <code>signerRecord</code> from <code>OwnerAssignments</code>; if missing consult <code>ExternalUserMap</code>; if not resolvable, return <code>authorized=false</code> with <code>reason=UnknownSigner</code>. <br> 2. Retrieve task metadata from <code>TasksMaster</code>: <code>assignedOwnerId</code>, <code>department</code>, <code>priority</code>, <code>gatingCategory</code>, <code>estimatedImpact</code>. <br> 3. Compute required roles for the task by consulting <code>policySnapshot.approvalMatrix[(priority,gatingCategory)]</code> and evaluate <code>twoPerson</code> rules using <code>RequireTwoPersonApproval</code>. <br> 4. If <code>signedRole == &quot;owner&quot;</code> and <code>signerId == assignedOwnerId</code>, return authorized. <br> 5. If <code>signerRecord.roleMembership</code> includes <code>signedRole</code> within the task's department or assigned approvers list, return authorized. <br> 6. If <code>OwnerAssignments.delegations</code> exist and match task scope & not expired, return authorized with <code>delegated=true</code> and <code>delegationRef</code>. <br> 7. If <code>approvalRef</code> present and maps to validated external token in <code>ExternalApprovalRegistry</code> (cryptographically verifiable), map to <code>signedRole=external</code> and return authorized. <br> 8. Otherwise return <code>authorized=false</code> with <code>reason</code> containing required roles and contact suggestions. <br> <strong>Edge behaviors:</strong> <br> • Two-person requirement: <code>ValidateSigner</code> may return <code>authorized=true</code> for the first signer but include <code>note=RequiresSecondSignOff</code> to inform callers. <br> • Cross-version acceptance: if policy allows sign-offs from prior manifest within <code>signoffTimeWindow</code>, validate accordingly and return authorized if within window. <br> <strong>Audit:</strong> each <code>ValidateSigner</code> decision used by <code>RecordSignOff</code> must be included in <code>fa.signoff.recorded</code> <code>details</code> for traceability. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: ComputeSignOffRowChecksum — canonicalization rules & examples (complete):</strong> <br> <strong>Signature:</strong> <code>ComputeSignOffRowChecksum(signOffRow, canonicalVersion) -&gt; String</code> <br> <strong>Implementation notes:</strong> <br> 1. Apply <code>modUtils.CanonicalizeText</code> to textual fields: <code>signOffId</code> (string), <code>taskId</code>, <code>signedBy</code>, <code>signedRole</code>, <code>approvalRef</code>, <code>comment</code>. <br> 2. Format <code>signedTs</code> and <code>createdTs</code> using <code>modUtils.FormatDateISO</code> to <code>YYYY-MM-DDTHH:MM:SSZ</code>. <br> 3. Replace internal <code>|</code> with <code>\|</code> and newline with <code>\n</code>. <br> 4. Concatenate fields in the canonical order <code>canonicalVersion|signOffId|taskId|signedBy|signedRole|signedTs|versionId|approvalRef|comment</code>. <br> 5. Encode UTF-8 and compute SHA-256; return <code>sha256:</code> + lowercase hex string. <br> <strong>Example canonical string (human readable):</strong> <code>v1|s-111|T-100|alice|owner|2026-01-24T12:00:00Z|v-abc|appr-123|Approved\n</code> -> compute sha256. <br> <strong>Determinism note:</strong> the same inputs under same <code>canonicalVersion</code> must always yield identical checksum across environments; if a mismatch is observed, check <code>modUtils.CanonicalizeText</code> implementation and <code>canonicalVersion</code>. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: QuerySignOffs — readback, filters, pagination & forensic validation (complete):</strong> <br> <strong>Signature (conceptual):</strong> <code>QuerySignOffs(filters, includeChecksumValidation=False, pageSize=100, continuationToken=None) -&gt; {rows, nextToken}</code> <br> <strong>Supported filters:</strong> <code>taskId</code>, <code>signerId</code>, <code>signedRole</code>, <code>fromTs</code>, <code>toTs</code>, <code>versionId</code>, <code>status</code>, <code>correlationId</code>. <br> <strong>Behavioral details:</strong> <br> 1. Read-only operation; does not require mutative lock. <br> 2. If <code>includeChecksumValidation=True</code>, compute <code>ComputeSignOffRowChecksum</code> for each returned row and add <code>checksumOk</code> boolean and <code>computedChecksum</code> fields. Optionally include <code>canonicalString</code> in secure diagnostics if operator has compliance privileges. <br> 3. Support stable pagination via <code>pageSize</code> and <code>continuationToken</code> to avoid UI timeouts. <br> 4. Provide optional <code>exportFormat</code> parameter for large forensic exports to be passed to <code>ExportSignOffRegistry</code>. <br> 5. Access control: restrict <code>includeChecksumValidation</code> output to compliance roles since it can reveal canonical strings. <br> <strong>Return schema:</strong> each row includes full sign-off fields and additional diagnostics <code>checksumOk</code>, <code>computedChecksum</code> (if requested), and <code>rowSource</code> (e.g., <code>manual|import|api</code>). </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: GetTaskSignOffStatus — deterministic gating evaluator (complete):</strong> <br> <strong>Signature:</strong> <code>GetTaskSignOffStatus(taskId, Optional versionId) -&gt; {taskId, requiredRoles, signOffByRole, signOffCount, signOffComplete, missingRoles, signOffPending, lastSignOffTs, reasonCodes}</code> <br> <strong>Algorithm (step-by-step deterministic):</strong> <br> 1. Retrieve <code>taskRow</code> from <code>TasksMaster</code>. <br> 2. Determine <code>requiredRoles</code> via <code>policySnapshot.approvalMatrix</code> for <code>(priority,gatingCategory)</code> and apply <code>RequireTwoPersonApproval</code> to incorporate thresholds and taxonomy rules. <br> 3. Query <code>SignOffEntries</code> for <code>taskId</code> (filter by <code>versionId</code> if provided) and group by <code>signedRole</code>. <br> 4. For each role check counts and distinct <code>signedBy</code> if multiplicity required; treat revoked sign-offs as not active. <br> 5. Apply <code>signoffTimeWindow</code> filter: any sign-offs outside window are flagged stale; stale sign-offs may be treated as missing depending on <code>policySnapshot</code>. <br> 6. Set <code>signOffComplete = True</code> only if all required roles satisfied with valid <code>active</code> sign-offs and no stale/revoked entries block acceptance. <br> 7. Populate <code>reasonCodes</code> for remediation (e.g., <code>MissingRole:manager</code>, <code>StaleSignOff:owner</code>, <code>DuplicateSignOffs</code>). <br> <strong>Usage:</strong> <code>modGating.AttemptClose</code> must call this for each task to decide pass/fail deterministically. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: RequireTwoPersonApproval — deterministic rule evaluator (complete):</strong> <br> <strong>Signature:</strong> <code>RequireTwoPersonApproval(taskRow, policySnapshot) -&gt; {required:Bool, ruleId:String|null, rationale:String, requiredDistinctSignerCount:Int}</code> <br> <strong>Rule patterns (policySnapshot driven):</strong> <br> 1. Monetary threshold: if <code>taskRow.estimatedImpact &gt;= policySnapshot.twoPersonThresholds.amount</code> => <code>required=true</code> with <code>ruleId=&quot;TP_AMT&quot;</code>. <br> 2. Priority/gating rule: for <code>priority in [P0,P1]</code> and <code>gatingCategory=&quot;critical&quot;</code> => <code>required=true</code> with <code>ruleId=&quot;TP_PRI&quot;</code>. <br> 3. Taxonomy rule: specific <code>taskType</code> values map to two-person requirement (e.g., <code>statutory_filing</code>). <br> 4. Manual override table: <code>policySnapshot.overrideRules[taskId]</code> may disable/enable two-person for specific tasks with recorded rationale. <br> <strong>Deterministic return:</strong> always include <code>rationale</code> string and <code>requiredDistinctSignerCount</code> (commonly 2) to be stored in <code>AuditLog</code> when sign-offs recorded. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: RevokeSignOff — compensating append-only operation (complete):</strong> <br> <strong>Signature:</strong> <code>RevokeSignOff(signOffId, operatorId, reason, Optional replacementSignOffId) -&gt; {status, revokeEventId, auditRef}</code> <br> <strong>Behavior & constraints:</strong> <br> 1. Authorization: only roles listed in <code>policySnapshot.revocationRoles</code> (e.g., compliance/legal/admin) may revoke; if unauthorized return <code>ERR_SIGNOFF_REVOKE_PROHIBITED</code>. <br> 2. Create <code>SignOffRevocation</code> row with fields: <code>revocationId</code>, <code>targetSignOffId</code>, <code>revokedBy</code>, <code>revokedTs</code>, <code>reason</code>, <code>replacementSignOffId</code> (optional), <code>revokeRowChecksum</code>. <br> 3. Append <code>fa.signoff.revoked</code> to <code>AuditLog</code> with full context and <code>correlationId</code>. <br> 4. Do not delete the original sign-off row; mark it logically revoked in views and PQ via <code>SignOffRevocation</code> join. <br> 5. Update derived <code>TasksMaster</code> fields to recompute <code>signOffComplete</code> status (either incremental or next PQ run). <br> <strong>Forensics & policy:</strong> revocation must include operator justification and reference to any compensating evidence; revocation records are included in forensic bundles exported by <code>ExportSignOffRegistry</code>. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: ExportSignOffRegistry — forensic bundle composer (complete):</strong> <br> <strong>Signature:</strong> <code>ExportSignOffRegistry(versionId, outPath, operatorId, includeChecksums=True, signArtifact=True) -&gt; {status, exportPath, exportHash, auditRef}</code> <br> <strong>Export recipe (normative):</strong> <br> 1. Collect all sign-offs scoped to <code>versionId</code> and linked task rows. <br> 2. For each sign-off include full canonical fields plus <code>signOffRowChecksum</code> and <code>checksumOk</code> if recomputed. <br> 3. Build <code>manifest.json</code> containing <code>canonicalVersion</code>, <code>exportedBy</code>, <code>exportedTs</code>, <code>versionId</code>, <code>rowCount</code> and compute top-level <code>manifestHash</code> over canonical concatenation of per-row canonical strings. <br> 4. Package <code>signoffs.csv</code>, <code>manifest.json</code>, <code>auditlog_slice.json</code>, and <code>readme.txt</code> into a compressed archive. <br> 5. Optionally sign archive using org signing keys and include <code>signature.sig</code>. <br> 6. Persist atomically to <code>outPath</code> (write to temp file then move). <br> 7. Append <code>fa.signoff.exported</code> with <code>exportHash</code>, <code>exportPath</code>, operatorId and <code>auditRef</code>. <br> <strong>Security:</strong> ensure <code>outPath</code> is under preapproved archive root and restrict access to compliance roles. Exports are retained per legal retention policy and may be marked with <code>legalHold=true</code>. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: ReconcileSignOffsFromImport — robust bulk import (complete):</strong> <br> <strong>Signature:</strong> <code>ReconcileSignOffsFromImport(importRows, operatorId, Optional idempotencyKey) -&gt; {importId, summary, errors}</code> <br> <strong>Idempotency & validation rules:</strong> <br> 1. Each import row must include <code>externalId</code> (recommended), <code>taskId</code>, <code>signedBy</code>, <code>signedRole</code>, <code>signedTs</code>, <code>approvalRef</code> (if available). <br> 2. If <code>idempotencyKey</code> present and matches prior import, return prior summary to avoid duplicates. <br> 3. Validate rows in memory, produce <code>validationErrors[]</code> listing row index and reason before persisting any writes (preflight). <br> 4. Persist valid rows in transactional chunks (e.g., 200 rows per batch). For each persisted row call <code>RecordSignOff</code> wrapper to ensure canonical checksum, audit events and telemetry are produced. <br> 5. Collect per-row errors and continue; do not abort entire import on single row failure. <br> 6. Return summary with counts: <code>imported</code>, <code>skipped</code>, <code>errors</code>, and <code>importId</code>. Append <code>fa.signoff.imported</code> audit event. <br> <strong>Performance guidance:</strong> perform imports during off hours for large volumes and use chunking to avoid workbook locks causing timeouts. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: ResolveStaleSignOffs — detect, flag & propose remediation (complete):</strong> <br> <strong>Signature:</strong> <code>ResolveStaleSignOffs(versionId, policySnapshot, operatorId) -&gt; {staleList, suggestedActions}</code> <br> <strong>Behavior:</strong> <br> 1. Identify sign-offs outside <code>policySnapshot.signoffTimeWindow</code> relative to <code>version.generatedTs</code> or where <code>signOffRowChecksum</code> missing. <br> 2. For each flagged sign-off append <code>fa.signoff.staleDetected</code> AuditLog event containing <code>signOffId</code>, <code>taskId</code>, <code>signedBy</code>, <code>signedTs</code>, and <code>reason</code>. <br> 3. Suggest actions: <code>re-sign</code>, <code>accept-with-compensating-control</code>, <code>create-post-close-adjustment</code>. <br> 4. Optionally create <code>PostCloseAdjustment</code> tasks for high-severity stale items. <br> 5. Return structured <code>staleList</code> with remediation steps for operator review. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: NotifyPendingApprovers — integration for reminders & escalations (complete):</strong> <br> <strong>Signature:</strong> <code>NotifyPendingApprovers(taskIds, templateId, operatorId) -&gt; {sentCount, errors}</code> <br> <strong>Behavior & constraints:</strong> <br> 1. For each <code>taskId</code> compute <code>GetTaskSignOffStatus</code> and identify <code>missingRoles</code> and approver contact details via <code>OwnerAssignments</code>. <br> 2. Build templated tokens: <code>{OwnerName}</code>, <code>{TaskList}</code>, <code>{MissingRoles}</code>, <code>{ManifestLink}</code>, <code>{DueDate}</code> and substitute per recipient. <br> 3. Call <code>modRemind.SendReminder</code> to deliver messages (email or internal). Ensure messages avoid embedding raw PII unless recipient has <code>accessPolicy</code>. <br> 4. Append <code>fa.signoff.reminder.sent</code> events to <code>AuditLog</code> per recipient. <br> 5. Record <code>Telemetry.reminder.sent.count</code> and <code>reminder.failure.count</code>. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Function: MergeSignOffs — deterministic consolidation & invariants (complete):</strong> <br> <strong>Signature:</strong> <code>MergeSignOffs(primarySignOffId, secondarySignOffIds, operatorId, reason) -&gt; {status, mergedIds, auditRef}</code> <br> <strong>Rules & sequence:</strong> <br> 1. Validate <code>primarySignOffId</code> exists and that each <code>secondarySignOffId</code> maps to same <code>taskId</code> and <code>signedRole</code> or allowable compatible role per policy. If conflicts exist (different roles, different <code>signedBy</code> with conflicting timestamps) return <code>ERR_SIGNOFF_MERGE_CONFLICT</code>. <br> 2. Append <code>SignOffMerge</code> row recording <code>mergeId</code>, <code>primarySignOffId</code>, <code>secondarySignOffIds</code>, <code>mergedBy</code>, <code>mergedTs</code>, <code>reason</code>, <code>mergeRowChecksum</code>. <br> 3. Mark <code>secondary</code> rows as <code>deprecated=true</code> in logical view (do not delete), and record <code>fa.signoff.merge</code> AuditLog event. <br> 4. Recompute <code>TasksMaster</code> aggregates to reflect de-duplicated sign-off references. <br> 5. Preserve all original rows to support e-discovery and ensure merge operation is fully auditable. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Power Query (PQ) orchestration for sign-off enrichment — conceptual recipe (complete, no code):</strong> <br> PQ steps must be named and deterministic to allow for traceable reruns. PQ remains read-only and is the canonical aggregator for UI and gating views. Conceptual PQ pipeline: <br> 1. <strong>Source ingestion:</strong> load <code>SignOffEntries</code>, <code>SignOffRevocations</code>, <code>SignOffMerge</code>, <code>ChecklistVersionManifest</code>, <code>TasksMaster</code>, <code>OwnerAssignments</code>, and <code>PolicySnapshot</code> (single row). <br> 2. <strong>Normalization step:</strong> apply whitespace collapse, trimming and limited casefolding on text fields used for duplicates and joins (note PQ may not fully support Unicode NFKC; document differences and include <code>canonicalVersion</code> for parity). <br> 3. <strong>Join & enrichment:</strong> left-join sign-offs to tasks to compute <code>signOffCount</code>, <code>distinctSigners</code>, <code>signOffByRoles</code> aggregated as records, <code>lastSignOffTs</code>. <br> 4. <strong>Revocation & merge application:</strong> left-join revocation and merge tables to tag rows with <code>revokedFlag</code> and <code>deprecatedFlag</code>. Exclude revoked rows when computing <code>signOffComplete</code>. <br> 5. <strong>Scope by manifest:</strong> filter sign-offs by <code>versionId</code> to produce <code>SignOffByManifest</code> view. For cross-version rules include a controlled step referencing <code>policySnapshot.crossVersionAcceptance</code>. <br> 6. <strong>Derived flags & PQ_Issues:</strong> compute <code>staleFlag</code> for sign-offs outside <code>signoffTimeWindow</code>, <code>checksumMissing</code> if <code>signOffRowChecksum</code> null, <code>checksumCandidate</code> for parity candidates; produce <code>PQ_Issues_SignOff</code> entries for unknown signers, checksum absent, duplicate detection and ambiguous roles. Each PQ_Issue row must contain <code>issueId</code>, <code>issueType</code>, <code>entityRef</code>, <code>severity</code>, <code>details</code>, and <code>suggestedAction</code>. <br> 7. <strong>Outputs:</strong> <code>SignOffMasterView</code> (for dashboards), <code>SignOffByManifest</code> (for gating), <code>PQ_Issues_SignOff</code> (for analysts), and <code>SignOffParityCandidates</code> for nightly checksum validation. <br> Operational note: PQ should not perform cryptographic hash over files or binary content; use <code>modUtils</code> or external signed services for checksum operations when file content accessible. Keep named steps simple and expose final <code>issuesHash</code> to allow deterministic comparison between runs. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX measures & reporting patterns for sign-offs (complete, no code):</strong> <br> Implementers and report builders should model measures to reflect deterministic gating logic used by <code>GetTaskSignOffStatus</code>. Key conceptual measures and visual patterns: <br> 1. <code>SignOffRate</code> — ratio of tasks where <code>signOffComplete = True</code> to total tasks; slicers: department, owner, priority, manifest. <br> 2. <code>CriticalSignOffCoverage</code> — percent of <code>gatingCategory=critical</code> tasks with complete sign-offs; alert tile when below threshold. <br> 3. <code>TwoPersonComplianceRate</code> — percent of tasks requiring two persons that have two distinct signers recorded. <br> 4. <code>StaleSignOffCount</code> — count of sign-offs flagged stale by <code>ResolveStaleSignOffs</code>. <br> 5. <code>AvgTimeToSignOff</code> — average elapsed time from manifest <code>generatedTs</code> to <code>lastSignOffTs</code>. <br> 6. <code>SignOffThroughput</code> — time-series of sign-offs per day; useful to correlate with reminder sends. <br> 7. <code>ParityMismatchCount</code> — number of sign-offs with <code>checksumOk = False</code>; alert tile for compliance. <br> Visual patterns: sign-off registry grid with filter by manifest, owner heatmap for sign-off gaps, timeline showing sign-off velocity in close window and a parity tile showing manifests with verification issues. Ensure DAX replicates deterministic logic, especially two-person distinct signer counting and time-window enforcement. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Comprehensive worked examples & scenarios (expanded):</strong> <br> Example 1 — Statutory tax reconciliation (full E2E and audit packaging): <br> • Task: <code>TAX-STAT-2026</code> — <code>gatingCategory=critical</code>, <code>priority=P0</code>, <code>evidenceRequirements=[taxReconPdf, signedManagerApproval]</code>. <br> • Owner <code>U-ALICE</code> attaches <code>taxRecon.pdf</code> via <code>modEvidence.AttachEvidence</code> producing <code>evidenceId E-123</code> with checksum. <br> • <code>RecordSignOff(TAX-STAT-2026, U-ALICE, owner, approvalRef=appr-abc, comment=&quot;Reviewed&quot;, operatorId=&quot;alice&quot;, correlationId=&quot;corr-001&quot;)</code> creates <code>s-1001</code>. <br> • <code>RecordSignOff(TAX-STAT-2026, U-BOB, manager, approvalRef=appr-def, comment=&quot;Validated&quot;, operatorId=&quot;bob&quot;, correlationId=&quot;corr-002&quot;)</code> creates <code>s-1002</code>. <br> • <code>GetTaskSignOffStatus</code> returns <code>signOffComplete=true</code>. <code>GenerateChecklistPDF</code> persisted manifest <code>v-2026-12-31-1</code> referencing these sign-offs. <br> • <code>ExportSignOffRegistry(v-2026-12-31-1, outPath, operatorId=&quot;compliance&quot;)</code> packages <code>s-1001</code> and <code>s-1002</code> plus <code>manifest.json</code> and <code>auditlog_slice.json</code> with <code>manifestHash</code>. Archive is signed and moved to retention store. <br> Example 2 — Two-person distinct signer enforcement and edge-case: <br> • Task <code>ASSET-COUNT-A</code> flagged two-person. Owner <code>U-ALICE</code> attempts to sign both <code>owner</code> and <code>manager</code> roles. <br> • <code>ValidateSigner</code> rejects second sign-off for <code>U-ALICE</code> if policy requires distinct individuals and returns <code>ERR_SIGNOFF_UNAUTHORIZED</code>. If policy is soft-enforced it may accept with note <code>RequiresDistinctSigner</code>. <br> Example 3 — External approval token mapping: <br> • External auditor signs in external system and provides <code>approvalRef</code> token. <code>RecordSignOff</code> validates token via <code>ExternalApprovalRegistry</code> (signed token) and records <code>signedRole=external</code>. If token invalid, <code>ERR_SIGNOFF_UNAUTHORIZED</code>. <br> Example 4 — Import with idempotency: <br> • Bulk import CSV includes <code>externalId</code> for each row. <code>ReconcileSignOffsFromImport</code> uses <code>idempotencyKey=&quot;import-2026-01-24-1&quot;</code>. On second run with same key the import detects prior <code>importId</code> and short-circuits returning prior summary without duplication. <br> Example 5 — Revoke & replace flow: <br> • Sign-off <code>s-2000</code> found invalid. Compliance runs <code>RevokeSignOff(&quot;s-2000&quot;,&quot;U-COMP&quot;,&quot;Incorrect signer; replaced by s-2001&quot;,&quot;s-2001&quot;)</code>. <code>SignOffRevocation</code> row appended, <code>fa.signoff.revoked</code> event recorded, and <code>TasksMaster</code> updated so <code>s-2000</code> no longer contributes to <code>signOffComplete</code>. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Duplicate detection & merge flow for sign-offs (expanded):</strong> <br> Detection heuristics: <br> 1. Exact duplicates on <code>(taskId, signedBy, signedRole, signedTs)</code> => high-confidence duplicate. <br> 2. Tokenized fuzzy match on canonicalized <code>signedBy</code> variants (email aliases) within a small time window => probable duplicate. <br> 3. Matching external <code>externalId</code> from imports => idempotent duplicate detection. <br> Merge workflow: <br> 1. PQ emits <code>PossibleDuplicate</code> rows to <code>PQ_Issues_SignOff</code>. <br> 2. Analyst reviews and calls <code>MergeSignOffs(primary, secondaries, operatorId, reason)</code> which creates <code>SignOffMerge</code> audit entry and marks secondaries <code>deprecated=true</code> in views. <br> 3. Do not rewrite historic manifests; preserve original rows for forensic trace and include <code>SignOffMerge</code> in exported forensic bundles. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Ad-hoc intake & emergency overrides (policy & audit expanded):</strong> <br> Ad-hoc intake process: <br> 1. <code>AdhocRequests</code> table captures <code>adhocId, requestedBy, descriptionRaw, rationale, requestedDueDate</code>. <br> 2. Analyst triages and creates <code>YearEndTaskRow</code> with <code>taskSource=adhoc</code> and recommended <code>defaultOwnerId</code>. <br> Emergency override flow (strict audit trail): <br> 1. <code>policySnapshot.emergencyRules</code> enumerates who can override and the compensating controls required. <br> 2. Operator must record <code>overrideApprovalRef</code> and <code>overrideRationale</code> at time of override; <code>fa.checklist.override</code> and <code>fa.signoff.override</code> audit events recorded. <br> 3. Compensating controls (e.g., two independent post-close reviews) must be documented and evidence attached. Overrides must be time-boxed and flagged for compliance review. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Post-close adjustments, reopen & superseding manifests (detailed):</strong> <br> 1. Discovering an issue after close: create <code>PostCloseAdjustment</code> task referencing <code>closeEventId</code>. <br> 2. Obtain required approvals per <code>policySnapshot.twoPersonThresholds</code> and record them via <code>RecordSignOff</code>. <br> 3. <code>ReopenClose(closeId, operatorId, approvals[])</code> validates approvals, creates <code>reopenEvent</code>, marks previous <code>closeEvent</code> as <code>superseded</code> and produces <code>supersedingCloseId</code>. <br> 4. Archive both original and superseding manifests with clear <code>superseding</code> relation in archive metadata, and export forensic bundles for e-discovery. <br> 5. Ensure chain-of-custody preserved by exporting <code>AuditLog</code> slices covering both original and superseding manifests. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Observability, telemetry & alerting (exhaustive):</strong> <br> Metrics to record (examples): <br> 1. <code>signoff.recorded.count</code> by role and department. <br> 2. <code>signoff.record.durationMs</code> distribution and percentiles. <br> 3. <code>signoff.revoke.count</code> and <code>signoff.import.errors.count</code>. <br> 4. <code>signoff.checksum.mismatch.count</code> and <code>signoff.checksum.mismatch.perManifest</code>. <br> 5. <code>signoff.export.count</code> and <code>export.durationMs</code>. <br> Alerts and thresholds: <br> 1. <code>manifestParityFailure</code> — any manifest with <code>manifestHash</code> mismatch → severity High; immediate compliance notification. <br> 2. <code>criticalSignoffMissing</code> — <code>CriticalOpen &gt; 0</code> within 48 hours of <code>closeDate</code> → severity High. <br> 3. <code>twoPersonComplianceRate &lt; threshold</code> for critical tasks in 72 hours of close → severity High. <br> 4. <code>import.errorRate</code> above configured threshold → investigate importer mappings. <br> Implement telemetry via <code>Telemetry</code> sheet or push to external monitoring; ensure <code>AuditLog</code> includes event ids to reconcile metrics with audit trails. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Security, privacy & compliance controls (detailed):</strong> <br> 1. Never store authentication credentials, bearer tokens or secrets in <code>SignOffEntries</code>. Only store opaque approval pointers or hashed tokens in <code>approvalRef</code>. <br> 2. Access control: restrict exports, revocations and parity tools to compliance roles. <br> 3. Redaction: exported CSVs and PDFs must redact PII unless the recipient has explicit <code>accessPolicy</code>. Prefer embedding manifest/record pointers rather than raw evidence in distributed artifacts. <br> 4. Signing & integrity: sign exported forensic bundles and compute top-level <code>manifestHash</code>. <br> 5. Retention & legal hold: enforce retention policies and support <code>legalHold</code> flag which prevents deletion or modification of related artifacts. <br> 6. Macro signing: sign the workbook VBA project and restrict editing to authorized operators; maintain operator list in secure <code>Operators</code> table. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Testing & QA matrix (comprehensive):</strong> <br> Unit tests: <br> 1. <code>ComputeSignOffRowChecksum</code> must produce exact expected digest for three canonical fixtures (small, mid, edge). <br> 2. <code>ValidateSigner</code> tests: owner, approver, delegated approver, external token valid, unknown signer error. <br> 3. <code>RequireTwoPersonApproval</code> tests: monetary threshold, priority rule, taxonomy rule, override rule. <br> Integration tests: <br> 1. E2E: PQ ingest -> RecordSignOff -> GenerateChecklistPDF -> AttemptClose -> ExportSignOffRegistry -> Verify exportHash. <br> 2. Import tests: idempotencyKey duplication, partial failures reporting. <br> 3. Concurrency tests: simulate concurrent <code>RecordSignOff</code> attempts and confirm mutex prevents corruption. <br> Parity & regression tests: nightly parity recomputes <code>signOffRowChecksum</code> across manifests; expected zero mismatches for golden fixtures. <br> Performance tests: bulk import 5k+ sign-offs with chunking; measure throughput and memory; tune chunk sizes. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Operational runbooks & step checklists (detailed):</strong> <br> Pre-close readiness: <br> 1. Refresh PQ and run <code>SignOffMasterView</code> and <code>PQ_Issues_SignOff</code>. <br> 2. Remediate high-severity PQ_Issues (missing owner, checksum missing). <br> 3. Generate manifests for departmental scopes and distribute via <code>modChecklist.GenerateChecklistPDF</code>. <br> 4. Use <code>NotifyPendingApprovers</code> for reminders at T-14, T-7, T-3 days. <br> 5. Monitor <code>SignOffThroughput</code> and escalate via <code>modRemind</code> for delayed items. <br> 6. Attempt <code>modGating.AttemptClose</code> in staging and then production once all critical blocks resolved. <br> Emergency reopen runbook: <br> 1. Create <code>PostCloseAdjustment</code> and record rationale. <br> 2. Obtain required approvals and run <code>ReopenClose</code>. <br> 3. Archive both original and superseding manifests; update audit and notify compliance. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Migration & change governance (migrationManifest requirements):</strong> <br> For changes to canonicalization, <code>approvalMatrix</code>, or two-person thresholds, produce a <code>migrationManifest</code> containing: <code>migrationId</code>, <code>author</code>, <code>createdTs</code>, <code>changeRationale</code>, <code>affectedTaskIdsBeforeAfter</code>, <code>sampleFixturesBeforeAfter</code> with expected checksums, <code>canaryPlan</code>, <code>rollbackPlan</code>, and <code>approvals[]</code>. <br> Canary procedure: run change on non-critical cohort, validate parity checks for golden fixtures, collect KPI telemetry (critical open delta) and only promote once compliance approves. Do not silently change past manifest semantics; use <code>PostCloseAdjustment</code> for retroactive enforcement. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Diagnostics & forensic investigation procedures (explicit):</strong> <br> Parity mismatch investigation steps: <br> 1. Run <code>QuerySignOffs</code> with <code>includeChecksumValidation=True</code> for affected <code>versionId</code>. <br> 2. For mismatched rows, extract canonical string and recompute <code>ComputeSignOffRowChecksum</code> with matching <code>canonicalVersion</code>. <br> 3. Check <code>migrationManifest</code> for deliberate canonicalVersion changes; if present, follow migration reconciliation plan rather than treat as tamper. <br> 4. If no sanctioned migration, produce <code>ExportSignOffRegistry</code> forensic bundle and notify compliance; preserve original workbook file and evidence store under <code>legalHold</code>. <br> 5. Document findings in <code>AuditLog</code> with remediation actions. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Appendices — canonical orders and example canonical strings (normative):</strong> <br> Appendix A — canonical field order for sign-off hashing: <code>canonicalVersion|signOffId|taskId|signedBy|signedRole|signedTs|versionId|approvalRef|comment</code>. <br> Appendix B — example canonical string (human): <code>v1|s-111|T-100|alice|owner|2026-01-24T12:00:00Z|v-abc|appr-123|Approved\n</code> then compute SHA-256. <br> Appendix C — minimal JSON schema summary: <code>signOffId:string, taskId:string, signedBy:string, signedRole:string, signedTs:string, versionId?:string, approvalRef?:string, comment?:string, status:string, createdBy:string, createdTs:string, signOffRowChecksum:string, correlationId?:string</code>. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Acceptance criteria for <code>modSignOff</code> delivery (testable):</strong> <br> 1. <code>RecordSignOff</code> persists canonical rows with <code>signOffRowChecksum</code> computed per recipe, writes <code>fa.signoff.recorded</code> audit event, and returns structured success object. <br> 2. <code>ValidateSigner</code> enforces <code>policySnapshot</code> deterministically and returns auditable reasons for decisions. <br> 3. <code>QuerySignOffs</code> supports filters and optional checksum validation with pagination. <br> 4. <code>RevokeSignOff</code> appends revocation rows (no deletion) and updates derived state. <br> 5. <code>ExportSignOffRegistry</code> produces signed archive with <code>manifestHash</code> that verifies on recomputation. <br> 6. Nightly parity job yields zero mismatches on golden fixtures. </td></tr><tr><td data-label="modSignOff — Per-function Expert Technical Breakdown"> <strong>Next deliverables available on request (pick any):</strong> <br> 1. JSON Schema for <code>SignOffEntry</code> and <code>SignOffRevocation</code> with exact field types and string length limits. <br> 2. Ready-to-copy VBA function header stubs and XML documentation comments for every public function in <code>modSignOff</code> (no implementation). <br> 3. PQ named-step recipe mapping with intermediate sample row counts and representative <code>PQ_Issues</code> entries. <br> 4. Golden fixture CSV <code>fixture_signoffs_small</code> with canonical fields and expected <code>signOffRowChecksum</code> values for parity tests. <br> 5. Operator quick-reference checklist PDF template content for pre-close and reopen flows. <br> Indicate which artifact(s) you want and I will produce them immediately. </td></tr></tbody></table></div><div class="row-count">Rows: 34</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>