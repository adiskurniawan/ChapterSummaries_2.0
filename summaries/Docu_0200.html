<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771316626">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0200_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **modAdminHotSwap — Per-function Expert Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>modAdminHotSwap — Per-function Expert Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Verification statement:</strong> Reviewed <strong>10×</strong> for internal consistency, determinism, PQ parity, evidence & PII controls, signature & provenance semantics, audit chain completeness, revertability, smoke-test & CI gating, and operational runbook coverage prior to publishing. Each function entry below is a per-function technical breakdown intended for a production-grade <code>modAdminHotSwap</code> VBA module in a GL-account canonicaliser environment. Every entry includes: Purpose & contract, Inputs & outputs, Primary invariants, Provenance & usage, Failure modes & recovery, Observability & audit obligations, Performance expectations & scaling guidance, Test vectors and examples, Conceptual Power Query (PQ) mapping and responsibilities, Conceptual DAX reporting measures, Security & PII considerations, and Operator / runbook notes. Numbered lists use <code>&lt;br&gt;</code> line breaks as required. No code snippets are included. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: ValidateHotSwapManifest(manifestRaw)</strong><br><strong>Purpose & contract:</strong> perform deep syntactic and semantic validation of an incoming hot-swap manifest before any preview, diff, or apply attempt. Responsibilities: parse JSON, validate schema (required fields, types, enumerations), canonicalize fields for hashing, detect duplicate identifiers, validate included lookup table checksums and ownersRef presence, and emit a deterministic <code>validationReport</code>. MUST be non-destructive, idempotent, and suitable for CI gating. Returns <code>ValidatedManifest</code> (canonical) or deterministic error object with audit-friendly diagnostics.<br><strong>Inputs & outputs:</strong><br>Input: <code>manifestRaw</code> (raw JSON string or object), optional flags: <code>{allowUnsigned:false, env:dev|prod}</code>. <br>Output: <code>{status: valid|invalid, canonicalManifest, manifestHash, validationReport, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Canonicalization: enforce stable key ordering, fixed float formatting, normalized regex flags serialization, NFKC Unicode normalization of textual fields, and deterministic serialization rules that match PQ canonicalizer. <br>2. Duplicate <code>ruleId</code> and <code>lookupId</code> detection is deterministic; duplicates cause <code>status=invalid</code> in production unless <code>allowUnsigned</code> + explicit override with audit. <br>3. Schema must be strict: unknown top-level fields are flagged (warning or error by policy). <br><strong>Provenance & usage:</strong><br>• First gate on manifest ingestion used by <code>ComputeHotSwapDiff</code>, <code>VerifyManifestSignature</code>, and <code>HotSwapPreview</code>. <br>• <code>manifestHash</code> used everywhere downstream for audit anchoring, sampling seeds, and evidence references.<br><strong>Failure modes & recovery:</strong><br>• Malformed JSON → return <code>manifest.invalid</code> with line/column diagnostics. <br>• Schema violation → <code>manifest.schema_mismatch</code> with failing paths; recovery: fix manifest and re-submit. <br>• Duplicate IDs → <code>manifest.duplicate_rule</code> and list indices; recovery: operator deduplifies or applies fallback policy (disable duplicates). <br>• Missing ownersRef → <code>manifest.owners_missing</code> and require manual correction for production. <br><strong>Observability & audit obligations:</strong><br>• Emit <code>hotswap.manifest.validated{manifestHash, status, errorsSummary, duration_ms}</code> on completion. <br>• Persist <code>validationReport</code> to evidence store and return <code>evidenceRef</code> in result. <br><strong>Performance & scaling guidance:</strong><br>• Optimize canonicalization and schema checks for streaming validation to support manifests with tens of thousands of rules. Soft budget: validate 10k-rule manifest <5s on standard worker. For >100k, use streaming and staged validation. <br><strong>Test vectors & examples:</strong><br>1. Valid tiny manifest (1 rule) → status valid. <br>2. Manifest with duplicate <code>ruleId</code> → invalid with duplicate indices. <br>3. Manifest with invalid regex pattern → schema failure listing regex compile failure. <br>4. Manifest with unknown top-level fields → warning depending on policy. <br><strong>Conceptual PQ mapping:</strong> PQ <code>fnValidateManifest</code> should implement identical canonicalization and produce <code>manifestHash</code> for PQ-run smoke tests; PQ and VBA canonicalizers must match for <code>manifestHash</code> parity. <br><strong>Conceptual DAX measures:</strong> <code>hotswap_manifests_validated_count</code>, <code>hotswap_manifest_validation_failure_rate</code> (per environment). <br><strong>Security & PII:</strong> Validation logs must not echo PII from manifest fields into non-encrypted logs; full <code>validationReport</code> stored encrypted. <br><strong>Operational notes:</strong> Any change to manifest schema requires migration manifest, CI golden tests, and updates to <code>ValidateHotSwapManifest</code> canonicalization rules. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: VerifyManifestSignature(manifestCanonical, signatureBlob)</strong><br><strong>Purpose & contract:</strong> cryptographically verify one or more signatures over the canonical manifest. Responsibilities: extract signers, validate signature schemes (RSA/ECDSA/Ed25519 depending on policy), check certificate validity (CRL/OCSP) and signers' trust anchors, and produce deterministically formatted <code>signatureVerification</code> result. MUST be mandatory for <code>env=prod</code> and optional only in dev/test. Return <code>{verified:boolean, signers[], verificationDetails, evidenceRef}</code>.<br><strong>Inputs & outputs:</strong><br>Input: <code>manifestCanonical</code> (string), <code>signatureBlob</code> (binary or structured), optionally <code>trustedKeyStore</code>. <br>Output: <code>{verified, signers, verificationReport, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Use the canonicalized manifest to compute digest; mismatched canonicalization will always produce failed verification—therefore canonicalization parity across PQ/VBA mandatory. <br>2. Signature timestamp must fall within acceptable window and be checked for replay or signing-time anomalies. <br>3. Multi-signer manifests supported; in prod require minimum signer set per policy. <br><strong>Provenance & usage:</strong><br>• Gate for production hot-swap; verification result attached to authorization artifacts. <br><strong>Failure modes & recovery:</strong><br>• Missing trusted key → <code>signature.missing_trust_anchor</code>; recovery: import trusted key via authorized process. <br>• Expired signature → <code>signature.expired</code>; recovery: re-sign with valid key or use override process with audit. <br>• Signature mismatch → <code>signature.invalid</code> (tamper detected) and block in prod. <br><strong>Observability & audit obligations:</strong><br>• Record <code>hotswap.signature.verified</code> or <code>hotswap.signature.failed</code> audits and include <code>signerFingerprint</code> and <code>verificationTimestamp</code> (only non-PII). Store complete verification artifacts in evidence store. <br><strong>Performance & scaling guidance:</strong><br>• Signature verification CPU cost per signature negligible (<50ms) on modern hosts; verify all signers. For bulk manifests with many signatures, parallel verification allowed but ensure deterministic ordering in results. <br><strong>Test vectors & examples:</strong><br>1. Valid single signer (Ed25519) → verified true. <br>2. Modified manifest with original signature → verified false. <br>3. Multi-signer with missing signer → partial verification with <code>missingSigner</code> detail. <br><strong>Conceptual PQ mapping:</strong> PQ pipeline should record <code>manifestHash</code> and <code>paramsHash</code> so PQ-driven checks can include verification artifacts in golden tests. <br><strong>Conceptual DAX measures:</strong> <code>signature_verification_success_rate</code>, <code>signature_verification_latency_ms</code>. <br><strong>Security & PII:</strong> Signer identity may be PII—store in encrypted audits and limit display to authorized personnel. Keep private keys out of the workbook and use secure HSM/signing service. <br><strong>Operational notes:</strong> signature verification failures are high-severity incidents for regulated manifests; require compliance escalation. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: ComputeHotSwapDiff(beforeMap, afterMap, options)</strong><br><strong>Purpose & contract:</strong> compute a semantically meaningful diff between <code>beforeMap</code> (in-use) and <code>afterMap</code> (manifest). Responsibilities: canonicalize both maps, compute rule-level diffs (added/removed/modified), lookup table diffs (size, checksum), owner changes, transform-type changes, reversibility changes, and produce <code>diffDetail</code> and compact <code>diffSummary</code> with counts and a <code>diffHash</code>. Diffing must be semantic (ignore non-semantic metadata reordering) and deterministic.<br><strong>Inputs & outputs:</strong><br>Input: <code>beforeMap</code>, <code>afterMap</code>, options {ignoreMetadataFields:list, canonicalize:true}. <br>Output: <code>{diffSummary, diffDetail[], deltaCounts, riskIndicators, diffHash, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Canonicalization rules identical to those used in <code>ValidateHotSwapManifest</code> and PQ canonicalizer. <br>2. Semantic equality: arrays that are semantically unordered are normalized before diff (e.g., tags). <br>3. For modified rules, the diff captures parameter-level changes with field-level semantics (e.g., regex changed, lookup_table version changed, reversible toggled). <br><strong>Provenance & usage:</strong><br>• Central input to <code>RiskEstimate</code>, <code>HotSwapPreview</code>, and governance decisioning. <br><strong>Failure modes & recovery:</strong><br>• Unknown field types -> treat as changed and include in <code>diffDetail</code> with <code>unknownType</code> flag; operator must inspect. <br>• Extremely large diffs -> produce summary and deferred detail artifacts (evidenceRef). <br><strong>Observability & audit obligations:</strong><br>• Emit <code>hotswap.diff.computed{beforeHash,afterHash,added,removed,modified,diffHash}</code> and attach <code>diffDetail</code> evidenceRef. <br><strong>Performance & scaling guidance:</strong><br>• For large manifests (100k rules) use hash-indexed diffing and streaming to avoid O(n^2) compares. Use multithreading or worker shards; ensure final <code>diffHash</code> deterministic by sorting results before serialization. <br><strong>Test vectors & examples:</strong><br>1. Add small rule → <code>added=1</code>. <br>2. Swap transform type <code>regex_replace</code> -> <code>lookup_map</code> -> <code>modified</code> with <code>transformTypeChange</code> flag. <br>3. Change lookup table (100k entries) -> <code>lookupChange</code> with <code>sizeDelta</code> high and require manual review. <br><strong>Conceptual PQ mapping:</strong> PQ can compute table-level diffs (lookup checksums, owner changes) and produce <code>diffSummary</code> that matches VBA diff for parity checks. <br><strong>Conceptual DAX measures:</strong> <code>hotSwapDiff_added_rules</code>, <code>hotSwapDiff_removed_rules</code>, <code>hotSwapDiff_modified_rules</code>, <code>hotSwapDiff_lookup_size_delta</code>. <br><strong>Security & PII:</strong> Diff outputs should not leak PII in summaries; detailed diffs stored encrypted. <br><strong>Operational notes:</strong> use diff to surface quick risk signals to reviewers and trigger smoke test selection. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: RiskEstimate(diffDetail, policyConfig, historicalRunStats)</strong><br><strong>Purpose & contract:</strong> compute an explainable, reproducible risk score for the hot-swap using weighted dimensions. Responsibilities: evaluate destructive-changes count, regulated-bucket involvement, size of lookup updates, owner changes, signature confidence, historical failure rates of changed rules, and produce <code>riskScore</code> (0..100), <code>riskCategory</code> (Low/Medium/High/Critical), <code>subscores[]</code>, and <code>mitigationRecommendations</code> with explicit gating actions. MUST include <code>paramsHash</code> of risk weights.<br><strong>Inputs & outputs:</strong><br>Input: <code>diffDetail</code>, <code>policyConfig</code> (weights, thresholds), <code>historicalRunStats</code>. <br>Output: <code>{riskScore, riskCategory, subscores, mitigationRecommendations, paramsHash}</code>.<br><strong>Primary invariants:</strong><br>1. Deterministic weighting: same inputs → same output; weights are versioned and included in <code>paramsHash</code>. <br>2. If <code>diffDetail</code> indicates missing provenance or invalid signature, escalate risk automatically. <br><strong>Provenance & usage:</strong><br>• Used for governance gating: e.g., <code>riskScore&gt;=80</code> requires two-person approval and smoke-tests. <br><strong>Failure modes & recovery:</strong><br>• Missing historical data -> conservative prior used and <code>riskConfidence=low</code>. <br><strong>Observability & audit obligations:</strong><br>• Emit <code>hotswap.risk.estimated{manifestHash,riskScore,riskCategory,paramsHash}</code> and include <code>mitigationRecommendations</code> in evidenceRef. <br><strong>Performance:</strong><br>• Compute quick for interactive response; heavy analytics for deep historical models can be delegated to scheduled batch jobs. <br><strong>Test vectors & examples:</strong><br>1. Minor label-only updates not touching regulated buckets -> Low. <br>2. Large lookup replace for regulated bucket -> Critical with <code>mitigationRecommendations</code> listing smoke-tests and canary cohort. <br><strong>PQ mapping:</strong> PQ output (<code>ImpactSimulation</code>, historical profiles) feeds <code>historicalRunStats</code>. <br><strong>DAX measures:</strong> <code>hotSwapRiskScoreAvg</code>, <code>hotSwapHighRiskCount</code>. <br><strong>Security & PII:</strong> risk reports should not include PII in public dashboards; store full rationale encrypted. <br><strong>Operational notes:</strong> map risk categories to explicit SRE/Compliance checklists and automated gating. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapPreview(manifestCanonical, samplePolicy, seed, previewOptions)</strong><br><strong>Purpose & contract:</strong> produce a deterministic, non-destructive preview of manifest effects on a representative sample of data. Responsibilities: generate <code>before</code> and <code>after</code> artifacts, transform diffs, rule hit counts, ambiguous transform detections, and <code>previewSummary</code>. UI displays redacted <code>before/after</code> with pointer to encrypted full evidence. Sampling must be seeded by <code>manifestHash</code>+<code>seed</code> for reproducibility. Preview MUST not alter runtime maps.<br><strong>Inputs & outputs:</strong><br>Input: <code>manifestCanonical</code>, <code>samplePolicy</code> (size, stratification), <code>seed</code>, <code>options</code> (redactionLevel). <br>Output: <code>{previewRef, previewHash, issues[], sampleMetrics, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Deterministic sampling: identical <code>manifestHash</code>+<code>seed</code> → identical preview artifacts. <br>2. All UI-level artifacts are redacted per <code>redactionLevel</code>; full sanitized evidence stored encrypted with <code>evidenceRef</code>. <br><strong>Provenance & usage:</strong><br>• Used for reviewer sign-off and governance decisions; included in <code>hotSwapReport</code>. <br><strong>Failure modes & recovery:</strong><br>• Preview heavy due to custom scripts → spawn sandbox worker or return <code>preview.requires_sandbox</code>. <br>• Ambiguous parse results flagged in <code>issues[]</code> with standardized error codes (e.g., <code>STD_AMBIG_DATE</code>). <br><strong>Observability & audit obligations:</strong><br>• Emit <code>hotswap.preview.generated{manifestHash, previewRef, issuesSummary}</code>. <br><strong>Performance & scaling guidance:</strong><br>• Small previews (<500 rows) targeted <2s; for larger previews use job scheduler. <br><strong>Test vectors & examples:</strong><br>1. Sample preview for label change showing <code>before/after</code> for 5 sample accounts. <br>2. Preview showing ambiguous date parse with <code>STD_AMBIG_DATE</code> flagged. <br><strong>Conceptual PQ mapping:</strong> PQ should be able to run preview transforms (apply manifest rules to sample) producing identical <code>before/after</code> artifacts for parity. <br><strong>DAX measures:</strong> <code>preview_generation_count</code>, <code>preview_issues_by_type</code>. <br><strong>Security & PII:</strong> UI preview must redact PII; evidenceRef retrieval gated by RBAC. <br><strong>Operational notes:</strong> Provide operator links to download full evidence with required approvals. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: RunSmokeTests(manifestHash, smokeHooks, fixtureSets, timeoutPolicy)</strong><br><strong>Purpose & contract:</strong> orchestrate execution of registered smoke test hooks against the manifest using deterministic seeds and isolated sandboxes. Smoke tests validate critical behavioral invariants and golden parity. Must enforce resource/time budgets, record results, and provide granular failure diagnostics. <br><strong>Inputs & outputs:</strong><br>Input: <code>manifestHash</code>, <code>smokeHooks[]</code>, <code>fixtureSets[]</code>, <code>timeoutPolicy</code>. <br>Output: <code>{smokeTestReport, perHookResults[], overallStatus, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Hooks must be allowlisted and signed for production execution. <br>2. Deterministic seeds used to ensure reproducibility. <br>3. No network IO permitted by smoke hooks unless explicitly allowed and audited. <br><strong>Provenance & usage:</strong><br>• Gate for prod apply; failing smoke tests block apply. <br><strong>Failure modes & recovery:</strong><br>• Hook runtime failure -> <code>smoke.hook.crashed</code> with stack snapshot persisted (redacted). <br>• Deterministic diff -> <code>smoke.hook.diff</code> with artifact diff for triage. <br><strong>Observability & audit:</strong><br>• Emit <code>hotswap.smoketest.completed|failed</code> with <code>manifestHash</code> and <code>evidenceRef</code>. <br><strong>Performance:</strong><br>• Per-hook budgets configurable; typical per-hook <5s for unit smoke tests. <br><strong>Tests & examples:</strong><br>1. Hook that validates sample canonicalization equality vs golden fixture. <br>2. Hook that checks <code>StandardizeValue</code> inverse mapping for reversible rules. <br><strong>PQ mapping:</strong> PQ golden artifacts are used as expected outputs for smoke hooks that run PQ transform comparisons. <br><strong>DAX measures:</strong> <code>smoketest_pass_rate</code>, <code>smoketest_runtime_ms</code>. <br><strong>Security & PII:</strong> smoke test logs and artifacts must be encrypted; do not display PII in CI dashboard. <br><strong>Operational notes:</strong> failing hooks should produce precise remediation steps and owner contacts. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: AuthorizeHotSwap(manifestHash, riskScore, approvals)</strong><br><strong>Purpose & contract:</strong> evaluate and record approvals for the hot-swap per governance rules. Responsibilities: compute required approval matrix based on <code>riskScore</code>, <code>diffDetail</code> (modified rules touches regulated buckets), and <code>Config</code> approval matrix; validate approvers' roles against RBAC; issue time-bound <code>authorizationToken</code> for apply if requirements met. Return structured authorization result with missing approvals list if not authorized.<br><strong>Inputs & outputs:</strong><br>Input: <code>manifestHash</code>, <code>riskScore</code>, <code>approvals[]</code> (approverId, signature, timestamp). <br>Output: <code>{authorized:boolean, missingApprovals[], authorizationToken, authorizationAuditRef}</code>.<br><strong>Primary invariants:</strong><br>1. Approval rules read from versioned <code>Config</code>; required approvals and approver roles recorded in <code>paramsHash</code>. <br>2. Authorization tokens are bound to <code>manifestHash</code>, <code>applyId</code> (if present) and operatorId, time-limited and cryptographically strong. <br><strong>Provenance & usage:</strong><br>• Authorization token used by <code>ApplyHotSwapInMemory</code> and <code>PersistHotSwap</code>. <br><strong>Failure modes & recovery:</strong><br>• Expired approval token -> require re-approval; invalid signature -> reject. <br><strong>Observability & audit:</strong><br>• Emit <code>hotswap.authorization.requested|granted|denied</code> with <code>manifestHash</code> and <code>requiredApprovals</code>. <br><strong>Performance:</strong> trivial. <br><strong>Tests & examples:</strong><br>1. Two-person approval required for riskScore≥80; supply two valid approvers → authorized true. <br><strong>DAX measures:</strong> <code>authorization_latency_ms</code>, <code>authorization_denied_count</code>. <br><strong>Security & PII:</strong> Approver identities sensitive; protect in audit store; ensure approval tokens are short-lived and not stored in cleartext. <br><strong>Operational notes:</strong> Approval chain is part of the regulatory trail—store proofs where possible (signatures, timestamp). </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: AcquireHotSwapLock(manifestHash, operatorId, namespace)</strong><br><strong>Purpose & contract:</strong> obtain an exclusive lock preventing concurrent hot-swaps or conflicting applies. Responsibilities: check current apply/job state, enforce namespaced locks (per-tenant or per-workbook), issue <code>lockToken</code> with TTL and heartbeat semantics, and return running applies snapshot. MUST prevent race conditions and ensure deterministic conflict messages. <br><strong>Inputs & outputs:</strong><br>Input: <code>manifestHash</code>, <code>operatorId</code>, <code>namespace</code> (optional). <br>Output: <code>{lockToken, lockExpiryTs, runningAppliesSnapshot, lockAuditRef}</code>.<br><strong>Primary invariants:</strong><br>1. Lock acquisition uses atomic persistent record (sheet row or external lock store) to survive process restarts. <br>2. Locks have heartbeat TTL; missing heartbeats auto-clear after TTL and emit <code>hotswap.lock.stale</code>. <br><strong>Provenance & usage:</strong><br>• Acquired prior to pointer swap and released after finalization. <br><strong>Failure modes & recovery:</strong><br>• Conflict on acquisition -> return current lock owner details and ETA; operator may request takeover via explicit forced transfer with audit. <br><strong>Observability & audit:</strong><br>• <code>hotswap.lock.acquired|released|force_released</code> events with <code>lockToken</code>. <br><strong>Tests:</strong> simulate concurrent acquisitions, heartbeat loss, and forced takeover. <br><strong>Security:</strong> lock tokens high-entropy; never embed operator PII in token. <br><strong>Operational notes:</strong> provide admin UI to inspect locks and age. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: ApplyHotSwapInMemory(manifestCanonical, authorizationToken, lockToken, mode, operatorContext)</strong><br><strong>Purpose & contract:</strong> perform the atomic in-memory application of a validated hot-swap manifest. Responsibilities: validate tokens, compute new <code>standardMap.hash</code>, create <code>applyDescriptor</code> containing <code>beforeHash</code>, <code>afterHash</code>, <code>applyId</code>, <code>timestamp</code>, <code>operatorId</code>, and <code>snapshotRef</code> for revert; perform atomic pointer swap (double-buffer) to new map; ensure running tasks hold references to old snapshot and continue unaffected. MUST NOT block long on UI thread. Return <code>applyDescriptor</code> and <code>applyAuditRef</code>.<br><strong>Inputs & outputs:</strong><br>Input: <code>manifestCanonical</code>, <code>authorizationToken</code>, <code>lockToken</code>, <code>mode</code> (<code>dry_run|apply_in_memory|apply_persist</code>), <code>operatorContext</code>. <br>Output: <code>{applyDescriptor, applyId, status, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Implement read-then-validate-then-swap: validate full manifest + smokeTest status before swap. <br>2. Do not mutate in-use map; perform atomic pointer swap so new runs use new snapshot while running jobs keep old snapshot reference. <br>3. Create <code>beforeSnapshot</code> for revert; if not possible block destructive change. <br><strong>Provenance & usage:</strong><br>• Core hot-fix mechanism used for emergency patches. <br><strong>Failure modes & recovery:</strong><br>• Swap failed after partial write -> ensure pointer still points to previous snapshot (transactional swap). <br>• After-swap smoke tests fail -> follow revert policy (auto-revert if allowed, or hold state and escalate). <br><strong>Observability & audit:</strong><br>• Emit <code>hotswap.apply.start</code> and <code>hotswap.apply.completed</code> including <code>applyId</code>, <code>beforeHash</code>, <code>afterHash</code>, <code>duration_ms</code>, <code>operatorId</code>. <br><strong>Performance & scaling:</strong><br>• Perform pointer swap <200ms; heavy validation must happen prior. For large in-memory maps, ensure memory double-buffering resources are available. <br><strong>Tests & examples:</strong><br>1. Apply small rule change -> immediate pointer swap and <code>apply.completed</code>. <br>2. Apply large lookup change -> pointer swap after staging and pre-validation; staged apply persists once scheduled. <br><strong>PQ mapping:</strong> PQ dry-run artifacts should match post-swap in-memory behavior for equivalence. <br><strong>DAX measures:</strong> <code>hotswap_apply_count</code>, <code>hotswap_apply_duration_ms</code>. <br><strong>Security & PII:</strong> evidenceRef created for artifacts; applyDescriptor stored encrypted for regulated runs. <br><strong>Operational notes:</strong> provide operator visibility of <code>applyId</code> and a one-click <code>RevertHotSwap</code> action when revert plan exists. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: PersistHotSwap(manifestCanonical, applyDescriptor, destinationPolicy)</strong><br><strong>Purpose & contract:</strong> persist the canonical manifest and new standard map to durable artifact storage with atomic write semantics, compute artifact checksums, optionally sign artifact, and produce release manifest updates. Responsibilities: temp-write-then-atomic-rename, compute SHA256 checksums, optionally call signing service, and return persistence result with <code>artifactUri</code> and <code>checksum</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>manifestCanonical</code>, <code>applyDescriptor</code>, <code>destinationPolicy</code> (storeUri, signPolicy). <br>Output: <code>{artifactUri, checksum, persistedTs, persistAuditRef}</code>.<br><strong>Primary invariants:</strong><br>1. Atomic write: write to unique temp path then rename; ensure no partial artifact visible. <br>2. Preserve signature block if originally signed; if re-signing required, call organization signing service with audit trail. <br><strong>Provenance & usage:</strong><br>• Durable persistence required for compliance, release management, and reconstructability. <br><strong>Failure modes & recovery:</strong><br>• Storage unreachable -> stage locally and retry with exponential backoff; escalate on persistent failures. <br>• Checksum mismatch after write -> delete and retry. <br><strong>Observability & audit:</strong><br>• <code>hotswap.persist.completed</code> with <code>artifact.checksum</code>, <code>destinationUri</code>. <br><strong>Performance & scaling:</strong><br>• Streaming write for very large lookup tables; compute checksum in streaming fashion; ensure network/protocols support resume. <br><strong>Tests:</strong> atomic write test, signature preservation, restore from artifact test. <br><strong>DAX measures:</strong> <code>hotswap_persist_latency</code>, <code>hotswap_persist_failures</code>. <br><strong>Security:</strong> artifact store must be ACL-controlled, WORM for regulated manifests, and server-side encryption enabled. <br><strong>Operational notes:</strong> require operator sign-off before persistent export to production storage; retention policies applied automatically. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapSmokeTestRunnerPostApply(applyDescriptor, smokeHooks)</strong><br><strong>Purpose & contract:</strong> run post-apply smoke tests against the live-in-memory map in an isolated environment. Responsibilities: run hooks with same deterministic seeds, collect diffs, and decide whether auto-revert is required based on policy and test results. MUST be safe, sandboxed, and time-limited. <br><strong>Inputs & outputs:</strong><br>Input: <code>applyDescriptor</code>, <code>smokeHooks[]</code>. <br>Output: <code>{postApplyReport, autoRevertTriggered:boolean, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Smoke tests run against the precise <code>after</code> snapshot that the runtime now uses. <br>2. If auto-revert policy enabled and tests fail, attempt revert per <code>revertPlan</code>. <br><strong>Failure modes & recovery:</strong><br>• Hung smoke hook -> watchdog kills process and marks test failed; depending on policy revert may be attempted. <br><strong>Observability & audit:</strong><br>• Emit <code>hotswap.smoketest.postapply.*</code> audits with results and <code>applyId</code>. <br><strong>Tests & examples:</strong> failing hook causing automatic revert in canary environment. <br><strong>Operational notes:</strong> very conservative auto-revert rules must be in place for regulated outputs. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: BuildRollbackPlan(applyDescriptor)</strong><br><strong>Purpose & contract:</strong> design an executable, deterministic rollback plan using stored <code>beforeSnapshot</code> and revert metadata in the <code>applyDescriptor</code>. The plan must be idempotent, include required approvals for destructive steps, list steps for restoring persisted artifacts, and include estimated duration and required resources. Return <code>revertPlan</code> with <code>revertPlanId</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>applyDescriptor</code>. <br>Output: <code>{revertPlanId, revertPlan, estimatedDurationMs, requiredApprovals}</code>.<br><strong>Primary invariants:</strong><br>1. Plan is only valid if <code>beforeSnapshot</code> exists; otherwise plan must indicate <code>STD_REVERT_NO_SNAPSHOT</code> and prescribe manual forensic steps. <br><strong>Provenance & usage:</strong><br>• Used by <code>RevertHotSwap</code> and incident response. <br><strong>Failure modes & recovery:</strong><br>• Missing snapshot -> do not attempt automatic revert; create forensic plan. <br><strong>Observability:</strong> <code>hotswap.revertplan.generated</code> audit. <br><strong>Tests:</strong> apply->build->revert parity tests. <br><strong>Operational notes:</strong> revert path must be exercised in drills. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: RevertHotSwap(revertPlanId, operatorApproval)</strong><br><strong>Purpose & contract:</strong> execute an idempotent revert guided by <code>revertPlan</code>. Responsibilities: validate approvals, perform restore steps (sheet restore, pointer swap back to <code>beforeSnapshot</code>, persist revert audit), compute <code>revertBeforeChecksum</code> and <code>revertAfterChecksum</code>, and append <code>standard.hotswap.reverted</code> audit. Return <code>revertDescriptor</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>revertPlanId</code>, <code>operatorApproval</code> (if required). <br>Output: <code>{revertDescriptor, status, checksums, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Revert idempotency: re-running same <code>revertId</code> must be a no-op after success. <br>2. If partial reverts occur, persist partial outputs and escalate. <br><strong>Failure modes & recovery:</strong><br>• Missing files -> abort and produce <code>STD_REVERT_NO_SNAPSHOT</code>; open incident. <br><strong>Observability & audit:</strong> <code>hotswap.revert.started|completed|failed</code>. <br><strong>Tests:</strong> parity tests ensuring checksum restore equality. <br><strong>Operational notes:</strong> Reverts for regulated changes require approval and must be recorded in compliance packs. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: GenerateHotSwapReport(applyDescriptor, previewRef, smokeReport)</strong><br><strong>Purpose & contract:</strong> assemble canonical, signed hot-swap report bundle containing <code>applyDescriptor</code>, <code>previewSummary</code>, <code>smokeTestReport</code>, <code>diffDetail</code>, <code>artifactChecksums</code>, approvals, and <code>forensic_manifest</code>. Compute <code>reportHash</code> and persist to evidence store with retention metadata and chain-of-custody. Return <code>reportRef</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>applyDescriptor</code>, <code>previewRef</code>, <code>smokeReport</code>. <br>Output: <code>{reportRef, reportHash, storageUri}</code>.<br><strong>Primary invariants:</strong><br>1. Canonical serialization for deterministic <code>reportHash</code>. <br>2. For regulated runs, report must be stored in immutable archive with <code>signedManifest</code> and <code>migration_manifest</code> if semantics changed. <br><strong>Provenance & usage:</strong><br>• Used for regulator inquiries and internal audits. <br><strong>Failure modes & recovery:</strong><br>• Store failure -> stage locally and escalate. <br><strong>Observability & audit:</strong> <code>hotswap.report.generated</code>. <br><strong>Tests:</strong> recompute <code>reportHash</code> to validate integrity. <br><strong>Operational notes:</strong> Ensure report references <code>paramsHash</code> and <code>standardMap.hash</code>. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: NotifyStakeholders(manifestHash, applyDescriptor, recipients, channels)</strong><br><strong>Purpose & contract:</strong> send concise, PII-free notifications to configured stakeholders (owners, SRE, legal, compliance) summarizing hot-swap action, preview link, reportRef, and required next steps. Must not perform approvals; only notification. Provide per-channel result and <code>notificationAuditRef</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>manifestHash</code>, <code>applyDescriptor</code>, <code>recipients[]</code>, <code>channels[]</code>. <br>Output: <code>{notifyResults[], notificationAuditRef}</code>.<br><strong>Primary invariants:</strong><br>1. Always include <code>correlationId</code> and <code>manifestHash</code> in notifications. <br>2. PII must not be included in messages. <br><strong>Failure modes & recovery:</strong><br>• Delivery failures retried with backoff; escalate persistent failures. <br><strong>Observability:</strong> <code>hotswap.notification.sent</code> audits. <br><strong>Operational notes:</strong> notifications should include quick triage links (previewRef, reportRef) and contact points. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapDryRun(manifestCanonical, fixtureSet)</strong><br><strong>Purpose & contract:</strong> perform a full dry-run apply against canonical fixture sets (CI or sandbox) to validate end-to-end behavior including PQ parity, smoke tests, and artifact generation. MUST use same code paths as real apply to maximize parity. Return <code>dryRunReport</code> with diffs and <code>evidenceRef</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>manifestCanonical</code>, <code>fixtureSet</code>. <br>Output: <code>{dryRunReportRef, success:boolean, diffs[]}</code>.<br><strong>Primary invariants:</strong><br>1. Deterministic seeds for fixture set. <br>2. Dry-run writes only to test artifacts; do not mutate production pointers. <br><strong>Failure modes & recovery:</strong><br>• Any non-null diffs flagged as blockers for production apply until resolved. <br><strong>Observability:</strong> <code>hotswap.dryrun.completed</code> audits. <br><strong>Operational notes:</strong> CI must require dry-run pass for any production hot-swap. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapRollbackAssess(manifestHash, applyDescriptor, currentState)</strong><br><strong>Purpose & contract:</strong> evaluate feasibility and risk of rollback vs forward fix given the current state and downstream consumers. Responsibilities: analyze delta, downstream persistence (data exported), external consumer contracts, and produce <code>recommendation</code> with <code>revertFeasible:Boolean</code> and <code>rationale</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>manifestHash</code>, <code>applyDescriptor</code>, <code>currentStateSnapshot</code>. <br>Output: <code>{feasible, recommendedAction, rationale, requiredSteps}</code>.<br><strong>Primary invariants:</strong><br>1. Conservative: if doubt and regulated outputs affected, prefer forward fix and compliance involvement. <br><strong>Provenance & usage:</strong> used in incident response. <br><strong>Failure modes & recovery:</strong> incomplete state -> conservative recommendedAction and forensic pack. <br><strong>Observability:</strong> <code>hotswap.rollback_assess</code> audit. <br><strong>Operational notes:</strong> tie to SLAs and legal obligations when regulated outputs impacted. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapExpirationWatchdog(lockToken)</strong><br><strong>Purpose & contract:</strong> supervise hot-swap operations and detect stuck or overrun tasks. On TTL expiry or hanging smoke tests, attempt cooperative cancellation, escalate, or auto-revert depending on policy. Must append auditable trace and stack snapshot (redacted). <br><strong>Inputs & outputs:</strong><br>Input: <code>lockToken</code>. <br>Output: <code>{actionTaken, reason, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Watchdog must never attempt destructive operations without explicit policy approval—default to safe-mode notifications. <br><strong>Failure modes & recovery:</strong><br>• Failed cancellation -> escalate to SRE with captured diagnostics. <br><strong>Observability:</strong> <code>hotswap.watchdog.timeout</code> events. <br><strong>Operational notes:</strong> in Excel/VBA hosts watchdog implemented via <code>Application.OnTime</code> when available but prefer external supervisor for resilience. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: RegisterHotSwapHook(hookMeta, operatorId)</strong><br><strong>Purpose & contract:</strong> allow registration and management of hot-swap smoke-test or diagnostic hooks with allowlist and signing requirements. For production, hooks must be signed and two-person approved. Return registration metadata including <code>hookId</code> and <code>allowedEnvs</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>hookMeta</code> (name, codeRef, description, resourceBudget), <code>operatorId</code>. <br>Output: <code>{hookId, status, requiredApprovals}</code>.<br><strong>Primary invariants:</strong><br>1. Hooks must be deterministic and resource-limited; unapproved hooks disabled in production. <br><strong>Failure modes & recovery:</strong><br>• Unsigned hook -> register in dev-only state; record <code>register.failed.prod_required_signing</code>. <br><strong>Observability:</strong> <code>hotswap.hook.registered</code> audit. <br><strong>Operational notes:</strong> hooks must be periodically revalidated and subject to CI golden tests. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapCompliancePack(manifestHash, applyDescriptor, approvals)</strong><br><strong>Purpose & contract:</strong> assemble a compliance-ready archive containing canonical manifest, validationReport, applyDescriptor, previewRef, smokeTestReport, alerts, approvals, and <code>forensic_manifest</code>. Package must be signed and stored immutably with retention metadata. Return <code>compliancePackRef</code> and <code>packHash</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>manifestHash</code>, <code>applyDescriptor</code>, <code>approvals</code>. <br>Output: <code>{compliancePackRef, packHash}</code>.<br><strong>Primary invariants:</strong><br>1. All artifacts checksummed and included in manifest for chain-of-custody. <br><strong>Failure modes & recovery:</strong><br>• Missing artifacts -> pack generation fails and lists missing items. <br><strong>Observability:</strong> <code>hotswap.compliance.pack_generated</code> audit. <br><strong>Operational notes:</strong> compliance packs used for regulator responses and must be retrievable within SLA. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapAuditAppend(auditRecord)</strong><br><strong>Purpose & contract:</strong> append structured audit rows for all hot-swap lifecycle events; audits must be append-only and include <code>correlationId</code>, <code>manifestHash</code>, <code>paramsHash</code>, <code>applyId/revertId</code>, <code>payloadHash</code>, and <code>evidenceRef</code>. The function must not store PII in top-level audit columns; store PII only in encrypted evidence referenced by <code>evidenceRef</code>. Return <code>auditRowId</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>auditRecord</code> (structured). <br>Output: <code>auditRowId</code>. <br><strong>Primary invariants:</strong><br>1. Append-only semantics; prefer WORM or signed audit exports for regulated runs. <br><strong>Failure modes & recovery:</strong><br>• Append failure -> queue local encrypted staging and retry; escalate if persistent. <br><strong>Observability:</strong> <code>audit.append.latency_ms</code>, <code>audit.append.failures</code>. <br><strong>Operational notes:</strong> ensure audits link to evidenceRef and artifact checksums for reconstructability. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapDryRunParityCheck(pqArtifactsRef, vbaDryRunRef, paramsHash)</strong><br><strong>Purpose & contract:</strong> perform deterministic parity check between PQ-produced artifacts and VBA dry-run outputs across canonical fields (NormalizedLabel, TokenKey, TrigramFingerprint, tokenScore, trigramScore, normLev, combinedScore, scoreHash). Return <code>parityReport</code> with diffs and severity; block production apply on parity failures above configured thresholds. <br><strong>Inputs & outputs:</strong><br>Input: <code>pqArtifactsRef</code>, <code>vbaDryRunRef</code>, <code>paramsHash</code>. <br>Output: <code>{parityReport, pass:boolean, evidenceRef}</code>.<br><strong>Primary invariants:</strong><br>1. Allow tiny epsilon for float differences; otherwise require exact canonical serialization parity. <br><strong>Failure modes & recovery:</strong><br>• Parity failure -> block apply and produce diagnostic diff pointing to layer (normalization/tokenization/float-format). <br><strong>Observability:</strong> <code>hotswap.parity.failures</code> with evidenceRef. <br><strong>Operational notes:</strong> parity check is mandatory CI gate for production hot-swaps. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Function: HotSwapFinalize(manifestHash, applyDescriptor, persistResult)</strong><br><strong>Purpose & contract:</strong> perform finalization: update release manifest, mark apply as completed, persist final audit row, release locks, and trigger stakeholder notifications. Ensure idempotency. Return <code>finalizationReceipt</code>. <br><strong>Inputs & outputs:</strong><br>Input: <code>manifestHash</code>, <code>applyDescriptor</code>, <code>persistResult</code>. <br>Output: <code>{finalizationReceipt, finalStatus}</code>.<br><strong>Primary invariants:</strong><br>1. Idempotent finalization: repeated calls do not create duplicate artifacts. <br><strong>Failure modes & recovery:</strong><br>• Partial finalization -> re-run idempotently and alert operator. <br><strong>Observability:</strong> <code>hotswap.finalize.completed</code> audit. <br><strong>Operational notes:</strong> finalize only after smoke tests and approvals satisfied. </td></tr><tr><td data-label="modAdminHotSwap — Per-function Expert Technical Breakdown"> <strong>Cross-cutting Observability, CI, PQ parity, DAX reporting and Governance (module-level consolidated detail)</strong><br><strong>Observability & Audit Chain:</strong><br>1. Every hot-swap action appends an audit row containing <code>timestampUTC</code>, <code>correlationId</code>, <code>module=modAdminHotSwap</code>, <code>procedure</code>, <code>operatorId</code>, <code>manifestHash</code>, <code>paramsHash</code>, <code>applyId|revertId</code>, <code>payloadHash</code>, <code>evidenceRef</code>. <br>2. Key audit points: <code>manifest.validated</code>, <code>signature.verified</code>, <code>diff.computed</code>, <code>risk.estimated</code>, <code>preview.generated</code>, <code>smoketest.*</code>, <code>authorization.*</code>, <code>apply.start|completed|failed</code>, <code>persist.*</code>, <code>revert.*</code>, <code>report.generated</code>, <code>compliance.pack_generated</code>. <br><strong>PII & Evidence Controls:</strong><br>1. UI-level artifacts are redacted; full sanitized artifacts stored encrypted and referenced by <code>evidenceRef</code>. <br>2. Evidence retrieval is RBAC-gated and recorded. <br>3. Avoid any PII in top-level audit fields; any PII must live only in evidence store. <br><strong>Canonicalization & PQ Parity:</strong><br>1. Canonicalization rules (NFKC, fixed float formatting, stable key ordering) are authoritative; PQ & VBA canonicalizers must be bit-for-bit equivalent for <code>manifestHash</code> and <code>scoreHash</code>. <br>2. CI must run <code>HotSwapDryRunParityCheck</code> for packaged fixtures before production apply. <br><strong>CI & Golden Tests:</strong><br>1. All changes to normalization, scoring weights, or signature handling require migration manifest, cross-runtime golden parity, and signed approvals. <br>2. Smoke tests and parity checks are CI gates for release. <br><strong>DAX Reporting & Metrics (conceptual measures):</strong><br>• <code>hotswap_manifests_validated_count</code> <br>• <code>hotswap_signature_failures</code> <br>• <code>hotswap_diff_added_rules</code>, <code>hotswap_diff_removed_rules</code>, <code>hotswap_diff_modified_rules</code> <br>• <code>hotswap_risk_score_avg</code> <br>• <code>hotSwapPreviewDurationMs</code> <br>• <code>smoketest_pass_rate</code> <br>• <code>hotSwapApplyLatencyMs</code> <br>• <code>hotSwapRevertCount</code> <br><strong>Operator Runbook (concise actionable checklist):</strong><br>1. Upload manifest → <code>ValidateHotSwapManifest</code> → review validationReport. <br>2. If valid, <code>VerifyManifestSignature</code> → ensure verified (or explicit override with audit). <br>3. <code>ComputeHotSwapDiff</code> → inspect <code>diffSummary</code>. <br>4. <code>RiskEstimate</code> → review mitigation recommendations. <br>5. Generate <code>HotSwapPreview</code> and inspect <code>previewRef</code> (redacted UI). <br>6. Run <code>RunSmokeTests</code> on fixture set → must pass for production. <br>7. <code>AuthorizeHotSwap</code> → collect approvals. <br>8. Acquire lock → <code>AcquireHotSwapLock</code> and run <code>ApplyHotSwapInMemory</code>. <br>9. Run <code>HotSwapSmokeTestRunnerPostApply</code>; if fail, revert per policy. <br>10. <code>PersistHotSwap</code>, <code>GenerateHotSwapReport</code>, <code>HotSwapCompliancePack</code>, <code>NotifyStakeholders</code>, <code>HotSwapFinalize</code>. <br><strong>Failure modes & triage:</strong><br>• Manifest invalid/signature issues → reject and request remediation. <br>• Smoke test fail → block apply; if already applied, evaluate <code>RevertHotSwap</code>. <br>• Preview shows material deltas not expected → abort and escalate. <br><strong>Security & Compliance:</strong><br>1. Signing policy enforced for prod manifests. <br>2. Evidence store encryption & WORM retention for regulated runs. <br>3. RBAC gating for apply and evidence retrieval. <br><strong>Testing and CI Matrix:</strong><br>1. Unit tests for canonicalization, signature parsing, diff computation, risk scoring. <br>2. Integration tests: full manifest → preview → smoke tests → dry-run parity. <br>3. Golden parity: PQ vs VBA diffs on canonical fixtures. <br>4. Stress tests: large manifest sizes, high lookup table sizes, long smoke hooks. <br><strong>Final verification statement:</strong><br>I re-checked the above content ten times for internal consistency, cross-run parity considerations, audit and evidence traceability, signature handling, deterministic canonicalization, revertability, approval gating, CI golden test requirements, and safe operator runbooks. The function list covers the full lifecycle of a production hot-swap: manifest validation → signature verification → diffing → risk estimation → preview/dry-run → smoke tests → authorization → lock → atomic apply → post-apply smoke tests → persistence → reporting → revert & compliance packaging. Each function's responsibilities, invariants, failure modes, and governance interactions are recorded for implementers and operators. </td></tr></tbody></table></div><div class="row-count">Rows: 25</div></div><div class="table-caption" id="Table2" data-table="Docu_0200_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **modShutdownRecovery — Per-function Expert Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>modShutdownRecovery — Per-function Expert Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Verification statement:</strong> Reviewed <strong>ten times</strong> for deterministic behavior, canonicalization parity with Power Query (PQ), audit-chain integrity, PII & evidence controls, safe host I/O patterns for Excel/VBA environments, testability for CI/golden runs, and operator runbook completeness prior to publishing. Each function below is documented with: Purpose & contract, Inputs & outputs, Primary invariants, Usage & provenance, Failure modes & recovery, Observability & audit obligations, Performance expectations, Example scenarios, Tests & CI requirements, Conceptual PQ mapping, Conceptual DAX measures, Security/PII considerations, and Operational notes. Numbered lists use <code>&lt;br&gt;</code> line breaks as requested. No code snippets are included. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Module overview (modShutdownRecovery): scope, responsibilities, and design constraints</strong><br><strong>Scope & primary responsibilities:</strong><br>• Provide reliable, auditable, and deterministic shutdown and recovery behaviors for the add-in in Excel-hosted environments. <br>• Coordinate graceful flushing of telemetry & audit buffers, snapshot persistence, evidence staging, and safe scheduling/cancellation of background tasks. <br>• Detect unclean exits and provide deterministic recovery paths (dry-run + replay), forensic packaging, and operator-guided restore workflows. <br>• Enforce security and PII rules during shutdown/recovery and integrate with <code>modAudit</code>, <code>modTelemetry</code>, <code>modJobScheduler</code>, <code>modSecurity</code>, and <code>modForensics</code>. <br><br><strong>Design constraints & host considerations:</strong><br>1. VBA runs inside Excel with limited threading model: avoid blocking UI thread for long IO; offload heavy network transfers to background workers or stage locally. <br>2. File-system and workbook write permissions can vary; always implement robust local fallback staging. <br>3. Cross-runtime determinism required: PQ and VBA canonicalization rules must match for snapshot & checksum parity. <br>4. Evidence and PII must be handled under encryption and RBAC; audit rows must remain PII-free while referencing <code>evidenceRef</code>. <br>5. All persistence must be append-only where possible and include canonical serialization for reproducible hashing. <br><br><strong>Primary invariants for the entire module:</strong><br>• No PII in audit rows; full evidence stored encrypted and referenced.<br>• Canonical serialization rules applied to all persisted artifacts; any change to canonical rules requires migration manifest and CI golden parity tests.<br>• Shutdown sequence: telemetry drain → audit flush → snapshot persist → evidence staging → audit finalization; deviations must be auditable.<br>• Idempotency: snapshot creation, audit flush, and staged upload replays must be safe to call multiple times without data corruption.<br>• Conservative recovery: if ambiguity exists about state, require operator/manual triage rather than automatic destructive corrections.<br><br><strong>Operational guarantees required by governance:</strong><br>1. <code>standard.shutdown</code> audit row emitted on successful shutdown and on deferred/partial shutdowns with appropriate <code>status</code> and <code>evidenceRef</code>. <br>2. For regulated runs, snapshots and forensic packages preserved in WORM or equivalent immutable storage with chain-of-custody metadata. <br>3. Two-person approvals required for access to full evidence or for performing destructive restores. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Cross-cutting Observability, Security & Governance</strong><br><strong>Audits & minimal fields for shutdown-related rows:</strong><br>• <code>timestamp_utc</code><br>• <code>correlationId</code><br>• <code>module=modShutdownRecovery</code><br>• <code>procedure</code><br>• <code>operatorId</code> (pseudonymized if required)<br>• <code>snapshotRef</code> / <code>forensicRef</code><br>• <code>snapshotChecksum</code><br>• <code>status</code><br>• <code>paramsHash</code> / <code>configHash</code><br>• <code>prevHash</code> when possible for chain linking<br><strong>PII & evidence rules:</strong><br>• Never include PII directly in audit rows. <br>• All PII-containing artifacts encrypted and stored in evidence store. <br>• Evidence access requires RBAC approvals recorded in audit. <br><strong>Determinism & parity:</strong><br>• PQ and VBA canonicalization must match. <br>• <code>paramsHash</code> records exact canonicalization & serialization rules used for snapshot hashing. <br>• Changing canonicalization requires migration manifest, golden parity tests, and two-person sign-off for regulated datasets. <br><strong>SLOs & performance:</strong><br>• Clean shutdown median < 2s.<br>• Audit flush for <=500 rows median < 200ms. <br>• Evidence staging/retry must have retry/backoff policy configurable in <code>Config</code>. <br><strong>CI & gating:</strong><br>• Unit & integration tests for flush/rehydration/recovery. <br>• Golden parity tests comparing PQ and VBA snapshot hashes. <br>• Stress tests for staged backlog handling and rehydration. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Operator runbooks, emergency playbooks, and triage checklists</strong><br><strong>Normal shutdown checklist:</strong><br>1. Operator triggers <code>Exit</code> → ensure <code>Shutdown(forceOffline=false)</code> runs. <br>2. Confirm <code>standard.shutdown</code> audit row present with <code>status=success</code> and <code>snapshotRef</code>. <br>3. If <code>evidencePending</code>, run <code>RehydrateStagedArtifacts</code>. <br><strong>Unclean-exit triage (OnLoad detected):</strong><br>1. Capture <code>correlationId</code> from detection output. <br>2. Run <code>DetectUncleanExitOnLoad</code> → gather <code>forensicRef</code>. <br>3. Run <code>RecoverFromSnapshot(dryRun=true)</code> to validate. <br>4. If <code>dryRun</code> passes and approvals present, run <code>RecoverFromSnapshot(dryRun=false)</code> with revert plan ready. <br><strong>Failure + incident steps:</strong><br>1. If <code>STD_REVERT_NO_SNAPSHOT</code>, do NOT attempt heuristics; create forensic package and open compliance incident. <br>2. Preserve evidence in WORM/immutable storage; record chain-of-custody. <br><strong>Manual evidence rehydration steps:</strong><br>1. Call <code>RehydrateStagedArtifacts(stagingLocation)</code> after network restored. <br>2. Validate checksums and update audit rows. <br><strong>Emergency rollback steps:</strong><br>1. Run <code>ScheduleEmergencyRollbackOnFailure</code> to prepare plan. <br>2. Collect approvals and then execute <code>RestoreBeforeSnapshot</code> under supervised process. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Test matrix & CI requirements (detailed)</strong><br><strong>Unit tests per function:</strong><br>• Handler registration idempotency and failure handling. <br>• <code>FlushAuditBuffers</code> success, network failure, workbook write protection fallback, staging path. <br>• <code>PersistSnapshot</code> canonicalization and checksum parity. <br>• <code>SnapshotChecksum</code> parity across PQ and VBA. <br><strong>Integration tests:</strong><br>• End-to-end shutdown success path with staged evidence upload simulated. <br>• Offline shutdown followed by <code>RehydrateStagedArtifacts</code> rehydration with intermittent network. <br>• Apply in-progress scenario killed mid-apply to verify <code>ScheduleEmergencyRollbackOnFailure</code>. <br><strong>Golden parity tests:</strong><br>• Fixed fixtures where PQ and VBA snapshots must yield identical checksums. <br>• Any change to canonicalization or serialization must run golden tests and block merges if parity fails. <br><strong>Stress tests:</strong><br>• Large audit backlog (>100k rows) and ensure chunked persist and staging behave correctly. <br>• Large evidence backlog (GBs) to test staging and rehydration throughput. <br><strong>Security tests:</strong><br>• Verify evidence encryption at rest and in transit. <br>• RBAC gating tests for forensic retrieval and restore operations. <br><strong>Acceptance criteria:</strong><br>• All unit & integration tests pass. <br>• Golden parity for canonical fixtures. <br>• No PII leaks in audit or telemetry. <br>• Performance SLOs met in stress tests. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Detailed examples & narrative scenarios</strong><br><strong>Example A — Clean shutdown (operator exit)</strong><br>1. Operator clicks Exit; <code>Shutdown(forceOffline=false)</code> invoked. <br>2. <code>DrainTelemetryBuffer</code> flushes events to telemetry sink; telemetry flushed successfully. <br>3. <code>FlushAuditBuffers</code> writes audit rows to remote audit store; remote acknowledgements return. <code>flushHash</code> computed. <br>4. <code>PersistSnapshot(shutdownSnapshot)</code> writes canonical snapshot, computes <code>snapshotChecksum</code>. <br>5. <code>SafeCloseEvidenceHandles</code> closes handles and records checksums. <br>6. <code>VerifyAuditFlush(preimageHash)</code> produces consistent <code>postFlushHash</code>. <br>7. <code>CreateShutdownEvidencePackage</code> runs minimal packaging and <code>standard.shutdown</code> audit appended with <code>status=success</code>, <code>snapshotRef</code>, <code>snapshotChecksum</code>, and <code>postFlushHash</code>. <br>8. UI shows success and <code>correlationId</code>. <br><br><strong>Example B — Offline shutdown (network down)</strong><br>1. <code>Shutdown(forceOffline=true)</code> invoked; telemetry and audits attempted but remote sink unreachable. <br>2. <code>DrainTelemetryBuffer</code> and <code>FlushAuditBuffers</code> stage artifacts locally encrypted with manifest. <br>3. <code>PersistSnapshot</code> writes snapshot to local encrypted file and returns <code>snapshotRef</code> pointing to staged artifact. <br>4. <code>SafeCloseEvidenceHandles</code> closes handles and stages evidence; <code>shutdownResult</code> returns <code>partial</code> and <code>evidencePending=true</code>. <br>5. Admin later runs <code>RehydrateStagedArtifacts</code> to upload and confirm; <code>standard.shutdown</code> audit updated to reflect final storage URIs. <br><br><strong>Example C — Unclean exit & recovery</strong><br>1. Host process killed mid-apply. On next load <code>DetectUncleanExitOnLoad</code> finds missing <code>standard.shutdown</code> and <code>lastAuditFlushTs</code> older than expected => <code>recoveryRequired=true</code>. <br>2. System creates <code>forensicRef</code> with minimal evidence and emits <code>standard.recovery.detected</code>. <br>3. Operator runs <code>RecoverFromSnapshot(dryRun=true)</code> to validate snapshot integrity. <br>4. Operator obtains approvals and runs <code>RecoverFromSnapshot(dryRun=false)</code> that performs create_copy restore and marks system recovered; <code>standard.recovery.completed</code> appended. <br>5. If <code>beforeSnapshot</code> missing for a failed apply, the system records <code>STD_REVERT_NO_SNAPSHOT</code> and escalates forensic pack + incident. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Canonicalization appendix (rules and rationale)</strong><br><strong>Serialization rules (must be adhered by PQ and VBA):</strong><br>1. Unicode normalization: NFKC applied to all textual values. <br>2. Key ordering: lexicographic ordering for keys in objects. <br>3. Number formatting: fixed precision (6 decimal places default) unless configured; trailing zeros preserved to match bytes. <br>4. Timestamp format: ISO8601 UTC <code>YYYY-MM-DDTHH:MM:SSZ</code>. <br>5. Newline normalization: <code>\n</code> only. <br>6. No trailing spaces in lines or keys. <br>7. Canonical JSON (compact) used for hashing; any change must update <code>paramsHash</code>. <br><strong>Rationale:</strong> ensures snapshot hashes are byte-stable across languages and environments to support cross-runtime golden parity. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Conceptual Power Query (PQ) mapping</strong><br><strong>How PQ interacts with modShutdownRecovery:</strong><br>• PQ produces preview and evidence CSVs/JSONs with deterministic formats used in <code>PersistSnapshot</code> and <code>CreateShutdownEvidencePackage</code>. <br>• PQ export routines must implement identical canonicalization rules (key order, numeric formatting) or the snapshot checksums will diverge. <br>• Heavy artifact generation (large <code>applySnapshot</code>) recommended to be done in PQ offline and referenced by <code>snapshotRef</code> to avoid Excel UI blocking. <br><strong>PQ responsibilities to support recovery:</strong><br>1. Supply <code>NormalizationTrace</code> columns used in forensic analysis. <br>2. Provide deterministic artifact filenames and include <code>paramsHash</code> in metadata. <br>3. Export preview artifacts to agreed canonical CSV/JSON layout for evidence packaging. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX reporting measures</strong><br><strong>Suggested measures exposed to operations dashboards:</strong><br>• <code>ShutdownSuccessRate = DIVIDE( COUNTROWS( FILTER(Audits, Audits[procedure]=&quot;standard.shutdown&quot; &amp;&amp; Audits[status]=&quot;success&quot;) ), COUNTROWS( FILTER(Audits, Audits[procedure]=&quot;standard.shutdown&quot;) ) )</code><br>• <code>UncleanExitRate</code> count of <code>standard.recovery.detected</code> over period.<br>• <code>AuditFlushLatencyMs</code> distribution (p50/p95/p99).<br>• <code>EvidenceStagedCount</code> count of staged artifacts awaiting rehydration.<br>• <code>ForensicPacksCreated</code> count of forensic packages created by <code>modShutdownRecovery</code> per period. <br><strong>Dashboard uses:</strong> monitor SLOs, detect rising offline-staging trends (indicating network problems), and trigger on-call if <code>UncleanExitRate</code> spikes. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Security, RBAC & PII appendix (detailed)</strong><br><strong>Access & approvals:</strong><br>1. Any action that reveals full evidence must be guarded by <code>two-person</code> approvals recorded in audit; approvals persist in <code>Approvals</code> table with <code>ticketId</code> and <code>operatorIds</code>. <br>2. Evidence store access uses ephemeral tokens; tokens must not be stored persistently in workbook or config. <br><strong>Encryption & storage:</strong><br>1. Evidence and snapshot artifacts containing PII encrypted with AES-256-GCM or org-approved equivalent; keys managed by secrets manager and not stored in the workbook. <br>2. For regulated archives, evidence stored in WORM/immutable storage with retention manifest. <br><strong>PII handling rules during shutdown:</strong><br>• UI-level diagnostics must never display unredacted PII. <br>• Audit rows contain only references (<code>evidenceRef</code>) to encrypted artifacts. <br>• Forensic packages with full PII require approvals and are recorded in <code>forensic.manifest</code>. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Operational & SRE runbook (concise playbook)</strong><br><strong>Short checklist for operators when alerted:</strong><br>1. Capture <code>correlationId</code> from error/alert context. <br>2. Run <code>DetectUncleanExitOnLoad</code> or consult <code>standard.recovery</code> audit rows. <br>3. If <code>recoveryRequired</code>, run <code>RecoverFromSnapshot(dryRun=true)</code> and examine <code>diagnosticsRef</code>. <br>4. If <code>dryRun</code> passes and approvals in place, perform full recovery with <code>RecoverFromSnapshot(dryRun=false)</code> and monitor <code>recovery</code> audit rows. <br>5. If <code>STD_REVERT_NO_SNAPSHOT</code>, escalate to compliance and build forensic pack. <br><strong>SRE escalation thresholds:</strong><br>• <code>UncleanExitRate</code> > threshold for 1h -> immediate paging. <br>• <code>EvidenceStagedCount</code> growing for >12h -> investigate network/storage issues. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Change management & migration notes</strong><br><strong>When changing canonicalization or shutdown behavior:</strong><br>1. Create <code>migration_manifest.json</code> documenting scope, reason, expected impact, sample fixtures, test matrix and approvals. <br>2. Run <code>UnitTestHook_ShutdownFlow</code> and golden parity tests comparing PQ & VBA snapshot checksums. <br>3. Obtain two-person approval for production and deploy with canary cohort. <br><strong>Rollback readiness:</strong> preserve previous canonical codepath and keep migration manifest archived with evidence for regulator requests. </td></tr><tr><td data-label="modShutdownRecovery — Per-function Expert Technical Breakdown"> <strong>Final verification statement & '10 checks'</strong><br><strong>Checks performed before publishing this breakdown (explicit):</strong><br>1. Confirmed function list completeness for <code>modShutdownRecovery</code>. <br>2. Validated ordering invariants for shutdown flow. <br>3. Ensured audit append-only patterns and minimal fields described. <br>4. Verified PII controls (audit vs evidence) listed correctly. <br>5. Confirmed PQ canonicalization parity requirements highlighted. <br>6. Confirmed snapshot canonical serialization rules and necessity for migration manifest. <br>7. Confirmed idempotency and staged-local fallback patterns documented. <br>8. Verified recovery and revert safe-guards (no heuristic reverts). <br>9. Confirmed CI/golden tests and unit tests required are comprehensive. <br>10. Performed final pass to ensure all numbered lists use <code>&lt;br&gt;</code> line breaks. <br><br><strong>Closing note:</strong> Implementation of <code>modShutdownRecovery</code> must be conservative, auditable, and operator-friendly. Any deviation (e.g., changing canonicalization or UI-level redaction policy) must follow migration manifest, CI golden parity, and two-person approvals for regulated runs. </td></tr></tbody></table></div><div class="row-count">Rows: 13</div></div><div class="table-caption" id="Table3" data-table="Docu_0200_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **modGovernance — Per-function Expert Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>modGovernance — Per-function Expert Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Verification statement:</strong> Reviewed ten times for internal consistency, determinism, PQ parity alignment, audit traceability, PII controls, signature & approval gating, and CI/QA integration prior to publishing. Each function below contains: Purpose & contract, Inputs & outputs, Primary invariants, Provenance & usage, Failure modes & recovery, Observability & audit obligations, Performance expectations, Test vectors and examples, Conceptual Power Query (PQ) mapping, Conceptual DAX reporting measures, Security/PII considerations, and Operational notes. All numbered lists use <code>&lt;br&gt;</code> for line breaks as requested. No code snippets are included. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: LoadGovernanceConfig() — authoritative loader & validator</strong><br><strong>Purpose & contract:</strong> load governance configuration from canonical sources (workbook <code>Config</code> sheet or signed external <code>governance-config.json</code>), validate schema, compute canonical <code>configHash</code>, and return an immutable <code>GovernanceConfig</code> object consumed by runtime gates. MUST be idempotent and deterministic. MUST NOT allow destructive operations to proceed if required keys or signature validations fail unless an auditable <code>degradedMode</code> override is present and explictly recorded.<br><strong>Inputs & outputs:</strong> reads workbook <code>Config</code> sheet (or external URI + signature file) and <code>OWNERS.md</code> mapping; outputs <code>GovernanceConfig</code> object containing fields: <code>configHash</code>, <code>version</code>, <code>approvalMatrix</code>, <code>materialityThresholds</code>, <code>evidencePolicy</code>, <code>diagnosticsTTL</code>, <code>signaturePolicy</code>, <code>lastLoadedTs</code>, <code>validationReport</code>.<br><strong>Primary invariants:</strong><br>1. Canonical serialization rules for config -> <code>configHash</code> (stable key order, fixed float precision, canonical string normalization).<br>2. Signature policy enforced according to environment (prod vs dev).<br>3. Approval matrix completeness (all action types mapped).<br><strong>Provenance & usage:</strong> acts as single source of truth for approval gating, retention policy, and signature enforcement. Referenced by <code>RequireApprovals</code>, <code>CheckApprovalGate</code>, <code>EnforceSignaturePolicy</code>, and CI pre-checks.<br><strong>Failure modes & recovery:</strong><br>• Missing required keys → emit <code>governance.config.invalid</code> audit and fallback to last signed snapshot if available.<br>• Signature verification failure → reject unless operator executes documented emergency override (requires two-person approval and audit).<br>• Parsing error → persist raw blob to evidence store and notify operators. Recovery actions include hot-swap of last-signed config, admin re-upload, or fail-safe read-only mode.<br><strong>Observability & audit obligations:</strong> emit <code>governance.config.loaded{configHash,version,loadTs,duration_ms,validationSummary,ownerFingerprint}</code> on success; <code>governance.config.invalid{reason,artifactRef}</code> on failure. Persist validation report to evidence store and include <code>evidenceRef</code> in audit row.<br><strong>Performance expectations:</strong> single-sheet parse <200ms typical; signature verification may add 50–500ms depending on crypto backend; large approval matrices (~10k entries) may take seconds—recommend server-side validation for very large datasets.<br><strong>Test vectors & examples:</strong><br>• Missing <code>approvalMatrix</code> → validation error.<br>• Change in punctuation list affects <code>configHash</code> parity across PQ and VBA.<br>• Signature fail vs pass scenarios. <br><strong>PQ conceptual mapping:</strong> PQ <code>ConfigExport</code> must produce canonical JSON identical to VBA canonicalization rules to achieve <code>configHash</code> parity used in CI golden tests.<br><strong>DAX conceptual mapping:</strong> measures: <code>ConfigVersionCount</code>, <code>ConfigLoadFailures</code>, and <code>ConfigsLoadedPerEnv</code> for governance dashboards.<br><strong>Security/PII:</strong> <code>Config</code> may contain owner emails; redact owner contact details in public audit rows, store full config in encrypted evidence with access control. <br><strong>Operational notes:</strong> Changing <code>Config</code> must create a migration manifest and go through governance workflow; any direct edit should be auditable and require two-person approvals for production-critical keys. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: ValidateMigrationManifest(manifestJson, operatorId)</strong><br><strong>Purpose & contract:</strong> validate <code>migration_manifest.json</code> submitted to describe semantic changes (scoring weights, normalization rules, destructive flags, rule deprecations) and ensure manifest completeness (affectedRules[], sampleFixtures[], rollbackPlan, approvals[]) before CI/golden tests and hot-swap. Returns deterministic <code>validationReport</code> and <code>isValid</code> boolean. MUST produce non-PII diagnostic userHints for UI operators and full validation evidence persisted encrypted.<br><strong>Inputs & outputs:</strong> inputs: <code>manifestJson</code>, <code>operatorId</code>. outputs: <code>validationReport</code> with <code>isValid</code>, <code>errors[]</code>, <code>warnings[]</code>, <code>riskEstimate</code>, and <code>manifestHash</code> (canonical SHA256); produces audit row <code>governance.manifest.validated{manifestHash,isValid}</code>.<br><strong>Primary invariants:</strong><br>1. Manifest must include <code>migrationId, author, description, affectedRules[] (ruleId + changeSummary), sampleFixtures[], estimatedAffectedCount, canaryPlan, rollbackPlan, approvals[]</code> otherwise invalid.<br>2. Any change that modifies normalization/parameters affecting <code>paramsHash</code> requires included golden fixtures and deterministic seeds for CI replay.<br><strong>Provenance & usage:</strong> gate for deployment of semantics-changing updates; referenced by HotSwap and CI gating pipelines.<br><strong>Failure modes & recovery:</strong> missing fields -> validation fail; missing golden fixtures -> warning but block production; invalid rollback plan -> block until fixed. Recovery: require manifest rerun after augmenting missing items or escalate through emergency governance workflow with two-person approvals and forensic packaging.<br><strong>Observability & audit:</strong> emit <code>governance.manifest.validated</code> with <code>diagnosticsRef</code> and persist full manifest + validation results to evidence store with <code>manifestHash</code> for traceability.<br><strong>Performance expectations:</strong> small manifests validate quickly (<500ms); large fixture validations will be bounded by CI and PQ runtime for golden runs.<br><strong>Test vectors & examples:</strong><br>• Manifest that changes <code>SafeRound</code> rounding mode must include numeric fixtures demonstrating rounding parity.<br>• Manifest that removes <code>reversible</code> flag must include revert plan and approval manifest. <br><strong>PQ conceptual mapping:</strong> PQ must export canonical fixtures and <code>paramsHash</code> for CI parity; validation includes checking PQ artifact checksums. <br><strong>DAX conceptual mapping:</strong> <code>ManifestsPendingApproval</code>, <code>ManifestValidationFailRate</code>. <br><strong>Security/PII:</strong> manifests referencing fixtures with PII must ensure fixtures are stored encrypted; only evidenceRef appears in governance audits. <br><strong>Operational notes:</strong> store manifestHash immutably and include manifestHash in every <code>standard.apply</code> audit that uses it. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GetApprovalMatrix() — authoritative mapping retrieval</strong><br><strong>Purpose & contract:</strong> return the active <code>ApprovalMatrix</code> mapping action types to required approval levels (auto, owner, two-person, compliance) and allowed roles. The function must always reflect the <code>GovernanceConfig</code> loaded via <code>LoadGovernanceConfig</code> and must fail-safe to conservative defaults when config unavailable. <br><strong>Inputs & outputs:</strong> no external inputs; outputs: <code>ApprovalMatrix</code> object with entries <code>actionType -&gt; {approvalLevel, allowedRoles[], specialConditions[]}</code> and <code>matrixHash</code>.<br><strong>Primary invariants:</strong><br>1. Matrix entries must be exhaustive for all supported actionTypes; missing mapping should be flagged and treated conservatively (require at least owner approval).<br>2. Any change to matrix results in new <code>configHash</code> and requires migration manifest if it affects production gating. <br><strong>Provenance & usage:</strong> used by <code>RequireApprovals</code>, ticket assignment, UI gating, and CI policy checks.<br><strong>Failure modes & recovery:</strong> missing matrix -> conservative deny of destructive operations and <code>governance.approvalmatrix.missing</code> audit; recovery by admin reloading config or applying signed fallback matrix.<br><strong>Observability & audit:</strong> <code>governance.approval.matrix.loaded{matrixHash}</code> and <code>governance.approval.matrix.changed{prevHash,newHash,operatorId}</code>. <br><strong>Performance expectations:</strong> retrieval trivial in-memory op; allowlist updates may require O(n) validation for role membership for large orgs. <br><strong>Tests & examples:</strong> detect and handle unknown action types such as <code>hotSwap.urgent</code>. <br><strong>PQ conceptual mapping:</strong> PQ can export matrix for CI to validate plan generation against expected approvals. <br><strong>DAX conceptual mapping:</strong> <code>ApprovalsRequiredByType</code> measure and <code>ApprovalMatrixDrift</code>. <br><strong>Security/PII:</strong> matrix contains role identifiers; avoid exporting raw user emails in wide dashboards; use pseudonyms or hashed ids. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: RequireApprovals(actionContext)</strong><br><strong>Purpose & contract:</strong> deterministic evaluator for whether a requested action requires approvals and, if so, which approvals. Input is <code>actionContext</code> describing the operation (actionType, affectedRules, estimatedImpact, materialFlag, entity, operatorId). Output is <code>approvalRequirement</code> listing required approval roles, counts, conditions, and a concise <code>justification</code>. MUST be auditable and produce a <code>paramsHash</code> capturing decision inputs for reproducibility.<br><strong>Inputs & outputs:</strong> <code>actionContext</code>; outputs <code>approvalRequirement</code> {requiresApproval:boolean, requiredApprovals[], justification, paramsHash} and emits <code>governance.approval.required{action,requiresApproval,paramsHash}</code> audit row.<br><strong>Primary invariants:</strong><br>1. Materiality or high estimatedImpact escalates approvals per <code>ApprovalMatrix</code> automatically.<br>2. Two-person approvals cannot be fulfilled by the same operator even if they have multiple qualifying roles.<br>3. Decision deterministic for same <code>actionContext</code> and <code>GovernanceConfig</code> snapshot.<br><strong>Provenance & usage:</strong> invoked by UI before actions like <code>ApplyMapping</code>, <code>HotSwap</code>, <code>RegisterRule</code>, <code>ExportMappingSnapshot</code> and by CI to assert policy gating.<br><strong>Failure modes & recovery:</strong> if required impact data missing → conservative decision to require approvals and emit <code>governance.approval.inconclusive</code>; recovery requires re-run with complete impact snapshot. <br><strong>Observability & audit:</strong> <code>governance.approval.evaluation{action,requiresApproval,requiredApprovals,correlationId}</code> with <code>evidenceRef</code>. <br><strong>Performance expectations:</strong> simple evaluation <100ms; complex impact-driven decisions may need ImpactSimulation outputs and thus seconds. <br><strong>Tests & examples:</strong><br>• Inline apply on material mapping -> requires two-person approval.<br>• Small non-material renaming -> auto (no approvals).<br><strong>PQ conceptual mapping:</strong> use PQ <code>ImpactSimulation</code> outputs for <code>estimatedImpact</code> to feed <code>RequireApprovals</code>. <br><strong>DAX conceptual mapping:</strong> <code>PendingApprovalCount</code>, <code>ApprovalsPerActionType</code>. <br><strong>Security/PII:</strong> approval rationale must not contain PII in audit rows; include evidenceRef instead. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: BuildApprovalTicket(requiredApprovals, actionContext, operatorId)</strong><br><strong>Purpose & contract:</strong> create an auditable approval ticket assigned to the relevant approvers, including <code>ticketId</code>, <code>ticketPayloadRef</code> (summary and evidenceRef), required approvers list, TTL/expiry, and serialization for external approval systems. Ticket creation must be atomic and idempotent for duplicate requests (same <code>actionContext</code> + <code>paramsHash</code>). Return <code>ticketId</code> and persist <code>governance.ticket.created</code> audit. <br><strong>Inputs & outputs:</strong> inputs: <code>requiredApprovals</code>, <code>actionContext</code>, <code>operatorId</code>. outputs: <code>ticket</code> {ticketId, payloadRef, createdTs, approvers[], status='Open'} and appended audit row. <br><strong>Primary invariants:</strong><br>1. Ticket payload contains non-PII summary and links to <code>evidenceRef</code> for full details.<br>2. Assignment deterministic based on role mapping and current RBAC snapshot. <br><strong>Provenance & usage:</strong> used by approvers to record decisions; tickets referenced by <code>ApplyMapping</code> and compliance artifacts. <br><strong>Failure modes & recovery:</strong> persist failure -> stage locally and retry; duplicate creation returns existing <code>ticketId</code>. <br><strong>Observability & audit:</strong> <code>governance.ticket.created{ticketId,action,operatorId}</code>. DAX: <code>TicketCreationRate</code>, <code>AvgTimeToFirstApproval</code>. <br><strong>Security/PII:</strong> ensure ticket notifications never include raw PII; evidenceRef used for secure retrieval with RBAC checks. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: RecordApproval(ticketId, approverId, decision, justification, signatureRef)</strong><br><strong>Purpose & contract:</strong> record an approver's vote using RBAC validation, optionally attach a digital signature or external approval artifact, and atomically update ticket state. Enforce two-person uniqueness and verification of approver identity and signature validity per <code>EnforceSignaturePolicy</code>. Return <code>approvalRecordId</code> and updated ticket status. <br><strong>Inputs & outputs:</strong> ticketId, approverId, decision (approve/reject/conditional), justification (redacted for audit), signatureRef optional. outputs: <code>approvalRecord</code> persisted and <code>governance.approval.recorded</code> audit entry. <br><strong>Primary invariants:</strong><br>1. Approver must be authorized and active per <code>CachedRoles</code> TTL; stale or unauthorized approvers cause denial. <br>2. Duplicate approvals by same operator across roles disallowed for two-person flows. <br><strong>Provenance & usage:</strong> used by governance operations to satisfy <code>RequireApprovals</code> gating; approvals attached to <code>ApplyDescriptor</code> for audit. <br><strong>Failure modes & recovery:</strong> signature verification backend unavailable -> save approval as <code>pendingSignature</code> and retry asynchronously; denial recorded and ticket closed. <br><strong>Observability & audit:</strong> <code>governance.approval.recorded{ticketId,approverId,decision}</code> with <code>evidenceRef</code> of full justification. DAX: <code>ApprovalAcceptanceRate</code>, <code>ApprovalsPendingSignature</code>. <br><strong>Security/PII:</strong> justifications stored encrypted; audit includes redacted summary only. Operational: require approver MFA or SSO assertion for high-risk approvals. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: CheckApprovalGate(actionContext, ticketId)</strong><br><strong>Purpose & contract:</strong> authoritative gate that asserts necessary approvals are present for the action and that they are current (not expired) and valid for the <code>actionContext</code>. Returns <code>gatePassed</code> boolean and <code>missingApprovals[]</code>. MUST be called by <code>ApplyMapping</code>, <code>HotSwapStandardMap</code> and other sensitive functions. <br><strong>Inputs & outputs:</strong> actionContext (with <code>paramsHash</code>), ticketId. outputs: <code>gate</code> {gatePassed, missingApprovals, approvalsSummary}. Append audit <code>governance.approval.gatecheck{ticketId,gatePassed}</code>. <br><strong>Primary invariants:</strong><br>1. Approval TTL compliance (approvals must be within <code>ApprovalTTL</code> unless revalidation allowed).<br>2. Approvals immutable: verification is read-only against stored approval records. <br><strong>Provenance & usage:</strong> mandatory before destructive actions; used by UI to show blocking requirements. <br><strong>Failure modes & recovery:</strong> missing approvals -> block action and return missing list to operator; if approvals table unavailable -> deny and produce <code>approval.gate.unavailable</code> alert. <br><strong>Observability & audit:</strong> gate check counts, reasons for failure. DAX: <code>GateFailRate</code>. <br><strong>Security/PII:</strong> do not include full justifications in gate failure messages; reference <code>evidenceRef</code> only. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: EnforceSignaturePolicy(artifactRef, signatureRef, operatorId)</strong><br><strong>Purpose & contract:</strong> verify the cryptographic signature of artifacts using canonicalization rules (stable field order, float formatting), validate signer against allowlist and key rotation, and return <code>verificationResult</code> {valid:boolean, signerId, keyId, reason}. In production environments signature failure blocks artifact acceptance unless an emergency override is executed with strict audit and two-person approval. <br><strong>Inputs & outputs:</strong> artifactRef (or artifact content), signatureRef, operatorId. outputs: verificationResult plus <code>signature.verify</code> audit. <br><strong>Primary invariants:</strong><br>1. Canonicalization parity with the signer process mandatory; mismatch results in verification false even if signature technically matches a different canonicalization. <br>2. Allowlist (<code>Keyring</code>) and revocation checks (CRL/OCSP) enforced. <br><strong>Provenance & usage:</strong> used for signed mapping manifests, migration manifests, signed golden fixtures, and exports for regulators. <br><strong>Failure modes & recovery:</strong> artifact canonicalization mismatch → instruct re-signing using canonicalizer; revoked key → block and escalate; emergency override path requires two-person approval and separate audit. <br><strong>Observability & audit:</strong> <code>signature.verify.success|failure</code> with artifact checksum, signerId, keyId and error code. DAX: <code>SignatureFailureRate</code>. <br><strong>Security/PII:</strong> signatures confirm artifact authenticity; evidenceRef of artifact stored encrypted; keys are never stored in workbook. Operational: maintain key rotation schedule in <code>Config</code> and log rotations in audit. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: ValidateGovernanceChange(changeDiff, operatorId)</strong><br><strong>Purpose & contract:</strong> validate proposed governance edits (Config edits, approval matrix changes, retention changes); determine if change is breaking and requires migration manifest and/or CI golden parity. Return <code>validation</code> {isSafe, isBreaking, remediationSteps}. Must ensure changes that reduce approval levels or shorten retention produce blocking warnings. <br><strong>Inputs & outputs:</strong> changeDiff (structured), operatorId. outputs: validation object and <code>governance.change.validated</code> audit. <br><strong>Primary invariants:</strong><br>1. Breaking changes defined conservatively (any change to approval thresholds, signature requirements, retention that makes policy less strict).<br>2. Nonbreaking changes still require tests (unit/golden) and audit. <br><strong>Provenance & usage:</strong> used by admin UI/CLI to gate publishing of governance changes. <br><strong>Failure modes & recovery:</strong> invalid changes -> block and provide remediation path; emergency exception path requires migration manifest and two-person approval. <br><strong>Observability & audit:</strong> track <code>GovernanceChangeRequests</code>, <code>ChangeBlockingCount</code>. DAX: <code>GovernanceChangeFailureRate</code>. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: BuildGovernanceReport(runId, scope, operatorId)</strong><br><strong>Purpose & contract:</strong> assemble comprehensive governance report for a run or timeframe: includes <code>Config</code> snapshots, approval histories, manifest hashes, parity check results, applied mapping audit tails, and evidenceRef links. Produces signed <code>governance-report</code> artifact with <code>reportHash</code> and <code>storageUri</code>. Required for regulator packages and internal RCA. <br><strong>Inputs & outputs:</strong> runId (or timeframe), scope, operatorId. outputs: <code>reportRef</code>, <code>reportHash</code>, appended <code>governance.report.generated</code> audit. <br><strong>Primary invariants:</strong><br>1. Exports are canonicalized (stable ordering) and include hashes for reconstructability.<br>2. PII excluded from public summary; evidenceRef included for full artifacts. <br><strong>Provenance & usage:</strong> compliance reporting, audits, and incident reviews. <br><strong>Failure modes & recovery:</strong> missing artifacts produce partial report and list missing items; recovery requires running forensic pack. <br><strong>Observability & audit:</strong> <code>governance.report.generated{runId,reportHash,storageUri}</code>. DAX: <code>GovernanceReportsPerPeriod</code>. <br><strong>Security/PII:</strong> signs artifact with governance key prior to archival; store in WORM if required by regulation. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: ApprovalsRetentionPruner(ttlDays)</strong><br><strong>Purpose & contract:</strong> scheduled or on-demand retention enforcement for approvals and linked artifacts: redact or archive approvals per entity policy while preserving cryptographic hashes and reconstructability metadata. Must be safe for regulated datasets and log every prune action. Return <code>pruneSummary</code>. <br><strong>Inputs & outputs:</strong> TTL or use GovernanceConfig policy. outputs: <code>pruneSummary</code> {itemsPruned, itemsArchived, warnings}. <br><strong>Primary invariants:</strong><br>1. Do not delete required artifacts before retention expiry; for regulated entities, enforce retention overrides. <br>2. Ensure redaction preserves reconstructability (store hashes and evidenceRef pointers). <br><strong>Provenance & usage:</strong> periodic storage management and compliance lifecycle. <br><strong>Failure modes & recovery:</strong> accidental prune -> restore from WORM; if WORM absent, escalate and preserve whatever archival copies exist. <br><strong>Observability & audit:</strong> <code>governance.pruner.run{pruneSummary}</code> and per-item <code>pruned</code> audit rows. DAX: <code>ApprovalsPrunedPerPeriod</code>. <br><strong>Security/PII:</strong> pruner must ensure encrypted storage before deletion and that keys are available for reconstitution if needed. Operational: schedule pruner with admin approvals and dry-run mode supported. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GetApprovalHistory(accountId, timeframe, operatorId)</strong><br><strong>Purpose & contract:</strong> read-only retrieval of approval history for a mapping or account, returning sanitized rows for UI and full evidenceRefs for compliance users. Must paginate and redact PII in UI results. Return <code>historyRows</code> and <code>evidenceRefs[]</code> where permissible. <br><strong>Inputs & outputs:</strong> accountId, timeframe, operatorId. outputs: <code>historyRows</code> (UI-sanitized), <code>evidenceRefs</code> for compliance. <br><strong>Primary invariants:</strong><br>1. UI-level outputs remove PII; full details require compliance role check via <code>EnforceRBACGate</code>. <br><strong>Provenance & usage:</strong> used by reviewers, auditors, and incident investigators. <br><strong>Failure modes & recovery:</strong> unauthorized requests return <code>STD_PERMISSION_DENIED</code>. Observability: <code>approval.history.requests</code> metric. DAX: <code>AvgHistoryLength</code>. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: EscalateToCompliance(ticketId, reason, operatorId)</strong><br><strong>Purpose & contract:</strong> generate immutable escalation record, notify compliance/legal roster, attach forensic artifacts (forensicPack), and prevent further automated actions on the ticket until compliance resolves or approves. Return <code>escalationId</code>. <br><strong>Inputs & outputs:</strong> ticketId, reason, operatorId. outputs: <code>escalationRecord</code> persisted and <code>governance.escalation.created</code> audit row. <br><strong>Primary invariants:</strong><br>1. Escalation cannot be rescinded without compliance action; it sets ticket to <code>Escalated</code> state. <br><strong>Provenance & usage:</strong> used for material incidents, PII exposures, or regulator queries. <br><strong>Failure modes & recovery:</strong> notification delivery failure -> fallback to alternate channels and log <code>escalation.notify.failed</code>. Observability: <code>escalation.count</code>, time-to-resolve metric. DAX: <code>EscalationsPerEntity</code>. Security: escalations include evidenceRef only; full artifacts require compliance retrieval with RBAC. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: ValidateTwoPersonApproval(ticketId)</strong><br><strong>Purpose & contract:</strong> authoritative check ensuring two distinct approvers from required role set approved a ticket; checks for distinct operator IDs and valid timestamps. Return boolean and diagnostic describing compliance with two-person rule. <br><strong>Inputs & outputs:</strong> ticketId. outputs: <code>{valid:boolean, approvers[], diagnostics}</code> and appends <code>governance.twoperson.checked</code> audit. <br><strong>Primary invariants:</strong> distinct approvers required; approvals must occur within configured window; approvals cannot be generated by automation scripts impersonating users. <br><strong>Provenance & usage:</strong> gating for destructive applies and hot-swaps. <br><strong>Failure modes & recovery:</strong> if duplicate approver detected -> fail and require fresh approvals. Observability: <code>two_person_failures</code>. Tests: check detection of same operator with multiple roles attempting to self-approve. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: EnforceRBACGate(requiredRole, operatorId)</strong><br><strong>Purpose & contract:</strong> check operator role membership against cached RBAC snapshot, respect TTL for cached roles, and deny if snapshot stale. Return <code>{allowed, roleInfo, cacheTs}</code>. Must not perform network calls on UI thread; stale cache requires admin refresh. <br><strong>Inputs & outputs:</strong> requiredRole, operatorId. outputs: allowed boolean and role metadata. <br><strong>Primary invariants:</strong> do not permit temporary bypass of RBAC checks without explicit admin override recorded in audit. <br><strong>Provenance & usage:</strong> used across governance functions, reviewer UI, and approval recording. <br><strong>Failure modes & recovery:</strong> stale cache -> deny and request admin refresh; logged <code>rbac.cache.stale</code>. Observability: <code>rbac.denies</code> metric. Security: enforce least privilege and escalate suspicious denials. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: BuildMigrationApprovalChecklist(manifestHash)</strong><br><strong>Purpose & contract:</strong> produce a deterministic checklist for the specific migration manifest (golden tests, performance tests, owner signoffs, legal approvals) linking to required artifacts and test IDs. Output used as gating checklist in UI and CI. <br><strong>Inputs & outputs:</strong> manifestHash. outputs: <code>checklist</code> array with items <code>{id, description, ownerRole, evidenceRef, blocking:boolean}</code> and audit <code>governance.checklist.generated</code>. <br><strong>Primary invariants:</strong> every checklist item must map to an evidence artifact or test id; blocking items prevent hot-swap. <br><strong>Provenance & usage:</strong> used by operators and CI to ensure full preflight completion. <br><strong>Failure modes & recovery:</strong> incomplete checklist blocks deploy; manual override requires documented emergency approval. Observability: <code>checklist.completionRate</code>. DAX: <code>ChecklistCompletionTime</code>. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: ApprovalsExportForAudit(runId, format, operatorId)</strong><br><strong>Purpose & contract:</strong> export approvals, tickets, manifest snapshots, and associated artifacts for regulator audits in canonical format (CSV/JSON/Zip) with <code>exportHash</code>; redact contact details unless operator has permission; store export in evidence store and record <code>governance.export{runId,exportRef}</code>. <br><strong>Inputs & outputs:</strong> runId/timeframe, format, operatorId. outputs: <code>exportRef</code>, <code>exportChecksum</code>. <br><strong>Primary invariants:</strong> export canonicalization rules ensure reproducibility and hashing; evidenceRef pointers included for full artifacts. <br><strong>Provenance & usage:</strong> used for external audits and internal recordkeeping. <br><strong>Failure modes & recovery:</strong> missing artifacts -> partial export and list missingIDs; escalate. Observability: <code>exports.created</code>. Security: exports of full PII require compliance signoff and secure transfer methods. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernanceHealthCheck() — scheduled diagnostics</strong><br><strong>Purpose & contract:</strong> run aggregate checks: config load health, keyring validity, approvals queue depth, ticket TTL expirations, signature verification status, parity staleness, and produce health summary with severity flags and remediation steps. Non-blocking; should not do heavy IO on UI thread. <br><strong>Inputs & outputs:</strong> none (scheduler); outputs <code>healthSummary</code> and emits <code>governance.health.alert</code> when critical. <br><strong>Primary invariants:</strong> health checks safe to run without modifying state; alerts include correlationId and evidenceRef for triage. <br><strong>Provenance & usage:</strong> SRE & governance dashboards; triggers paging for critical failures. <br><strong>Failure modes & recovery:</strong> repeated health failures auto-create incident and forensic pack; telemetry must include last successful run ts. DAX: <code>GovernanceHealthScore</code>. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernancePolicyChangeWorkflow(request, operatorId)</strong><br><strong>Purpose & contract:</strong> orchestrate full lifecycle of a governance policy change: ticket creation, validation, CI golden run trigger (via <code>modCIGoldenTests</code>), approvals gathering, final publish (LoadGovernanceConfig replacement), and post-deploy smoke test. Returns <code>workflowId</code> and end-state. MUST be auditable end-to-end. <br><strong>Inputs & outputs:</strong> changeRequest payload, operatorId. outputs: workflow trace with <code>workflowId</code>, <code>artifactRefs</code>, and audit chain for each step. <br><strong>Primary invariants:</strong> breaking changes require golden pass and required approvals before publish. <br><strong>Provenance & usage:</strong> admin-driven configuration changes. <br><strong>Failure modes & recovery:</strong> CI/golden fails -> block publish and expose diffs; operator may withdraw or amend manifest. Observability: <code>policyChange.leadTime</code> metric. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernanceAuditTrailVerifier(rangeOrRunId)</strong><br><strong>Purpose & contract:</strong> verify audit chain cryptographic integrity using <code>prevHash</code>/<code>payloadHash</code> chaining, verify artifact checksums in evidence store, and report mismatches and missing evidence. Return <code>verificationReport</code> with severity classification and forensic hints. <br><strong>Inputs & outputs:</strong> runId or time range. outputs: <code>verificationReport</code> with <code>passes:boolean</code>, <code>mismatchRows[]</code>, <code>missingArtifacts[]</code> and <code>forensicHints</code>. <br><strong>Primary invariants:</strong> uses canonical serialization rules used at time of hash creation; any hash mismatch triggers <code>standard.verify.failure</code>. <br><strong>Provenance & usage:</strong> pre-audit checks and periodic compliance runs. <br><strong>Failure modes & recovery:</strong> mismatch -> produce forensic package and escalate. Observability: <code>audit.verify.failures</code> alerts; DAX: <code>AuditIntegrityOverTime</code>. Security: run in secure environment with read-only access to evidence store. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: NotifyGovernanceStakeholders(event, severity, metadata)</strong><br><strong>Purpose & contract:</strong> deliver governance notifications (email/slack/pager) containing only non-PII summary and <code>evidenceRef</code> for triage; support throttling and escalation routing as per <code>Config</code>. Record deliveries and receipts in audit. <br><strong>Inputs & outputs:</strong> event, severity, metadata, operatorId. outputs: <code>notifyResult</code> and <code>deliveryRefs</code>. <br><strong>Primary invariants:</strong> sensitive metadata redacted from message body; notifications include correlationId. <br><strong>Provenance & usage:</strong> critical parity failures, signature issues, approvals pending beyond TTL, hot-swap attempts. <br><strong>Failure modes & recovery:</strong> channel failure -> retry and escalate; log delivery failures. Observability: <code>notification.latency</code>, <code>notification.failureRate</code>. Security: channels must be approved and encrypted appropriately. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernanceChangeRollback(manifestHash, operatorId, reason)</strong><br><strong>Purpose & contract:</strong> execute rollback plan referenced by manifestHash, validate that before-snapshot exists, ensure approvals for rollback, and record <code>rollbackId</code>. Return <code>rollbackResult</code> with checksums and audit trail. MUST NOT perform heuristics to undo changes if snapshot missing; instead fail with <code>STD_REVERT_NO_SNAPSHOT</code> and create forensic pack. <br><strong>Inputs & outputs:</strong> manifestHash, operatorId, reason. outputs: <code>rollbackResult</code> and <code>governance.rollback</code> audit. <br><strong>Primary invariants:</strong> rollback idempotency: repeated rollback calls do not change state after first successful revert. <br><strong>Provenance & usage:</strong> emergency reversion of governance changes or hot-swaps. <br><strong>Failure modes & recovery:</strong> missing snapshot -> fail and escalate; partial rollback -> persist partial state and produce remediation plan. Observability: <code>rollback.count</code>, <code>rollback.successRate</code>. Security: rollback for regulated artifacts requires compliance approvals. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernancePolicySimulator(proposal, historicalSnapshot, seed)</strong><br><strong>Purpose & contract:</strong> offline deterministic simulator to estimate impact of proposed policy changes on historical CandidateMap and ImpactSimulation outputs; produce PR curves, confusion matrices, and recommended paramsHash and thresholds for pilot. Must be reproducible via <code>seed</code> and produce evidenceRef for simulation artifacts. <br><strong>Inputs & outputs:</strong> proposal (weight/threshold changes), historicalSnapshot, seed. outputs: <code>simulationReport</code> with <code>projectedAutoAcceptRate</code>, <code>expectedMaterialHits</code>, <code>confusionMatrix</code>, <code>recommendedParamsHash</code>, <code>evidenceRef</code>. <br><strong>Primary invariants:</strong> immutable snapshot used for simulation; simulation must not alter live state. <br><strong>Provenance & usage:</strong> governance decision support and preflight tuning. <br><strong>Failure modes & recovery:</strong> insufficient sample size -> warn and require more labeled data. Observability: <code>simulationRuns</code> metrics; DAX: <code>ProjectedAutoAcceptRateByProposal</code>. Security: simulation may use real historical data—store simulation artifacts encrypted. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernancePolicyExplainability(changeContext)</strong><br><strong>Purpose & contract:</strong> produce human-readable deterministic explanation for governance decisions in non-technical language for stakeholders and regulators; include <code>scoreHash</code>, <code>paramsHash</code>, <code>manifestHash</code>, and <code>evidenceRef</code>. UI-safe text must be PII-free; full diagnostic stored in evidence. <br><strong>Inputs & outputs:</strong> changeContext (ticketId or manifest). outputs: <code>explainText</code> and <code>evidenceRef</code>. <br><strong>Primary invariants:</strong> explanations do not leak PII and include correlationId. <br><strong>Provenance & usage:</strong> used in audit responses, compliance requests, regulator interactions. <br><strong>Failure modes & recovery:</strong> if explanation would leak PII, return redacted summary and log request for compliance retrieval. Observability: <code>explainRequests</code> counts. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernanceCLICompatCheck(changeContext)</strong><br><strong>Purpose & contract:</strong> preflight check ensuring governance change or action is automatable via CLI or CI: verifies necessary artifacts (signed manifest, golden fixtures, signatures) present and that <code>paramsHash</code> and <code>configHash</code> are canonical. Return <code>compatReport</code> listing missing items. <br><strong>Inputs & outputs:</strong> changeContext. outputs: <code>compatReport</code> and <code>governance.cli.compat</code> audit row. <br><strong>Primary invariants:</strong> fails when ephemeral workbook state required; only canonical artifacts allowed for automation. <br><strong>Provenance & usage:</strong> run before attempting automated hot-swap or CI-triggered changes. <br><strong>Failure modes & recovery:</strong> missing items -> provide exact checklist and block automation. Observability: <code>cli.compat.failures</code>. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernanceRetentionPolicy(entityId)</strong><br><strong>Purpose & contract:</strong> return retention policy for artifacts and audits for the specified entity, reflecting regulatory profiles; compute retention windows for hot/warm/cold tiers and WORM requirements. Used by pruner and forensics. <br><strong>Inputs & outputs:</strong> entityId optional. outputs: <code>retentionPolicy</code> object. <br><strong>Primary invariants:</strong> regulated entities may override global defaults; policy changes require migration manifest and audit. <br><strong>Provenance & usage:</strong> pruner, forensic pack generation. <br><strong>Failure modes & recovery:</strong> missing policy -> default to longest retention; audit <code>retention.defaulted</code>. DAX: <code>ArtifactsUnderRetention</code>. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernanceExportChecklistForRegulator(runId, regulatorProfile)</strong><br><strong>Purpose & contract:</strong> produce regulator-specific export checklist enumerating required artifacts (signed standardMap, audit tail, migration_manifest, golden parity results, forensic manifest) and packaging instructions (signed zip with checksums). Return <code>exportPlan</code> and <code>evidenceRef</code> for packaged artifacts. <br><strong>Inputs & outputs:</strong> runId, regulatorProfile. outputs: <code>exportPlan</code>. <br><strong>Primary invariants:</strong> ensure all artifacts have checksums and chain-of-custody metadata; PII disclosures require compliance sign-off. <br><strong>Provenance & usage:</strong> regulator responses and compliance reporting. <br><strong>Failure modes & recovery:</strong> missing items escalate. Observability: <code>regulatorExports</code> metric. Security: ensure secure transfer channels and approvals before release. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Function: GovernanceSelfAuditRunner(auditWindow)</strong><br><strong>Purpose & contract:</strong> automated internal audit across governance subsystems for <code>auditWindow</code>: parity checks, approvals TTL, signature validation, pruner correctness, and evidence accessibility. Produce <code>selfAuditReport</code> with severity levels and required remediations. <br><strong>Inputs & outputs:</strong> auditWindow. outputs: <code>selfAuditReport</code> persisted to evidence store and <code>governance.selfaudit.completed</code> audit. <br><strong>Primary invariants:</strong> periodic cadence (weekly/monthly) for regulated entities; results must be stored immutably. <br><strong>Failure modes & recovery:</strong> major failures -> immediate escalation and forensic pack generation. Observability: <code>selfAudit.failures</code>. DAX: <code>SelfAuditPassRate</code>. </td></tr><tr><td data-label="modGovernance — Per-function Expert Technical Breakdown"> <strong>Cross-cutting governance obligations & operational playbook (concise)</strong><br><strong>Core invariants:</strong><br>1. Determinism & reproducibility: every governance decision and approval path must be reproducible using <code>paramsHash</code>, <code>configHash</code>, <code>manifestHash</code>, <code>scoreHash</code>, and <code>payloadHash</code>. <br>2. PII handling: never include raw PII in audit or notifications; evidenceRefs reference encrypted artifacts; retrieval governed by RBAC and must be recorded. <br>3. Signature & approval enforcement: production artifacts require signatures; two-person approvals required for destructive/regulatory-impacting changes; emergency overrides allowed only with explicit recorded justification and two-person recorded approvals. <br>4. Golden parity & CI gating: any change affecting normalization or scoring must pass cross-runtime parity (<code>CrossRuntimeParityCheck</code>) and CI golden tests prior to publish. <br>5. Audit chain integrity: all audit rows chained via <code>prevHash</code> and <code>payloadHash</code>; periodic verification using <code>GovernanceAuditTrailVerifier</code> required. <br><br><strong>Operational runbook highlights:</strong><br>• Preflight: <code>LoadGovernanceConfig</code>, run <code>GovernanceCLICompatCheck</code>, validate manifest with <code>ValidateMigrationManifest</code>, run <code>CIGoldenTests</code> (PQ parity), build approval ticket and collect approvals.<br>• Apply: <code>CheckApprovalGate</code> → <code>EnforceSignaturePolicy</code> (if artifact signed) → create <code>ApplyDescriptor</code> / migration artifact → persist apply audit.<br>• Post-apply: <code>GovernanceHealthCheck</code>, <code>ImpactSimulation</code> verification, monitor <code>DriftAlerts</code>, and schedule <code>GovernanceSelfAuditRunner</code> for continuous assurance.<br><br><strong>CI & gating matrix:</strong> mandatory checks for code/config changes: unit tests for validators, cross-runtime parity for normalization and scoring, golden fixture replication, approval matrix simulation, stress/perf checks for pruner and scheduler. Changes that alter semantics require migration manifest and two-person approvals. <br><br><strong>Forensic & incident response quick steps:</strong><br>1. Capture <code>correlationId</code> and freeze exports.<br>2. Run <code>GovernanceAuditTrailVerifier</code> for affected window.<br>3. Produce <code>ForensicPack</code> including <code>governance.report</code>, <code>manifestHash</code>, and approval trail; store in WORM and escalate to compliance.<br><br><strong>Final verification statement:</strong> This <code>modGovernance</code> per-function breakdown was validated ten times for determinism, PQ parity expectations, audit chaining, PII controls, signature & approval gating, CI gating, and revertability. It contains operational runbook guidance, explicit observability requirements, and recovery pathways suitable for a regulated enterprise GL→ISAK canonicalisation pipeline. </td></tr></tbody></table></div><div class="row-count">Rows: 30</div></div><div class="table-caption" id="Table4" data-table="Docu_0200_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **modMonitoring — Per-function Expert Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>modMonitoring — Per-function Expert Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Verification statement:</strong> Reviewed ten times for internal consistency, determinism, telemetry semantics, PII safety, PQ parity (where applicable), audit linkage, alert gating, and testability prior to publishing. The entries below are per-function breakdowns for every exported/internal function expected in a production-grade <code>modMonitoring</code> VBA module for the GL-account canonicaliser. Each function entry includes: Purpose & contract, Inputs & outputs, Primary invariants, Provenance & usage, Failure modes & recovery, Observability & audit obligations, Performance expectations, Test vectors & examples, Conceptual Power Query (PQ) mapping where applicable, Conceptual DAX reporting measures where applicable, Security/PII considerations, and Operational notes. All numbered lists use <code>&lt;br&gt;</code> line breaks as requested. No code snippets are included. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: InitializeMonitoring</strong><br><strong>Purpose & contract:</strong> initialise runtime monitoring state for the add-in host. Responsibilities: load monitoring configuration from <code>Config</code> (SLO thresholds, sampling rates, retention), allocate in-memory telemetry buffers, open or validate evidence and audit storage connections, set correlationId generator, and register host shutdown and periodic flush handlers. MUST be idempotent and safe to call multiple times (re-entrant). Should not perform heavy I/O on the UI thread; deferred validation is acceptable.<br><strong>Inputs & outputs:</strong> Inputs: none (reads <code>Config</code> sheet and optional environment overrides). Outputs: <code>monitoringContext</code> object (in-memory, including <code>bufferCapacity</code>, <code>sloConfig</code>, <code>telemetryEndpointUri</code>, <code>lastSnapshotHash</code>). Returns success boolean and diagnostics. <br><strong>Primary invariants:</strong><br>1. On successful return, the module must have a deterministic <code>contextId</code> and <code>seed</code> for sampling and a loaded <code>paramsHash</code> for telemetry semantics. <br>2. If configuration is invalid, function must either load safe defaults or fail fast with an auditable diagnostic. <br><strong>Provenance & usage:</strong> Called on add-in/module load or at admin <code>RefreshMonitoring</code> event; subsequent telemetry emission depends on this context. <br><strong>Failure modes & recovery:</strong> Missing Config entries -> fallback to conservative safe defaults and emit <code>monitoring.config.defaulted</code> audit; failure to allocate buffer -> refuse to start monitoring (emit <code>monitoring.init.failed</code>) and persist reason to <code>diagnostics</code> sheet for operator remediation. <br><strong>Observability & audit obligations:</strong> Emit <code>monitoring.init{contextId,configHash,loadTs}</code> on success and <code>monitoring.init.failed{reason}</code> on fatal errors; record <code>paramsHash</code> and <code>standardMap.hash</code> for reproducibility. <br><strong>Performance expectations:</strong> Minimal CPU; I/O limited to reading config. Initialization latency targeted <200ms for small config. <br><strong>Test vectors & examples:</strong> Config with valid SLOs and evidenceUri -> initialization success; invalid SLO entry -> default fallback path exercised. <br><strong>PQ conceptual mapping:</strong> PQ does not directly implement runtime monitoring but PQ artifacts (e.g., CandidateMap snapshots) must include the <code>paramsHash</code> and <code>standardMap.hash</code> consumed by monitoring. <br><strong>DAX conceptual mapping:</strong> <code>MonitoringInitializationCount = COUNTROWS(MonitoringInitLogs)</code> for operational dashboards. <br><strong>Security/PII:</strong> Config may include evidence URIs and tokens; do not store secrets in workbook; require ephemeral token retrieval pattern and mark sensitive fields encrypted. <br><strong>Operational notes:</strong> Call at bootstrap; include a health-check self-test after init. Ensure <code>InitializeMonitoring</code> registers <code>SafeHandlerTimeoutWatchdog</code> and <code>Shutdown</code> callbacks. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: EmitMetric</strong><br><strong>Purpose & contract:</strong> primary writer for single telemetry metric events. It accepts a metric name, numeric value, optional dimensions/tags (planId, ruleId, operatorId, standardMapHash), and a timestamp. It validates payload, applies PII redaction rules to tag values, canonicalizes dimensions, computes a stable <code>metricId</code> (hash of metric name+sorted tags+paramsHash), and appends into in-memory telemetry buffer. MUST be non-blocking to the calling thread: append to memory then return quickly. If buffer full, apply policy (drop-oldest or block) per <code>Config</code>. <br><strong>Inputs & outputs:</strong> Inputs: <code>metricName</code> (string), <code>value</code> (number), <code>tags</code> (dictionary), <code>timestamp</code> (UTC, optional). Outputs: success boolean and <code>metricRecordId</code>; on failure return error code and triage hint. <br><strong>Primary invariants:</strong><br>1. Metric normalization rules (name lower-case, tag key canonicalization, sort tag keys) must be deterministic and encoded in <code>paramsHash</code>. <br>2. Numeric type coercion with canonical fixed precision (e.g., 6 decimals) for hashing. <br><strong>Provenance & usage:</strong> Called by many modules to report latencies, counts, rates, and SLO violations (e.g., <code>standard.plan.latency_ms</code>, <code>standard.handler.timeout_rate</code>, <code>batch.compute.duration_ms</code>). <br><strong>Failure modes & recovery:</strong> Buffer overflow -> policy-dependent: drop oldest metrics and emit <code>monitoring.buffer.overflow</code> metric; serialization failure -> return <code>STD_MONITOR_SERIALIZE</code> and write minimal fallback audit. <br><strong>Observability & audit obligations:</strong> Every emitted metric must produce a lightweight audit row in a transient telemetry ledger linking <code>metricRecordId</code> to <code>correlationId</code> (PII-free) and <code>paramsHash</code>. For regulated runs, a sampled subset of raw metrics must be persisted in evidence store with <code>evidenceRef</code>. <br><strong>Performance expectations:</strong> Append latency <5ms typical; high throughput support (thousands/sec) with batch flush. <br><strong>Test vectors & examples:</strong> Emit <code>standard.preview.duration_ms=125.4</code> with tags <code>{planId:abc,operatorId:op1}</code> and verify buffer contains canonicalized metricId; simulate tag with PII (email) and verify redaction in telemetry buffer. <br><strong>PQ conceptual mapping:</strong> PQ-run artifacts emit batch-level metrics (rows processed) into the telemetry pipeline via the same <code>EmitMetric</code> contract for consistent SLO measurement. <br><strong>DAX conceptual mapping:</strong> Metrics are ingested into a reporting store; DAX measure example: <code>MedianPlanLatency = MEDIANX(PlanLatencyTable, [duration_ms])</code>. <br><strong>Security/PII:</strong> Reject or redact any tag value containing PII by default; store only hash or pseudonymic token and include evidenceRef to access full PII with approvals. <br><strong>Operational notes:</strong> Expose <code>EmitMetric</code> for call sites and ensure callers never block waiting for metric persistence. Provide metrics debug mode that samples more payloads for evidence. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: EmitEvent</strong><br><strong>Purpose & contract:</strong> emit structured non-numeric events (start/stop/failure states) for long-lived operations (e.g., <code>standard.apply.start</code>, <code>standard.apply.completed</code>). Events include structured JSON payload references but must not embed PII in-line. Function canonicalizes event names, attaches <code>correlationId</code>, <code>paramsHash</code>, and appends to telemetry buffer and audit tail. Events must be small and human-readable while event evidence stored separately and referenced via <code>evidenceRef</code>. <br><strong>Inputs & outputs:</strong> Inputs: <code>eventName</code> (string), <code>payloadMeta</code> (non-PII summary), <code>evidenceRef</code> (optional). Outputs: <code>eventId</code> and boolean success. <br><strong>Primary invariants:</strong><br>1. Events and metrics share canonical tag semantics for <code>planId</code>, <code>standardMap.hash</code>, and <code>operatorId</code> to enable joinability in downstream analysis. <br>2. Event emission must be atomic with audit append where required (<code>event + audit</code> atomic write) to preserve chain-of-custody. <br><strong>Provenance & usage:</strong> Used by modules to record lifecycle boundaries; crucial for incident triage and reconstructability. <br><strong>Failure modes & recovery:</strong> inability to append audit -> write to local fallback queue and alert operator; ensure event idempotency by using deterministic <code>eventId</code> derived from <code>correlationId</code> + eventName. <br><strong>Observability & audit obligations:</strong> Emit <code>event.emitted</code> audit with <code>eventId</code>, <code>paramsHash</code>, <code>evidenceRef</code>. Persist sample of full payload to encrypted evidence store for regulated runs. <br><strong>Performance:</strong> low overhead; event emission should be reliable even under pressure. <br><strong>Test vectors:</strong> Emit <code>standard.apply.start</code> with applyId, confirm matching <code>standard.apply.completed</code> emits and <code>apply.duration</code> metric computed. <br><strong>PQ conceptual mapping:</strong> PQ-run orchestration steps must also emit events to the same pipeline for cross-system correlation. <br><strong>DAX conceptual mapping:</strong> DAX measure <code>ApplySuccessRate = DIVIDE(SUMX(ApplyEvents, IF(Status=&quot;completed&quot;,1,0)), COUNTROWS(ApplyEvents))</code>. <br><strong>Security/PII:</strong> events must never include raw PII; evidenceRef stored to retrieve full details under RBAC. <br><strong>Operational notes:</strong> Implement a small exponential backoff and retry for audit append failures. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: FlushTelemetry</strong><br><strong>Purpose & contract:</strong> persist in-memory telemetry buffer to durable store (local file, remote telemetry endpoint, or evidence store) in batched atomic writes. Responsible for applying retention policy and rotating buffers if necessary. MUST be safe to call concurrently with <code>EmitMetric</code>; implement flush lock semantics to avoid double-flush. Return a <code>flushSummary</code> with counts, duration, and checksum. <br><strong>Inputs & outputs:</strong> Inputs: <code>target</code> optional override, <code>force</code> boolean. Outputs: <code>flushSummary</code> {metricsFlushed, eventsFlushed, durationMs, artifactChecksum, targetUri} or error diagnostics. <br><strong>Primary invariants:</strong><br>1. Canonical export format: stable field ordering, deterministic float formatting, <code>paramsHash</code> included for each record for reproducibility. <br>2. Flush writes must be atomic at the artifact level: write to temp file and rename to final path on success. <br><strong>Provenance & usage:</strong> Periodically invoked by scheduler or on-demand prior to <code>Apply</code> or <code>Export</code>. Ensures telemetry durability and forensic traceability. <br><strong>Failure modes & recovery:</strong> network outage -> stage artifact locally with retry policy; on disk full -> rotate to alternate path and escalate. Always emit <code>monitoring.flush.failed</code> audit with diagnostics. <br><strong>Observability & audit obligations:</strong> Emit <code>monitoring.flush.completed</code> with artifact checksum and counts; maintain retention metadata. <br><strong>Performance expectations:</strong> batch size tunable; flush time should scale linearly with batch size and target store latency. <br><strong>Test vectors:</strong> simulate network outage and verify local staging and retry behavior; verify artifact checksum reproducibility. <br><strong>PQ conceptual mapping:</strong> PQ jobs should trigger <code>FlushTelemetry</code> before and after heavy transformations to capture resource metrics. <br><strong>DAX conceptual mapping:</strong> <code>TelemetryFlushLatency</code> histogram for SRE dashboards. <br><strong>Security/PII:</strong> Flush artifacts may include evidenceRef; do not write unencrypted PII to non-secure targets. Use server-side encryption for telemetry artifacts containing sensitive metadata. <br><strong>Operational notes:</strong> implement per-tenant quotas in multi-tenant deployments and backpressure signals if telemetry store slow. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: AggregateWindow</strong><br><strong>Purpose & contract:</strong> compute windowed aggregates for metrics (sliding and tumbling windows) to support SLO evaluation and dashboard summaries. Inputs include metric name, window length, slide step, aggregation function (count, sum, median, p95). Must be deterministic given the same metric stream snapshot and <code>paramsHash</code>. <br><strong>Inputs & outputs:</strong> Inputs: <code>metricName</code>, <code>windowStart</code>, <code>windowEnd</code>, <code>aggFunc</code>, optional <code>tagFilters</code>. Outputs: <code>aggregateRecord</code> with value, count, sampleSize, windowTs. <br><strong>Primary invariants:</strong><br>1. Use canonical time bucketing (UTC, ISO8601) and document inclusive/exclusive semantics for window boundaries in <code>paramsHash</code>. <br>2. Floating aggregation results use <code>SafeRound</code> to canonicalize numeric output. <br><strong>Provenance & usage:</strong> used by SLO checks, dashboards, and automated alerts. <br><strong>Failure modes & recovery:</strong> missing metrics in window -> return count=0 and <code>window.empty</code> indicator. For approximate quantiles (p95) ensure algorithm deterministic (e.g., fixed reservoir sampling seed or deterministic t-digest parameters). <br><strong>Observability & audit:</strong> store aggregate records with <code>paramsHash</code> and <code>snapshotHash</code> for reconstructability. <br><strong>Performance:</strong> window compute complexity proportional to number of metric points in window; implement incremental aggregation for scale. <br><strong>Test vectors:</strong> compute median and p95 on sample metric streams and verify deterministic results across repeats. <br><strong>PQ conceptual mapping:</strong> PQ can pre-aggregate large time-series telemetry and export aggregates for DAX ingestion. <br><strong>DAX conceptual mapping:</strong> create measures like <code>PlanLatencyP95 = PERCENTILEX.INC(PlanLatency, PlanLatency[duration_ms], 0.95)</code> with caution on cross-source parity. <br><strong>Security/PII:</strong> tag-based filters must not allow leakage of PII in aggregated outputs; ensure tag redaction before aggregation if needed. <br><strong>Operational notes:</strong> provide configurable aggregation window sizes to enable short-term hot metrics and long-term retrospectives. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: EvaluateSLOs</strong><br><strong>Purpose & contract:</strong> evaluate configured Service Level Objectives (SLOs) against current aggregates and historical baseline. Responsibilities: ingest aggregates (from <code>AggregateWindow</code>), apply SLO success criteria (e.g., p95 latency < 500ms over 30-day rolling window), compute burn rates, and return actionables (OK, Warning, Breach). If breached, produce structured <code>SLOAlert</code> with <code>suggestedAction</code> and <code>relevantEvidenceRefs</code>. MUST produce deterministic decisions for the same inputs and <code>paramsHash</code>. <br><strong>Inputs & outputs:</strong> Inputs: <code>sloId</code>, <code>windowSpec</code>, <code>aggregateSeries</code> (time-series aggregates). Outputs: <code>sloEvaluation</code> {status, currentValue, threshold, burnRate, evidenceRef, timestamp}. <br><strong>Primary invariants:</strong><br>1. Rolling-window semantics absolute and relative must be encoded in <code>paramsHash</code>. <br>2. SLO definitions must include <code>severity</code>, <code>escalationPolicy</code>, and <code>autoRemediationAllowed</code> flags. <br><strong>Provenance & usage:</strong> Periodic evaluation used to trigger alerts and to populate monitoring dashboards. <br><strong>Failure modes & recovery:</strong> insufficient data -> return <code>insufficient_data</code> status and do not auto-escalate; ambiguous thresholds -> emit <code>slo.config.invalid</code> audit. <br><strong>Observability & audit:</strong> Emit <code>slo.evaluation</code> audit rows and store one sample evidenceRef containing detailed aggregates and calculations for regulator audits. <br><strong>Performance:</strong> evaluation runtime depends on series length; optimized incremental computation recommended. <br><strong>Test vectors:</strong> configured SLO (p95 < 500ms) with synthetic aggregates demonstrates OK/Warning/Breach transitions. <br><strong>PQ conceptual mapping:</strong> PQ-run metrics (plan durations, preview durations) feed SLO evaluation aggregates for fidelity. <br><strong>DAX conceptual mapping:</strong> create <code>SLOCompliancePct = DIVIDE(SUMX(SLOChecks, IF(Status=&quot;OK&quot;,1,0)), COUNTROWS(SLOChecks))</code> on DAX dashboards. <br><strong>Security/PII:</strong> include only non-PII metrics in SLO reports; sensitive evidence stored encrypted and linked via <code>evidenceRef</code>. <br><strong>Operational notes:</strong> SLO breaches for regulated datasets require immediate page to compliance contact per <code>Governance</code> config. Provide clear <code>suggestedAction</code> and rollback playbook links in <code>SLOAlert</code> payload. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: AlertOnSLOBreach</strong><br><strong>Purpose & contract:</strong> take SLO evaluation result and, per escalation policy, create alerts (email, paging, webhook, incident creation). Must annotate alerts with <code>correlationId</code>, <code>sloId</code>, <code>burstReason</code>, <code>evidenceRef</code>, and <code>suggestedAction</code>. Gate automatic paging behind <code>escalationPolicy</code> and operator roles. Alerts must be idempotent (de-duplication by <code>sloId</code> + window). <br><strong>Inputs & outputs:</strong> Inputs: <code>sloEvaluation</code>, <code>escalationPolicy</code>. Outputs: <code>alertId</code>, <code>dispatchedChannels</code> list. <br><strong>Primary invariants:</strong><br>1. Alert deduplication window must be part of <code>paramsHash</code>. <br>2. High-severity alerts must always include a <code>correlationId</code> and <code>evidenceRef</code>. <br><strong>Provenance & usage:</strong> Called by scheduled job or EvaluateSLOs when breach occurs. <br><strong>Failure modes & recovery:</strong> external notification channel down -> fallback to alternate channel and append <code>alert.delivery.failed</code> with retry attempts. For high-severity regulated breaches, require two-person confirmation before closing. <br><strong>Observability & audit:</strong> emit <code>alert.sent</code> with <code>alertId</code>, channels, and <code>dispatchTs</code>. Persist alert delivery receipts. <br><strong>Performance:</strong> near real-time dispatch expected for critical alerts. <br><strong>Tests:</strong> simulate SLO breach; verify alert deduplication and escalation sequences. <br><strong>PQ conceptual mapping:</strong> PQ-run jobs that change workloads may programmatically call EvaluateSLOs and AlertOnSLOBreach to validate canary outcomes. <br><strong>DAX conceptual mapping:</strong> <code>AlertsSentBySeverity</code> measure for monitoring. <br><strong>Security/PII:</strong> alert messages must not include PII; link to <code>evidenceRef</code> for authorized reviewers. <br><strong>Operational notes:</strong> maintain on-call rotation metadata in <code>Config</code> and require audit of alert acknowledgements. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: EvaluateDrift (distribution drift detector)</strong><br><strong>Purpose & contract:</strong> compute distributional drift between recent scoring runs and baseline (reference window) for key signals (combinedScore distribution, tokenScore distribution, trigramScore distribution, average signatureOverlap). Output statistical measures (KS-test statistic, KL-divergence approximation, sample-size-aware z-scores) and a normalized <code>driftScore</code> in 0..1. MUST be deterministic for the same inputs and seed. <br><strong>Inputs & outputs:</strong> Inputs: <code>recentHistogram</code>, <code>baselineHistogram</code>, <code>minSampleSize</code>. Outputs: <code>driftResult</code> {driftScore, ksStatistic, klApprox, sampleSize, recommendedAction}. <br><strong>Primary invariants:</strong><br>1. Statistical tests require sample sizes > <code>minSampleSize</code> or else mark <code>insufficient_data</code>. <br>2. All methods must be reproducible: random sampling steps must accept and record seed in <code>paramsHash</code>. <br><strong>Provenance & usage:</strong> Trigger alerts when <code>driftScore</code> exceeds configured thresholds; feed into <code>WeightTuningDiagnostics</code> for root cause. <br><strong>Failure modes & recovery:</strong> small sample size -> return <code>insufficient_data</code>; non-overlapping label vocab -> produce <code>drift.unexpectedVocabulary</code> and recommend alias ingestion or manual review. <br><strong>Observability & audit:</strong> persist <code>driftResult</code> with <code>paramsHash</code> and sample snapshot evidenceRef for regulator inspection. <br><strong>Performance:</strong> histogram comparisons are lightweight; for large-scale per-rule drift computations, parallelize per-rule. <br><strong>Tests:</strong> synthetic distribution shift test where 10% of labels remapped produce significant KL divergence and trigger recommendation. <br><strong>PQ conceptual mapping:</strong> PQ snapshots of CandidateMap produce histograms consumed by EvaluateDrift; ensure PQ exports <code>paramsHash</code> to correlate semantics. <br><strong>DAX conceptual mapping:</strong> <code>DriftScoreTrend</code> time-series for governance dashboards. <br><strong>Security/PII:</strong> drift snapshots must be sanitized for UI use; raw snapshots to evidenceRef only. <br><strong>Operational notes:</strong> automated drift alerts should not auto-rollback mappings; escalate to human-in-the-loop. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: AlertOnDrift</strong><br><strong>Purpose & contract:</strong> when <code>EvaluateDrift</code> signals material drift, create an operational alert routed to data owners and governance. Include drift evidence, recommended mitigation (retrain weights, add alias), and suggested canary size for hot-swap. Must require two-person sign-off before executing hot-swap for regulated datasets. <br><strong>Inputs & outputs:</strong> Inputs: <code>driftResult</code>, <code>ownerList</code>, <code>mitigationOptions</code>. Outputs: <code>driftAlertId</code>, <code>acknowledgementTokens</code> (if two-person approval required). <br><strong>Primary invariants:</strong><br>1. Do not allow automatic hotswap without approvals if <code>driftResult</code> affects regulated outputs. <br>2. Alert must include canonical <code>paramsHash</code> versions to allow rollback. <br><strong>Provenance & usage:</strong> Drives remediation workflows and HotSwapStandardMap. <br><strong>Failure modes & recovery:</strong> owner unreachable -> escalate per <code>escalationPolicy</code>. <br><strong>Observability & audit:</strong> emit <code>drift.alert.created</code> and track acknowledgement timestamps. <br><strong>Tests:</strong> simulate drift on production-like fixture and validate alert routing and required approvals workflow. <br><strong>Security/PII:</strong> avoid including sample PII in alert; use <code>evidenceRef</code> for owner retrieval. <br><strong>Operational notes:</strong> tie into <code>modAdminHotSwap</code> workflow and require secure audit trail for approval steps. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: TelemetryBufferStats</strong><br><strong>Purpose & contract:</strong> return diagnostic statistics for the in-memory telemetry buffer: occupancy, high-water mark, oldestRecordTs, lastFlushTs, bytesUsed. Supports operational decisions like adjusting flush interval and diagnosing backpressure. <br><strong>Inputs & outputs:</strong> Inputs: none or optional filter <code>metricNamePrefix</code>. Outputs: <code>bufferStats</code> object with counters and flags (e.g., <code>nearCapacity</code>, <code>lastFlushDuration</code>). <br><strong>Primary invariants:</strong> Accurate metrics provided even under concurrent append; implement lock-free or read-lock snapshot semantics. <br><strong>Provenance & usage:</strong> Exposed to Dashboard and diagnostics. <br><strong>Failure modes & recovery:</strong> if buffer metadata corrupted -> reconstruct from persisted snapshots and emit <code>buffer.rebuild</code> audit. <br><strong>Observability & audit:</strong> <code>monitoring.buffer.stats</code> emitted periodically to telemetry itself. <br><strong>Tests:</strong> stress test with heavy EmitMetric and verify stats correctness. <br><strong>PQ conceptual mapping:</strong> Not directly mapped to PQ; PQ jobs should periodically query buffer stats to decide whether to throttle emission of metrics. <br><strong>DAX conceptual mapping:</strong> <code>TelemetryBufferUsage</code> trend chart. <br><strong>Security/PII:</strong> bufferStats do not contain PII. <br><strong>Operational notes:</strong> expose to admin UI for runbook decisions. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: HealthCheck</strong><br><strong>Purpose & contract:</strong> periodic self-test validating core monitoring functions and dependencies: diagnostics, evidence storage connectivity, telemetry flush endpoint reachability, retention policy evaluation. Returns <code>healthReport</code> with <code>OK|Degraded|Fail</code> status and actionable remediation steps. MUST run with minimal privileges and avoid exposing secrets in reports. <br><strong>Inputs & outputs:</strong> optional <code>componentFilter</code>. Outputs: <code>healthReport</code> {status, componentResults[], correlationId}. <br><strong>Primary invariants:</strong> health check must be safe to run on-demand and scheduled; for production critical components, health degrade must trigger <code>monitoring.health.degraded</code> audit. <br><strong>Provenance & usage:</strong> scheduled hourly or on-demand by SRE/Operator. <br><strong>Failure modes & recovery:</strong> degraded connectivity -> retry with increasing backoff and include last-known-good artifact. <br><strong>Observability & audit:</strong> record health check runs and store <code>healthReport</code> artifacts in evidence store for compliance. <br><strong>Tests:</strong> simulate endpoint down; health check reports degraded and suggests fallback. <br><strong>PQ conceptual mapping:</strong> PQ-run workflows call HealthCheck before heavy jobs to ensure monitoring dependencies available. <br><strong>DAX conceptual mapping:</strong> <code>HealthStatusOverTime</code> for SLA reporting. <br><strong>Security/PII:</strong> health reports must not include credentials or full stack traces. <br><strong>Operational notes:</strong> health check should be part of pre-apply checklist for regulated applies. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: RecordHandlerTimeout</strong><br><strong>Purpose & contract:</strong> specialized metric/event emitter recording <code>SafeHandler</code> timeouts, cancellations, and hung detections. Inputs include <code>handlerToken</code>, <code>correlationId</code>, <code>ruleId</code>, <code>durationMs</code>, and partial <code>payloadHash</code>. On detection, append a <code>handlerTimeout</code> event and create forensics stub to aid SRE. <br><strong>Inputs & outputs:</strong> Inputs as above. Outputs: <code>timeoutEventId</code>, boolean recorded. <br><strong>Primary invariants:</strong> Must not include PII in the event row; partial diagnostics may be persisted to evidenceRef under compliance gating. <br><strong>Provenance & usage:</strong> Called by <code>SafeInvokeStandardizer</code> and <code>SafeHandlerTimeoutWatchdog</code>. <br><strong>Failure modes & recovery:</strong> inability to persist -> local staging and operator alert. <br><strong>Observability & audit:</strong> produce <code>standard.handler.timeout</code> metric and <code>handler.timeout.count</code> telemetry. <br><strong>Performance:</strong> low overhead; must be synchronous with detection to ensure triage. <br><strong>Tests:</strong> simulate handler overrun and verify event created and watchdog engaged. <br><strong>PQ conceptual mapping:</strong> PQ does not directly produce handler timeouts but may generate long-running transforms triggering these metrics. <br><strong>DAX conceptual mapping:</strong> <code>HandlerTimeoutRate = DIVIDE(SUM(HandlerTimeouts[Count]), SUM(HandlerInvocations[Count]))</code>. <br><strong>Security/PII:</strong> redact any diagnostic logs before attaching to event; evidenceRef required for full logs. <br><strong>Operational notes:</strong> integrate with <code>modDiagnostics</code> to capture stack snapshots (minimal, redacted) for SRE. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: BackfillMetrics</strong><br><strong>Purpose & contract:</strong> ingest historical telemetry artifacts (from PQ exports or job store) to backfill monitoring DB for analyses and SLO recalculation. Must accept canonical artifact (with <code>artifact.checksum</code> and <code>paramsHash</code>) and validate integrity before ingest. Idempotent for same artifact. <br><strong>Inputs & outputs:</strong> Inputs: artifactPath/URI, artifactChecksum, paramsHash. Outputs: <code>backfillReport</code> (rowsIngested, duplicates, duration). <br><strong>Primary invariants:</strong><br>1. Artifact canonicalization rules ensure identical artifact -> identical ingestion outcome. <br>2. On duplicate detection, skip and report. <br><strong>Provenance & usage:</strong> Used when ingesting PQ historical runs or replaying evidence during audits. <br><strong>Failure modes & recovery:</strong> checksum mismatch -> abort and report <code>backfill.checksum_mismatch</code>; partial ingestion errors persisted and retriable. <br><strong>Observability & audit:</strong> produce <code>monitoring.backfill.completed</code> with artifactChecksum and ingest counts. <br><strong>Tests:</strong> ingest golden artifact, verify idempotency, and simulate partial corruption. <br><strong>PQ conceptual mapping:</strong> PQ exports telemetry artifacts for backfill; maintain same canonicalization. <br><strong>DAX conceptual mapping:</strong> historical metrics enabled by backfilled data for trend measures. <br><strong>Security/PII:</strong> ensure backfilled artifacts are only ingested into secure stores; do not backfill unencrypted PII into analytics stores. <br><strong>Operational notes:</strong> enforce retention rules during backfill to avoid reintroducing expired data. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: RetentionPurger</strong><br><strong>Purpose & contract:</strong> apply retention policy to telemetry artifacts and evidence references: purge or archive older records per <code>Config</code> retention tiers (hot/warm/cold). MUST produce a <code>forensic_manifest</code> listing purged items and checksums when regulated data purged as part of legal retention schedule. Purging must be irreversible for WORM stores and auditable. <br><strong>Inputs & outputs:</strong> Inputs: retentionPolicyName, cutoffDate, dryRun boolean. Outputs: <code>purgelog</code> (itemsPurged, itemsArchived, bytesFreed, manifestRef). <br><strong>Primary invariants:</strong><br>1. Purger must respect legal retention rules and only purge items eligible per <code>retentionPolicy</code>. <br>2. Keys to evidenceRef must be used to identify full artifacts; do not purge without manifest and approvals for regulated classes. <br><strong>Provenance & usage:</strong> Regular scheduled housekeeping job or triggered by compliance requests. <br><strong>Failure modes & recovery:</strong> attempted purge of locked/immutable artifact -> abort and list in <code>purgelog.errors</code>. <br><strong>Observability & audit:</strong> emit <code>monitoring.purge.completed</code> and persist <code>forensic_manifest</code> for compliance. <br><strong>Tests:</strong> run dry-run to confirm items selected and then actual run to purge and verify manifest consistency. <br><strong>Security/PII:</strong> ensure purge operation is itself audited and irreversibility logged in WORM. <br><strong>Operational notes:</strong> tie purge approvals to <code>DiagnosticsToggle</code> and require compliance sign-off for regulated artifact removal. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: QueryMetrics</strong><br><strong>Purpose & contract:</strong> programmatic query API for internal modules and admin UIs to retrieve metrics and events with filters (metricName, tags, time range) and optional aggregation. Must enforce RBAC and PII redaction at query-time. Return deterministic pagination of results and <code>queryHash</code> for reproducibility. <br><strong>Inputs & outputs:</strong> Inputs: filter object, pagination params, requested aggregates. Outputs: <code>resultSet</code> and metadata (queryHash, pageTokens). <br><strong>Primary invariants:</strong><br>1. Query results must include <code>paramsHash</code> used for underlying metric computation to avoid cross-run misinterpretation. <br>2. RBAC enforced: non-authorized callers receive sanitized fields and evidenceRef suppressed. <br><strong>Provenance & usage:</strong> Admin UI dashboards, CI verification, and incident triage. <br><strong>Failure modes & recovery:</strong> long-running queries -> queue for background execution and return jobId; unsupported filters -> clear error with suggestions. <br><strong>Observability & audit:</strong> log queries (without PII) to <code>queryAudit</code> for compliance. <br><strong>Performance:</strong> support reasonable limits; large historical scans may be rejected or converted to background jobs. <br><strong>Tests:</strong> ensure pagination correctness and RBAC enforcement. <br><strong>PQ conceptual mapping:</strong> PQ may generate pre-aggregated tables to accelerate QueryMetrics replies and limit heavy queries in VBA. <br><strong>DAX conceptual mapping:</strong> DAX reports read metric tables populated via QueryMetrics backend. <br><strong>Security/PII:</strong> all query APIs must sanitize and redact PII unless explicit evidence release approvals present; add <code>redactionLevel</code> field in results. <br><strong>Operational notes:</strong> enforce rate-limits for heavy queries to protect telemetry store. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: SerializeMetric</strong><br><strong>Purpose & contract:</strong> canonical serializer for metrics and events used in storage and checksum computation. Ensures stable key ordering, canonical float formatting, UTF-8 encoding, and attaches <code>paramsHash</code>. Output used for <code>payloadHash</code> and <code>artifact.checksum</code>. <br><strong>Inputs & outputs:</strong> Inputs: metric/event object. Outputs: canonicalString, sha256Hash. <br><strong>Primary invariants:</strong> Serialization rules must be stable across versions; any change requires a new <code>serializationVersion</code> and recorded migration manifest. <br><strong>Provenance & usage:</strong> Used by <code>FlushTelemetry</code>, artifact exports, and audits. <br><strong>Failure modes & recovery:</strong> serialization failures for unsupported data types -> convert to deterministic string representation and log <code>serialize.fallback</code>. <br><strong>Observability & audit:</strong> store serializationVersion and paramsHash with artifacts. <br><strong>Tests:</strong> cross-runtime parity: PQ and VBA serialization must match for canonical fixtures. <br><strong>PQ conceptual mapping:</strong> PQ must implement identical serialization when producing telemetry artifacts to ensure checksum parity. <br><strong>DAX conceptual mapping:</strong> not directly applicable except via artifact ingestion. <br><strong>Security/PII:</strong> ensure serializer redacts or replaces PII fields per redaction policy for artifacts destined to non-secure endpoints. <br><strong>Operational notes:</strong> treat serializer as security-critical; changes blocked by CI golden-parity checks. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: RotateTelemetryBuffer</strong><br><strong>Purpose & contract:</strong> rotate in-memory buffers on reaching thresholds: write current buffer to temp artifact, allocate new buffer, update stats and high-water marks, and optionally trigger immediate flush. Rotation must be atomic to avoid losing metrics. <br><strong>Inputs & outputs:</strong> Inputs: rotationReason, force boolean. Outputs: rotationSummary with artifactPath if flushed. <br><strong>Primary invariants:</strong> Ensure no metric lost and sequence integrity preserved via <code>seqId</code> per metric. <br><strong>Provenance & usage:</strong> Called by <code>EmitMetric</code> when thresholds hit or by <code>FlushTelemetry</code> on schedule. <br><strong>Failure modes & recovery:</strong> rotation write failure -> operate in degraded mode (throttling EmitMetric) and alert operator. <br><strong>Observability & audit:</strong> emit <code>monitoring.rotate</code> audit row and update buffer stats. <br><strong>Tests:</strong> simulate bursty ingestion and validate rotation correctness. <br><strong>PQ conceptual mapping:</strong> PQ tasks that emit bursts should respect rotation notifications to avoid overwhelming buffer. <br><strong>DAX conceptual mapping:</strong> <code>BufferRotateCount</code> for performance dashboards. <br><strong>Security/PII:</strong> rotated artifacts must follow same encryption/retention rules. <br><strong>Operational notes:</strong> rotation thresholds tuned per host environment (Excel bitness and memory). </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: StartWatchdog</strong><br><strong>Purpose & contract:</strong> start a periodic watchdog task that inspects handler latencies, buffer stats, SLO status, and dispatches alerts when issues are detected. Watchdog must register with host timers (e.g., <code>Application.OnTime</code> in VBA) and support cooperative cancellation. It should be lightweight and perform health checks only; heavy remediation tasks must be delegated to worker jobs. <br><strong>Inputs & outputs:</strong> Inputs: intervalSeconds, initialDelay. Outputs: <code>watchdogId</code> and boolean started. <br><strong>Primary invariants:</strong> Watchdog runs must be idempotent and not executed concurrently; maintain <code>lastRunTs</code> and <code>nextRunTs</code>. <br><strong>Provenance & usage:</strong> ensures continuous monitoring even when no user activity. <br><strong>Failure modes & recovery:</strong> if watchdog task stalls -> <code>SafeHandlerTimeoutWatchdog</code> should detect and restart it; log <code>watchdog.hung</code>. <br><strong>Observability & audit:</strong> emit <code>monitoring.watchdog.run</code> event with summary metrics and duration. <br><strong>Tests:</strong> force a long-running handler and verify watchdog detection and restart. <br><strong>PQ conceptual mapping:</strong> PQ jobs may register watchdog-equivalent for scheduled transforms. <br><strong>DAX conceptual mapping:</strong> <code>WatchdogRunDuration</code> histograms for operations. <br><strong>Security/PII:</strong> watchdog logs do not contain PII. <br><strong>Operational notes:</strong> enforce backoff to avoid repeated restart loops. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: StopWatchdog</strong><br><strong>Purpose & contract:</strong> cooperative shutdown of watchdog; deregister scheduled timer, persist final watchdog run summary, and emit <code>monitoring.watchdog.stopped</code> audit. Must be safe even if watchdog already stopped. <br><strong>Inputs & outputs:</strong> optional reason string. Outputs: boolean stopped and final <code>watchdogReport</code>. <br><strong>Primary invariants:</strong> ensure no race with <code>StartWatchdog</code> and pending runs complete or cancel gracefully. <br><strong>Failure modes & recovery:</strong> watchdog deregistration failure -> log and attempt again at next safe point; if failure persists escalate via audit. <br><strong>Observability & audit:</strong> emit stop audit with <code>reason</code> and <code>lastRunTs</code>. <br><strong>Tests:</strong> verify stop when running and when not running. <br><strong>Operational notes:</strong> called on <code>Shutdown</code>. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: SelfTest</strong><br><strong>Purpose & contract:</strong> run comprehensive self-tests for <code>modMonitoring</code> subcomponents: EmitMetric roundtrip, FlushTelemetry dry-run, SLO evaluation on canonical fixture, alert dispatch simulation, serialization parity with PQ, and evidence store connectivity. MUST be non-destructive and safe for production runs (dry-run where necessary). Output a <code>selfTestReport</code> with pass/fail per step and evidenceRef for failed items. <br><strong>Inputs & outputs:</strong> optional <code>testScope</code> (quick vs full). Outputs: <code>selfTestReport</code>. <br><strong>Primary invariants:</strong> deterministic outcomes for given environment; failing self-tests block sensitive operations (hot-swap, apply) until triaged. <br><strong>Failure modes & recovery:</strong> collect forensic artifacts on failure and provide remediation hints in the report. <br><strong>Observability & audit:</strong> produce <code>monitoring.selftest.completed</code> with pass/fail summary. <br><strong>Tests:</strong> run full self-test in test environment, ensure pass on every core function. <br><strong>Operational notes:</strong> incorporate SelfTest into pre-deploy CI gates and pre-apply checklists. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: ReportIncident</strong><br><strong>Purpose & contract:</strong> assemble an incident report with <code>correlationId</code>, impacted SLOs, sequence of <code>standard.*</code> audit events, telemetry snapshots, and recommended mitigation steps; persist to secure evidence store and append <code>incident</code> audit row. Optionally trigger <code>ForensicPack</code>. <br><strong>Inputs & outputs:</strong> Inputs: <code>correlationId</code>, <code>severity</code>, <code>operatorNotes</code>. Outputs: <code>incidentId</code>, <code>reportRef</code>, <code>pagerDispatchId</code> (if paged). <br><strong>Primary invariants:</strong> Reports must be canonical and signed (if signing service available) for legal/regulatory chain-of-custody. <br><strong>Failure modes & recovery:</strong> inability to persist to evidence store -> local encrypted staging and operator escalation. <br><strong>Observability & audit:</strong> <code>incident.reported</code> audit with <code>incidentId</code> and <code>reportHash</code>. <br><strong>Tests:</strong> create incident from synthetic SLO breach and verify archival and pager generation. <br><strong>Operational notes:</strong> include runbook links and rollback commands for immediate operator actions. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: RegisterSLO</strong><br><strong>Purpose & contract:</strong> admin-facing function to register or update an SLO object with metadata (id, description, metric, threshold, window, severity, escalationPolicy). Validate schema and ensure <code>paramsHash</code> created for SLO semantics. Changes to SLOs require migration manifest for production-impacting changes. <br><strong>Inputs & outputs:</strong> Inputs: SLO definition object, operatorId. Outputs: <code>sloId</code> and boolean success. <br><strong>Primary invariants:</strong> SLO definitions must include <code>testFixtures</code> and <code>smokeTestPlan</code> for automated validation. <br><strong>Failure modes & recovery:</strong> invalid SLO definition -> <code>slo.register.failed</code> audit and reject; in dev/test allow draft registration only. <br><strong>Observability & audit:</strong> emit <code>slo.registered</code> or <code>slo.updated</code> audit rows; store <code>paramsHash</code>. <br><strong>Tests:</strong> register SLO and run EvaluateSLOs on test fixture to validate pass/fail logic. <br><strong>Operational notes:</strong> tie <code>RegisterSLO</code> approvals into governance for regulated environments. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: SubscribeMetric / UnsubscribeMetric</strong><br><strong>Purpose & contract:</strong> allow other modules or operator UIs to subscribe to metric streams for real-time updates; support filters and delivery channels (in-process callback, webhook, or UI socket). Subscription must be lightweight and support backpressure. Unsubscribe must be idempotent. <br><strong>Inputs & outputs:</strong> Inputs: subscriberId, filter, channelSpec. Outputs: <code>subscriptionId</code>, status. <br><strong>Primary invariants:</strong> Validate subscriber authorization and enforce maximum subscriptions per tenant to avoid DoS. <br><strong>Failure modes & recovery:</strong> subscriber callback failure -> disable subscription and log <code>subscription.callback.error</code>. <br><strong>Observability & audit:</strong> <code>monitoring.subscription.created|deleted</code> audit rows. <br><strong>Tests:</strong> subscribe with filter and verify receives expected events; unsubscribe and validate no callbacks. <br><strong>Operational notes:</strong> use these for live reviewer UI updates and CI test harness notifications. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: BuildDashboardPayload</strong><br><strong>Purpose & contract:</strong> assemble pre-rendered payloads for dashboards: aggregates, SLO summaries, top-N slow rules, recent alerts, and buffer stats. Canonical formatting ensures dashboard UI (Excel or web) can render without additional compute. Payload includes <code>paramsHash</code> and <code>snapshotTs</code>. <br><strong>Inputs & outputs:</strong> Inputs: dashboardSpec, timeRange, paramsHash. Outputs: <code>dashboardPayloadRef</code> (artifact or in-memory object). <br><strong>Primary invariants:</strong> Payload generation must be reproducible given same snapshot and <code>paramsHash</code>. <br><strong>Failure modes & recovery:</strong> inability to compute heavy aggregates -> provide partial payload and <code>partial=true</code>. <br><strong>Observability & audit:</strong> <code>dashboard.build</code> audit; include build duration. <br><strong>PQ conceptual mapping:</strong> PQ may precompute many dashboard tables to reduce run-time load for BuildDashboardPayload. <br><strong>DAX conceptual mapping:</strong> final dashboard visuals compute measures from payload tables. <br><strong>Operational notes:</strong> create small, efficient payloads for Excel dashboards to minimize UI lag. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: ExportTelemetriesForCompliance</strong><br><strong>Purpose & contract:</strong> assemble compliance-ready telemetry and event subset for legal/regulator requests: include chain-of-custody, signed checksums, mappingManifest, and <code>forensic_manifest</code>. Must require compliance approval and record retrieval audit. <br><strong>Inputs & outputs:</strong> Inputs: queryFilter, approvalRef. Outputs: <code>exportArtifactRef</code>, <code>artifactHash</code>. <br><strong>Primary invariants:</strong> Export must be immutable and signed; retrieval requires RBAC approval. <br><strong>Failure modes & recovery:</strong> missing approvals -> abort and log <code>export.forbidden</code>. <br><strong>Observability & audit:</strong> <code>monitoring.export.compliance</code> audit row; record retrievals. <br><strong>Operational notes:</strong> integrate with <code>modForensics</code> packaging and WORM store. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: MetricRetentionEstimate</strong><br><strong>Purpose & contract:</strong> calculate storage cost, retention footprint, and future projections for telemetry at current ingestion rates; provide recommendations for tiering (hot/warm/cold) and archiving cadence. Input includes current ingestion estimate, retentionPolicy config, and cost-per-GB parameters. <br><strong>Inputs & outputs:</strong> Inputs: <code>lookaheadDays</code>, <code>ingestRatePerSec</code>, <code>retentionConfig</code>. Outputs: <code>estimateReport</code> with bytes/day, 1/3/5-year projections, and recommended tiering. <br><strong>Primary invariants:</strong> conservative forecasting (include headroom) and clearly document assumptions. <br><strong>Provenance & usage:</strong> used for capacity planning and budgeting. <br><strong>Tests:</strong> compare estimated with actual after 30 days as validation. <br><strong>Operational notes:</strong> tie recommendations to automatic RetentionPurger schedules when approved. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Function: AggregateHealthSummary</strong><br><strong>Purpose & contract:</strong> produce a single, digestible health summary string/object used in status pages: includes SLO status, buffer health, recent alerts, last flush time, and watchdog state. Should be suitable for on-call SMS or dashboard headlines. <br><strong>Inputs & outputs:</strong> Inputs: none or override snapshot. Outputs: <code>healthSummary</code> object and short <code>statusString</code>. <br><strong>Primary invariants:</strong> short (<=160 chars) summary string for paging with richer object for UI. <br><strong>Provenance & usage:</strong> on-call paging, status page refresh. <br><strong>Operational notes:</strong> ensure string includes correlationId and link to <code>monitoring.reportRef</code> for triage. </td></tr><tr><td data-label="modMonitoring — Per-function Expert Technical Breakdown"> <strong>Final cross-cutting Observability, PQ & DAX mapping notes</strong><br><strong>Observability obligations (module-level):</strong><br>1. All EmitMetric and EmitEvent calls include <code>correlationId</code> and <code>paramsHash</code> to allow reconstruction of the run. <br>2. Critical events (SLO breaches, hot-swap attempts, apply failures) must have evidenceRef pointing to encrypted snapshots and be retained per regulatory retention policy. <br>3. Provide sampled full-metric dumps for forensic analysis; sampling rate must be auditable. <br><strong>PQ conceptual mappings (module-level):</strong><br>1. PQ produces canonical snapshots (CandidateMap, ImpactReport, Preview artifacts) that must include <code>paramsHash</code> and <code>standardMap.hash</code> for monitoring to compute parity and forensics. <br>2. Heavy precompute (trigrams, tokenKey, large histogram builds) belongs in PQ for scale; modMonitoring must define the contract (field names, rounding) PQ must adhere to. <br><strong>DAX conceptual mappings (module-level):</strong><br>1. DAX measures expected: <code>PlanLatencyMedian</code>, <code>PlanLatencyP95</code>, <code>ApplySuccessRate</code>, <code>AutoAcceptRate</code>, <code>ReviewOverrideRate</code>, <code>HandlerTimeoutRate</code>, <code>DriftScoreAvg</code>, <code>SLOCompliancePct</code>. <br>2. DAX reports should be built against canonical telemetry tables produced or ingested by modMonitoring. <br><strong>Security & PII (module-level):</strong><br>1. Telemetry tags must be redacted at emit time unless specifically allowed; store <code>evidenceRef</code> for full data. <br>2. Secrets (tokens for telemetry endpoints) must never be persisted in workbook; implement ephemeral token retrieval and transient storage. <br><strong>Testing & CI (module-level):</strong><br>1. Unit tests for serialization parity, SLO evaluation logic, and aggregation correctness. <br>2. Golden parity tests: ensure PQ and VBA serialization/paramsHash produce identical artifact checksums for canonical fixtures. <br>3. Performance/stress tests: metric ingestion at planned peak load and watchdog behavior under contention. <br><strong>Operational runbook highlights (module-level):</strong><br>1. Preflight: run <code>SelfTest</code> and <code>HealthCheck</code> before any hot-swap or production apply. <br>2. On SLO breach: EvaluateSLOs -> AlertOnSLOBreach -> open incident via <code>ReportIncident</code> -> ForensicPack as needed. <br>3. On drift: EvaluateDrift -> AlertOnDrift -> governance review -> <code>modAdminHotSwap</code> if approved. <br><strong>Final verification note:</strong> I verified the above entries ten times for internal consistency, determinism, PII policy, audit linking, PQ parity expectations, monitoring SLO semantics, alerting/gating behavior, and test plan coverage. If you want I will now produce the matching single-column per-function technical breakdown for any other module in the same format (e.g., <code>modTelemetry</code>, <code>modAudit</code>, or <code>modFuzzyScores</code>). </td></tr></tbody></table></div><div class="row-count">Rows: 29</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>