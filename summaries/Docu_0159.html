<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1766850683">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li>
<li class="toc-item"><a class="toc-link" href="#Table6">Table 6</a></li>
<li class="toc-item"><a class="toc-link" href="#Table7">Table 7</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0159_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modCalculations)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modCalculations)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Overview:</strong> This table documents <code>modCalculations</code> (VBA) at a per-function level. Each entry records: purpose, signature, inputs/outputs, internal behaviour, complexity, side-effects, invariants, failure modes, recommended tests, and maintainer notes. The implementation preserves public signatures, centralizes rounding/error routing, defers to <code>modConfig</code>/<code>modUtilities</code> when present, and prefers safe conversions and best-effort central logging. Use this as authoritative inline technical documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Constants & Enums</strong> — <em>module metadata & domain primitives</em><br><strong>Purpose:</strong> Central constants and enums define versioning, feature defaults, numeric limits and business enums used across functions.<br><strong>Members:</strong> <code>MODCALC_VERSION</code>, <code>DEFAULT_*</code>, <code>PV_MAX_NPER</code>, <code>TINY_RESIDUAL_THRESHOLD</code>, <code>RATE_NEAR_ZERO</code>, <code>DepMethod</code> enum, <code>RoundingPolicy</code> enum.<br><strong>Behavior:</strong> Read-only; used to guard numeric edge-cases and to drive rounding/feature behaviour.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Values are treated as stable constants; changing them is breaking for behaviour and tests (especially <code>RATE_NEAR_ZERO</code> and <code>PV_MAX_NPER</code>).<br><strong>Failure modes:</strong> None by themselves but improper values (e.g., extremely small <code>RATE_NEAR_ZERO</code>) can change numeric branching. <br><strong>Tests:</strong> Ensure <code>MODCALC_VERSION</code> increments on behaviour changes; edge-case tests for thresholds. <br><strong>Notes:</strong> Keep version string and numeric guards in sync with tests and CI. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcDepreciation(cost As Double, usefulLife As Double) As Double</strong> — <em>simple SL façade</em><br><strong>Purpose:</strong> Backwards-compatible convenience for straight-line depreciation using default rounding policy.<br><strong>Signature:</strong> <code>CalcDepreciation(Double, Double) -&gt; Double</code> (returns 0 on error).<br><strong>Behavior:</strong> Calls <code>CalcDepreciationEx</code> with <code>depStraightLine</code> and default rounding policy. Error routed to <code>HandleCalcError</code> and returns 0 on failure.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Possible audit/log via error handler on failure.<br><strong>Invariants:</strong> Preserves public signature and behaviour expected by callers. <br><strong>Failure modes:</strong> Invalid numerics or exceptions inside underlying call -> returns 0 and logs. <br><strong>Tests:</strong> SL on typical costs (e.g., 1000,5 ->200), salvage-clamping via underlying. <br><strong>Notes:</strong> Lightweight wrapper; maintain if <code>CalcDepreciationEx</code> signature changes. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcEBITDA(revenue As Double, expenses As Double) As Double</strong> — <em>direct arithmetic</em><br><strong>Purpose:</strong> Compute EBITDA-like simple subtraction (no adjustments).<br><strong>Signature:</strong> <code>CalcEBITDA(Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Returns <code>revenue - expenses</code>. Errors handled centrally.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None (except error audit on exceptions).<br><strong>Invariants:</strong> Pure arithmetic. <br><strong>Failure modes:</strong> Non-numeric inputs produce routed error and 0. <br><strong>Tests:</strong> Positive/negative/zero inputs, very large numbers. <br><strong>Notes:</strong> If future adjustments (e.g., addbacks) required, convert to more explicit API. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcDepreciationEx(cost, usefulLife, method, Optional salvage, Optional unitsProduced, Optional unitsTotal, Optional rounding) As Double</strong> — <em>general depreciation engine</em><br><strong>Purpose:</strong> Compute depreciation per several methods (straight-line, declining balance, sum-of-years, units-of-production) with sanitization and central rounding.<br><strong>Signature:</strong> <code>CalcDepreciationEx(Double, Double, DepMethod, Optional Double, Optional Double, Optional Double, Optional RoundingPolicy) -&gt; Double</code>.<br><strong>Behavior (high level):</strong> Validates numeric inputs; clamps salvage to [0,cost]; enforces <code>usefulLife&gt;0</code> except for units-of-production; implements algorithms:<br>- <strong>Straight-line:</strong> <code>(cost - salvage) / usefulLife</code>.<br>- <strong>Declining balance:</strong> <code>rate = 2/usefulLife</code>, <code>result = cost * rate</code>, clamped ≤ <code>(cost - salvage)</code> and ≥ 0.<br>- <strong>Sum-of-years:</strong> uses integer <code>n = Fix(usefulLife)</code> and <code>sumYears = n*(n+1)/2</code>, <code>result = (cost - salvage) * (n / sumYears)</code> (caller should interpret position/year externally).<br>- <strong>Units-of-production:</strong> requires <code>unitsTotal&gt;0</code>, <code>result = (cost - salvage) * (unitsProduced / unitsTotal)</code>.<br>Finally applies <code>ApplyRounding(result, policy)</code> and returns result. All errors go to <code>HandleCalcError</code> and function returns 0 on error.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error/audit calls on invalid inputs; may call central rounding helpers if configured.<br><strong>Invariants:</strong> <code>0 &lt;= salvage &lt;= cost</code>; returned value >= 0; uses consistent rounding policy. <br><strong>Failure modes:</strong> Invalid numerics, zero/negative usefulLife for non-UoP methods, unitsTotal<=0 for UoP -> logged and returns 0. Rounding policy conversion errors default to module policy. <br><strong>Security:</strong> No I/O; no sensitive data handling. <br><strong>Recommended tests:</strong> Per-method correctness (including boundary cases: salvage>cost, usefulLife fractional, n=0, very large numbers), rounding policy variants, units-production edge cases, and error routing integration (mock <code>modError</code>/<code>modAudit</code>).<br><strong>Notes for maintainers:</strong> Keep tokenization of usefulLife for Sum-of-Years explicit — changing integer truncation breaks outputs; adding new methods must preserve existing signatures and rounding behaviour. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>LeaseAmortizationSchedule(pmt As Double, ratePerPeriod As Double, periods As Long, Optional startDate As Date) As Variant</strong> — <em>period-by-period amortization generator</em><br><strong>Purpose:</strong> Build a 1-based 2D array amortization schedule (Period, OpeningBalance, Payment, Interest, Principal, ClosingBalance). Designed for leases/loan style schedules where payment is known.<br><strong>Signature:</strong> <code>LeaseAmortizationSchedule(Double pmt, Double ratePerPeriod, Long periods, Optional Date) -&gt; Variant (1..n,1..6) or Empty on error</code>.<br><strong>Behavior (detailed):</strong><br>- Validates <code>periods&gt;0</code>.<br>- Computes opening balance via <code>PvFromPmt(pmt, ratePerPeriod, n)</code> and uses absolute value to avoid sign confusion.<br>- Iterative loop for each period computes <code>interest = bal * ratePerPeriod</code> (zeroed for near-zero rates), <code>principal = payment - interest</code> then guards <code>principal</code> between 0 and balance. All numeric outputs go through <code>ApplyRounding</code> at relevant points (payment, interest, principal, balances). Tiny residuals are zeroed using <code>TINY_RESIDUAL_THRESHOLD</code>.<br>- After loop verifies sum(principal) ≈ opening and adjusts last principal/closing if discrepancy beyond tolerance. Returns populated 2D array. Errors routed to <code>HandleCalcError</code> and returns <code>Empty</code> on failure.<br><strong>Complexity:</strong> O(nPeriods).<br><strong>Side-effects:</strong> None besides error/audit on failure; may read rounding/config via <code>ApplyRounding</code> helper.<br><strong>Invariants:</strong> Output array dimensions = <code>n×6</code>; sum of principals ≈ opening (within tolerance). Outstanding balance never negative. Rounding consistent across rows.<br><strong>Failure modes:</strong> Invalid <code>periods</code>, extremely large <code>periods</code> may stress memory; <code>PvFromPmt</code> returning 0 leads to zero opening; potential tiny floating residuals corrected at end. <br><strong>Recommended tests:</strong> Zero rate vs very small rate, large <code>periods</code> near PV cap, sum-principal adjustment correctness, final residual zeroing. <br><strong>Notes:</strong> Payment is expected positive; if callers supply negative semantics, document behavior. Consider adding <code>maxPeriods</code> guard if module runs on low-memory hosts. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>PvFromPmt(pmt As Double, rate As Double, nper As Long) As Double</strong> — <em>robust present value from payment</em> (private)<br><strong>Purpose:</strong> Compute PV for known payment across <code>nper</code> periods; handles near-zero rate and clamps large <code>nper</code> for safety.<br><strong>Signature:</strong> <code>PvFromPmt(Double, Double, Long) -&gt; Double</code>.<br><strong>Behavior:</strong> If <code>nper &lt;= 0</code> returns 0. Clamps <code>nper</code> to <code>PV_MAX_NPER</code>. For <code>Abs(rate) &lt; RATE_NEAR_ZERO</code> uses <code>pmt * n</code>, else computes <code>pmt / rate * (1 - (1+rate)^(-n))</code>. If denom too small the function falls back to <code>pmt * n</code>. Returns absolute value to standardize sign for asset balances. Errors return 0.<br><strong>Complexity:</strong> O(1) (power calculation cost).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Returns non-negative PV value for positive pmt. <br><strong>Failure modes:</strong> Overflow/power extremes mitigated by clamping and fallbacks. <br><strong>Tests:</strong> Zero/near-zero rate, negative rate boundary <code>&gt;-1</code>, large <code>nper</code> behavior, sign normalization. <br><strong>Notes:</strong> Keep <code>PV_MAX_NPER</code> tuned; if financial precision required, consider using higher precision math or spreadsheet functions. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>RecognizeRevenue(transactionPrice As Double, progress As Double) As Double</strong> — <em>simple progress-based revenue recognition</em><br><strong>Purpose:</strong> Return revenue recognized as <code>transactionPrice * progress</code> with validations and rounding.<br><strong>Signature:</strong> <code>RecognizeRevenue(Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates <code>progress</code> numeric and in [0,1]; returns <code>ApplyRounding(transactionPrice * progress)</code>. On invalid input logs error and returns 0. Errors routed centrally.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error audit on invalid input. <br><strong>Invariants:</strong> <code>0 &lt;= progress &lt;= 1</code>; result rounded as configured. <br><strong>Failure modes:</strong> Out-of-range <code>progress</code>, non-numeric inputs. <br><strong>Tests:</strong> Values at 0,1, fractional, invalid, and rounding policy effects. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ImpairmentLoss(carryingAmount As Double, recoverableAmount As Double) As Double</strong> — <em>simple impairment comparator</em><br><strong>Purpose:</strong> Compute impairment loss when <code>recoverableAmount &lt; carryingAmount</code> as rounded difference.<br><strong>Signature:</strong> <code>ImpairmentLoss(Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates numerics; if <code>recoverableAmount &lt; carryingAmount</code> returns <code>ApplyRounding(carryingAmount - recoverableAmount)</code> else 0. Errors go to handler and return 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error/audit on invalid input. <br><strong>Invariants:</strong> Returns non-negative number. <br><strong>Failure modes:</strong> Non-numeric inputs. <br><strong>Tests:</strong> boundary where equal, recoverable bigger, invalid types. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ImpairmentLossByNPV(carryingAmount As Double, cashflows As Variant, discountRate As Double) As Double</strong> — <em>impairment via discounted cash flows</em><br><strong>Purpose:</strong> Compute impairment comparing carrying amount vs NPV of future cashflows; if NPV < carrying => loss = carrying - NPV (rounded).<br><strong>Signature:</strong> <code>ImpairmentLossByNPV(Double, Variant, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Calls <code>NPVFromArray</code> to compute npv. If <code>npv &lt;= 0</code> treats as potential full impairment check; otherwise compares and returns <code>ApplyRounding(carrying - npv)</code> if positive; 0 otherwise. Errors routed centrally. <br><strong>Complexity:</strong> O(N) where N = number of cashflow periods.<br><strong>Side-effects:</strong> May call error logger from <code>NPVFromArray</code> when discount invalid. <br><strong>Invariants:</strong> Numeric conversions via safe helpers. <br><strong>Failure modes:</strong> Bad discount rate, malformed cashflows; NPV false negatives due to numeric issues. <br><strong>Tests:</strong> Scalar and array cashflows, negative/zero NPV behavior, discountRate boundaries (> -1). </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>NPVFromArray(cashflows As Variant, discountRate As Double) As Double</strong> — <em>NPV evaluator with flexible input</em> (private)<br><strong>Purpose:</strong> Compute NPV for scalar or array cashflows; supports arbitrary LBound/UBound arrays and returns 0 on invalid discount rates.<br><strong>Signature:</strong> <code>NPVFromArray(Variant, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates <code>discountRate</code> numeric and <code>&gt; -1</code>. Iterates array from LBound to UBound (or handles scalar as single-period) applying <code>cf / ((1+discountRate)^periodIndex)</code> where <code>periodIndex</code> is 1-based relative to LBound. Uses <code>ToDoubleSafe</code> to coerce CFs. Errors are logged and function returns 0 on failure.<br><strong>Complexity:</strong> O(N) per cashflow count.<br><strong>Side-effects:</strong> None aside from error routing. <br><strong>Invariants:</strong> Deterministic mapping of array bounds to periods. <br><strong>Failure modes:</strong> <code>discountRate &lt;= -1</code>, malformed arrays, non-numeric cashflow entries. <br><strong>Tests:</strong> Arrays with non-zero LBound, scalar path, discount edge values, known sample NPV calculations. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ExpectedCreditLoss(exposure As Double, pd As Double, lgd As Double) As Double</strong> — <em>ECL single-case formula</em><br><strong>Purpose:</strong> Return ECL = exposure × PD × LGD with validation for PD/LGD in [0,1] and rounding.<br><strong>Signature:</strong> <code>ExpectedCreditLoss(Double, Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates numerics and ranges; computes <code>ApplyRounding(exposure * pd * lgd)</code>. On invalid inputs logs and returns 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error/audit on invalid inputs. <br><strong>Invariants:</strong> <code>0 &lt;= pd, lgd &lt;= 1</code>. <br><strong>Failure modes:</strong> Out-of-range parameters, NaN. <br><strong>Tests:</strong> Boundaries (0,1), random combinations, rounding check. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ExpectedCreditLossBatch(exposures As Variant, pds As Variant, lgds As Variant) As Variant</strong> — <em>vectorized ECL over input arrays</em><br><strong>Purpose:</strong> Accept scalar or array inputs for exposures/pds/lgds and return a 1-based array of ECL results; normalizes inputs to common length and applies <code>ExpectedCreditLoss</code> per index.<br><strong>Signature:</strong> <code>ExpectedCreditLossBatch(Variant, Variant, Variant) -&gt; Variant (1..n) or Empty on error</code>.<br><strong>Behavior:</strong> Uses <code>NormalizeArrayInput</code> to produce 1-based arrays; determines <code>n = Max(UBoundSafe(exArr), UBoundSafe(pdArr), UBoundSafe(lgArr))</code>. Iterates 1..n and uses <code>ToDoubleSafeIndex</code> to fetch indexed values and calls <code>ExpectedCreditLoss</code> for each element; returns an array of doubles. Errors logged and returns <code>Empty</code> on top-level exception.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> Error routing on top-level problems. <br><strong>Invariants:</strong> Output length equals computed n; missing elements treated as 0. <br><strong>Failure modes:</strong> Empty inputs produce <code>Array()</code> early; improper array shapes handled defensively. <br><strong>Tests:</strong> Mixed scalar/arrays, unequal lengths, invalid items. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GenerateDepreciationSchedule(cost As Double, usefulLife As Double, Optional method As DepMethod, Optional salvage As Double, Optional startYear As Long, Optional rounding As RoundingPolicy) As Variant</strong> — <em>periodic schedule generator</em><br><strong>Purpose:</strong> Produce a 0-based table (header row at index 0) containing rows for each period with columns: Period, DepreciationExpense, AccumulatedDepreciation, CarryingAmount.<br><strong>Signature:</strong> <code>GenerateDepreciationSchedule(Double, Double, Optional DepMethod, Optional Double, Optional Long, Optional RoundingPolicy) -&gt; Variant (0..periods,1..4) or Empty</code>.<br><strong>Behavior:</strong> Validates <code>usefulLife&gt;0</code>; computes <code>periods = Fix(usefulLife)</code>; iterates 1..periods and computes expense according to method (implementations: SL, declining balance, sum-of-years, units-of-production fallbacks). Expenses are rounded via <code>ApplyRounding(expense, rpolicy)</code> and accumulated. Header row inserted at index 0. Returns <code>out</code> 2D variant. Errors logged and returns <code>Empty</code>.<br><strong>Complexity:</strong> O(periods).<br><strong>Side-effects:</strong> None aside from rounding/config access. <br><strong>Invariants:</strong> Sum of expenses + salvage = cost (subject to rounding); carrying amount never negative. <br><strong>Failure modes:</strong> <code>usefulLife</code> not numeric or ≤0, extremely large periods; rounding aggregate drift — expected and accepted but maintainers should monitor. <br><strong>Tests:</strong> Method-specific sequences, rounding policy checks, startYear mapping. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>DeferredTax(tempDifference As Double, taxRate As Double) As Double</strong> — <em>deferred tax simple product</em><br><strong>Purpose:</strong> Compute deferred tax as <code>tempDifference * taxRate</code> with validation for taxRate in [0,1] and rounding.<br><strong>Signature:</strong> <code>DeferredTax(Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates taxRate numeric and between 0 and 1; returns <code>ApplyRounding(tempDifference * taxRate)</code>. Logs and returns 0 on invalid inputs.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error/audit on invalid input. <br><strong>Invariants:</strong> <code>0 &lt;= taxRate &lt;= 1</code>. <br><strong>Failure modes:</strong> Out-of-range taxRate, non-numeric inputs. <br><strong>Tests:</strong> Boundaries and rounding. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GetRoundPolicy() As Long</strong> — <em>config-driven rounding policy resolver</em> (private)<br><strong>Purpose:</strong> Read configured rounding policy via <code>GetConfigValue</code> and fall back to <code>DEFAULT_ROUNDING_POLICY</code> if missing or invalid.<br><strong>Signature:</strong> <code>GetRoundPolicy() -&gt; Long</code>.<br><strong>Behavior:</strong> Calls <code>GetConfigValue(&quot;modCalculations.RoundPolicy&quot;, DEFAULT_ROUNDING_POLICY)</code> then normalizes numeric/variant types to <code>Long</code>. Errors return default.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Attempts <code>GetConfigValue</code> which calls <code>SafeCallCentral</code> to consult <code>modConfig</code> or global <code>GetConfigValue</code>.<br><strong>Invariants:</strong> Return one of <code>RoundingPolicy</code> values. <br><strong>Failure modes:</strong> Central config missing -> uses default. <br><strong>Tests:</strong> Mock <code>GetConfigValue</code> returns (vbBoolean, vbLong, numeric string) and ensure conversion. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ShouldUseCentralRounding() As Boolean</strong> — <em>config boolean resolver</em> (private)<br><strong>Purpose:</strong> Decide whether to route rounding to centralized helper (e.g., <code>modUtilities</code>) based on config key <code>modCalculations.UseCentralRounding</code>.<br><strong>Signature:</strong> <code>ShouldUseCentralRounding() -&gt; Boolean</code>.<br><strong>Behavior:</strong> Calls <code>GetConfigValue</code> with default; converts variant to boolean by VarType/IsNumeric. Errors → default. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls <code>GetConfigValue</code> (safe-run).<br><strong>Tests:</strong> Ensure true/false numeric/string conversion. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ApplyRounding(value As Double, Optional policy As Variant) As Double</strong> — <em>central rounding entry</em><br><strong>Purpose:</strong> Apply module rounding policy, optionally delegating to centralized rounding helpers if <code>ShouldUseCentralRounding()</code> is true. Provides safe fallbacks to <code>WorksheetRound</code> if central helper absent.<br><strong>Signature:</strong> <code>ApplyRounding(Double, Optional Variant) -&gt; Double</code>.<br><strong>Behavior:</strong> Determines <code>pol</code> via explicit <code>policy</code> or <code>GetRoundPolicy()</code>. If <code>ShouldUseCentralRounding()</code> attempts <code>SafeCallCentral(&quot;modUtilities.ApplyRounding&quot;, r, value, pol)</code> then tries <code>modUtilities.Round</code> variant; if those succeed uses returned value (converted via <code>ToDoubleSafe</code>). Otherwise falls back to internal <code>WorksheetRound</code> implementation for <code>roundNone</code>, <code>roundFinancial</code> (2 decimals), <code>roundInteger</code> (0 decimals). Errors return original <code>value</code> (safe non-destructive fallback).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call external modules via <code>Application.Run</code> (<code>SafeCallCentral</code>) which can produce exceptions that are swallowed and routed to fallback. <br><strong>Invariants:</strong> If central rounding used, result should match central semantics; otherwise deterministic local rounding used. <br><strong>Failure modes:</strong> Central helper present but throws — fallback to local rounding; failure to convert returned type uses <code>ToDoubleSafe</code>. <br><strong>Recommended tests:</strong> Behavior when <code>ShouldUseCentralRounding</code> true/false, central helper returns numeric/non-numeric, policy variations, and rounding edge cases (.5 rounding semantics). <br><strong>Notes:</strong> Keep consistent rounding semantics documented; unit tests must assert parity between central and local rounding in environments where central is enabled. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>WorksheetRound(value As Double, digits As Long) As Double</strong> — <em>worksheet rounding wrapper</em> (private)<br><strong>Purpose:</strong> Use <code>Application.WorksheetFunction.Round</code> but degrade gracefully if unavailable.<br><strong>Signature:</strong> <code>WorksheetRound(Double, Long) -&gt; Double</code>.<br><strong>Behavior:</strong> Calls the worksheet function, returns <code>value</code> on error.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Worksheet Round missing or error -> returns unrounded input; callers must accept this fallback. <br><strong>Tests:</strong> Compare to known rounding for positive and negative values, digits=0 and 2. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ValidateNumeric(v As Variant) As Boolean</strong> — <em>defensive numeric checker</em> (private)<br><strong>Purpose:</strong> Centralize numeric detection and error-resilience when validating inputs.<br><strong>Signature:</strong> <code>ValidateNumeric(Variant) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Returns False for <code>IsError(v)</code> or non-numeric; True if <code>IsNumeric</code>. Uses <code>On Error Resume Next</code> defensively. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Numeric strings, Empty, Null, Error CVErr values. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>NormalizeArrayInput(v As Variant) As Variant</strong> — <em>normalize scalar/array → 1-based array</em> (private)<br><strong>Purpose:</strong> Convert scalar or VB array (any LBound) into a predictable 1-based contiguous 1-D array for batch functions.<br><strong>Signature:</strong> <code>NormalizeArrayInput(Variant) -&gt; Variant (1..n) array</code>.<br><strong>Behavior:</strong> If <code>IsArray(v)</code> copies elements from <code>LBound..UBound</code> into <code>out(1..n)</code>; if scalar returns <code>out(1)=v</code>. Returns zero-length <code>1 To 0</code> when n<=0 or on error. Errors handled and zero-length fallback returned. <br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Output always 1-based if non-empty. <br><strong>Failure modes:</strong> Jagged/bad arrays preserved as values; callers should use <code>SafeArrayLength</code> if uncertain. <br><strong>Tests:</strong> LBound != 0 arrays, scalar input, empty-array input. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ToDoubleSafe(v As Variant, Optional defaultValue As Double = 0#) As Double</strong> — <em>safe numeric coercion</em> (private)<br><strong>Purpose:</strong> Convert variant to Double when numeric; otherwise return default safely without throwing.<br><strong>Signature:</strong> <code>ToDoubleSafe(Variant, Optional Double) -&gt; Double</code>.<br><strong>Behavior:</strong> If <code>IsNumeric(v)</code> returns <code>CDbl(v)</code>, else <code>defaultValue</code>. Errors return default. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Numeric strings, Null, Empty, Error values. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ToDoubleSafeIndex(arr As Variant, idx As Long) As Double</strong> — <em>safe indexed conversion</em> (private)<br><strong>Purpose:</strong> Return <code>ToDoubleSafe</code> for element at <code>idx</code> in array normalized to the calling module's indexed convention; supports scalar fallback when <code>idx=1</code>.<br><strong>Signature:</strong> <code>ToDoubleSafeIndex(Variant, Long) -&gt; Double</code>.<br><strong>Behavior:</strong> If arr is array, computes <code>pos = LBound + idx -1</code> and returns element safely; otherwise if <code>idx=1</code> returns scalar. Returns 0 on out-of-range or errors. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> LBound/UBound boundary, scalar path. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>UBoundSafe(arr As Variant) As Long</strong> — <em>defensive UBound</em> (private)<br><strong>Purpose:</strong> Return <code>UBound(arr)</code> or 0 for non-arrays or errors, swallowing errors.<br><strong>Signature:</strong> <code>UBoundSafe(Variant) -&gt; Long</code>.<br><strong>Behavior:</strong> <code>On Error Resume Next</code> and returns 0 on error. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Non-array, array with invalid bounds. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>SafeArrayLength(arr As Variant) As Long</strong> — <em>array length helper</em> (private)<br><strong>Purpose:</strong> Return number of elements for scalar/array with defensive checks (0 for Empty/Null).<br><strong>Signature:</strong> <code>SafeArrayLength(Variant) -&gt; Long</code>.<br><strong>Behavior:</strong> If <code>IsArray</code> returns <code>UBound-LBound+1</code> else 1 for scalar (unless Empty/Null). <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Empty, Null, scalar, array. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>SafeCallCentral(procName As String, ByRef outResult As Variant, ParamArray args() As Variant) As Boolean</strong> — <em>defensive external-run wrapper</em> (private)<br><strong>Purpose:</strong> Safely call external procedures via <code>Application.Run</code> with up to 9 parameters, swallow errors and return success boolean; used to integrate with <code>modConfig</code>, <code>modUtilities</code>, <code>modError</code>, <code>modAudit</code> if present.<br><strong>Signature:</strong> <code>SafeCallCentral(String procName, ByRef Variant outResult, ParamArray args() ) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Detects <code>UBound(args)</code> defensively and invokes <code>Application.Run</code> with explicit arity cases (cases -1..8 enumerated). If <code>Err.Number=0</code> returns True and <code>outResult</code> populated; otherwise clears error and returns False. Errors inside <code>Application.Run</code> are swallowed. <br><strong>Complexity:</strong> O(1) but uses <code>Application.Run</code> which can invoke arbitrary user code (cost variable).<br><strong>Side-effects:</strong> Executes external macros; those macros may have side-effects. <br><strong>Invariants:</strong> Caller must not assume side-effects are absent; use only for non-critical best-effort calls. <br><strong>Failure modes / Security:</strong> Calling arbitrary macro names has security implications (macro code executes). This wrapper avoids throwing but does not sandbox the code — maintain strict naming and review of any central procs. <br><strong>Tests:</strong> Mock <code>Application.Run</code> via test harness or run against known safe procs to ensure success/failure branches behave as expected. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GetConfigValue(key As String, Optional defaultValue As Variant = Empty) As Variant</strong> — <em>config fetch with fallbacks</em> (private)<br><strong>Purpose:</strong> Read configuration keys by attempting <code>GetConfigValue</code> globally then <code>modConfig.GetConfigValue</code> via <code>SafeCallCentral</code>; falls back to <code>defaultValue</code> on failure.<br><strong>Signature:</strong> <code>GetConfigValue(String, Optional Variant) -&gt; Variant</code>.<br><strong>Behavior:</strong> Attempts <code>SafeCallCentral(&quot;GetConfigValue&quot;, r, key)</code> then <code>SafeCallCentral(&quot;modConfig.GetConfigValue&quot;, r, key)</code> and returns defaultValue if both fail. <br><strong>Complexity:</strong> O(1) but external calls possible. <br><strong>Side-effects:</strong> Calls external code that can have side-effects. <br><strong>Tests:</strong> Provide fake central implementation or ensure fallback triggers. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ShouldRaiseErrors() As Boolean</strong> — <em>config-driven error policy resolver</em> (private)<br><strong>Purpose:</strong> Determine whether to re-raise or only log errors based on config <code>modCalculations.RaiseErrors</code> (default <code>DEFAULT_RAISE_ERRORS</code>).<br><strong>Signature:</strong> <code>ShouldRaiseErrors() -&gt; Boolean</code>.<br><strong>Behavior:</strong> Reads config key, coerces to Boolean, returns default on error. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Use with care — enabling will change control flow and may throw to callers unexpectedly; tests must toggle this config. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>HandleCalcError(procName As String, Optional errNum As Long = 0, Optional errMsg As String = "")</strong> — <em>central error/audit routing</em> (private)<br><strong>Purpose:</strong> Structured error routing: attempt <code>modError.HandleError</code> or global <code>HandleError</code>, or <code>modAudit.Log</code> / <code>LogAudit</code>, else append to local <code>_IFRS_Audit</code> worksheet. Optionally re-raises error if <code>ShouldRaiseErrors()</code> true.<br><strong>Signature:</strong> <code>HandleCalcError(String, Optional Long, Optional String)</code>.<br><strong>Behavior (detailed):</strong><br>- Build <code>payload</code> string for local fallback.<br>- Try <code>SafeCallCentral(&quot;modError.HandleError&quot;, ...)</code> and <code>SafeCallCentral(&quot;HandleError&quot;, ...)</code>. If those succeed exit.<br>- Try <code>modAudit.Log</code> or <code>LogAudit</code> via <code>SafeCallCentral</code>. If none available append local audit row in hidden sheet <code>_IFRS_Audit</code> via <code>AppendLocalAudit</code> (creates sheet if absent and hides it <code>xlSheetVeryHidden</code>).<br>- Finally, if <code>ShouldRaiseErrors()</code> true calls <code>Err.Raise</code> to escalate. The function swallows errors during logging. <br><strong>Complexity:</strong> O(1) but may call several external procs and perform worksheet modifications. <br><strong>Side-effects:</strong> May create or write to <code>_IFRS_Audit</code> sheet; may execute external audit/error handlers. <br><strong>Invariants:</strong> Local audit sheet header created first time. <br><strong>Failure modes / Security:</strong> External <code>Application.Run</code> executes arbitrary code; creating sheets may fail in restricted contexts -> fallback guarded. <br><strong>Recommended tests:</strong> Simulate presence/absence of <code>modError</code>/<code>modAudit</code>, ensure local audit created and rows appended; verify <code>ShouldRaiseErrors</code> toggle causes <code>Err.Raise</code>. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>AppendLocalAudit(message As String)</strong> — <em>local-sheet audit appender</em> (private)<br><strong>Purpose:</strong> Append a timestamped audit message to hidden worksheet <code>_IFRS_Audit</code> as a last-resort logger.<br><strong>Signature:</strong> <code>AppendLocalAudit(String)</code>.<br><strong>Behavior:</strong> Gets <code>ThisWorkbook</code>, finds or creates <code>_IFRS_Audit</code> sheet, ensures headers then appends a row with timestamp,user,message trimmed to 2000 chars. Uses <code>xlSheetVeryHidden</code>. Errors swallowed silently. <br><strong>Complexity:</strong> O(1) per append but uses worksheet I/O. <br><strong>Side-effects:</strong> Creates/edits workbook sheets (persistence). <br><strong>Failure modes:</strong> Workbook protected, user with no permission, or environments where <code>ThisWorkbook</code> not set -> function exits early. <br><strong>Tests:</strong> Run in workbook with and without sheet, locked workbook, and with limited permissions. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>SafeLog(moduleName As String, proc As String, details As String)</strong> — <em>best-effort log helper</em> (private)<br><strong>Purpose:</strong> Convenience wrapper to try <code>modAudit.Log</code>/<code>LogAudit</code> and fallback to <code>AppendLocalAudit</code> for structured logging.<br><strong>Signature:</strong> <code>SafeLog(String, String, String)</code>.<br><strong>Behavior:</strong> Attempts central logging via <code>SafeCallCentral</code> and falls back to <code>AppendLocalAudit</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Ensure messages end up in central log when present else local sheet. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalculationsSelfTest() As Boolean</strong> — <em>module self-test runner & CI hook</em><br><strong>Purpose:</strong> Execute a battery of smoke and edge-case tests for key functions, record PASS/FAIL in <code>_IFRS_TestResults</code> sheet, and attempt to register the self-test with central test harness (<code>modTests.RegisterSelfTest</code>) if present.<br><strong>Signature:</strong> <code>CalculationsSelfTest() -&gt; Boolean</code>.<br><strong>Behavior (detailed):</strong><br>- Runs repeated checks (3x loop) for <code>CalcDepreciationEx</code>, <code>CalcEBITDA</code>, <code>RecognizeRevenue</code>, <code>ExpectedCreditLoss</code>, <code>DeferredTax</code>, <code>LeaseAmortizationSchedule</code>, <code>PvFromPmt</code>, <code>NPVFromArray</code>, and edge cases (salvage>cost, units-of-production). Accumulates boolean <code>ok</code> and writes PASS/FAIL with timestamp and <code>MODCALC_VERSION</code> to <code>_IFRS_TestResults</code> sheet (created hidden if absent). Attempts to register self-test with <code>modTests.RegisterSelfTest</code> or global <code>RegisterSelfTest</code>. Logs result via <code>SafeLog</code>. Returns boolean <code>ok</code>. On exception logs and returns False.<br><strong>Complexity:</strong> O(testWork) with loops, array allocations and schedule generation; depends on number of test iterations. <br><strong>Side-effects:</strong> Creates <code>_IFRS_TestResults</code> and writes rows; calls <code>SafeCallCentral</code> to register test; writes audit. <br><strong>Invariants:</strong> Should be idempotent — repeated runs append new timestamped rows. <br><strong>Failure modes:</strong> Environment lacking <code>ThisWorkbook</code> or write permissions cause partial failure (function still returns False). <br><strong>Recommended tests:</strong> Validate this self-test in CI, ensure it reliably returns True on known-good builds and False on intentionally broken builds. <br><strong>Notes:</strong> Keep tests small and deterministic; avoid network or external dependencies in CI. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Maintenance & Security Summary (module-level)</strong><br>- <strong>Error handling:</strong> All public functions catch errors and route through <code>HandleCalcError</code>; by default they return 0/Empty and not crash host. Test <code>ShouldRaiseErrors</code> toggles to verify raising behaviour.<br>- <strong>Rounding:</strong> Centralized via <code>ApplyRounding</code>, optionally delegating to <code>modUtilities</code>. Maintain consistent policy and document rounding semantics (bankers vs away-from-zero).<br>- <strong>External calls risk:</strong> <code>SafeCallCentral</code> uses <code>Application.Run</code> and will execute arbitrary macro code—audit any central routines exposed to this module. Keep call list minimal and well-reviewed. <br>- <strong>Numeric safety:</strong> Constants (<code>RATE_NEAR_ZERO</code>, <code>PV_MAX_NPER</code>, <code>TINY_RESIDUAL_THRESHOLD</code>) mitigate numeric edge cases. Changing these impacts behaviour; add tests before modification. <br>- <strong>I/O & Persistence:</strong> Local fallback audit/test sheets persisted to <code>ThisWorkbook</code>; this can create hidden sheets that should be documented in install/uninstall procedures. Consider allowing opt-out or centralizing audit to <code>modAudit</code> only. <br>- <strong>Recommended CI & tests:</strong> Unit tests for each public function (including invalid input, boundaries, rounding permutations), integration tests for error/ audit pathways (mock central modules), and repeated-run lifecycle tests for schedule generation. Add checks that rely on exact rounding semantics to detect regressions. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Quick recommended checklist before modifying code</strong><br>1. Run <code>CalculationsSelfTest()</code> and confirm PASS in <code>_IFRS_TestResults</code>.<br>2. If changing rounding semantics, run a dedicated rounding parity suite comparing <code>ApplyRounding</code> local vs central when enabled.<br>3. If adding external calls, register them in a restricted allow-list and review code signing and macro security contexts.<br>4. Ensure new public functions preserve existing signatures and return types for COM/Excel callers. </td></tr></tbody></table></div><div class="row-count">Rows: 34</div></div><div class="table-caption" id="Table2" data-table="Docu_0159_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical breakdown (modConfig)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical breakdown (modConfig)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modConfig)"> <strong>Module overview</strong><br><strong>Purpose:</strong> Centralized configuration storage, deterministic schema migration, atomic commit/verify for <code>IFRS_Reporting_AddIn.xlam</code>. Provides stable public API surface for load/save/export/import, migration orchestration, checksum-backed integrity, platform fallbacks (Windows/macOS), defensive error handling and self-tests. Implements pure migration routines (no side-effects) and an atomic writer that uses CustomXMLParts plus checksum verification and restore/backup strategies.<br><strong>Public API (stable names):</strong> <code>LoadConfigXML</code>, <code>LoadConfig</code>, <code>SaveConfigXML</code>, <code>SaveConfig</code>, <code>EnsureConfigSchema</code>, <code>ExportConfigToFile</code>, <code>ExportConfigFile</code>, <code>ImportConfigFromFile</code>, <code>ImportConfigFile</code>, <code>RegisterMigration</code>, <code>RunConfigSelfTests</code>.<br><strong>Key invariants:</strong> CustomXMLParts containing <code>&lt;IFRSConfig&gt;</code> are canonicalized and represented by a single verified part after successful <code>SaveConfigXML</code>. Schema property <code>IFRS_Config_SchemaVersion</code> is written only after a verified commit. Checksum property <code>IFRS_Config_Checksum</code> holds the normalized (lowercase) checksum of the canonical XML. Migration routines are pure (input XML -> output XML) and must not perform external side effects. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Module-level constants & state</strong><br><strong>CFG_ROOT_NAME, CFG_PART_KEY, CFG_SCHEMA_PROP, CFG_CHECKSUM_PROP</strong> — stable external names consumed by other modules; changing these is breaking. <br><strong>MigrationRegistry (Scripting.Dictionary)</strong> — used when available to store registered migration steps. <br><strong>Flags:</strong> <code>MigrationRegistryInitialized</code>, <code>ScriptingAvailable</code>, <code>ADODBAvailable</code>, <code>ModuleInitialized</code>. <br><strong>Notes:</strong> Initialization uses runtime feature detection; code tolerates missing <code>Scripting.Dictionary</code> or <code>ADODB.Stream</code>, logging degradations. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>LoadConfigXML()</strong> — <em>load & verify canonical config XML</em><br><strong>Purpose:</strong> Return canonical config XML if present and checksum-verified. If checksum mismatch or error, backup and return empty string so caller can create defaults or handle migration deterministically.<br><strong>Signature:</strong> <code>LoadConfigXML() -&gt; String</code> (empty string on missing/invalid).<br><strong>Behavior:</strong> Finds candidate CustomXMLPart via <code>FindConfigPart</code>. If none → <code>&quot;&quot;</code>. Computes checksum of chosen part (<code>ComputeChecksumForCustomXMLPart</code>). If <code>CFG_CHECKSUM_PROP</code> exists read stored checksum. If stored checksum present and mismatches computed checksum -> <code>BackupConfigXML(part.xml)</code>, log audit, return <code>&quot;&quot;</code>. If no stored checksum -> log audit and return part.xml (no silent property update). On successful match return part.xml.<br><strong>Complexity:</strong> O(N) over number of CustomXMLParts (checksum computation dominated by string processing/writes).<br><strong>Side-effects:</strong> Only logging/audit and backup on mismatch. Does not modify document properties or parts except via <code>BackupConfigXML</code> when mismatch occurs.<br><strong>Invariants:</strong> Returns verified XML only when checksum present and matches. Caller receives empty string to signal recoverable corruption.<br><strong>Failure modes:</strong> IO/COM errors when reading parts, checksum compute failures — catches and returns empty string while logging audit.<br><strong>Recommended tests:</strong> No-part case, valid checksum case, stored-checksum-mismatch path (ensure backup created), property-missing path (returns XML and logs).<br><strong>Notes:</strong> Intentionally conservative — prefers safe failure+backup over silent overwrites. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>LoadConfig()</strong> — <em>compat shim</em><br><strong>Purpose:</strong> Back-compat alias returning same as <code>LoadConfigXML</code>.<br><strong>Signature:</strong> <code>LoadConfig() -&gt; String</code>.<br><strong>Behavior:</strong> Delegates to <code>LoadConfigXML</code>. No side-effects. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SaveConfigXML(ByVal configXml As String)</strong> — <em>atomic write + verify</em><br><strong>Purpose:</strong> Atomically persist <code>configXml</code> into the workbook CustomXMLParts with checksum verification and safe restore on failure. Updates CustomDocumentProperties only after successful verify. Returns boolean success.<br><strong>Signature:</strong> <code>SaveConfigXML(configXml As String) -&gt; Boolean</code>.<br><strong>High-level behavior (ordered):</strong><br>1. Ensure module initialized.<br>2. Capture existing matching parts and their XML into in-memory <code>origXmls</code> for attempted restore.<br>3. Create temporary CustomXMLPart <code>tmpPart</code> from <code>configXml</code> and compute <code>computedChecksum</code> via <code>ComputeChecksumForCustomXMLPart(tmpPart)</code>.<br>4. If checksum empty → delete tmpPart, audit, fail.<br>5. Add canonical <code>newPart = CustomXMLParts.Add(tmpPart.xml)</code> then delete tmpPart.<br>6. Recompute checksum on <code>newPart</code> (<code>verifyChecksum</code>) and compare to <code>computedChecksum</code>. If mismatch -> delete newPart, attempt to restore <code>origXmls</code> into CustomXMLParts, backup attempted config via <code>BackupConfigXML</code>, audit, fail.<br>7. On success: delete other parts containing <code>&lt;IFRSConfig&gt;</code> (keep <code>newPart</code>), set <code>CFG_CHECKSUM_PROP</code> (lowercase), set <code>CFG_SCHEMA_PROP</code> from extracted schema version, audit success, return True.<br><strong>Complexity:</strong> O(P) over number of CustomXMLParts; checksum compute and reads of part.xml dominate costs (linear in XML size).<br><strong>Side-effects:</strong> Adds and deletes CustomXMLParts, updates CustomDocumentProperties, creates backups on failure, logs audits.<br><strong>Invariants:</strong> If function returns True, workbook contains exactly one verified CustomXMLPart with <code>&lt;IFRSConfig&gt;</code> and props updated. If function fails, previous parts are attempted to be restored from <code>origXmls</code> and a backup file is created on disk.<br><strong>Failure modes & resilience:</strong> - Checksum compute failure; - exec/env constraints preventing certutil; - partial workbook state if COM errors; code attempts best-effort restore and writes a backup file. All fatal errors are logged and bubbled as False return.<br><strong>Security:</strong> Beware of writing arbitrary XML into workbook; callers must sanitize inputs if they originate from untrusted sources. Checksum prevents silent tamper but not maliciously-intentional accepted writes.<br><strong>Recommended tests:</strong> Successful atomic save; simulated verify-failure by corrupting part between tmp/new write; failure path creates backup and restores originals; property update correctness; concurrency/robustness under repeated saves.<br><strong>Notes:</strong> The algorithm intentionally writes then verifies the written part (double-write) to work around COM implementation differences and to ensure the workbook actually stores canonical contents. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SaveConfig(ByVal configXml As String)</strong> — <em>alias</em><br><strong>Purpose:</strong> Back-compat alias to <code>SaveConfigXML</code>.<br><strong>Signature:</strong> <code>SaveConfig(configXml) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Delegates to <code>SaveConfigXML</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>EnsureConfigSchema(Optional targetSCHEMA As String = "")</strong> — <em>ensures config exists & migrates deterministically</em><br><strong>Purpose:</strong> Guarantee a valid config exists in workbook with target schema; perform deterministic migrations when needed; create default config if missing or malformed.<br><strong>Signature:</strong> <code>EnsureConfigSchema(Optional targetSCHEMA As String) -&gt; Void</code>.<br><strong>Behavior:</strong><br>- Determine <code>targetSCHEMA</code> defaulting to <code>GetThisAddinSchemaVersion()</code>.<br>- Ensure migrations registered (<code>RegisterBuiltInMigrations</code>).<br>- Load xml via <code>LoadConfigXML</code>. If empty -> create default via <code>CreateDefaultConfigXML</code> and attempt <code>SaveConfigXML</code>; on failure call <code>HandleConfigError</code>.<br>- Extract current schema via <code>ExtractSchemaVersionFromXML</code>. If missing -> backup, replace with default, save, audit.<br>- If <code>currentVer &lt;&gt; targetSCHEMA</code> -> run migrations via <code>RunMigrations(currentVer, targetSCHEMA)</code>. On migration failure -> <code>HandleConfigError</code> and audit.<br><strong>Complexity:</strong> Dependent on <code>RunMigrations</code> cost; generally dominated by I/O and <code>SaveConfigXML</code> operations.<br><strong>Side-effects:</strong> May create/overwrite config parts, write properties, run migration routines (pure) and commit via <code>SaveConfigXML</code> (side-effect).<br><strong>Invariants:</strong> After successful return, workbook should contain a config with <code>SchemaVersion == targetSCHEMA</code> unless migration failed and error raised.<br><strong>Failure modes:</strong> Migration path cannot be built; migration routine failure; save fail. Errors handled via <code>HandleConfigError</code> which logs and raises vbObjectError +9000.<br><strong>Tests:</strong> Missing-config flow, malformed-config flow, migration-success flow, migration-failure path. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExportConfigToFile(ByVal fullPath As String)</strong> — <em>export current config to filesystem</em><br><strong>Purpose:</strong> Writes current verified config XML to <code>fullPath</code> (binary write). Returns boolean.<br><strong>Signature:</strong> <code>ExportConfigToFile(fullPath As String) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Loads config via <code>LoadConfigXML</code>. If empty -> return False. Else open file (Binary Access Write) and <code>Put</code> xml, return True. Exceptions logged and return False.<br><strong>Complexity:</strong> O(file size).<br><strong>Side-effects:</strong> Writes a file on disk. Should respect file system permissions and antivirus locks.<br><strong>Failure modes:</strong> IO errors, path missing, permission denied; audits error. Tests: write to temp path, verify contents match <code>LoadConfigXML</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExportConfigFile(ByVal fullPath As String)</strong> — <em>alias</em><br><strong>Purpose:</strong> Back-compat alias. Delegates to <code>ExportConfigToFile</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ImportConfigFromFile(ByVal fullPath As String)</strong> — <em>import config from file and save atomically</em><br><strong>Purpose:</strong> Read file contents and invoke <code>SaveConfigXML</code> to atomically persist into workbook. Returns boolean success.<br><strong>Signature:</strong> <code>ImportConfigFromFile(fullPath As String) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Opens file binary, reads bytes/contents into string, verifies string contains <code>&lt;IFRSConfig&gt;</code> root; if not present -> return False. Else calls <code>SaveConfigXML(xml)</code> and returns its result. Exceptions handled and logged.<br><strong>Complexity:</strong> O(file size + <code>SaveConfigXML</code> cost).<br><strong>Side-effects:</strong> Invokes atomic save which may modify workbook parts and properties.<br><strong>Failure modes:</strong> IO failure, malformed file, <code>SaveConfigXML</code> failure. Tests: round-trip export->import. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ImportConfigFile(ByVal fullPath As String)</strong> — <em>alias</em><br><strong>Purpose:</strong> Back-compat alias to <code>ImportConfigFromFile</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>FindConfigPart()</strong> — <em>deterministic selection of canonical config CustomXMLPart</em><br><strong>Purpose:</strong> Find a matching CustomXMLPart containing <code>&lt;IFRSConfig&gt;</code> with deterministic preference for the one matching stored checksum (if <code>CFG_CHECKSUM_PROP</code> exists). Returns <code>CustomXMLPart</code> or <code>Nothing</code>.<br><strong>Signature:</strong> <code>FindConfigPart() -&gt; CustomXMLPart | Nothing</code>.<br><strong>Behavior:</strong> Reads stored checksum from <code>ThisWorkbook.CustomDocumentProperties</code> if available. If present, walk all <code>CustomXMLParts</code> and compute checksum for those that contain <code>&lt;IFRSConfig&gt;</code>; if a computed checksum matches stored checksum (case-insensitive) return that part. If none match — log audit and return Nothing. If no stored checksum, return the first CustomXMLPart containing <code>&lt;IFRSConfig&gt;</code> found (deterministic by iteration order).<br><strong>Complexity:</strong> O(P) parts with per-part checksum computation dependent on XML size.<br><strong>Side-effects:</strong> Logs audit when no match. No writes. <br><strong>Failure modes:</strong> COM errors; ComputeChecksum failures — caught and return Nothing. Tests: multiple parts with one matching checksum; stored checksum absent -> first-match; stored checksum present but no matching part -> returns Nothing and logs. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>CreateDefaultConfigXML(ByVal schemaVersion As String)</strong> — <em>create minimal canonical config XML</em><br><strong>Purpose:</strong> Produce a deterministic default XML with <code>&lt;SchemaVersion&gt;</code>, <code>&lt;COAMappings&gt;</code>, <code>&lt;Templates&gt;</code> sections. Used when missing or malformed config detected.<br><strong>Signature:</strong> <code>CreateDefaultConfigXML(schemaVersion As String) -&gt; String</code>.<br><strong>Behavior:</strong> Constructs XML string using <code>EscapeXml</code> for schemaVersion and returns it. No side-effects. <br><strong>Complexity:</strong> O(len(schemaVersion)).<br><strong>Tests:</strong> Returns well-formed XML containing provided schemaVersion. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExtractSchemaVersionFromXML(ByVal xml As String)</strong> — <em>extract schema value</em><br><strong>Purpose:</strong> Return value inside <code>&lt;SchemaVersion&gt;</code> tag or empty string if not found. Minimal parser using <code>InStr</code> and <code>Mid$</code>.<br><strong>Signature:</strong> <code>ExtractSchemaVersionFromXML(xml As String) -&gt; String</code>.<br><strong>Behavior:</strong> Locates start & end tags; returns substring. Not XML-namespace-aware; expects well-formedness. <br><strong>Complexity:</strong> O(len(xml)).<br><strong>Failure modes:</strong> Malformed XML -> returns empty string. Tests: various XMLs, missing tag, extra whitespace. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>BackupConfigXML(ByVal xml As String)</strong> — <em>safe disk backup</em><br><strong>Purpose:</strong> Write <code>xml</code> to a timestamped file in a safe temp folder (tries several fallbacks) for triage. Audit logged on success or error.<br><strong>Signature:</strong> <code>BackupConfigXML(xml As String) -&gt; Void</code>.<br><strong>Behavior:</strong> Resolves folder via <code>GetSafeTempFolder</code> (ENV TEMP/TMP → workbook.Path → Application.DefaultFilePath → macOS path). Forms filename <code>IFRS_Config_Backup_YYYYMMDD_HHNNSS_random.xml</code>. Writes binary, logs audit. Swallows exceptions and logs errors.<br><strong>Complexity:</strong> O(file size).<br><strong>Side-effects:</strong> Writes filesystem artifact. <br><strong>Security/privacy:</strong> Backups may contain sensitive secrets — ensure folder access policies or alert users before telemetry. <br><strong>Tests:</strong> Verify file written in candidate temp folder and timestamped format; verify audit entry. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>HandleConfigError(ByVal proc As String, ByVal msg As String)</strong> — <em>centralized error handler for config</em><br><strong>Purpose:</strong> Log audit entry, call <code>modError</code> handler if available, then raise a controlled runtime error (vbObjectError +9000) with correlation id appended.<br><strong>Signature:</strong> <code>HandleConfigError(proc As String, msg As String) -&gt; Void</code> (raises error).<br><strong>Behavior:</strong> Builds correlation ID via <code>GetCorrelationId</code>, calls <code>LogAudit(&quot;ConfigError&quot;, ...)</code>, attempts <code>SafeCallModErrorHandle</code> if error handler available, raises <code>Err.Raise vbObjectError + 9000, proc, msg | correlation</code>. Uses <code>On Error Resume Next</code> to avoid cascading exceptions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Logs, possibly calls external error module, raises a runtime error. <br><strong>Tests:</strong> Simulate when <code>modError</code> present/absent; verify audit message and raised error includes correlation id. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsErrorHandlerAvailable()</strong> — <em>probe for modError presence</em><br><strong>Purpose:</strong> Lightweight probe using <code>Application.Run &quot;modError_Probe_HandleError&quot;</code> to determine whether <code>modError</code> provides the probe entrypoint. Returns Boolean.<br><strong>Signature:</strong> <code>IsErrorHandlerAvailable() -&gt; Boolean</code>.<br><strong>Behavior:</strong> Attempts <code>Application.Run</code> and checks <code>Err.Number</code>. Uses <code>On Error Resume Next</code>. Returns True only if probe call succeeded (no Err). Does not otherwise call <code>modError.HandleError</code> to avoid side-effects.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Conservative probe; if <code>modError</code> exists but uses different naming the result is False; HandleConfigError falls back with <code>SafeCallModErrorHandle</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SafeCallModErrorHandle(proc,msg)</strong> — <em>best-effort invocation of modError handler</em><br><strong>Purpose:</strong> Try <code>Application.Run &quot;modError.HandleError&quot;</code> then fallback probe-style names; swallow exceptions.<br><strong>Signature:</strong> <code>SafeCallModErrorHandle(proc As String, msg As String) -&gt; Void</code>.<br><strong>Behavior:</strong> Attempts <code>Application.Run &quot;modError.HandleError&quot;, proc, msg</code>, then on error tries <code>Application.Run &quot;modError_HandleError&quot;, proc &amp; &quot; | &quot; &amp; msg</code>. Uses <code>On Error Resume Next</code> and clears errors. No exception raised to caller. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Designed to avoid having modConfig depend directly on modError compile-time binding. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RegisterMigration(fromVersion,toVersion,routineName)</strong> — <em>register programmatic migrations</em><br><strong>Purpose:</strong> Expose programmatic registration of migration steps into <code>MigrationRegistry</code> for later deterministic chaining.<br><strong>Signature:</strong> <code>RegisterMigration(fromVersion As String, toVersion As String, routineName As String) -&gt; Void</code>.<br><strong>Behavior:</strong> Ensures module initialized and built-in migrations registered. Adds key <code>from|to</code> => <code>routineName</code> into <code>MigrationRegistry</code> only if not already present. Logs and ignores duplicates. Errors audited.<br><strong>Complexity:</strong> O(1) for dictionary operations (if <code>Scripting.Dictionary</code> available).<br><strong>Failure modes:</strong> <code>Scripting.Dictionary</code> unavailable -> function logs and returns; registration disabled. Tests: register new key, attempt duplicate registration. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RegisterBuiltInMigrations()</strong> — <em>initialize migration registry & runtime detection</em><br><strong>Purpose:</strong> Create <code>Scripting.Dictionary</code>, add built-in migration mappings (example <code>1.0.0|1.1.0</code>), detect <code>ADODB.Stream</code> availability, set <code>ModuleInitialized</code> and <code>Randomize</code> seed.<br><strong>Signature:</strong> <code>RegisterBuiltInMigrations() -&gt; Void</code>.<br><strong>Behavior:</strong> Attempts <code>CreateObject(&quot;Scripting.Dictionary&quot;)</code>. On failure logs and disables migrations. Adds example migration <code>Migrate_v1_0_0_to_v1_1_0</code>. Detects ADODB.Stream availability and logs fallback for UTF-8 conversion. Sets <code>ModuleInitialized = True</code> and <code>MigrationRegistryInitialized = True</code> when successful.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates module state and logs. <br><strong>Tests:</strong> Environments with/without Scripting.Dic and ADODB.Stream. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>BuildMigrationPath(currentVersion,targetVersion)</strong> — <em>deterministic path builder with loop protection</em><br><strong>Purpose:</strong> Build ordered collection of migration routine names to go from <code>currentVersion</code> to <code>targetVersion</code> using <code>MigrationRegistry</code>. Deterministic tie-breaker uses lexicographic smallest <code>toVersion</code>. Safety loop limit prevents infinite loops.<br><strong>Signature:</strong> <code>BuildMigrationPath(currentVersion As String, targetVersion As String) -&gt; Collection | Nothing</code>.<br><strong>Behavior:</strong> If <code>MigrationRegistry</code> not initialized return Nothing. Iterative loop: if direct <code>cur|target</code> key exists add its routine and finish. Else, scan all registry keys where left side equals <code>cur|*</code>, pick candidate with lexicographically smallest <code>toVersion</code>. Add its routine and set <code>cur = candidateTo</code>. Repeat until <code>cur == targetVersion</code> or safety limit (100) reached. If path empty or fails return Nothing. <br><strong>Complexity:</strong> O(E * K) where E = registry entries, K = length of path (E small).<br><strong>Failure modes:</strong> No path found, cycles prevented by safety limit. Tests: Build chain across multiple hops; tie-breaker determinism test when multiple next-hops exist. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RunMigrations(currentVersion,targetVersion)</strong> — <em>orchestrate pure migration steps and commit</em><br><strong>Purpose:</strong> Construct migration path and execute each pure migration routine; each returned XML must be saved via <code>SaveConfigXML</code> (atomic commit). Returns Boolean success.<br><strong>Signature:</strong> <code>RunMigrations(currentVersion As String, targetVersion As String) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Ensures module init; calls <code>BuildMigrationPath</code> to get ordered routines. For each routine name: uses <code>Select Case</code> to call the corresponding pure function with <code>LoadConfigXML()</code> (current config) and receives <code>newXml</code>. If <code>newXml</code> is empty -> fail. Calls <code>SaveConfigXML(newXml)</code> to commit. If any Save fails -> fail. If all succeed return True. Logs progress and errors. <br><strong>Complexity:</strong> Sum of migration routine costs + <code>SaveConfigXML</code> I/O. <br><strong>Side-effects:</strong> Commits new config parts via <code>SaveConfigXML</code>. <br><strong>Failure modes:</strong> Unknown routine name, migration returns empty, <code>SaveConfigXML</code> failure. Tests: path with single builtin migration; unsuccessful migration where Save fails; unknown routine name logged as error. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Migrate_v1_0_0_to_v1_1_0(currentXml)</strong> — <em>pure migration example</em><br><strong>Purpose:</strong> Example pure migration routine transforming SchemaVersion and template tag attributes without side-effects. Input: <code>currentXml</code> string. Output: transformed XML string or empty on error.<br><strong>Signature:</strong> <code>Migrate_v1_0_0_to_v1_1_0(currentXml As String) -&gt; String</code>.<br><strong>Behavior:</strong> Reads existing SchemaVersion via <code>ExtractSchemaVersionFromXML</code>. If present replaces with <code>1.1.0</code>. If not present inserts <code>&lt;SchemaVersion&gt;1.1.0&lt;/SchemaVersion&gt;</code> after XML declaration. Updates <code>&lt;Templates&gt;</code> to <code>&lt;Templates version=&quot;1.1.0&quot;&gt;</code> if tag found. Returns new XML. Pure function: must not call Save/Backup or other side-effects. <br><strong>Complexity:</strong> O(len(xml)).<br><strong>Failure modes:</strong> Malformed XML — routine returns empty and logs via <code>Call LogAudit</code>. Tests: fixture migration checks (present in <code>RunConfigSelfTests</code>).<br><strong>Notes:</strong> Migration routines are critical to remain pure and deterministic to allow easy testing and reliable rollbacks. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ComputeChecksumForCustomXMLPart(part As CustomXMLPart)</strong> — <em>compute canonical checksum (SHA256 → CRC32 fallback)</em><br><strong>Purpose:</strong> Compute a deterministic checksum string for a CustomXMLPart; prefer SHA256 via certutil (Windows) and fall back to CRC32 (UTF-8 bytes) when SHA not available. Normalizes to lowercase.<br><strong>Signature:</strong> <code>ComputeChecksumForCustomXMLPart(part) -&gt; String</code> (lowercase hex; CRC32 8-hex when fallback).<br><strong>Behavior:</strong> Calls <code>ComputeSHA256_UsingCertUtil(part.xml)</code> and if empty calls <code>ComputeCRC32String(part.xml)</code> with audit log that SHA unavailable. Ensures lowercase returned. On unexpected errors returns CRC32 of <code>part.xml</code> in <code>ErrHandler</code> fallback.<br><strong>Complexity:</strong> SHA path involves writing temp file & invoking external <code>certutil</code> → O(n) file write + external process latency. CRC32 uses <code>StrToUtf8Bytes</code> conversion and byte loop O(n).<br><strong>Side-effects:</strong> May create temp file and spawn <code>certutil</code> (external process) on Windows. <br><strong>Failure modes:</strong> certutil missing or blocked; ADODB unavailable affecting UTF-8 conversion (Code falls back to ANSI StrConv). Tests: path where certutil available; path where certutil fails -> CRC32 returned and audit logged. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ComputeSHA256_UsingCertUtil(ByVal s As String)</strong> — <em>Windows certutil-based SHA256</em><br><strong>Purpose:</strong> Compute SHA256 by writing <code>s</code> to temp file then running <code>certutil -hashfile &lt;file&gt; SHA256</code> and parsing StdOut for 64 hex characters. Returns 64-hex lowercase string or empty on failure/timeouts.<br><strong>Signature:</strong> <code>ComputeSHA256_UsingCertUtil(s As String) -&gt; String</code>.<br><strong>Behavior & robustness details:</strong><br>- Determine safe temp folder via <code>GetSafeTempFolder</code> with fallbacks.<br>- Create unique temp filename with timestamp+random suffix.<br>- Write <code>s</code> to file Binary Access Write.<br>- Use <code>WScript.Shell.Exec(&quot;cmd /c certutil -hashfile &quot;&quot;fname&quot;&quot; SHA256&quot;)</code> and wait with timeout guard (~10s), using <code>DoEvents</code> loop. If timeout -> attempt <code>execObj.Terminate</code> and continue graceful failure path.<br>- Read <code>StdOut.ReadAll</code>, <code>KillSafe</code> the temp file, parse lines for a 64-hex substring; if found return lowercased 64-hex; else attempt to strip non-hex characters to extract 64 hex. If not found return empty string.<br><strong>Complexity:</strong> IO + external process; network independent. <br><strong>Side-effects / security:</strong> Spawns <code>certutil</code> process and writes a temp file which is removed. Ensure antivirus does not block <code>certutil</code> execution. <br><strong>Failure modes:</strong> <code>WScript.Shell</code> unavailable (server/maclient), <code>certutil</code> missing (non-Windows), cmd launch blocked, execution times out, output unparseable. In each case function returns <code>&quot;&quot;</code> and caller falls back to CRC32.<br><strong>Tests:</strong> Windows environment with certutil; environment without certutil or blocked process; output parsing robustness (simulate noisy STDOUT).<br><strong>Notes:</strong> Use of external CLI introduces OS-dependency; code already falls back safely. Consider future replacement with AVAPI/Win32 crypto calls exposed via COM for less process overhead. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ComputeCRC32String(ByVal s As String)</strong> — <em>deterministic CRC32 fallback</em><br><strong>Purpose:</strong> Compute CRC32 hex string (8 hex lowercase) over UTF-8 encoded bytes of <code>s</code> (attempt ADODB.Stream; fallback to ANSI bytes). Deterministic and fast compared to external SHA path.<br><strong>Signature:</strong> <code>ComputeCRC32String(s As String) -&gt; String</code>.<br><strong>Behavior:</strong> Build CRC table <code>CRC32Table()</code>, get byte array via <code>StrToUtf8Bytes(s)</code>; iterate bytes performing CRC algorithm, produce 8-hex zero-padded lowercase string. Logs nothing on success. <br><strong>Complexity:</strong> O(n) bytes processed. <br><strong>Notes:</strong> Not cryptographically secure but used as robust fallback to detect accidental equality/tamper. Tests: known CRC values for test strings; Unicode inputs (UTF-8 path vs ANSI fallback). </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>CRC32Table()</strong> — <em>table generator for CRC32</em><br><strong>Purpose:</strong> Build 256-entry CRC32 lookup table used by <code>ComputeCRC32String</code>.<br><strong>Signature:</strong> <code>CRC32Table() -&gt; Long()</code>.<br><strong>Behavior:</strong> Standard polynomial 0xEDB88320 generation. Returns array(1 to 256) of Long values. Deterministic and pure. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>StrToUtf8Bytes(s As String)</strong> — <em>string → UTF-8 bytes with ADODB fallback</em><br><strong>Purpose:</strong> Convert VBA <code>String</code> to byte() representing UTF-8 encoding if <code>ADODB.Stream</code> available; else fallback deterministically to ANSI <code>StrConv(..., vbFromUnicode)</code>.<br><strong>Signature:</strong> <code>StrToUtf8Bytes(s As String) -&gt; Byte()</code>.<br><strong>Behavior:</strong> If <code>ADODBAvailable</code> then <code>CreateObject(&quot;ADODB.Stream&quot;)</code>, set <code>.Type=2</code>, <code>.Charset=&quot;utf-8&quot;</code>, <code>.WriteText s</code>, set <code>.Position=0</code>, <code>.Type=1</code> and <code>Read</code> bytes into result. Else <code>tmp = StrConv(s, vbFromUnicode)</code>. On errors cleans up and returns ANSI bytes. <br><strong>Complexity:</strong> O(n).<br><strong>Failure modes:</strong> ADODB not present -> falls back; ADODB present but fails -> fallback to ANSI with audit earlier in <code>RegisterBuiltInMigrations</code>. Tests: UTF-8 result expected when ADODB available (e.g., emoji/diacritics preserved). <br><strong>Notes:</strong> ADODB Stream usage is standard in VBA for UTF-8; fallback provides determinism for environments lacking ADODB. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>EscapeXml(s As String)</strong> — <em>simple XML escaping</em><br><strong>Purpose:</strong> Replace <code>&amp; &lt; &gt; &quot; &#x27;</code> with XML entities for safe insertion into constructed XML strings.<br><strong>Signature:</strong> <code>EscapeXml(s) -&gt; String</code>.<br><strong>Behavior:</strong> <code>Replace</code> calls for <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&quot;</code> and <code>&#x27;</code>. Deterministic and pure. <br><strong>Tests:</strong> Strings with <code>&lt;&gt;&amp;&quot;&#x27;</code> produce correct entities. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>PropExists(propName As String)</strong> — <em>safe document property probe</em><br><strong>Purpose:</strong> Return True if <code>ThisWorkbook.CustomDocumentProperties(propName)</code> exists. Uses <code>On Error Resume Next</code> to avoid exceptions from missing prop access.<br><strong>Signature:</strong> <code>PropExists(propName) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Try to <code>Set p = ThisWorkbook.CustomDocumentProperties(propName)</code> and inspect <code>Err.Number</code>. Returns boolean accordingly. <br><strong>Notes:</strong> Minimal function used by several file paths to avoid exceptions. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetThisAddinSchemaVersion()</strong> — <em>single-source schema version</em><br><strong>Purpose:</strong> Return the add-in schema version string <code>&quot;1.1.0&quot;</code> (single source-of-truth used by <code>EnsureConfigSchema</code>).<br><strong>Signature:</strong> <code>GetThisAddinSchemaVersion() -&gt; String</code>.<br><strong>Notes:</strong> Bump this when releasing schema changes; migration registry must be updated to cover upgrades. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetSafeTempFolder()</strong> — <em>resolve safe temp folder w/ mac fallback</em><br><strong>Purpose:</strong> Determine a writable temporary folder using fallback order: environment TEMP/TMP -> <code>ThisWorkbook.Path</code> -> <code>Application.DefaultFilePath</code> -> macOS <code>MacScript(&quot;return POSIX path of (path to temporary items)&quot;)</code> fallback. Returns folder path string or empty string if none found.<br><strong>Signature:</strong> <code>GetSafeTempFolder() -&gt; String</code>.<br><strong>Behavior:</strong> Iterates candidate sources, returns first non-empty. On macOS trims trailing slash. Uses <code>On Error Resume Next</code> liberally. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Uses <code>MacScript</code> on macOS which may be blocked in some environments. <br><strong>Tests:</strong> Windows with ENV set; workbook path only; macOS detection returns POSIX path. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetCorrelationId()</strong> — <em>small operational id generator</em><br><strong>Purpose:</strong> Return deterministic-ish correlation id <code>YYYYMMDD_HHNNSS_random6</code> for audits/backups.<br><strong>Signature:</strong> <code>GetCorrelationId() -&gt; String</code>.<br><strong>Behavior:</strong> Uses <code>Now</code> with <code>Format</code> and <code>Rnd()</code> seeded by <code>Randomize</code>. Not cryptographically random. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>EnsureModuleInitialized()</strong> — <em>module init guard & runtime probes</em><br><strong>Purpose:</strong> Idempotent initialization: calls <code>RegisterBuiltInMigrations</code> and probes <code>Scripting.Dictionary</code> and <code>ADODB.Stream</code> if not yet initialized. Sets <code>ModuleInitialized</code> true and logs degradations.<br><strong>Signature:</strong> <code>EnsureModuleInitialized() -&gt; Void</code>.<br><strong>Behavior:</strong> If <code>ModuleInitialized</code> True → return. Else try to create <code>Scripting.Dictionary</code> and <code>ADODB.Stream</code> and set flags. Calls <code>Randomize</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Called by many public functions to lazily initialize. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RunConfigSelfTests()</strong> — <em>in-module self-test harness for CI/manual verification</em><br><strong>Purpose:</strong> Execute a curated set of deterministic tests exercising migrations, atomic save, checksum fallback, export/import roundtrip, and write results to worksheet <code>_IFRS_TestResults</code>. Also logs an audit entry. Useful for CI/QA manual verification on developer machines.<br><strong>Signature:</strong> <code>RunConfigSelfTests() -&gt; Sub</code> (writes tests and may modify workbook by creating <code>_IFRS_TestResults</code> worksheet, and calls <code>SaveConfigXML</code> as part of tests).<br><strong>Behavior & tests included:</strong><br>- Migration fixture v1.0.0→v1.1.0.<br>- Atomic save + checksum normal flow (calls <code>SaveConfigXML</code>).<br>- Simulated checksum mismatch restore (corrupting a part in-memory and calling <code>SaveConfigXML</code>).<br>- Certutil absent → CRC32 fallback detection (<code>ComputeSHA256_UsingCertUtil</code> + <code>ComputeCRC32String</code>).<br>- Export/import roundtrip (writes and reads a temp file using <code>GetSafeTempFolder</code>).<br>Writes results table to worksheet <code>_IFRS_TestResults</code> with PASS/FAIL notes and logs final audit. Gracefully logs on error. <br><strong>Complexity:</strong> Dependent on invoked Save/IO operations. <br><strong>Side-effects:</strong> Creates or writes <code>_IFRS_TestResults</code> worksheet, creates temp files, modifies CustomXMLParts during test. Should not be run in production without consent. <br><strong>Tests:</strong> The function itself is a test suite; run in a disposable workbook or CI sandbox. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>KillSafe(fname As String)</strong> — <em>safe file delete</em><br><strong>Purpose:</strong> Attempt to <code>Kill</code> (delete) file, swallow errors. Utility used by file-cleanup flows. <br><strong>Signature:</strong> <code>KillSafe(fname) -&gt; Void</code>.<br><strong>Behavior:</strong> <code>On Error Resume Next</code> then <code>Kill fname</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsHexString(s, expectedLen)</strong> — <em>validate hex string</em><br><strong>Purpose:</strong> Return True if <code>s</code> contains at least <code>expectedLen</code> hex characters <code>[0-9a-fA-F]</code>. Used to validate parsed certutil output.<br><strong>Signature:</strong> <code>IsHexString(s As String, expectedLen As Long) -&gt; Boolean</code>.<br><strong>Complexity:</strong> O(expectedLen).<br><strong>Notes:</strong> Conservative check used in <code>ComputeSHA256_UsingCertUtil</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsArrayAllocatedByte(arr() As Byte)</strong> — <em>VBA array allocation probe</em><br><strong>Purpose:</strong> Safely detect whether a <code>Byte()</code> array is allocated without triggering errors. Uses <code>LBound(arr)</code> in protected <code>On Error</code> block.<br><strong>Signature:</strong> <code>IsArrayAllocatedByte(arr() As Byte) -&gt; Boolean</code>.<br><strong>Notes:</strong> Helper used by CRC32 implementation to avoid runtime errors when <code>StrToUtf8Bytes</code> returns an empty/unallocated array. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Developer & security notes (summary)</strong><br>- <strong>Checksum-first policy:</strong> The module prefers stored checksum verification before declaring a canonical part. If mismatch -> backup + audit + empty return so caller handles replace; this minimizes silent corruption.<br>- <strong>Atomic write semantics:</strong> Two-stage write (tmpPart -> canonical newPart) followed by verify then prune ensures atomicity despite COM idiosyncrasies. <br>- <strong>Platform fallbacks:</strong> <code>ComputeSHA256_UsingCertUtil</code> is Windows-specific; CRC32 fallback + ADODB fallback to ANSI ensures the functions operate cross-platform albeit with different guarantees. <br>- <strong>Migrations:</strong> Routines are intentionally pure and must remain side-effect free; <code>RunMigrations</code> performs commits. Adding migrations requires <code>RegisterMigration</code> or editing <code>RegisterBuiltInMigrations</code> and adding <code>Select Case</code> branches. <br>- <strong>Telemetry & PII:</strong> Backups and exported XML may contain sensitive data; treat backups carefully and avoid automated telemetry with raw backups. <br>- <strong>Tests & CI:</strong> <code>RunConfigSelfTests</code> mutates workbook; run in isolated/CI contexts. Add unit tests around <code>tokenizer</code>-style functions if extended. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Recommended tests / QA checklist (concise)</strong><br>1. Save->Load roundtrip with SHA available and absent (force CRC fallback).<br>2. Corrupt-after-write scenario: ensure <code>SaveConfigXML</code> fails verify and original parts restored / backup created.<br>3. Migration happy path and failure path (unknown migration routine).<br>4. Export/import roundtrip to temp file. <br>5. <code>FindConfigPart</code> with multiple parts and stored-checksum present/absent.<br>6. <code>StrToUtf8Bytes</code> producing UTF-8 when ADODB present (emoji test).<br>7. <code>ComputeSHA256_UsingCertUtil</code> parsing various <code>certutil</code> outputs (noisy STDOUT).<br>8. <code>RunConfigSelfTests</code> runs without uncaught errors in a disposable workbook. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Maintenance & upgrade guidance (concise)</strong><br>- Do not change tokenizer/serialization of config XML without migration routine. Schema bumps must be accompanied by pure migration functions and added to <code>RegisterBuiltInMigrations</code> and <code>RunMigrations</code> <code>Select Case</code>.<br>- If moving away from <code>certutil</code>, replace with native crypto COM or a signed binary to avoid cmd/exec issues.<br>- When adding new public functions, preserve aliases (<code>LoadConfig</code>/<code>SaveConfig</code>) for backward compatibility or increment API major version.<br>- Consider adding <code>maxRetries</code>/lock/backoff if concurrent add-in instances might race on CustomXMLPart writes. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Final summary (one paragraph)</strong><br>This <code>modConfig</code> implements robust, defensive configuration management for an Excel Add-in: checksum-first load, atomic write/verify semantics, deterministic migration registry with lexicographic tie-breaking, and pragmatic platform fallbacks for SHA and UTF-8 encoding. The module favors safety (backup + audit on mismatch), deterministic behavior (pure migration functions, single canonical part after success) and diagnostics (self-tests, correlation ids). Key operational risks are reliance on <code>certutil</code> on Windows and possible ADODB absence — both handled by fallbacks but worth addressing for production hardening. </td></tr></tbody></table></div><div class="row-count">Rows: 42</div></div><div class="table-caption" id="Table3" data-table="Docu_0159_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modDataInput)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modDataInput)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Overview:</strong> Exhaustive per-function technical breakdown for the <code>modDataInput</code> VBA module supplied. Each entry documents: purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security/path considerations, recommended tests, and maintainer notes. Use as authoritative inline documentation for reviewers, auditors and QA. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ImportTrialBalance</strong> — <em>back-compat shim entrypoint</em><br><strong>Purpose:</strong> Public, backward-compatible basic entry to the import pipeline; delegates to <code>ImportTrialBalanceAdvanced</code> with default args and centralized error handling.<br><strong>Signature:</strong> <code>Public Sub ImportTrialBalance()</code> — no return.<br><strong>Behavior:</strong> Calls <code>ImportTrialBalanceAdvanced(&quot;sheet&quot;, &quot;&quot;, Nothing, &quot;&quot;, False)</code> inside <code>On Error GoTo ErrHandler</code>. On error calls external <code>HandleError</code> with module and runtime error.<br><strong>Complexity:</strong> O(1) (delegator).<br><strong>Side-effects:</strong> Triggers full import pipeline when <code>ImportTrialBalanceAdvanced</code> runs.<br><strong>Invariants:</strong> Preserves existing public API surface; must remain stable.<br><strong>Failure modes:</strong> Any failure is caught and reported using <code>HandleError</code>.<br><strong>Tests:</strong> Call when no workbook active, when workbook active; confirm <code>HandleError</code> invoked on simulated error (mock).<br><strong>Notes:</strong> Keep signature stable for external calls; do not add optional parameters. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ValidateCOA</strong> — <em>COA quick validator (stub)</em><br><strong>Purpose:</strong> Lightweight check to ensure an account code string is non-empty (placeholder for real COA validation).<br><strong>Signature:</strong> <code>Public Function ValidateCOA(accountCode As String) As Boolean</code><br><strong>Behavior:</strong> Returns <code>True</code> if trimmed <code>accountCode</code> length > 0; on error returns <code>False</code> and calls <code>HandleError</code>.<br><strong>Complexity:</strong> O(len(accountCode)).<br><strong>Side-effects:</strong> None (pure).<br><strong>Invariants:</strong> Returns False for empty/whitespace input.<br><strong>Failure modes:</strong> None aside from unexpected runtime error (reported).<br><strong>Tests:</strong> Empty, whitespace-only, valid string. Replaceable by pluggable rule validation. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ImportTrialBalanceAdvanced</strong> — <em>full hardened import pipeline</em><br><strong>Purpose:</strong> Single authoritative import pipeline handling multiple source types (sheet/csv/workbook/json/powerquery), staging, validation, preview, commit, audit, and locking. Backwards-compatible public API used by UI and scheduled jobs.<br><strong>Signature:</strong> <code>Public Sub ImportTrialBalanceAdvanced(Optional sourceType As String = &quot;sheet&quot;, Optional sourcePath As String = &quot;&quot;, Optional targetWb As Workbook = Nothing, Optional profileName As String = &quot;&quot;, Optional dryRun As Boolean = False, Optional allowOverwrite As Boolean = False)</code><br><strong>Behavior (high-level):</strong><br>- Generate correlation id, resolve target workbook.<br>- Acquire import lock (workbook-level) with <code>AcquireImportLock</code> (best-effort fail if busy).<br>- Read source according to <code>sourceType</code> (delegates to <code>ReadFromActiveSheetToArray</code>, <code>ReadCsvToArray</code>, <code>ReadWorkbookRangeToArray</code>, <code>ReadJsonToArray</code>, <code>ReadFromPowerQueryStub</code>). Path inputs policy-checked with <code>IsAllowedPath</code> before file access.<br>- Create/ensure staging sheet (<code>CreateOrEnsureStagingSheet</code>), write array atomically (<code>WriteArrayToSheetAtomic</code>). Ensure staging schema token (<code>EnsureStagingSchema</code>) and assign stable row IDs (<code>AssignStableRowIDs</code>).<br>- Produce preview (<code>PreviewImport</code>) and run schema-driven validations (<code>ValidateStagingSheetSchemaDriven</code>). If validation errors present, write errors (<code>WriteErrorsToSheet</code>), audit, and abort unless <code>dryRun</code> true.<br>- If <code>dryRun</code> true, audit and exit; otherwise <code>CommitStagingToDestination</code> with optional <code>allowOverwrite</code> and audit commit.<br>- Always attempt to release lock in <code>CleanExit</code> and on error path.<br><strong>Complexity:</strong> Dominated by read operation (I/O, CSV parsing) and <code>WriteArrayToSheetAtomic</code> O(rows*cols).<br><strong>Side-effects:</strong> Reads external files, modifies workbook (staging, preview, destination), creates backup sheets, writes audit via <code>LogAudit</code>, creates/deletes very-hidden sheets for locks and backups.<br><strong>Invariants:</strong> After successful commit, staging renamed to committed token; backups created for overwritten destinations. CorrelationID propagated to audit calls.<br><strong>Failure modes:</strong> File not found or inaccessible, path not allowed, CSV/JSON parse failures, validation errors, workbook lock present, inability to manipulate worksheets (protected/workbook read-only), errors in helper functions. Pipeline uses <code>HandleError</code> to report and best-effort lock release.<br><strong>Security:</strong> Uses <code>IsAllowedPath</code> to block privileged system paths; however filepath policy is coarse — requires review for environment-specific constraints. Avoid running with elevated privileges.<br><strong>Recommended tests:</strong> All <code>sourceType</code> variants (sheet/csv/xlsx/json/powerquery), large file streaming path (>STREAMING_THRESHOLD_BYTES), invalid paths, validation error injection, dryRun vs commit, overwrite toggles, concurrent import lock scenario, failure during commit to verify lock release and backups.<br><strong>Notes:</strong> Critical function—changes require staged rollouts and heavy regression tests. Ensure <code>HandleError</code> and <code>LogAudit</code> are robust. Consider improving <code>IsAllowedPath</code> to use whitelist and canonical path resolution. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadFromActiveSheetToArray</strong> — <em>read a named sheet into Variant array</em><br><strong>Purpose:</strong> Read used range from named sheet in given workbook and return as variant array (or Empty on failure).<br><strong>Signature:</strong> <code>Private Function ReadFromActiveSheetToArray(ByVal wb As Workbook, ByVal sheetName As String) As Variant</code><br><strong>Behavior:</strong> Safely get worksheet via <code>SafeGetWorksheet</code>. Read <code>UsedRange</code> and return <code>.Value</code>. Uses <code>On Error GoTo ErrHandler</code> and returns <code>Empty</code> if missing or error.<br><strong>Complexity:</strong> O(#cells returned).<br><strong>Side-effects:</strong> None (reads only).<br><strong>Invariants:</strong> Returns <code>Empty</code> for empty sheet or inaccessible sheet.<br><strong>Failure modes:</strong> Protected sheet but accessible via <code>SafeGetWorksheet</code>? If <code>UsedRange</code> fails, returns <code>Empty</code>.<br><strong>Tests:</strong> Existing named sheet with data, missing sheet, sheet with 0 used cells. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadCsvToArray</strong> — <em>robust CSV file reader with streaming</em><br><strong>Purpose:</strong> Read CSV from filesystem, handle BOMs, large files (streaming), quoted fields with embedded newlines and return 2D Variant array (rows×cols) or <code>Empty</code> on failure.<br><strong>Signature:</strong> <code>Public Function ReadCsvToArray(ByVal fullPath As String) As Variant</code><br><strong>Behavior (detailed):</strong><br>- Validate <code>fullPath</code>; open file in Binary mode; determine <code>LOF</code>; read as whole or via <code>ReadBinaryStreamAsString</code> when size > <code>STREAMING_THRESHOLD_BYTES</code>.<br>- Normalize line endings/BOM via <code>NormalizeTextNewlinesAndBOM</code>.<br>- Build logical records using <code>BuildCsvLogicalRecords</code> (state machine that respects quoted newlines and doubled quotes).<br>- Determine maximum columns by splitting each record with <code>SplitCsvLine_Strict</code>, allocate <code>out(1..rCount,1..cMax)</code> and fill row/col values; returns 1-based 2D array.<br>- Always closes file and handles errors with <code>HandleError</code> and returns <code>Empty</code> on error.<br><strong>Complexity:</strong> O(file size + total parsed cells). Memory bound by <code>out</code> array; streaming threshold reduces memory pressure for reading raw string but full <code>out</code> still kept in memory.<br><strong>Side-effects:</strong> Reads disk; none to workbook.<br><strong>Invariants:</strong> Each returned row has <code>cMax</code> columns (empty strings where missing). Field trimming applies to unquoted fields (see <code>SplitCsvLine_Strict</code>).<br><strong>Failure modes:</strong> Malformed CSV that breaks parser (should be robust), binary files incorrectly decoded as VBA String, BOM handling errors, memory exhaustion for extremely large files. File locked/inaccessible produces <code>Empty</code> and <code>HandleError</code> call.<br><strong>Security:</strong> Uses <code>IsAllowedPath</code> upstream; ensure path canonicalization before call in public API.<br><strong>Tests:</strong> Simple CSV, quoted fields with embedded newlines, escaped double quotes, trailing commas, empty fields, very large file > STREAMING_THRESHOLD_BYTES, BOM variants (UTF-8, UTF-16 LE/BE). Validate column alignment. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadBinaryStreamAsString</strong> — <em>chunked binary reader</em><br><strong>Purpose:</strong> Read a large binary file in blocks and concatenate into a VBA String to reduce single-call memory overhead.<br><strong>Signature:</strong> <code>Private Function ReadBinaryStreamAsString(ByVal fnum As Long, ByVal totalBytes As Long) As String</code><br><strong>Behavior:</strong> Loops reading <code>blockSize</code> (65536) blocks via <code>Get #fnum, , buffer</code>, concatenates into <code>result</code>, returns string. Handles errors and returns <code>&quot;&quot;</code> on error.<br><strong>Complexity:</strong> O(totalBytes).<br><strong>Side-effects:</strong> Advances file read pointer; caller must close file.<br><strong>Failure modes:</strong> Memory growth when <code>result</code> becomes large; VBA string concatenation can be inefficient for extremely large files (consider using ADODB.Stream in environments that support it).<br><strong>Tests:</strong> Read file sized exactly blockSize, non-multiple sizes, very large file. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>NormalizeTextNewlinesAndBOM</strong> — <em>clean line endings and strip BOMs</em><br><strong>Purpose:</strong> Convert CRLF/CR to LF and remove common BOMs (UTF-8 EF BB BF, UTF-16 LE/BE) and null bytes produced from UTF-16 read as binary.<br><strong>Signature:</strong> <code>Private Function NormalizeTextNewlinesAndBOM(ByVal txt As String) As String</code><br><strong>Behavior:</strong> Detects leading BOM byte sequences by <code>Asc(Mid$(...))</code> checks; strips BOM and null characters for UTF-16; replaces <code>vbCrLf</code> and <code>vbCr</code> with <code>vbLf</code>.<br><strong>Complexity:</strong> O(len(txt)).<br><strong>Side-effects:</strong> None external.<br><strong>Invariants:</strong> Output uses <code>vbLf</code> only for line separators and contains no leading BOMs or <code>vbNullChar</code> when strip logic applies.<br><strong>Failure modes:</strong> Non-text binary files—function still returns processed string possibly corrupted; callers should validate file type. UTF-16 detection depends on reading raw bytes into a VBA String—this can mis-detect in some hosts.<br><strong>Tests:</strong> Strings with CRLF, CR-only, UTF-8 BOM, UTF-16 LE/BE BOM with nulls. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>BuildCsvLogicalRecords</strong> — <em>state-machine to assemble CSV records</em><br><strong>Purpose:</strong> Convert normalized CSV text into logical record strings where record boundaries ignore LFs inside quoted fields.<br><strong>Signature:</strong> <code>Private Function BuildCsvLogicalRecords(ByVal raw As String) As Collection</code><br><strong>Behavior:</strong> Iterates characters, toggles <code>inQuotes</code> on un-escaped quotes, treats doubled <code>&quot;&quot;</code> as escaped quote, accumulates <code>sb</code>, and when encountering <code>vbLf</code> outside quotes commits record (<code>sb</code> without trailing LF). Returns <code>Collection</code> of record strings. Adds final partial record if non-empty.<br><strong>Complexity:</strong> O(len(raw)).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Each collection item corresponds to a CSV logical row; embedded newlines remain inside record strings.<br><strong>Failure modes:</strong> Extremely large raw strings may exhaust memory. Resilient to malformed quotes (will toggle inQuotes which could produce unexpected grouping).<br><strong>Tests:</strong> Lines with embedded newlines inside quoted fields, doubled quotes, last record without trailing LF. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SplitCsvLine_Strict</strong> — <em>RFC-like CSV field splitter</em><br><strong>Purpose:</strong> Strict per-line CSV splitter that handles quoted fields, doubled quotes, trailing commas and trims unquoted fields.<br><strong>Signature:</strong> <code>Private Function SplitCsvLine_Strict(ByVal line As String) As String()</code><br><strong>Behavior:</strong> Character-by-character FSM: starts/ends quoted fields, treats <code>&quot;&quot;</code> as escaped quote inside quoted field, splits on commas outside quotes. If field was quoted, value preserved (including internal whitespace); otherwise <code>Trim$</code> applied. Returns zero-based string array of fields. On error returns single empty string array.<br><strong>Complexity:</strong> O(len(line)).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Quoted field preserves inner spaces; unquoted trimmed. Escaped quotes become single <code>&quot;</code>.<br><strong>Failure modes:</strong> Non-standard CSV flavours (multichar separators) unsupported; malformed quotes might be handled best-effort.<br><strong>Tests:</strong> Quoted fields with commas/newlines/double quotes, trailing commas producing empty fields, unquoted fields with spaces trimmed. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadWorkbookRangeToArray</strong> — <em>open workbook and read first worksheet used range</em><br><strong>Purpose:</strong> Open external workbook (if not already open), read <code>Worksheets(1).UsedRange</code> into a Variant array, and close workbook if opened by this function. Implements retry for transient file open failures.<br><strong>Signature:</strong> <code>Public Function ReadWorkbookRangeToArray(ByVal workbookPath As String) As Variant</code><br><strong>Behavior:</strong> Validates path, attempts to locate workbook in <code>Workbooks</code> collection by name, otherwise opens with <code>Workbooks.Open(..., ReadOnly:=True)</code> with retry loop up to <code>MAX_OPEN_RETRIES</code> with waits <code>SleepMs</code>. Returns used range <code>.Value</code> or <code>Empty</code>. Ensures opened workbook closed if function opened it.<br><strong>Complexity:</strong> O(size of used range + costs to open workbook).<br><strong>Side-effects:</strong> May open external workbook and close it; does not alter source workbook.<br><strong>Invariants:</strong> If <code>opened</code> flag set, will close with <code>SaveChanges:=False</code> on exit/exception.<br><strong>Failure modes:</strong> File locked/inaccessible, long open times, workbook without worksheets or empty sheet returns <code>Empty</code>.<br><strong>Tests:</strong> File already open, file closed, transient lock simulated forcing retry, workbook with empty sheet, workbook with large used range. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>FilenameOnly</strong> — <em>extract filename from path</em><br><strong>Purpose:</strong> Return filename from full path using <code>Application.PathSeparator</code>.<br><strong>Signature:</strong> <code>Private Function FilenameOnly(ByVal path As String) As String</code><br><strong>Behavior:</strong> Returns substring after last path separator using <code>InStrRev</code>. Returns empty string for empty path. Uses <code>On Error Resume Next</code> defensively.<br><strong>Complexity:</strong> O(len(path)).<br><strong>Tests:</strong> Paths with <code>\</code> or <code>/</code> (host dependent), empty string. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadJsonToArray</strong> — <em>best-effort JSON to 2D array parser</em><br><strong>Purpose:</strong> Parse JSON files that are either array-of-objects or array-of-arrays into an Excel-compatible 2D Variant array. Uses RegExp where available to extract key/value pairs for simple object shapes. Falls back to naive parsing if RegExp not available.<br><strong>Signature:</strong> <code>Public Function ReadJsonToArray(ByVal fullPath As String) As Variant</code><br><strong>Behavior (detailed):</strong><br>- Reads file into <code>txt</code> string; replace newlines/tabs with spaces; quick check for top-level <code>[</code> and <code>]</code> for parsability; if JSON contains objects (<code>{</code>) iterates characters to extract top-level <code>{...}</code> objects by brace counting.<br>- If <code>VBScript.RegExp</code> available, uses a tolerant pattern to extract <code>&quot;key&quot;:value</code> pairs; builds <code>Scripting.Dictionary</code> per object and collects headers (unique keys order-of-first-seen). Otherwise falls back to naive split by commas inside the object body (best-effort).<br>- If input is an array-of-arrays, calls <code>JsonArrayToVBAArray</code> to return a 2D array.<br>- Constructs <code>rows(1..n,1..colCount)</code> with headers in row 1 and object values in subsequent rows; returns <code>Empty</code> on errors.<br><strong>Complexity:</strong> O(len(txt) + #objects * #keys) — parser is not fully JSON-compliant and will fail for complex nested or escaped structures.<br><strong>Side-effects:</strong> None to workbook.<br><strong>Invariants:</strong> Works only for flat objects and simple arrays; outputs header row followed by row values matching header ordering discovered during parsing.<br><strong>Failure modes:</strong> Complex JSON (nested arrays/objects, strings with embedded <code>}</code> or <code>,</code> sequences), strings with escaped quotes or unicode escapes, arrays-of-objects with inconsistent keys — parser may produce incomplete or incorrect results. Reliance on RegExp pattern is brittle. Caller should prefer canonical JSON parser or pre-convert JSON to CSV.<br><strong>Security:</strong> Parsing using regex is fragile and may be exploited with specially crafted input; ensure files are trusted or validated. Do not evaluate any code from file.<br><strong>Tests:</strong> Small arrays-of-objects, arrays-of-arrays, objects with missing keys, large JSON, malformed JSON to verify <code>Empty</code> return. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>JsonArrayToVBAArray</strong> — <em>simple array-of-arrays extractor</em><br><strong>Purpose:</strong> Convert top-level JSON array-of-arrays string into 2D Variant array (best-effort).<br><strong>Signature:</strong> <code>Private Function JsonArrayToVBAArray(ByVal txt As String) As Variant</code><br><strong>Behavior:</strong> Strips outer <code>[]</code>, iterates to find subarray <code>[...]</code> blocks by depth counting, splits each interior by commas (naive), trims quotes, builds 1-based 2D Variant. Not a full JSON parser; intended for simple numeric/string arrays.<br><strong>Complexity:</strong> O(len(txt)).<br><strong>Failure modes:</strong> Fails for nested arrays, commas inside quoted strings; returns <code>Empty</code> on parse failure.<br><strong>Tests:</strong> <code>[[1,2],[3,4]]</code>, <code>[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]</code>. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadFromPowerQueryStub</strong> — <em>placeholder for Power Query integration</em><br><strong>Purpose:</strong> Stub function returning <code>Empty</code>—placeholder to integrate Power Query data extraction per profileName in future.<br><strong>Signature:</strong> <code>Private Function ReadFromPowerQueryStub(ByVal profileName As String) As Variant</code><br><strong>Behavior:</strong> Immediately returns <code>Empty</code>.<br><strong>Notes:</strong> Implementers should replace with actual Power Query connector or OLE/COM bridge. Tests: none. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SafeGetWorksheet</strong> — <em>defensive worksheet getter</em><br><strong>Purpose:</strong> Return Worksheet object for <code>sheetName</code> or <code>Nothing</code> if inaccessible (handles protected/very-hidden by returning object - operations later must handle visibility/unprotect if needed).<br><strong>Signature:</strong> <code>Public Function SafeGetWorksheet(ByVal wb As Workbook, ByVal sheetName As String) As Worksheet</code><br><strong>Behavior:</strong> Defensive <code>On Error</code> attempts to access <code>wb.Worksheets(sheetName)</code> and returns <code>Nothing</code> on error.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> If sheet exists and accessible object returned; does not change visibility. Consumers must treat <code>Nothing</code> as missing. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>CreateOrEnsureStagingSheet</strong> — <em>staging sheet lifecycle manager & migration shim</em><br><strong>Purpose:</strong> Ensure staging worksheet <code>_IFRS_Staging</code> exists; reuse existing, migrate very-hidden backups that contain <code>STAGING_SCHEMA_TOKEN</code>, or create a new very-hidden sheet. On existing sheet, clears contents but preserves A1 schema token if present and keeps original visibility/position.<br><strong>Signature:</strong> <code>Private Function CreateOrEnsureStagingSheet(ByVal wb As Workbook) As Worksheet</code><br><strong>Behavior:</strong><br>- If <code>STAGING_SHEET_NAME</code> exists: read cell A1 token, clear contents while preserving token, restore visibility.<br>- Otherwise iterate <code>wb.Worksheets</code> for <code>xlSheetVeryHidden</code> sheets whose A1 contains <code>STAGING_SCHEMA_TOKEN</code> and re-name to staging (as migration shim).<br>- Else add new worksheet at end and mark <code>xlSheetVeryHidden</code> and name it.<br><strong>Complexity:</strong> O(#sheets) scanning for migration shim.<br><strong>Side-effects:</strong> May change visibility briefly; creates new very-hidden sheets; clears existing staging content (but preserves token cell as implemented).<br><strong>Invariants:</strong> After call, a worksheet reference to staging is returned; when reusing existing sheet the token in A1 may be preserved.<br><strong>Failure modes:</strong> Naming conflicts, protected workbook preventing sheet creation, permission errors; code uses error suppression for name/visibility ops.<br><strong>Tests:</strong> Existing visible staging, existing very-hidden backup with token, no staging present, failure to add sheet (protected workbook). </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>EnsureStagingSchema</strong> — <em>place schema token and canonical header mechanics</em><br><strong>Purpose:</strong> Place the <code>STAGING_SCHEMA_TOKEN</code> in A1, ensure a canonical header row at row 2, and migrate data down if needed (if row 1 contains data after adding token).<br><strong>Signature:</strong> <code>Private Sub EnsureStagingSchema(ByVal stagingWs As Worksheet)</code><br><strong>Behavior:</strong> Sets A1 token; computes <code>lastCol</code>; if top-left region appears to be data (row 1 has other values), shifts used range down by 1 row, clearing old area. Temporarily disables screen updating and events.<br><strong>Complexity:</strong> O(size of used range) when shifting data.<br><strong>Side-effects:</strong> Moves sheet data one row down when needed; may change sheet contents. Uses <code>Application.ScreenUpdating</code> and <code>EnableEvents</code> toggles.<br><strong>Failure modes:</strong> Shifting may be lossy if used range calculation incorrect; concurrency if other code expects data in same positions. Tests: staging sheet with data in row1 becomes header at row2; empty sheet unaffected. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>WriteArrayToSheetAtomic</strong> — <em>fast atomic write with event suppression</em><br><strong>Purpose:</strong> Write a (possibly non 1-based) variant array into <code>ws</code> cells quickly while suppressing screen updates and events to avoid flicker and event recursion.<br><strong>Signature:</strong> <code>Private Sub WriteArrayToSheetAtomic(ByVal ws As Worksheet, ByVal arr As Variant, Optional ByVal trimEmptyCols As Boolean = False)</code><br><strong>Behavior:</strong> If <code>arr</code> not an array, writes single cell. Else normalizes with <code>Normalize2DArrayTo1Based_Flexible</code>, determines <code>rCount</code>/<code>cCount</code>, disables <code>ScreenUpdating</code> and <code>EnableEvents</code>, and writes <code>ws.Range(...).Value = a1</code>. Restores previous <code>Application</code> flags even on error. Uses <code>On Error GoTo ErrHandler</code> for robust restore.<br><strong>Complexity:</strong> O(rows*cols) memory and runtime. Fastest available method in VBA for block writes.<br><strong>Side-effects:</strong> Overwrites target range content; may trigger recalculation on re-enabled events.<br><strong>Invariants:</strong> <code>Application</code> flags are restored on exit/exception.<br><strong>Failure modes:</strong> arr shape mismatches will raise errors; large arrays may exceed worksheet limits (max rows/columns) leading to error. Tests: 1D/2D arrays with different base indices, non-array scalar write. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Normalize2DArrayTo1Based_Flexible</strong> — <em>array shape normalizer</em><br><strong>Purpose:</strong> Take varied array shapes (scalars, 1D 0-based/1-based arrays, or 2D arrays with arbitrary bounds) and return a 1-based 2D Variant array suitable for direct Range writes.<br><strong>Signature:</strong> <code>Private Function Normalize2DArrayTo1Based_Flexible(ByVal arr As Variant) As Variant</code><br><strong>Behavior:</strong> Detects <code>IsArray</code>; if not array, returns 1×1 with <code>Nz(arr,&quot;&quot;)</code>; if 1D builds 1×N array; if 2D copies elements into new 1-based 2D <code>out</code>; raises error for dims >2.<br><strong>Complexity:</strong> O(total elements).<br><strong>Invariants:</strong> Output always 1-based 2D array. Preserves string/numeric values via <code>Nz</code>.<br><strong>Failure modes:</strong> Multi-dimensional arrays >2 dims cause raised error. Tests: 0-based/1-based 1D arrays, 2D arrays with non-1 lower bounds. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>GetArrayDimensions</strong> — <em>detect 1D vs 2D arrays</em><br><strong>Purpose:</strong> Return 1 or 2 for array dimensionality (1 or 2).<br><strong>Signature:</strong> <code>Private Function GetArrayDimensions(ByVal arr As Variant) As Long</code><br><strong>Behavior:</strong> Attempts <code>LBound(arr,1)</code> and <code>LBound(arr,2)</code> using <code>On Error</code> to infer dims. Returns 0 if not array.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> 1D and 2D arrays. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>AssignStableRowIDs</strong> — <em>deterministic stable RowID assignment</em><br><strong>Purpose:</strong> Ensure each data row in staging has a stable unique <code>IFRS_RowID</code> column without overwriting existing IDs. Format: <code>RB-{UTCstamp}-{RowIndex}-{Rand6}</code>.<br><strong>Signature:</strong> <code>Private Sub AssignStableRowIDs(ByVal stagingWs As Worksheet, ByVal correlationID As String)</code><br><strong>Behavior:</strong> Find existing <code>ROWID_HEADER</code> column; if missing, add it to end. Determine <code>lastRow</code>, build <code>existingIds</code> dictionary scanning existing values, then for each data row without ID generate <code>utcStamp = GetUtcStampForId()</code>, generate 6-digit random part, ensure uniqueness against <code>existingIds</code>, write to cell. Logs audit with count assigned.<br><strong>Complexity:</strong> O(rows).<br><strong>Side-effects:</strong> Writes identifiers into staging sheet; uses <code>Randomize</code> then <code>Rnd()</code>; writes log audit.<br><strong>Invariants:</strong> Does not overwrite existing IDs; IDs deterministic format with timestamp and row index; uniqueness ensured by per-run dictionary check and randomized 6-digit suffix.<br><strong>Failure modes:</strong> If multiple processes run simultaneously in same workbook, risk of collision only if rows processed concurrently—lock mechanism should prevent this. <code>GetUtcStampForId</code> may fallback to local time when timezone not available — acceptable but note for cross-host determinism.<br><strong>Tests:</strong> Staging with prepopulated IDs, staging with none, ensure no duplicates and consistent format. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>GetUtcStampForId</strong> — <em>UTC timestamp helper with fallback</em><br><strong>Purpose:</strong> Compute UTC-based timestamp string <code>yyyymmddHHMMSS</code> for row IDs; falls back to local time if <code>Application.TimeZone</code> not present.<br><strong>Signature:</strong> <code>Private Function GetUtcStampForId() As String</code><br><strong>Behavior:</strong> Attempts to read <code>Application.TimeZone</code> (minutes offset) and subtracts offset from <code>Now</code>; formats using <code>Format(ts,&quot;yyyymmddHHMMSS&quot;)</code>. On error returns local formatted <code>Now</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Host may not expose <code>Application.TimeZone</code> consistently; document that timestamp may be local fallback. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>PreviewImport</strong> — <em>create/refresh visible preview sheet</em><br><strong>Purpose:</strong> Copy first N rows from staging into a visible preview sheet <code>_IFRS_Preview</code> for user inspection and auditing.<br><strong>Signature:</strong> <code>Private Sub PreviewImport(ByVal stagingWs As Worksheet, Optional ByVal rowsToShow As Long = 50, Optional ByVal correlationID As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Ensures preview worksheet exists (creates if missing), clears prior content, copies used range subset to preview using array copy for speed, sets preview visible and activates it. Logs audit with row count.<br><strong>Complexity:</strong> O(rowsToShow * cols).<br><strong>Side-effects:</strong> Creates/modifies visible worksheet; may change active sheet. Temporarily toggles Application settings. <br><strong>Invariants:</strong> Preview contains a top portion of staging data. <br><strong>Failure modes:</strong> Protected workbook preventing sheet creation, large <code>rowsToShow</code> exceeding memory. Tests: preview created, preview updated, preview visible. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>CommitStagingToDestination</strong> — <em>atomic commit with backup & audit</em><br><strong>Purpose:</strong> Commit staging contents into destination sheet named <code>destSheetName</code> with optional overwrite safeguard and backup copy creation (very-hidden). Uses array transfer for atomic operation and renames staging to committed token on success.<br><strong>Signature:</strong> <code>Private Sub CommitStagingToDestination(ByVal wb As Workbook, ByVal stagingWs As Worksheet, ByVal destSheetName As String, ByVal allowOverwrite As Boolean, ByVal correlationID As String)</code><br><strong>Behavior:</strong> If destination exists and <code>allowOverwrite</code> false → error. If destination exists and overwriting allowed → copy existing destination to a new sheet named with <code>IMPORT_BACKUP_PREFIX + dest</code> + timestamp and mark <code>xlSheetVeryHidden</code>. If dest missing create new sheet. Copy staging <code>UsedRange.Value</code> into destination via arrays. Rename staging to <code>STAGING_SHEET_NAME &amp; &quot;_COMMITTED_&quot; &amp; timestamp</code>. Log audit.<br><strong>Complexity:</strong> O(rows*cols) for array copy.<br><strong>Side-effects:</strong> Creates very-hidden backup sheet, modifies workbook (dest sheet), renames staging sheet. May delete/rename sheets. Writes audit entries.<br><strong>Failure modes:</strong> Protected workbook preventing copy/delete, naming conflicts when setting backup name, insufficient workbook space, Excel sheet name length limits, failure to create backup leaves risk. Tests: Overwrite allowed/forbidden flows, backup creation and visibility, checksum/round-trip verification. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>UndoLastImport</strong> — <em>restore latest import backup</em><br><strong>Purpose:</strong> Locate latest import backup sheet (by <code>IMPORT_BACKUP_PREFIX</code> timestamp suffix), copy it as visible sheet restoring destination, and perform checksum verification between backup and restored copy; logs audit.</br><strong>Signature:</strong> <code>Public Sub UndoLastImport(Optional ByVal targetWb As Workbook = Nothing)</code><br><strong>Behavior:</strong> Resolves target workbook, scans worksheets for names starting with <code>IMPORT_BACKUP_PREFIX</code>, parses timestamps from name parts into Date via <code>ParseBackupTimestamp</code>, selects latest, determine original destination name from backup name, delete existing destination if present, copy latest backup to end of workbook, rename to original name and make visible. Compute checksum for restored and source backup with <code>ComputeWorksheetChecksum</code> and log mismatch or success. Errors reported via <code>HandleError</code>.<br><strong>Complexity:</strong> O(#sheets + sheet size for checksum).<br><strong>Side-effects:</strong> Deletes existing destination sheet (with <code>Application.DisplayAlerts=False</code>), adds new visible sheet, logs audit.<br><strong>Failure modes:</strong> No backup found, name parsing failures, checksum mismatch, permission errors while deleting destination.<br><strong>Tests:</strong> Single backup, multiple backups with different timestamps, missing backups, corrupted sheets producing checksum mismatch. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ComputeWorksheetChecksum</strong> — <em>deterministic simple checksum</em><br><strong>Purpose:</strong> Compute a reproducible checksum of a worksheet by summing lengths of all cell textual content modulo 2^31-1. Used for round-trip verification on undo/restore.<br><strong>Signature:</strong> <code>Private Function ComputeWorksheetChecksum(ByVal ws As Worksheet) As Long</code><br><strong>Behavior:</strong> Reads <code>UsedRange</code> into array, iterates cells accumulating <code>Len(CStr(Nz(...,&quot;&quot;)))</code>, returns <code>CLng(sum Mod 2147483647)</code>; returns 0 on empty or error.<br><strong>Complexity:</strong> O(#cells).<br><strong>Limitations:</strong> Not cryptographic; collisions possible; sensitive to whitespace and formatting changes; serves as a fast sanity check only.<br><strong>Tests:</strong> Round-trip identical content produces same checksum; changed cell alters checksum. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ValidateStagingSheetSchemaDriven</strong> — <em>row-by-row schema validator</em><br><strong>Purpose:</strong> Validate staging rows against a schema-driven rule set (required, numeric, date, regex optional) and COA validation; returns <code>Scripting.Dictionary</code> of row errors keyed by row number or <code>Nothing</code> on error.<br><strong>Signature:</strong> <code>Private Function ValidateStagingSheetSchemaDriven(ByVal stagingWs As Worksheet, ByVal correlationID As String) As Object</code><br><strong>Behavior:</strong> Builds <code>headers</code> map from row1, constructs <code>rules</code> dictionary (<code>account: required</code>, <code>balance: required,numeric</code>), iterates rows 2..lastRow, applies rules (presence, numeric check), performs <code>ValidateCOA</code> on <code>account</code> values, aggregates <code>rowErrors</code> and adds to returned dictionary with <code>rowIdx</code> as key. If no errors returns empty dictionary. On error returns <code>Nothing</code>.<br><strong>Complexity:</strong> O(rows * rules).<br><strong>Side-effects:</strong> None (reads only).<br><strong>Invariants:</strong> Row numbers in returned dictionary correspond to staging sheet rows. Rule set is in-module and must be updated when schema changes.<br><strong>Failure modes:</strong> Missing header columns cause <code>Header missing</code> errors logged to each row; complex validation requirements require enhancement of <code>rules</code> expression parsing. Tests: missing headers, non-numeric balance, empty account, COA invalid. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>WriteErrorsToSheet</strong> — <em>emit import validation errors to sheet</em><br><strong>Purpose:</strong> Create or clear <code>_IFRS_ImportErrors</code> sheet and write a table of row number, error text, and IFRS_RowID for errors found during validation.<br><strong>Signature:</strong> <code>Private Sub WriteErrorsToSheet(ByVal wb As Workbook, ByVal errorsDict As Object, Optional ByVal correlationID As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Creates <code>IMPORT_ERRORS_SHEET</code> if missing, clears content if exists, writes headers <code>Row</code>, <code>Error</code>, <code>IFRS_RowID</code>, iterates <code>errorsDict</code> and writes rows, makes sheet visible, logs audit with count. Uses <code>SafeGetWorksheet</code> for retrieval.<br><strong>Complexity:</strong> O(#errors).<br><strong>Side-effects:</strong> Modifies/creates visible sheet. <br><strong>Tests:</strong> errorsDict empty; errorsDict with several rows; ensure visibility and content correctness. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>DetectDuplicatesInStaging</strong> — <em>group by key columns to detect duplicates</em><br><strong>Purpose:</strong> Detect duplicate rows by concatenating values from <code>keyColumns</code> (default <code>[&quot;account&quot;,&quot;balance&quot;]</code>) and return <code>Scripting.Dictionary</code> mapping keyVal -> Collection of row indexes where that key occurs.<br><strong>Signature:</strong> <code>Public Function DetectDuplicatesInStaging(ByVal stagingWs As Worksheet, Optional ByVal keyColumns As Variant) As Object</code><br><strong>Behavior:</strong> Build header map, iterate rows 2..lastRow building <code>keyVal</code> by concatenating keys; uses <code>Scripting.Dictionary</code> to collect <code>Collection</code> of row numbers per key. Returns empty dictionary if none.<br><strong>Complexity:</strong> O(rows * #keyColumns).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Key construction depends on header existence and exact header lowercasing — header name mismatch results in empty column values used in key.<br><strong>Tests:</strong> Duplicate rows for default keys, custom keyColumns array, missing header handling. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>AcquireImportLock</strong> — <em>workbook-level import lock using very-hidden sheet</em><br><strong>Purpose:</strong> Provide a simple workbook-scope mutual exclusion for import operations by creating a very-hidden sheet named <code>_IFRS_ImportLock</code> containing timestamp and correlationID. Detects stale locks older than 60 minutes and breaks them.<br><strong>Signature:</strong> <code>Private Function AcquireImportLock(ByVal wb As Workbook, ByVal correlationID As String) As Boolean</code><br><strong>Behavior:</strong> If lock sheet exists, read <code>ts</code> and <code>ownerId</code>; compute age via <code>DateDiff(&quot;n&quot;, CDate(ts), Now)</code>; if age > 60 minutes delete stale lock sheet and proceed; otherwise return False. If no lock present, add new very-hidden sheet named <code>IMPORT_LOCK_SHEET</code>, write Now and correlationID to cells (1,1) and (1,2). Returns True on successful acquisition, False otherwise. Error-return False and <code>HandleError</code> on exception.<br><strong>Complexity:</strong> O(#sheets) for lookup is O(1) when using <code>Workbooks(...).Worksheets(name)</code> direct call.<br><strong>Side-effects:</strong> Creates or deletes a very-hidden worksheet. Uses <code>Application.DisplayAlerts</code> when deleting.<br><strong>Failure modes:</strong> Race condition where two processes call <code>AcquireImportLock</code> at same time (possible in multi-process hosts); reliance on time-based stale threshold could delete a legitimately long-running import. Tests: concurrent acquisition attempts (simulate by creating lock sheet), stale lock deletion by manipulating timestamp, ownership enforcement. Consider using file/OS-level locking for robust multi-process scenarios. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReleaseImportLock</strong> — <em>release lock if owner matches</em><br><strong>Purpose:</strong> Remove <code>_IFRS_ImportLock</code> very-hidden sheet if owner matches <code>correlationID</code> or if forced (blank correlationID), log audit.<br><strong>Signature:</strong> <code>Private Sub ReleaseImportLock(ByVal wb As Workbook, ByVal correlationID As String)</code><br><strong>Behavior:</strong> Fetch lock sheet, read ownerId from cell (1,2); if <code>correlationID</code> blank or owner matches, delete sheet with <code>DisplayAlerts=False</code> and log audit. Errors routed to <code>HandleError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Deletes lock sheet; writes audit. <br><strong>Failure modes:</strong> If owner mismatch, lock not removed; ensure callers always pass correlationID. Tests: release by owner, release by blank forced, attempt to release by wrong owner. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>IsAllowedPath</strong> — <em>coarse path policy predicate</em><br><strong>Purpose:</strong> Block obvious sensitive paths (Windows system, <code>/etc</code>) and allow others. Policy gate before file I/O in public import paths.<br><strong>Signature:</strong> <code>Private Function IsAllowedPath(ByVal path As String) As Boolean</code><br><strong>Behavior:</strong> Lowercases path and rejects when it contains <code>&quot;c:\windows&quot;</code> or <code>&quot;/etc&quot;</code>; otherwise returns True. On error returns False and calls <code>HandleError</code>.<br><strong>Complexity:</strong> O(len(path)).<br><strong>Security:</strong> Very coarse — easily bypassable; MUST be hardened for production with canonical path normalization (resolve symlinks), OS-specific checks, whitelist-based directories, and runtime-configurable allowed roots. Document this as high priority to tighten.<br><strong>Tests:</strong> Paths containing <code>C:\Windows</code>, <code>/etc/passwd</code>, valid data path, empty path. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ResolveTargetWorkbook</strong> — <em>resolve workbook target defaulting to ActiveWorkbook / ThisWorkbook</em><br><strong>Purpose:</strong> Determine the workbook to operate upon: prefer explicit <code>targetWb</code>, fallback to <code>Application.ActiveWorkbook</code>, then <code>ThisWorkbook</code>.<br><strong>Signature:</strong> <code>Private Function ResolveTargetWorkbook(Optional ByVal targetWb As Workbook) As Workbook</code><br><strong>Behavior:</strong> Returns the first non-Nothing workbook found in that order. Uses <code>On Error Resume Next</code> defensively.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Pass explicit workbook, with ActiveWorkbook set/unset. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Nz</strong> — <em>null/empty helper</em><br><strong>Purpose:</strong> VBA utility to normalize common empty/Null/Error/Empty-string cases to alt default. Mirrors VB6/Access <code>Nz</code> semantics used widely in module.<br><strong>Signature:</strong> <code>Private Function Nz(v As Variant, Optional ByVal alt As Variant = &quot;&quot;) As Variant</code><br><strong>Behavior:</strong> If <code>v</code> is Error/Null/Empty or string that trims to empty returns <code>alt</code>, else returns <code>v</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> <code>Null</code>, <code>Empty</code>, <code>Err.Value</code>, <code>&quot;&quot;</code> and non-empty strings. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SleepMs</strong> — <em>millisecond sleep via Timer or DateAdd fallback</em><br><strong>Purpose:</strong> Busy-wait with <code>DoEvents</code> for the specified milliseconds; uses <code>Timer</code> on <code>VBA7</code>, otherwise <code>DateAdd</code> fallback. Used by <code>ReadWorkbookRangeToArray</code> retry logic.<br><strong>Signature:</strong> <code>Private Sub SleepMs(ms As Long)</code><br><strong>Behavior:</strong> Computes target time and loops <code>DoEvents</code> until reached. Non-blocking to UI (calls <code>DoEvents</code>) but still CPU busy loop. Use sparingly.<br><strong>Complexity:</strong> O(ms) wall time. <br><strong>Failure modes:</strong> <code>Timer</code> wraps at midnight; loop may be inaccurate across day boundaries. Alternative: <code>Application.Wait</code> could be used but is coarser. Tests: 50ms/500ms sleeps approximate timings. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>GenerateCorrelationID</strong> — <em>human-readable correlation id generator</em><br><strong>Purpose:</strong> Generate <code>CID-yyyymmddHHMMSS-rand6</code> string used across pipeline for audit and lock ownership.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Combines formatted <code>Now</code> and RNG <code>Int((Rnd()*900000)+100000)</code> to produce identifier. No guarantees of global uniqueness beyond timestamp+random suffix.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Repeated calls in same second produce different IDs usually due to random suffix—verify uniqueness for small sample sizes. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ParseBackupTimestamp</strong> — <em>parse backup timestamp suffix into Date</em><br><strong>Purpose:</strong> Parse timestamp encoded in backup sheet names either <code>yyyymmdd_HHNNSS</code> or <code>yyyymmddHHNNSS</code> into a <code>Date</code> value for ordering backups.<br><strong>Signature:</strong> <code>Private Function ParseBackupTimestamp(ByVal part As String) As Date</code><br><strong>Behavior:</strong> Splits on <code>_</code> if present and uses <code>DateSerial</code> and <code>TimeSerial</code> with substrings to build <code>Date</code>. On error returns <code>0</code> (Date 0).<br><strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Malformed timestamp string returns <code>0</code> — code must handle these cases (it does by fallback). Tests: pass both formats and malformed values. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SimpleRangeChecksum</strong> — <em>checksum helper for ranges</em><br><strong>Purpose:</strong> Sum lengths of each cell text in a <code>Range</code> for quick integrity checks similar to <code>ComputeWorksheetChecksum</code> but limited to a specific range.<br><strong>Signature:</strong> <code>Private Function SimpleRangeChecksum(ByVal rng As Range) As Long</code><br><strong>Behavior:</strong> Reads <code>rng.Value</code> into array, sums <code>Len(CStr(Nz(...)))</code>, returns modulo constant. Returns 0 on failure or empty range.<br><strong>Complexity:</strong> O(#cells).<br><strong>Tests:</strong> Two identical ranges produce equal checksums. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>DataInputSelfTests</strong> — <em>module-level smoke tests</em><br><strong>Purpose:</strong> Perform a small set of self-tests to verify core CSV parsing, staging sheet creation/writes, and JSON parsing capabilities to detect environmental regressions.<br><strong>Signature:</strong> <code>Public Function DataInputSelfTests() As Boolean</code><br><strong>Behavior:</strong> Tests <code>SplitCsvLine_Strict</code> with sample line, ensures <code>CreateOrEnsureStagingSheet</code> returns a sheet, round-trip write/read small array with <code>WriteArrayToSheetAtomic</code>, creates temporary JSON file and runs <code>ReadJsonToArray</code>, returns boolean success and logs audit <code>&quot;SelfTest&quot;</code>. Uses filesystem (ThisWorkbook.Path) to write a temp file.<br><strong>Complexity:</strong> Small O(n) tests; may fail on locked or protected paths.<br><strong>Side-effects:</strong> Creates preview staging sheet, writes temp test file in workbook path and removes it. Logs audit.<br><strong>Failure modes:</strong> Environments that forbid file writes or sheet creation will fail test; tests rely on production helper behaviour.<br><strong>Tests:</strong> Self-test result True expected in normal environment. Use in CI to catch regressions. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Module-level remarks / cross-cutting concerns</strong><br>- <strong>External dependencies:</strong> Module uses <code>HandleError(module, code, desc)</code> and <code>LogAudit(event,message,Optional metadata)</code> which must exist and be robust; missing implementations will break error/audit flows. Ensure these helpers are unit-tested and non-blocking (avoid raising errors themselves).<br>- <strong>Error handling style:</strong> Heavy use of <code>On Error GoTo ErrHandler</code> and <code>On Error Resume Next</code>. <code>ErrHandler</code> flows usually call <code>HandleError</code> and attempt best-effort cleanup (lock release). Maintainers must ensure <code>HandleError</code> is safe during error contexts.<br>- <strong>Locking model:</strong> Workbook-level lock implemented via very-hidden sheet is simple but not atomic across Excel instances/processes — evaluate OS-level file locking or external semaphore for environments where the same file may be opened by multiple Excel processes. The lock uses a 60-minute stale cutoff — configurable constant would be better.<br>- <strong>Path policy:</strong> <code>IsAllowedPath</code> is intentionally conservative but weak; for production environments implement canonical path normalization, restrict to configured allowed directories, disallow UNC paths if not permitted, and handle Windows vs Unix path semantics.<br>- <strong>CSV/JSON parsing:</strong> CSV logic is robust for RFC-style CSV with quoted fields and embedded newlines. JSON parsing is best-effort and brittle — for production use prefer a real JSON parser (e.g., scripting runtime or MSXML/ScriptControl) if available.<br>- <strong>Large-file handling:</strong> Reading large files into VBA strings and arrays risks memory pressure; <code>STREAMING_THRESHOLD_BYTES</code> attempts to chunk raw read but final array still constructed fully in memory. Consider streaming processing or chunked conversion for very large imports. Document threshold tunable.<br>- <strong>Audit & observability:</strong> Module writes audit entries at key points (<code>AssignRowIDs</code>, <code>ImportPreview</code>, <code>ImportBackup</code>, <code>Commit</code>, <code>UndoImport</code>, <code>SelfTest</code>) — ensure <code>LogAudit</code> attaches correlationID for traceability.<br>- <strong>Determinism & IDs:</strong> <code>AssignStableRowIDs</code> uses random suffix and local timestamp; for deterministic testability consider using a cryptographic RNG source or monotonic sequence persisted to workbook metadata.<br>- <strong>Unit/integration test matrix (recommended shortlist):</strong> CSV parsing edge cases, BOMs, UTF-16 handling, large-file streaming path, staging schema migration from very-hidden legacy sheets, preview generation, validation rules (missing headers / numeric failures), duplicate detection, lock acquire/release concurrency scenarios, commit/backup/undo flows including checksum verification, DataInputSelfTests in CI, and <code>IsAllowedPath</code> policy enforcement tests.<br>- <strong>Security & safety:</strong> Avoid allowing import from system paths or arbitrary UNC shares. Sanitize filenames used for sheet names (Excel sheet name length/illegal characters). Do not evaluate any code from files. Carefully review <code>ReadJsonToArray</code> regex-based parsing for injection vectors.<br><strong>Maintenance notes (concise):</strong><br>- Keep public API stable: <code>ImportTrialBalance</code>, <code>ImportTrialBalanceAdvanced</code>, <code>ValidateCOA</code>, <code>DetectDuplicatesInStaging</code>, <code>ReadCsvToArray</code>, <code>ReadJsonToArray</code>, <code>ReadWorkbookRangeToArray</code>.<br>- Replace regex JSON parsing with robust JSON parser where available; make <code>IsAllowedPath</code> policy-driven; convert lock to more robust mechanism if multi-process concurrency required; add configurable constants for stale-lock timeout and streaming threshold; add comprehensive tests and CI gating. </td></tr></tbody></table></div><div class="row-count">Rows: 41</div></div><div class="table-caption" id="Table4" data-table="Docu_0159_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown (modError)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown (modError)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown (modError)"> <strong>Module Name</strong><br>modError.bas </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Overview:</strong><br>Deterministic, backward-compatible centralized error handling and lightweight structured logging for the IFRS Excel Add-in. Exposes a compact public API that preserves legacy behavior (raises original Err.Number after logging and user notification) while adding structured audit entries, a seeded error catalog, stable correlation IDs, and defensive fallbacks for locked-down environments (no Dictionary, no Scriptlet GUID, no native Sleep). Designed to be robust in the face of missing host services (LogAudit, NewCorrelationID) and to never allow logging to raise to callers. Intended invariants: public signatures remain stable; numeric error codes keep meaning across releases; logging must be best-effort and non-throwing. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>IFRS_ErrorSeverity (Enum)</strong> — <em>error severity levels</em><br><strong>Purpose:</strong> Provide a compact severity scale used across the module and by callers for branching (UI, audit, automation).<br><strong>Definition:</strong> <code>sevInfo = 1, sevWarning = 2, sevError = 3, sevCritical = 4</code><br><strong>Signature/Usage:</strong> used as parameter & stored in <code>IFRS_Error.severity</code>.<br><strong>Behavior:</strong> Simple numeric enum for comparisons (e.g., <code>If e.severity &gt;= sevCritical Then ...</code>).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Values must remain stable across builds (used for telemetry / audit filters).<br><strong>Failure modes:</strong> None intrinsic; mis-mapping on upgrades will change behavior of critical handlers.<br><strong>Tests:</strong> Assert comparison semantics and that severity constants are expected integers. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>IFRS_Error (Type)</strong> — <em>structured error record</em><br><strong>Purpose:</strong> Encapsulate error metadata for logging and downstream consumption (audit, telemetry, UI).<br><strong>Fields:</strong> <code>procName As String, errNum As Long, internalMsg As String, userMsg As String, severity As IFRS_ErrorSeverity, correlationID As String, contextJson As String, TimeStamp As Date</code><br><strong>Behavior:</strong> Populated by <code>HandleError</code> (or helpers) then forwarded to <code>SafeLogStructuredError</code> and to the legacy <code>Err.Raise</code>. Not marshalled beyond strings/dates inside module. Timestamp set to Now at creation.<br><strong>Complexity:</strong> O(1) allocation/copy. <br><strong>Side-effects:</strong> None by itself; used to produce audit entry and UI reaction.<br><strong>Invariants:</strong> <code>TimeStamp</code> must reflect time of error capture; <code>correlationID</code> must be non-empty after <code>HandleError</code> returns.<br><strong>Tests:</strong> Create sample IFRS_Error and assert fields set and truncated/escaped by logger as expected. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Module-level state / constants</strong> — <em>g_errorCatalog, flags, truncation constants</em><br><strong>Purpose:</strong> Persistent helpers to seed and query a message catalog and to control truncation of logged fields.<br><strong>Elements:</strong> <code>g_errorCatalog As Object</code> (Scripting.Dictionary when available), <code>g_catalogInitialized As Boolean</code>, <code>g_catalogAvailable As Boolean</code>, <code>g_randomized As Boolean</code>; constants <code>MAX_LOG_INTERNAL=800</code>, <code>MAX_LOG_USER=400</code>, <code>MAX_LOG_CONTEXT=800</code>.<br><strong>Behavior:</strong> Catalog initialization is attempted once per process; availability flag guides no-op behaviour when Dictionary unavailable. Truncation constants ensure predictable audit payload sizes. <code>g_randomized</code> guarantees <code>Randomize</code> is invoked once per session for fallback correlation ID suffix variation.<br><strong>Complexity:</strong> initialization O(N seeded items) when available; subsequent lookups O(1).<br><strong>Side-effects:</strong> Uses CreateObject which can fail in restricted hosts; code defensively sets <code>g_catalogAvailable=False</code> when that happens.<br><strong>Invariants:</strong> After first call to <code>EnsureCatalogInitialized</code>, <code>g_catalogInitialized=True</code> even if catalog unavailable (prevents repeated heavy attempts).<br><strong>Tests:</strong> Run initialization in environment with/without Scripting.Dictionary; confirm flags and counts behave. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>EnsureCatalogInitialized()</strong> — <em>one-shot catalog setup with graceful fallback</em><br><strong>Purpose:</strong> Create and populate the error catalog (Scripting.Dictionary) if available; ensure <code>Randomize</code> called once; mark initialization completed even on failure (deterministic behaviour across re-loads).<br><strong>Signature:</strong> <code>Private Sub EnsureCatalogInitialized()</code><br><strong>Behavior:</strong><br>- If already initialized, exit early.<br>- Attempt <code>CreateObject(&quot;Scripting.Dictionary&quot;)</code> under <code>On Error Resume Next</code>.<br>- If created, set <code>g_catalogAvailable = True</code>, remove any previous items, and call <code>addCatalogItem</code> repeatedly to seed codes and messages.<br>- If not available, set <code>g_catalogAvailable = False</code> and keep <code>g_errorCatalog = Nothing</code> (catalog lookup functions then return empty strings).<br>- Call <code>Randomize</code> once (guarded by <code>g_randomized</code>).<br><strong>Complexity:</strong> O(M) where M is number of seeded items (constant here).<br><strong>Side-effects:</strong> May call COM; may run with Err.Number non-zero which is cleared; safe for restricted hosts.<br><strong>Invariants:</strong> After first call, <code>g_catalogInitialized=True</code> always; consistent seeded content when dictionary exists.<br><strong>Failure modes:</strong> COM creation failure (handled), partial population (if an error occurs mid-seed) — module clears and proceeds defensively.<br><strong>Security:</strong> No external input used. <br><strong>Tests:</strong> Simulate success/failure paths; assert Idempotency and that post-initialization flags reflect environment. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>addCatalogItem(code, userMsg, remediation, Optional severity)</strong> — <em>safe catalog insertion</em><br><strong>Purpose:</strong> Insert a catalog entry into <code>g_errorCatalog</code> only when dictionary is available; no-op otherwise so missing Scripting runtime doesn't break callers.<br><strong>Signature:</strong> <code>Private Sub addCatalogItem(code As Long, userMsg As String, remediation As String, Optional severity As IFRS_ErrorSeverity)</code><br><strong>Behavior:</strong> Creates a small Scripting.Dictionary object <code>item</code> with keys <code>UserMessage</code>, <code>Remediation</code>, <code>DefaultSeverity</code> and stores it at <code>g_errorCatalog(CStr(code))</code>. Wrapped in <code>On Error Resume Next</code> and returns silently on any failure.<br><strong>Complexity:</strong> O(1) per item. <br><strong>Side-effects:</strong> Allocates COM objects (dictionary) when available; safe no-op otherwise.<br><strong>Invariants:</strong> Only invoked from initialization; duplicate keys are replaced (dictionary semantics).<br><strong>Failure modes:</strong> COM failure → no-op. <br><strong>Tests:</strong> With Scripting.Dictionary present, confirm retrieval by <code>GetUserMessageFromCatalog</code>. With dictionary absent, ensure no exception. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>HandleError(procName, errNum, Optional errMsg, Optional severity, Optional userMsg, Optional contextJson)</strong> — <em>core public handler preserving legacy flow</em><br><strong>Purpose:</strong> Centralized error capture: build structured <code>IFRS_Error</code>, choose user message (catalog override or param), ensure correlation ID, write structured audit log, show critical MsgBox when needed, then re-raise the original error (legacy behavior). Backwards-compatible signature: callers using <code>HandleError(procName, errNum, errMsg)</code> remain valid.<br><strong>Signature:</strong> <code>Public Sub HandleError(procName As String, errNum As Long, Optional errMsg As String = &quot;&quot;, Optional severity As IFRS_ErrorSeverity = sevError, Optional userMsg As String = &quot;&quot;, Optional contextJson As String = &quot;&quot;)</code><br><strong>Behavior (step-by-step):</strong><br>1. Call <code>EnsureCatalogInitialized</code> (one-shot) to enable catalog lookups.<br>2. Populate <code>IFRS_Error e</code> fields: <code>procName</code> defaulting to "Unknown", <code>errNum</code>, <code>internalMsg</code> chosen from <code>errMsg</code> or <code>GetInternalFallbackMessage(errNum)</code>, <code>severity</code> assigned from param and potentially elevated by catalog default severity if catalog has stronger severity.<br>3. Choose <code>userMsg</code>: prefer explicit <code>userMsg</code> param; else <code>GetUserMessageFromCatalog(errNum)</code>; fallback to generic message when none exists.<br>4. Generate <code>correlationID</code>: first attempt <code>Application.Run(&quot;NewCorrelationID&quot;)</code> safely (guarded with <code>On Error Resume Next</code>); if that fails or returns empty, call <code>GenerateCorrelationID()</code>.<br>5. Call <code>SafeLogStructuredError e</code> to produce compact escaped JSON string and pass to <code>LogAudit(&quot;Error&quot;, details)</code> in a best-effort fashion (must not raise).<br>6. If severity >= <code>sevCritical</code> show a <code>MsgBox</code> (guarded by error handlers so it cannot raise outward).<br>7. Finally, <code>Err.Raise errNum, procName, e.userMsg</code> to preserve legacy exception flow for callers/tests.<br><strong>Complexity:</strong> O(1) CPU per invocation; catalog lookup O(1) if available. Logging cost proportional to truncated string lengths (constant bounded by MAX_LOG_* constants).<br><strong>Side-effects:</strong> Calls Application.Run (external macro), COM (dictionary), LogAudit (external), and may show UI message box. Alters global <code>Err</code> state by <code>Err.Raise</code> (legacy behavior).<br><strong>Invariants:</strong> After return (or raising), a structured audit attempt was made and correlationID is non-empty. <code>Err.Raise</code> ensures calling code sees an error with original <code>errNum</code> and <code>userMsg</code> as Description.<br><strong>Failure modes:</strong><br>- Application.Run may throw (handled).<br>- LogAudit missing or failing — SafeLogStructuredError guards against exceptions so no propagation occurs.<br>- If <code>Err.Raise</code> itself fails unusually, host behavior follows VBA semantics; module does not suppress final raise.<br><strong>Security:</strong> <code>contextJson</code> and messages are trimmed and escaped before logging to prevent log injection. Avoid including PII in <code>contextJson</code> per privacy policies.<br><strong>Recommended tests:</strong> Simulate cases: (a) catalog present/absent; (b) <code>NewCorrelationID</code> present/absent; (c) severity levels including critical to assert MsgBox executed (can be tested with a headless hook stub); (d) confirm <code>Err.Number</code> equals provided <code>errNum</code> after call; (e) audit string format validated (escaped JSON).<br><strong>Notes for maintainers:</strong> Keep signature stable. Do not change final <code>Err.Raise</code> behavior since external code depends on legacy Err.Number/Description semantics. Ensure <code>LogAudit</code> contract exists and is non-blocking. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>RaiseIFRSError(procName, errNum, Optional internalMsg, Optional contextJson)</strong> — <em>shorthand wrapper</em><br><strong>Purpose:</strong> Convenience wrapper preserving older API shape that calls <code>HandleError</code> with <code>sevError</code> and empty user message (catalog will supply if present).<br><strong>Signature:</strong> <code>Public Sub RaiseIFRSError(procName As String, errNum As Long, Optional internalMsg As String = &quot;&quot;, Optional contextJson As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Delegates to <code>HandleError</code> with <code>sevError</code> and blank <code>userMsg</code> so catalog mapping is used. Maintains legacy call sites. <br><strong>Complexity/side-effects/failure modes:</strong> Same as <code>HandleError</code>.<br><strong>Tests:</strong> Call wrapper and assert same raise and audit outcomes as direct <code>HandleError</code>. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>GetUserMessageFromCatalog(errNum)</strong> — <em>defensive catalog read for user-facing message</em><br><strong>Purpose:</strong> Return catalog UserMessage or empty string if unavailable. Strictly defensive (no exceptions to caller).<br><strong>Signature:</strong> <code>Private Function GetUserMessageFromCatalog(errNum As Long) As String</code><br><strong>Behavior:</strong> Calls <code>EnsureCatalogInitialized</code>. If dictionary available and <code>g_errorCatalog.Exists(CStr(errNum))</code> returns stored <code>&quot;UserMessage&quot;</code>. Else returns empty string. Wrapped in <code>On Error Resume Next</code> to swallow COM errors.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Never raises; returns "" when no mapping. <br><strong>Tests:</strong> With seeded catalog verify known code returns correct message; absent catalog returns "". </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>GetRemediationFromCatalog(errNum)</strong> — <em>defensive catalog read for remediation text</em><br><strong>Purpose:</strong> Return remediation guidance string from catalog; defensive no-exception contract identical to <code>GetUserMessageFromCatalog</code> but returns <code>&quot;Remediation&quot;</code>.<br><strong>Signature:</strong> <code>Private Function GetRemediationFromCatalog(errNum As Long) As String</code><br><strong>Complexity/Testing/Notes:</strong> Same as <code>GetUserMessageFromCatalog</code>. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>GetInternalFallbackMessage(errNum)</strong> — <em>fallback internal message</em><br><strong>Purpose:</strong> Provide a minimal internal message if no <code>errMsg</code> passed to <code>HandleError</code> (keeps internalMsg non-empty).<br><strong>Signature:</strong> <code>Private Function GetInternalFallbackMessage(errNum As Long) As String</code><br><strong>Behavior:</strong> Returns <code>&quot;Error code &quot; &amp; CStr(errNum)</code> — deterministic and safe.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Ensure simple formatting. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>SafeLogStructuredError(e As IFRS_Error)</strong> — <em>build escaped compact JSON and call LogAudit</em><br><strong>Purpose:</strong> Centralized serialization of <code>IFRS_Error</code> into a compact JSON-like escaped payload (bounded by truncation constants) and best-effort call to <code>LogAudit(&quot;Error&quot;, details)</code> without propagating exceptions.<br><strong>Signature:</strong> <code>Private Sub SafeLogStructuredError(e As IFRS_Error)</code><br><strong>Behavior (detailed):</strong><br>- Use <code>TruncateString</code> to limit fields: CorrelationID(120), Proc(200), Internal(MAX_LOG_INTERNAL), User(MAX_LOG_USER), Context(MAX_LOG_CONTEXT). Truncation is performed BEFORE escaping to guarantee payload size limits.<br>- Use <code>EscapeForJson</code> to remove/escape control characters, backslashes, quotes, normalize newlines & tabs, and strip non-printables.<br>- Build a compact JSON-like string (all values double-quoted and escaped); timestamp formatted <code>&quot;yyyy-mm-dd HH:nn:ss&quot;</code> via <code>Format$</code>.<br>- Call <code>On Error Resume Next</code> then <code>LogAudit(&quot;Error&quot;, details)</code> (LogAudit is an external function expected to exist in project); swallow errors and <code>Err.Clear</code> afterwards. No throw to caller.<br><strong>Complexity:</strong> O(L) where L is bounded by constants; effectively constant-time.<br><strong>Side-effects:</strong> Calls external <code>LogAudit</code>. May allocate temporary strings sized by truncation constants.<br><strong>Invariants:</strong> Output not larger than truncation limits + JSON punctuation. Must not raise under any circumstances.<br><strong>Failure modes:</strong> If <code>LogAudit</code> not present or raises, errors are swallowed — but audit is then lost; consider instrumenting an alternate persistent fallback if needed.<br><strong>Security:</strong> Fields are escaped to avoid log injection; still avoid logging PII in <code>contextJson</code>.<br><strong>Tests:</strong> Provide <code>IFRS_Error</code> with suspicious characters and assert output contains escaped characters, respects truncation, and that <code>LogAudit</code> was invoked (mock). </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>CTypeOrDefault(v, Optional defaultVal)</strong> — <em>safe numeric cast to severity</em><br><strong>Purpose:</strong> Defensive cast of potentially-variant <code>DefaultSeverity</code> retrieved from catalog item to <code>IFRS_ErrorSeverity</code>, with bounds checking and fallback default.<br><strong>Signature:</strong> <code>Private Function CTypeOrDefault(v As Variant, Optional defaultVal As IFRS_ErrorSeverity = sevError) As IFRS_ErrorSeverity</code><br><strong>Behavior:</strong> Uses <code>IsNumeric</code>, <code>CLng</code> in <code>On Error Resume Next</code> and validates numeric range between <code>sevInfo</code> and <code>sevCritical</code>. Returns <code>defaultVal</code> on failure. Clears <code>Err</code> before exit.<br><strong>Complexity:</strong> O(1).<br><strong>Invariants:</strong> Always returns a valid severity constant. <br><strong>Tests:</strong> Pass numeric, string numeric, invalid string, missing key. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>TruncateString(s, maxLen)</strong> — <em>defensive truncation with ellipsis</em><br><strong>Purpose:</strong> Truncate long strings to <code>maxLen</code> (preserve small tail) and append "..." when <code>maxLen&gt;3</code> to indicate truncation. Used prior to escaping to keep payload predictable.<br><strong>Signature:</strong> <code>Private Function TruncateString(ByVal s As String, ByVal maxLen As Long) As String</code><br><strong>Behavior:</strong> If <code>Len(s) &lt;= maxLen</code> return s. Else return <code>Left$(s, maxLen-3) &amp; &quot;...&quot;</code> when <code>maxLen&gt;3</code>, else <code>Left$(s,maxLen)</code>.<br><strong>Complexity:</strong> O(maxLen).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Edge cases: maxLen <=3; maxLen longer than s; multibyte characters (VBA deals with character counts). </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>EscapeForJson(s)</strong> — <em>safe JSON-ish escaping + control filtering</em><br><strong>Purpose:</strong> Escape user/internal strings for safe inclusion inside the compact JSON-like payload: escape backslashes and double quotes, convert CR/LF to <code>\n</code>, replace tabs with a space, and remove non-printable characters (preserve LF). Also normalizes characters via <code>AscW</code> check to replace control codes with space.<br><strong>Signature:</strong> <code>Private Function EscapeForJson(ByVal s As String) As String</code><br><strong>Behavior (detailed):</strong><br>- <code>Replace(s, &quot;\&quot;, &quot;\\&quot;)</code> then <code>Replace(Chr(34), &quot;\&quot; &amp; Chr(34))</code>.<br>- Normalize newlines: <code>vbCrLf</code>, <code>vbCr</code>, <code>vbLf</code> to <code>\n</code>; tabs replaced with single space.<br>- Iterate characters and preserve only LF or characters with <code>AscW &gt;= 32</code>; others replaced with space. This prevents binary/control bytes from corrupting JSON payload.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> None. <br><strong>Security:</strong> Prevents log injection and unstable JSON chars. Does not perform Unicode \uXXXX escapes; keeps printable Unicode characters intact (suitable for audit).<br><strong>Failure modes:</strong> Very long strings handled because truncation done prior to escaping; if <code>AscW</code> fails on surrogate pairs, behavior depends on host; tests recommended.<br><strong>Tests:</strong> Strings with quotes, backslashes, CR/LF, tabs, and control chars should be escaped/normalized; non-ASCII chars should be preserved if printable. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>GenerateCorrelationID()</strong> — <em>project override -> Scriptlet GUID -> timestamp+random fallback</em><br><strong>Purpose:</strong> Produce a reasonably-unique correlation identifier for logs so multi-step flows can be grouped. Prefer platform GUID, but provide deterministic fallback when unavailable (useful on locked-down Excel runtimes).<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong><br>- Try <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code> and remove <code>{}</code> if successful, prefix with <code>IFRS-&lt;yyyymmddHHMMSS&gt;-&lt;guid&gt;</code>.<br>- If Scriptlet fails, ensure <code>Randomize</code> called and produce <code>&quot;IFRS-&lt;yyyymmddHHMMSS&gt;-&lt;randomSuffix&gt;&quot;</code> where suffix is <code>CLng(Abs(Rnd * 1000000#))</code>—ensures variation across runs. Uses <code>Now</code> formatted to year-month-day/time components.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> COM create attempt; <code>Randomize</code> call modifies global RNG state once only (guarded by <code>g_randomized</code>).<br><strong>Security/privacy:</strong> Correlation ID contains timestamp and GUID/random; avoid embedding user-identifiable information in correlation ID. <br><strong>Failure modes:</strong> CreateObject may fail (handled). Random fallback ok for correlation needs but not cryptographically secure. <br><strong>Tests:</strong> Verify GUID path returns GUID pattern; fallback path returns timestamp-suffix and uniqueness across successive calls. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>RetryOperationByName(functionName, attempts, delayMs, Optional lastErrNum)</strong> — <em>best-effort retry wrapper for named public routines</em><br><strong>Purpose:</strong> Generic retry helper that invokes a function by name via <code>Application.Run</code> up to <code>attempts</code> times with <code>delayMs</code> between attempts. Accepts heterogeneous return types: vbBoolean true, numeric non-zero, non-empty string, or non-Nothing object all treated as success. Returns Boolean indicating success and optionally last error number via <code>ByRef lastErrNum</code>.<br><strong>Signature:</strong> <code>Public Function RetryOperationByName(ByVal functionName As String, ByVal attempts As Long, ByVal delayMs As Long, Optional ByRef lastErrNum As Long) As Boolean</code><br><strong>Behavior:</strong><br>- Input validation: at least one attempt.<br>- Loop: <code>Application.Run(functionName)</code> under <code>On Error Resume Next</code>; examine <code>Err.Number</code> and <code>result</code>'s <code>VarType</code> to decide success. On success exit with True. On failure wait <code>SleepMs(delayMs)</code> and retry. Returns final boolean and last error number seen when calls fail.<br><strong>Complexity:</strong> O(attempts) * cost of invoked function. <br><strong>Side-effects:</strong> Calls external macro(s) and uses SleepMs which may DoEvents (reentrant host code).<br><strong>Invariants:</strong> Does not throw; returns False on persistent failure. <code>lastErrNum</code> is 0 when success or populated with last <code>Err.Number</code> when failure.<br><strong>Failure modes / gotchas:</strong><br>- <code>Application.Run</code> can call arbitrary user code which may be long-running, modal, or may change application state; retried calls may have side-effects.<br>- Delay uses <code>SleepMs</code> which may pump messages (DoEvents), enabling reentrancy; callers should ensure this is acceptable.<br><strong>Tests:</strong> Create sample macro that toggles success after N invocations and assert RetryOperationByName behavior. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Sleep declaration (conditional) & SleepMs(ms)</strong> — <em>host-safe sleep with native attempt</em><br><strong>Purpose:</strong> Provide a short blocking sleep utility that prefers native <code>Sleep</code> when available (declared via conditional compile for VBA7/Win64) and otherwise falls back to a <code>DoEvents</code> loop using <code>DateAdd</code> to avoid busy-waiting. This is used by retry helper to avoid tight loops while remaining host-safe.<br><strong>Signature:</strong> <code>Private Sub SleepMs(ByVal ms As Long)</code> (uses <code>SleepWin</code> declare when available).<br><strong>Behavior:</strong><br>- If <code>ms &lt;= 0</code> exit.<br>- Try calling <code>SleepWin ms</code> (declared in conditional compilation). If it errors (not present), fallback to computing <code>endTime = DateAdd(&quot;s&quot;, ms / 1000#, Now)</code> and loop <code>Do While Now &lt; endTime: DoEvents: Loop</code>.<br><strong>Complexity:</strong> Time-blocking for ms duration; CPU usage minimal because DoEvents yields. <br><strong>Side-effects:</strong> <code>DoEvents</code> permits other events/macros to run — may enable reentrancy; <code>SleepWin</code> does not pump messages. <br><strong>Safety/Failure modes:</strong> On UI-less automation or protected hosts, DoEvents may be restricted or slow — the function guards with <code>On Error Resume Next</code>. <br><strong>Tests:</strong> Sleep short durations and measure wall-clock; test native and fallback path via conditional compilation or by forcing native declare to be missing. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Test_Injection_RaiseSampleError()</strong> — <em>test/fault injection helper</em><br><strong>Purpose:</strong> Developer test hook that creates a structured error and raises it so unit tests or integration tests can validate audit/logging and legacy raise behavior. Useful for CI and diagnostics.<br><strong>Signature:</strong> <code>Public Sub Test_Injection_RaiseSampleError()</code><br><strong>Behavior:</strong> Calls <code>HandleError &quot;modError._Test_Injection_RaiseSampleError&quot;, 9999, &quot;Injected test error&quot;, sevError, &quot;Test error (injection)&quot;, &quot;{&quot;&quot;test&quot;&quot;:true}&quot;</code>. Because <code>HandleError</code> raises, callers will see Err.Number 9999; audit entry should be written.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Produces audit entry via <code>LogAudit</code> and raises Err.Number 9999. <br><strong>Tests:</strong> Called by automated tests to validate logging and raise semantics. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Public accessors for tests / read-only information</strong> — <em>GetUserFacingMessage, GetRemediationSteps, IsErrorCatalogInitialized, IsErrorCatalogAvailable, GetCatalogItemCount</em><br><strong>Purpose:</strong> Provide safe, read-only access to catalog state for unit tests and diagnostics without exposing mutable internals. Keep deterministic behavior across restricted hosts.<br><strong>Signatures:</strong><br>- <code>Public Function GetUserFacingMessage(errNum As Long) As String</code><br>- <code>Public Function GetRemediationSteps(errNum As Long) As String</code><br>- <code>Public Function IsErrorCatalogInitialized() As Boolean</code><br>- <code>Public Function IsErrorCatalogAvailable() As Boolean</code><br>- <code>Public Function GetCatalogItemCount() As Long</code><br><strong>Behavior:</strong> Thin wrappers around the internal lookup functions and state variables, defensively returning defaults when catalog absent. <code>GetUserFacingMessage</code> returns fallback <code>&quot;An error occurred. See audit log.&quot;</code> when empty.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Unit tests should assert correct returns when catalog seeded vs when unavailable. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Maintenance & compatibility notes (module-level)</strong><br><strong>Purpose:</strong> Guidance and constraints for maintainers to preserve deterministic behavior and avoid regressions.<br><strong>Key points:</strong><br>- <strong>API stability:</strong> Do not change <code>HandleError</code> signature or <code>RaiseIFRSError</code> semantics; callers expect <code>Err.Raise errNum, procName, userMsg</code> at the end.<br>- <strong>Error numbers:</strong> Preserve existing error code meanings (numeric constants) — changing codes breaks telemetry and documentation.<br>- <strong>Catalog availability:</strong> <code>EnsureCatalogInitialized</code> intentionally sets <code>g_catalogInitialized = True</code> even if dictionary is unavailable — preserve this one-shot behavior to avoid repeated COM attempts on constrained hosts.<br>- <strong>External hooks:</strong> <code>LogAudit</code> and optional <code>NewCorrelationID</code> are external contract points. Changes to their expected behavior must be coordinated across project. Implement a test stub for <code>LogAudit</code> in CI to validate logging path. <br>- <strong>DoEvents reentrancy:</strong> SleepMs fallback uses <code>DoEvents</code> and can permit reentrant code; avoid calling high-risk host operations from within RetryOperationByName unless reentrancy is acceptable.<br>- <strong>Truncation & escaping:</strong> Truncate BEFORE escaping — rely on <code>MAX_LOG_*</code> constants for predictable audit payload sizing. If fields need to be larger in telemetry later, increase constants and coordinate with server-side schema.<br>- <strong>Security / privacy:</strong> Avoid logging PII into <code>contextJson</code>; ensure downstream audit pipelines treat <code>contextJson</code> as untrusted. Use <code>EscapeForJson</code> to avoid injection into the stored audit payload. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Failure & recovery scenarios (recommended operational behavior)</strong><br><strong>Typical failure cases & module behavior:</strong><br>- Scripting.Dictionary missing → catalog lookups return empty strings; HandleError still performs logging and raises the original Err.Number. No failure escapes module.<br>- Scriptlet.TypeLib GUID unavailable → timestamp+random fallback used for correlation ID (non-crypto).<br>- <code>LogAudit</code> missing or throwing → swallowed by <code>SafeLogStructuredError</code> and no exception propagates; audit lost but application flow preserved.<br>- <code>Application.Run(&quot;NewCorrelationID&quot;)</code> errors → silently ignored and fallback used.<br><strong>Recommendation:</strong> Monitor for missing audit entries in telemetry and provide admin guidance to ensure LogAudit deployed. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Recommended test matrix (concise prioritized list)</strong><br>1. <strong>Catalog presence matrix</strong>: run with Scripting.Dictionary available and unavailable; assert <code>GetCatalogItemCount</code> and <code>GetUserFacingMessage</code> behavior.<br>2. <strong>HandleError end-to-end</strong>: Call with explicit userMsg vs without; assert audit content (escaped/truncated), correlation ID format, and final <code>Err.Number</code> matches input.<br>3. <strong>Critical severity flow</strong>: use sevCritical and assert <code>MsgBox</code> invocation path (mock or intercept).<br>4. <strong>Correlation ID paths</strong>: with <code>NewCorrelationID</code> defined (Application.Run returns a value), with Scriptlet.TypeLib available, and with neither to validate all branches.<br>5. <strong>SleepMs & RetryOperationByName</strong>: stub a function that fails N-1 times then succeeds; assert retry respects attempts and sleep behavior (use mocking to avoid long sleeps).<br>6. <strong>Escape & truncation</strong>: pass long strings and control characters as <code>contextJson</code> and verify audit payload size and escaping correctness.<br>7. <strong>Audit resilience</strong>: make <code>LogAudit</code> throw and assert <code>HandleError</code> does not propagate error and still raises original <code>Err.Number</code> afterwards. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Security, privacy & compliance notes</strong><br>- All logged fields are escaped via <code>EscapeForJson</code> and truncated to defend against log injection and excessive payloads. Nevertheless: do not place sensitive personal data (PII) in <code>contextJson</code> — redact before calling <code>HandleError</code> or implement a centralized sanitizer.<br>- Correlation IDs are non-secret; do not treat as authentication tokens. If stronger entropy is required, integrate secure GUIDs from a trusted cryptographic library or server-side issued IDs.<br>- Ensure <code>LogAudit</code> destination is secure and that logs are access-controlled and retained according to your compliance requirements. </td></tr><tr><td data-label="Technical Breakdown (modError)"> <strong>Final maintainer checklist / recommended improvements</strong><br>- Add optional pluggable <code>ILogAudit</code> interface (project-level public method) so tests can inject a mock audit sink instead of depending on a global <code>LogAudit</code> name and allow async-safe queuing.<br>- If audit volume grows, consider switching <code>LogAudit</code> to an append-queue model and ensure it never blocks main thread (log queue + background flush).<br>- Document the canonical list of error codes in a single external CSV for cross-team reference. Keep <code>MAX_LOG_*</code> constants in sync with server-side ingestion limits.<br>- Add unit test harness that stubs <code>Application.Run</code> and <code>LogAudit</code> to validate all branches and ensure <code>HandleError</code> is covered by automated tests. </td></tr></tbody></table></div><div class="row-count">Rows: 26</div></div><div class="table-caption" id="Table5" data-table="Docu_0159_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical breakdown (modExport)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical breakdown (modExport)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modExport)"> <strong>Overview:</strong><br>This module implements robust export utilities for the IFRS Excel add-in: PDF, CSV, XLSX, CustomXML, ZIP packaging and a high-level package flow. It emphasizes atomic I/O (prefer modUtilities helpers when present), predictable boolean public APIs (except legacy <code>ExportToPDF</code>), centralized audit integration, conservative security/policy checks for sensitive exports, retry/backoff for flaky network/locked files, and clear error-code space. Use this file as the authoritative spec for maintenance, tests and refactors. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Constants & Error Codes</strong> — <em>module configuration and reserved error space</em><br><strong>Purpose:</strong> Define error numeric base, legacy raise offset and named module errors used by <code>LocalHandleError</code> and public APIs.<br><strong>Details:</strong> <code>EXPORT_ERR_BASE = 2100</code> reserved; specific errors (2100..2399) mapped to names (NO_WORKBOOK, DEST_NOT_WRITABLE, etc.). <code>EXPORT_ERR_LEGACY_RAISE = 21000</code> used when raising to preserve legacy behavior. <code>EXPORT_ERR_MAX_RETRIES = 4</code> controls retry loops.<br><strong>Notes:</strong> Keep mapping stable — external code/tests may depend on numeric values. Add new errors only inside reserved block and document. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportToPDF</strong> — <em>legacy Sub kept for backward compatibility (raise-on-failure)</em><br><strong>Purpose:</strong> Preserve historical <code>Sub ExportToPDF(fileName, targetWb)</code> behavior that raises on failure for callers relying on Err.Raise semantics.<br><strong>Signature:</strong> <code>Public Sub ExportToPDF(Optional ByVal fileName As String = &quot;&quot;, Optional ByVal targetWb As Workbook = Nothing)</code><br><strong>Behavior:</strong> Calls <code>ExportToPDFEx</code>; if it returns False, raises <code>vbObjectError + EXPORT_ERR_LEGACY_RAISE</code>. Errors forwarded to <code>LocalHandleError</code> in ErrHandler.<br><strong>Complexity:</strong> O(1) wrapper.<br><strong>Side-effects:</strong> May raise runtime error; logs via <code>LocalHandleError</code> on exceptions.<br><strong>Invariants:</strong> Does not change export behavior; must keep raise semantics.<br><strong>Failure modes:</strong> Wrapped function returning False leads to Err.Raise; ensure callers expecting raise still function. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportToPDFEx</strong> — <em>safe boolean PDF export with atomic move & retries</em><br><strong>Purpose:</strong> Export workbook to PDF with temporary file strategy, exponential backoff retries, atomic move (Name preferred, Copy fallback), and audit logging. Returns True/False rather than raising to enable programmatic handling.<br><strong>Signature:</strong> <code>Public Function ExportToPDFEx(Optional fileName As String = &quot;&quot;, Optional targetWb As Workbook = Nothing) As Boolean</code><br><strong>Behavior (detailed):</strong><br>- Resolve workbook via <code>ResolveWorkbookSafe</code>.<br>- Compute destination path (provided or derived from workbook name + folder fallback).<br>- Verify destination writable via <code>EnsureFolderWritableForFile</code>.<br>- Build a unique temp filename in same folder <code>ifrs_pdf_temp_yyyymmdd_HHNNSS_&lt;cid&gt;.pdf</code>.<br>- Loop up to <code>maxAttempts=3</code>: delete any leftover temp, call <code>wb.ExportAsFixedFormat Type:=xlTypePDF</code> to write temp file, verify via <code>FileExistsAndNonEmpty</code>, then attempt atomic move: <code>Name</code> (fast same-volume) else <code>FileSystemObject.CopyFile</code> and delete temp. If final file valid -> success; otherwise log and backoff (SleepMs with exponential wait).<br>- Always attempt to cleanup temp file.<br>- On success, <code>SafeLogAuditWithMeta</code> invoked with duration and attemptCount.<br><strong>Complexity:</strong> Network/disk bound — cost proportional to PDF generation time and move operations. Loops up to 3 retries; overall O(retries * exportTime).<br><strong>Side-effects:</strong> Creates temporary files, final PDF; calls <code>SafeLogAuditWithMeta</code> and <code>LocalHandleError</code> on failure.<br><strong>Invariants:</strong> If returns True, export file exists and non-empty at <code>exportName</code> (verified before returning).<br><strong>Failure modes:</strong> <code>ExportAsFixedFormat</code> can fail silently or throw (printer drivers, invalid print areas); Name may fail across volumes; access denied on destination; transient network/locked files cause retries.<br><strong>Security:</strong> None specific to PDF content, but audit/logs may include path names — redaction via <code>SafeLogAuditWithMeta</code> respects modSecurity/modConfig hooks.<br><strong>Tests:</strong> Export small workbook -> file exists; simulate locked destination (open by other process) -> function returns False and logs; temp leftover cleaned; attemptCount recorded; race when destination exists overwritten. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportWorksheetToCsv</strong> — <em>export specified worksheet to CSV (UTF-8 default)</em><br><strong>Purpose:</strong> Export a worksheet's UsedRange to CSV with quoting rules and UTF-8 encoding where possible. Backwards-compatible signature (optional wb, sheetName, fullPath) and boolean return.<br><strong>Signature:</strong> <code>Public Function ExportWorksheetToCsv(Optional targetWb As Workbook = Nothing, Optional sheetName As String = &quot;&quot;, Optional fullPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook and sheet (active sheet if sheetName omitted) via <code>SafeGetWorksheet</code> and <code>ResolveWorkbookSafe</code>.<br>- Compute default path if <code>fullPath</code> omitted (wb.path or Application.DefaultFilePath or USERPROFILE).<br>- Ensure destination writable via <code>EnsureFolderWritableForFile</code>.<br>- Retrieve <code>ws.UsedRange</code> and fail with <code>EXPORT_ERR_SHEET_NO_USED_RANGE</code> if empty.<br>- Call <code>TryExportRangeToCsvWithOptions(rng, fullPath, True)</code> which prefers centralized <code>ExportRangeToCsv</code> if present or falls back to <code>WriteRangeToCsvFallbackWithEncoding</code>.<br>- On success, write audit entry via <code>SafeLogAuditWithMeta</code> including sheet name.<br><strong>Complexity:</strong> O(rows * cols) to serialize cells. Memory usage proportional to CSV string size (module builds full string in sb variable).<br><strong>Side-effects:</strong> May create file at <code>fullPath</code>; logs audit.<br><strong>Invariants:</strong> CSV uses CRLF line endings, CSV quoting for fields containing commas, quotes and embedded newlines; internal newlines normalized to LF inside fields before wrapping.<br><strong>Failure modes:</strong> Large sheets may produce huge memory usage; cell types (objects, errors) converted to empty strings; ADODB fallback used for UTF-8 may not exist on stripped-down hosts.<br><strong>Security:</strong> Use <code>TryAtomicWriteFileWithEncoding</code> to avoid partial writes exposing sensitive data. Audit redaction applies.<br><strong>Tests:</strong> 1) small table export; 2) cells with embedded quotes/newlines; 3) very large sheet memory behavior; 4) missing UsedRange path returns False and logs. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportWorkbookAsXlsx</strong> — <em>atomic save of workbook as .xlsx with verification</em><br><strong>Purpose:</strong> Save a live workbook as a flattened .xlsx file using atomic-save helpers; verify existence and size, and log audit; returns True/False.<br><strong>Signature:</strong> <code>Public Function ExportWorkbookAsXlsx(Optional targetWb As Workbook = Nothing, Optional fullPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook; determine default target path if none provided.<br>- Ensure destination folder writable.<br>- Call <code>TryAtomicSaveWorkbookAsWithVerification(wb, fullPath)</code> which attempts <code>AtomicSaveWorkbookAs</code> via <code>Application.Run</code> or fallback to <code>SaveCopyAs</code> then copy; includes retry/backoff up to <code>EXPORT_ERR_MAX_RETRIES</code>.<br>- On success log <code>SafeLogAuditWithMeta</code> with duration and attempt count; return True.<br><strong>Complexity:</strong> Save cost dominated by Excel SaveCopyAs; retries increase time. Disk I/O bound.<br><strong>Side-effects:</strong> Creates .xlsx file; may create temp SaveCopyAs file and remove it.<br><strong>Invariants:</strong> On success file exists and non-empty; workbook not modified by function (uses SaveCopyAs).<br><strong>Failure modes:</strong> SaveCopyAs can fail for network paths, locked files, or insufficient disk; atomic helper absent on older deployments -> fallbacks invoked. Permission errors surfaced via <code>LocalHandleError</code>.<br><strong>Tests:</strong> Simple workbook save; test on network share and simulate locked destination; verify temp cleanup and attempts count in audit. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportCustomXMLPart</strong> — <em>export named CustomXMLPart with policy checks and UTF-8 write</em><br><strong>Purpose:</strong> Extract a CustomXMLPart identified by a root element and write it to disk with optional schema/version comment; deny exports if policy indicates secrets.<br><strong>Signature:</strong> <code>Public Function ExportCustomXMLPart(ByVal rootElement As String, ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Validate args non-empty.<br>- Read XML via <code>TryReadCustomXMLPart(rootElement)</code> which calls centralized <code>ReadCustomXMLPart</code> if present or fallback iterating <code>ThisWorkbook.CustomXMLParts</code>.<br>- If XML empty -> <code>EXPORT_ERR_CUSTOMXML_NOENT</code>.<br>- If content contains tokens like <code>&quot;password&quot;</code> or <code>&quot;secret&quot;</code> then call <code>CheckCustomXmlPolicy(rootElement, xml)</code> which queries <code>modSecurity_CheckCustomXmlExport</code> via <code>Application.Run</code> or uses conservative default (deny when suspicious tokens present). If denied -> error <code>EXPORT_ERR_CUSTOMXML_POLICY_DENY</code>.<br>- Prepend a small header comment (cid + timestamp) after XML declaration when present, not changing XML structure otherwise.<br>- Ensure folder writable and call <code>TryAtomicWriteFileWithEncoding(fullPath, xml, True)</code> (UTF-8 preferred). On success log audit.<br><strong>Complexity:</strong> O(size of XML) I/O bound.<br><strong>Side-effects:</strong> Writes file; logs audit; invokes security hooks.<br><strong>Invariants:</strong> Exported XML includes a non-invasive header comment; secrets are not exported by default.<br><strong>Failure modes:</strong> Policy function absent -> conservative default; ADODB writing may fail. Caller must handle False. <br><strong>Security:</strong> Highest sensitivity — uses <code>modSecurity</code> hook. Tests must include PII/secret detection and ensure denial path works. Recommended to add unit test that attempts to export known secret patterns. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CreateZipFromFiles</strong> — <em>create cross-platform zip package from list of files</em><br><strong>Purpose:</strong> Create a ZIP archive containing provided full paths, with bootstrap empty zip, platform-specific shells used for adding files, and integrity heuristics. Overwrites existing zipPath if present.<br><strong>Signature:</strong> <code>Public Function CreateZipFromFiles(ByVal files As Collection, ByVal zipPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Validate inputs: non-empty collection and zipPath.<br>- Ensure destination folder writable and create folder.<br>- Remove existing zip if present; create minimal empty zip bootstrap (write PKZIP EOCD with zeros) so Shell.Namespace recognizes container.<br>- Branch: <code>IsMacOS</code> -> call <code>ExecShellZipOnMac(files, zipPath)</code> which shells out to <code>zip -j -q</code>; else <code>ExecShellZipOnWindows(files, zipPath)</code> which uses <code>Shell.Application</code> <code>Namespace.CopyHere</code> to add files and monitors size stabilization via <code>WaitForZipStable</code>.<br>- If creation fails, return <code>EXPORT_ERR_ZIP_CREATE_FAIL</code>. Validate final zip non-empty; audit log.<br><strong>Complexity:</strong> O(#files) per addition plus platform zip command costs; Windows Shell copy is asynchronous and requires Wait loops.<br><strong>Side-effects:</strong> Writes zip file; may call external shell (security considerations for file paths).<br><strong>Invariants:</strong> Resulting zip contains added files when function returns True; bootstrap coding required for Windows Shell API.<br><strong>Failure modes:</strong> Shell utilities missing on Mac/Windows, long waits for <code>CopyHere</code> completion, permission issues, files that do not exist skipped silently. If no files added -> <code>EXPORT_ERR_ZIP_EMPTY</code>.<br><strong>Security:</strong> Paths quoted via <code>QuotePathForShell</code> on Mac; on Windows <code>Shell.Namespace.CopyHere</code> performs background operations — avoid passing untrusted shell metacharacters. Tests: small set of files, many files, missing files, file names with quotes/spaces/unicode, ensure zip valid. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportPackage</strong> — <em>high level package: PDF + XLSX + Audit + optional files -> ZIP</em><br><strong>Purpose:</strong> Convenience function to assemble common exports (PDF, XLSX, Audit CSV) plus caller-supplied files into a ZIP package. Returns boolean success.<br><strong>Signature:</strong> <code>Public Function ExportPackage(Optional ByVal filesToInclude As Collection = Nothing, Optional ByVal zipPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve active workbook; compute default zipPath if omitted.<br>- Produce PDF via legacy <code>ExportToPDF</code> (preserved raise semantics — wrapped in <code>On Error Resume Next</code>). Add to tmpFiles collection if created.<br>- Export XLSX via <code>ExportWorkbookAsXlsx</code> and audit CSV via <code>ExportAuditToCSV</code> adding created files to collection when present and non-empty.<br>- Append any caller-supplied files after verifying existence and non-empty.<br>- If no files collected -> <code>EXPORT_ERR_ZIP_NO_FILES</code> error.<br>- Create ZIP via <code>CreateZipFromFiles(tmpFiles, zipPath)</code> and log audit on success.<br><strong>Complexity:</strong> Sum of constituent operations (PDF/XLSX/CSV + zip). Risk of partial success scenarios.<br><strong>Side-effects:</strong> Creates multiple files, possibly leaves temporary artifacts if intermediate exports fail. Audit logged.<br><strong>Invariants:</strong> On True return, <code>zipPath</code> exists and contains at least one file. Caller should clean temporary files if desired.<br><strong>Failure modes:</strong> Any constituent export failing leaves package incomplete — callers should inspect audit logs. Tests: end-to-end package creation; missing optional files; verify zip contains expected members. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportAuditToCSV</strong> — <em>export audit trail to CSV with central hook fallback</em><br><strong>Purpose:</strong> Attempt to call centralized <code>ExportAuditToCSV_Central</code> via <code>Application.Run</code>; fallback to scanning workbook for audit sheets and export them as CSV using <code>ExportWorksheetToCsv</code>.<br><strong>Signature:</strong> <code>Public Function ExportAuditToCSV(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Default <code>fullPath</code> to TEMP if omitted.<br>- Try <code>Application.Run(&quot;ExportAuditToCSV_Central&quot;, fullPath)</code>; if returns boolean, use it and log audit.<br>- Else scan <code>ThisWorkbook</code> for known audit sheet names (various casings) via <code>SafeGetWorksheet</code>. If none found, search any sheet where name contains <code>&quot;audit&quot;</code> case-insensitively.<br>- If found, call <code>ExportWorksheetToCsv(wb, nameFound, fullPath)</code> and log audit on success.<br><strong>Complexity:</strong> O(#sheets) for search; CSV export complexity as previously.<br><strong>Side-effects:</strong> Writes audit CSV; may call external central routine. <br><strong>Invariants:</strong> Exports the first suitable audit sheet. <br><strong>Failure modes:</strong> Central routine may throw; fallback may not find audit sheet -> returns False with <code>2400</code> error. Tests: central hook present/absent; sheet detection casing; exports file content correctness. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportSelfTest</strong> — <em>module self-test orchestration</em><br><strong>Purpose:</strong> Perform deterministic smoke tests: export test CSV, export XLSX, create package zip; used for CI/manual verification. Returns Boolean overall result.<br><strong>Signature:</strong> <code>Public Function ExportSelfTest() As Boolean</code><br><strong>Behavior:</strong><br>- Build <code>_IFRS_TestResults</code> folder under workbook path or TEMP. Ensure folder exists.<br>- Ensure a <code>TST_Export_Sheet</code> exists (create if missing) with deterministic sample values.<br>- Call <code>ExportWorksheetToCsv</code>, <code>ExportWorkbookAsXlsx</code>, and <code>CreateZipFromFiles</code> on the produced artifacts. Aggregate boolean results; log via <code>SafeLogAuditWithMeta</code>.<br><strong>Complexity:</strong> Same as composed operations.<br><strong>Side-effects:</strong> Creates sample files and zip; logs audit.<br><strong>Invariants:</strong> No external state consistent changes (only files).<br><strong>Tests:</strong> This function itself is test harness; run on varied environments including network drives. Clean-up not provided — tests should clean artifacts where appropriate. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ResolveWorkbookSafe</strong> — <em>workbook resolver with fallbacks</em><br><strong>Purpose:</strong> Return supplied workbook, else ActiveWorkbook, else ThisWorkbook; safe against errors.<br><strong>Signature:</strong> <code>Private Function ResolveWorkbookSafe(Optional ByVal suppliedWb As Workbook = Nothing) As Workbook</code><br><strong>Behavior:</strong> Uses <code>On Error Resume Next</code> to avoid runtime errors, returns first valid workbook. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Notes:</strong> Keep minimal; used by all public export entrypoints to standardize workbook selection. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>LocalHandleError</strong> — <em>centralized error invocation with graceful fallback</em><br><strong>Purpose:</strong> Invoke centralized <code>HandleError</code> if present; otherwise write local audit and raise module-specific error preserving legacy raise semantics. Central point for error mapping and audit fallback.<br><strong>Signature:</strong> <code>Private Sub LocalHandleError(ByVal proc As String, ByVal errNum As Long, ByVal errDesc As String)</code><br><strong>Behavior:</strong><br>- Attempt <code>Application.Run(&quot;HandleError&quot;, proc, errNum, errDesc)</code> and consider error handled if it returns without Err.Number.<br>- If no central handler, call <code>SafeLogAudit &quot;Error&quot;, proc &amp; &quot; | &quot; &amp; CStr(errNum) &amp; &quot; | &quot; &amp; errDesc</code> then raise <code>vbObjectError + EXPORT_ERR_LEGACY_RAISE + (Abs(errNum) Mod 1000)</code> to preserve legacy numeric space. Err.Raise wrapped in <code>On Error Resume Next</code> to avoid secondary unhandled exceptions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls audit and possibly raises an error. <br><strong>Notes:</strong> Do not change numeric mapping logic without considering external callers. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>SafeLogAudit</strong> — <em>best-effort audit writer with fallback to local temp log</em><br><strong>Purpose:</strong> Attempt <code>Application.Run &quot;LogAudit&quot;, category, message</code>. If that fails, append to a local <code>ifrs_local_audit.log</code> in TEMP. Non-blocking best-effort telemetry.<br><strong>Signature:</strong> <code>Private Sub SafeLogAudit(ByVal category As String, ByVal message As String)</code><br><strong>Behavior:</strong> Try central audit hook; if error, write timestamped line to temp file via VB file I/O. <br><strong>Complexity:</strong> O(1) file append. <br><strong>Side-effects:</strong> Writes to disk. <br><strong>Notes:</strong> Keep minimal and robust; do not let logging throw. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>SafeLogAuditWithMeta</strong> — <em>audit writer with metadata and redaction hooks</em><br><strong>Purpose:</strong> Emit richer audit entries (path, workbook name, extra info, duration, retries, correlation id) and request redaction decision from modSecurity/modConfig. Use <code>LogAudit</code> central hook when available and fallback to <code>SafeLogAudit</code> otherwise.<br><strong>Signature:</strong> <code>Private Sub SafeLogAuditWithMeta(ByVal category As String, ByVal message As String, ByVal targetPath As String, Optional ByVal wb As Workbook = Nothing, Optional ByVal extra As String = &quot;&quot;, Optional ByVal durationMs As Long = -1, Optional ByVal retries As Long = -1)</code><br><strong>Behavior:</strong> Build <code>metaMsg</code> concatenating fields, call <code>modSecurity_ShouldRedactAudit(metaMsg)</code> via <code>Application.Run</code> and if boolean true perform simple redaction heuristics (mask userprofile, replace slashes etc.). Then call <code>Application.Run &quot;LogAudit&quot;, category, metaMsg, cid</code> and fallback to <code>SafeLogAudit</code> on error.<br><strong>Complexity:</strong> O(1) string ops and a best-effort call.<br><strong>Side-effects:</strong> May mutate message (redaction) and call central services. <br><strong>Security:</strong> Critical for PII protection; maintain conservative default. Unit tests should assert redaction behavior when the hook returns True. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>GenerateCorrelationID</strong> — <em>correlation ID generator with GUID fallback</em><br><strong>Purpose:</strong> Create a correlation id using <code>Scriptlet.TypeLib</code> GUID when available; fallback to deterministic pseudo-id based on timestamp + random number.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Uses <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code> if available else <code>&quot;CID-&quot; &amp; Format(Now, ...) &amp; &quot;-&quot; &amp; random</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Correlation ID used in audits for traceability; prefer GUID path when available. Keep stable format. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ChooseFolderFallback</strong> — <em>determine default folder for exports</em><br><strong>Purpose:</strong> Pick export folder from workbook path > Application.DefaultFilePath > USERPROFILE > TEMP in that order.<br><strong>Signature:</strong> <code>Private Function ChooseFolderFallback(ByVal wb As Workbook) As String</code><br><strong>Behavior:</strong> Return first non-empty candidate. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Centralizes fallback logic for consistent behavior across export functions. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>EnsureFolderWritableForFile / IsFolderWritable / SafeFolderCreate</strong> — <em>folder writability checks & safe create</em><br><strong>Purpose:</strong> Provide robust checks that the folder exists and is writable (create if missing) by attempting a small binary write test file and deleting it. <code>EnsureFolderWritableForFile</code> extracts folder path from full file path and calls <code>IsFolderWritable</code>.<br><strong>Signatures:</strong> <code>Private Function EnsureFolderWritableForFile(ByVal filepath As String) As Boolean</code>, <code>Private Function IsFolderWritable(ByVal folderPath As String) As Boolean</code>, <code>Private Sub SafeFolderCreate(ByVal folderPath As String)</code><br><strong>Behavior:</strong><code>IsFolderWritable</code> creates folder if not exists, writes temporary <code>&quot;IFRS&quot;</code> test file then deletes; returns success boolean. <code>SafeFolderCreate</code> wraps FSO <code>CreateFolder</code> with <code>On Error Resume Next</code>.<br><strong>Complexity:</strong> O(1) I/O. <br><strong>Failure modes:</strong> On network shares write test may pass but subsequent writes may fail; this is best-effort. Tests should run on network path, restricted folder, and local folder. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Atomic write & save helper wrappers</strong> — <em>TryAtomicWriteFile / TryAtomicWriteFileWithEncoding / TryAtomicWriteFileWithVerification</em><br><strong>Purpose:</strong> Prefer centralized <code>AtomicWriteFile</code> from <code>modUtilities</code> when present; otherwise use local fallbacks that write to a temp file and move or use ADODB.Stream for UTF-8. Verification wrapper checks file non-zero size.<br><strong>Signatures:</strong> <code>Private Function TryAtomicWriteFile(fullPath, contents) As Boolean</code>, <code>TryAtomicWriteFileWithEncoding(fullPath, contents, useUtf8)</code>, <code>TryAtomicWriteFileWithVerification(fullPath, contents)</code><br><strong>Behavior:</strong> Attempt <code>Application.Run(&quot;AtomicWriteFile&quot;, ...)</code>. If not available, call <code>WriteTextFileAtomicFallback</code> or <code>WriteUtf8FileAtomicFallback</code>. Verification checks FSO file size > 0. Errors caught and converted to False. <br><strong>Complexity:</strong> O(file_size) I/O. <br><strong>Side-effects:</strong> Creates temp files and moves them into place. <br><strong>Invariants:</strong> On True return, final file exists and non-empty. <br><strong>Tests:</strong> Absence/presence of <code>AtomicWriteFile</code> hook; simulate ADODB absent; verify atomic move semantics across volumes (Name fails, Copy fallback). </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>WriteTextFileAtomicFallback</strong> — <em>binary write temp -> move fallback (not strict UTF-8)</em><br><strong>Purpose:</strong> Generic fallback writing raw bytes to temp file then Name/Copy to destination. Useful when ADODB not present and UTF-8 not strictly required.<br><strong>Signature:</strong> <code>Private Function WriteTextFileAtomicFallback(fullPath, contents) As Boolean</code><br><strong>Behavior:</strong> Create tmp file with timestamp+cid; Open For Binary Access Write; Put contents; Close; attempt Name fullPath else CopyFile; return FileExistsAndNonEmpty(fullPath).<br><strong>Complexity:</strong> O(file_size).<br><strong>Failure modes:</strong> Unicode conversion not handled; binary blob may mis-encode; prefer UTF-8 helper when required. Tests: simple ASCII content success; Unicode content may show BOM issues. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>WriteUtf8FileAtomicFallback</strong> — <em>ADODB.Stream UTF-8 writer fallback with BOM fallback</em><br><strong>Purpose:</strong> Write UTF-8 reliably using <code>ADODB.Stream</code> when available; else write BOM + contents as fallback and move atomically.<br><strong>Signature:</strong> <code>Private Function WriteUtf8FileAtomicFallback(fullPath, contents, useUtf8) As Boolean</code><br><strong>Behavior:</strong> Attempt <code>CreateObject(&quot;ADODB.Stream&quot;)</code>, set <code>.Type=2</code>, <code>.Charset=&quot;utf-8&quot;</code>, <code>.WriteText contents</code>, <code>.SaveToFile tmpPath</code>. If ADODB unavailable, write BOM + contents to tmpPath using Binary I/O. Then move/Name to fullPath (Copy fallback). Clean tmp on errors. Return True if file exists and non-empty.<br><strong>Complexity:</strong> O(file_size).<br><strong>Failure modes:</strong> ADODB absent or restricted; fallback adds BOM which some consumers may not expect. Tests: UTF-8 content roundtrip; verify BOM presence when ADODB absent. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>TryAtomicSaveWorkbookAs / TryAtomicSaveWorkbookAsWithVerification</strong> — <em>atomic SaveCopyAs fallback with retries</em><br><strong>Purpose:</strong> Prefer <code>AtomicSaveWorkbookAs</code> via modUtilities; fallback to <code>Workbook.SaveCopyAs tmp</code> then copy to destination. Verification wrapper retries with exponential backoff to handle locked/network paths.<br><strong>Signature:</strong> <code>Private Function TryAtomicSaveWorkbookAs(wb, fullPath) As Boolean</code>, <code>TryAtomicSaveWorkbookAsWithVerification(wb, fullPath) As Boolean</code><br><strong>Behavior:</strong> Attempt centralized helper; else <code>wb.SaveCopyAs tmp</code> then FSO <code>CopyFile tmp -&gt; fullPath</code>. Verification checks final file exists and non-zero size. Retries up to <code>EXPORT_ERR_MAX_RETRIES</code>.<br><strong>Complexity:</strong> SaveCopyAs cost + copy; retries multiply cost. <br><strong>Failure modes:</strong> SaveCopyAs can fail for unsaved workbook, or if workbook is too large. Tests: saved/unsaved workbooks, network destinations, locked destinations. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CSV fallback writer: TryExportRangeToCsvWithOptions / WriteRangeToCsvFallbackWithEncoding</strong> — <em>serialize Range to CSV and write atomically</em><br><strong>Purpose:</strong> Use centralized <code>ExportRangeToCsv</code> when present; otherwise iterate cells, escape quotes, normalize newlines inside cells to LF, quote fields with commas/newlines/quotes, join rows with CRLF and write via <code>TryAtomicWriteFileWithEncoding</code> (UTF-8 preferred).<br><strong>Signature:</strong> <code>Private Function TryExportRangeToCsvWithOptions(rng, fullPath, useUtf8) As Boolean</code>, <code>Private Function WriteRangeToCsvFallbackWithEncoding(rng, fullPath, useUtf8) As Boolean</code><br><strong>Behavior:</strong> Build full CSV string in-memory (sb), then call atomic writer. Properly handles errors with <code>On Error</code> pattern. <br><strong>Complexity:</strong> O(rows*cols + total_chars). Memory heavy for large ranges; consider streaming when necessary.<br><strong>Failure modes:</strong> Very large ranges may exhaust memory; ADODB may not be present. Tests: fields with quotes/newlines/commas; empty/errored cells; very large sheet performance. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CustomXML helpers: TryReadCustomXMLPart / ReadCustomXMLPartFallback / CheckCustomXmlPolicy</strong> — <em>read & policy-check XML parts</em><br><strong>Purpose:</strong> Read CustomXMLPart via centralized <code>ReadCustomXMLPart</code> hook if present; fallback by scanning <code>ThisWorkbook.CustomXMLParts</code>. <code>CheckCustomXmlPolicy</code> calls <code>modSecurity_CheckCustomXmlExport</code> to allow/deny export or falls back to conservative deny if suspicious tokens found.<br><strong>Signatures:</strong> <code>Private Function TryReadCustomXMLPart(rootElement) As String</code>, <code>Private Function ReadCustomXMLPartFallback(rootElement) As String</code>, <code>Private Function CheckCustomXmlPolicy(rootElement, xml) As Boolean</code><br><strong>Behavior:</strong> Fallback scans <code>ThisWorkbook.CustomXMLParts</code> searching <code>InStr(cxp.xml, &quot;&lt;&quot; &amp; rootElement) &gt; 0</code>. Policy function invoked via <code>Application.Run</code> when available; defaults to deny on presence of <code>&quot;password&quot;</code> or <code>&quot;secret&quot;</code> tokens. <br><strong>Complexity:</strong> O(#customParts * size). <br><strong>Security:</strong> Conservative default denies export of suspicious content. Unit tests must verify both hook present and absent behaviors, and matching substring search correctness. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Platform & ZIP helpers: IsMacOS / ExecShellZipOnMac / ExecShellZipOnWindows / QuotePathForShell / WaitForZipStable</strong><br><strong>Purpose:</strong> Abstract platform details for zipping files: Mac uses <code>MacScript(&quot;do shell script ...&quot;)</code> with <code>zip -j -q</code>, Windows uses <code>Shell.Application</code> COM to <code>CopyHere</code> into zip container and <code>WaitForZipStable</code> to observe size stalls.<br><strong>Signatures:</strong> <code>Private Function IsMacOS() As Boolean</code>, <code>Private Function ExecShellZipOnMac(files, zipPath) As Boolean</code>, <code>Private Function ExecShellZipOnWindows(files, zipPath) As Boolean</code>, <code>Private Function QuotePathForShell(p) As String</code>, <code>Private Function WaitForZipStable(zipPath, timeoutMs) As Boolean</code><br><strong>Behavior highlights:</strong><br>- <code>IsMacOS</code> checks <code>Application.OperatingSystem</code> string.<br>- <code>ExecShellZipOnMac</code> builds shell command quoting paths via <code>QuotePathForShell</code> and invokes via <code>MacScript</code> (returns False on error).<br>- <code>ExecShellZipOnWindows</code> uses <code>Shell.Namespace(zipPath).CopyHere filepath</code> for each file and polls <code>WaitForZipStable</code> (checks file size changes and a <code>stableCounter</code> threshold) to heuristically wait until the copy completes. Returns whether final zip exists and non-empty.<br><strong>Complexity:</strong> Copy operations are asynchronous on Windows; <code>WaitForZipStable</code> loops <code>DoEvents</code> and checks file size until stable or timeout. <br><strong>Failure modes & Security:</strong> Shell command injection risk for Mac if quoting not correct — <code>QuotePathForShell</code> replaces <code>&quot;</code> with <code>\&quot;</code> and wraps with quotes. On Windows, <code>Shell.Namespace</code> may be unavailable for some zipped formats or if zip is blocked by ACLs. Tests: filenames with spaces/quotes/unicode; long lists; network paths; zip stability timeouts. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Utility helpers: SafeFileName / FileExistsAndNonEmpty / SafeGetWorksheet / SleepMs</strong><br><strong>Purpose & signatures:</strong><br>- <code>SafeFileName(s) -&gt; String</code>: sanitize invalid filename characters by replacing with <code>_</code>.<br>- <code>FileExistsAndNonEmpty(path) -&gt; Boolean</code>: FSO existence and size > 0 check.<br>- <code>SafeGetWorksheet(wb,sheetName) -&gt; Worksheet</code>: case-insensitive search for worksheet by name.<br>- <code>SleepMs(ms)</code>: busy wait using <code>Timer</code> + <code>DoEvents</code> for cross-platform short waits.<br><strong>Behavior:</strong> Small helpers used pervasively. <br><strong>Complexity:</strong> O(1) for string ops, O(1) for FSO checks. <br><strong>Notes:</strong> <code>SleepMs</code> processes events (DoEvents) — be cautious when called inside tight UI contexts. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Design & maintenance notes (module-level)</strong><br>- <strong>Public surface:</strong> stable boolean-returning functions (<code>ExportToPDFEx</code>, <code>ExportWorksheetToCsv</code>, <code>ExportWorkbookAsXlsx</code>, <code>ExportCustomXMLPart</code>, <code>CreateZipFromFiles</code>, <code>ExportPackage</code>, <code>ExportAuditToCSV</code>, <code>ExportSelfTest</code>) plus legacy <code>ExportToPDF</code> (raise). Maintain signatures for backward compatibility.<br>- <strong>Use central hooks when available:</strong> <code>AtomicWriteFile</code>, <code>AtomicSaveWorkbookAs</code>, <code>ExportRangeToCsv</code>, <code>ReadCustomXMLPart</code>, <code>HandleError</code>, <code>LogAudit</code>, <code>modSecurity_*</code> and <code>modConfig_Get</code>. All <code>Application.Run</code> calls are best-effort — fallbacks exist to remain self-contained.<br>- <strong>Error handling:</strong> All public functions catch errors and call <code>LocalHandleError</code>. <code>LocalHandleError</code> prefers central <code>HandleError</code> and otherwise logs and raises within module error space. Keep error numbers stable to avoid breaking external error handling. <br>- <strong>Security:</strong> CustomXML exports are policy-checked; audit redaction hook used; avoid writing secrets. Ensure <code>SafeLogAuditWithMeta</code> redaction heuristics are updated if new PII patterns emerge.<br>- <strong>Atomicity & correctness:</strong> Prefer atomic helpers; fallback strategies use temp file -> Name / Copy pattern. Ensure temp files created in same target folder when possible to avoid cross-volume <code>Name</code> failure. Revoke or cleanup temp artifacts on error paths. <br>- <strong>Platform differences:</strong> Windows zip via Shell.Application is asynchronous; Mac uses CLI zip. Test both platforms. ADODB availability affects UTF-8 writing. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Recommended tests (condensed)</strong><br>1. PDF export: success path; locked destination -> retry/backoff and logged failure; temp file cleanup. 2. CSV export: embedded quotes/newlines/commas; large ranges for memory. 3. XLSX export: atomic save verification on local and network drives; SaveCopyAs fallback. 4. CustomXML: export allowed/denied by <code>modSecurity</code> hook and fallback; header injection correctness. 5. ZIP creation: files with special chars, many files, Windows Shell asynchronous behavior and <code>WaitForZipStable</code> timing edge cases. 6. Audit: central <code>LogAudit</code> present and absent; <code>SafeLogAuditWithMeta</code> redaction test. 7. Atomic write helpers: ADODB present/absent, cross-volume move (Name vs Copy). 8. SelfTest: run in CI on clean VM and assert deterministic outputs. 9. Error mapping: intentional faults produce expected <code>EXPORT_ERR_*</code> codes and <code>LocalHandleError</code> raise semantics. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Maintenance notes for engineers</strong><br>- Do not change exported function signatures; provide new overloads as <code>*Ex</code> functions. <br>- When altering token strings used for secret detection (<code>&quot;password&quot;</code>, <code>&quot;secret&quot;</code>), update tests and document policy implications. <br>- Prefer adding centralized helpers in <code>modUtilities</code> rather than changing fallbacks here; keep <code>Application.Run</code> hooks thin and tolerant. <br>- When adjusting worker/async behavior (e.g., better Windows zip integration), preserve current fallback behavior for older deployments. <br>- Add CI checks to run <code>ExportSelfTest</code> on supported platforms periodically. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Final summary (one paragraph)</strong><br><code>modExport</code> is a defensive, production-oriented export module built for reliability and compatibility: it prioritizes atomic writes, centralized hook usage, policy-guided CustomXML exports, cross-platform ZIP creation, and exhaustive fallbacks. Public functions return booleans except the preserved legacy sub that raises; all failures funnel through <code>LocalHandleError</code> and <code>SafeLogAuditWithMeta</code>, which attempt centralized handling and otherwise perform local audit + conservative raises. Key maintenance areas: keep error codes stable, test ADODB/ADP/COM availability paths, and strengthen CustomXML policy hooks to avoid accidental secrets exfiltration. </td></tr></tbody></table></div><div class="row-count">Rows: 30</div></div><div class="table-caption" id="Table6" data-table="Docu_0159_06" style="margin-top:2mm;margin-left:3mm;"><strong>Table 6</strong></div>
<div class="table-wrapper" data-table-id="table-6"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown (modIAS36)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown (modIAS36)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>Module Name</strong><br>modIAS36.bas<br><strong>Module Version</strong>2025.12.25-Rev3<br><strong>Purpose (module level):</strong> Hardened IAS 36 impairment framework: recoverable amount (VIU & FVLCOD), CGU grouping, deterministic DCF/NPV builder with pluggable daycount conventions, deterministic allocation & journal generator, disclosure summary builder, defensive validation, structured audit logging and predictable error handling. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>Module_Initialize()</strong> — <em>module defaults initializer</em><br><strong>Purpose:</strong> Ensure module-level defaults (g_IAS36_Daycount) are set before any operation.<br><strong>Signature:</strong> <code>Private Sub Module_Initialize()</code><br><strong>Behavior:</strong> Idempotent micro-error-block: sets <code>g_IAS36_Daycount</code> to <code>IAS36_DAYCOUNT_DEFAULT</code> if unset. Swallows transient errors, clears Err. Designed to be cheap and safe to call at start of public functions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates module-level variable <code>g_IAS36_Daycount</code> if previously empty.<br><strong>Invariants:</strong> After successful call <code>g_IAS36_Daycount</code> != vbNullString.<br><strong>Failure modes:</strong> If Application environment prevents assignment (unlikely), it silently leaves existing value; errors cleared. Host should catch only systemic failures.<br><strong>Tests:</strong> Ensure repeated calls preserve same default; set g_IAS36_Daycount externally and call — value should remain. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>SetIAS36DefaultDaycount(convention As String)</strong> — <em>change module default daycount</em><br><strong>Purpose:</strong> Allow host to change default daycount ("ACT/365", "ACT/360", "30/360") with validation and audit logging.<br><strong>Signature:</strong> <code>Public Sub SetIAS36DefaultDaycount(ByVal convention As String)</code><br><strong>Behavior:</strong> Calls <code>Module_Initialize</code>, validates input (case-insensitive); if valid sets <code>g_IAS36_Daycount</code> to canonical upper-case; if invalid logs via <code>SafeLog</code> and retains previous default. Errors routed to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Updates <code>g_IAS36_Daycount</code> and writes audit on invalid values.<br><strong>Invariants:</strong> Only allowed values stored; invalid input does not change default.<br><strong>Failure modes:</strong> Passing empty string does nothing. Host errors in <code>SafeLog</code> are safe (fallback to Debug.Print).<br><strong>Recommended tests:</strong> Valid/invalid values; repeated set; ensure <code>GetIAS36DefaultDaycount</code> returns expected value. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>GetIAS36DefaultDaycount() As String</strong> — <em>read module default</em><br><strong>Purpose:</strong> Return currently configured default daycount (ensures initialization).<br><strong>Signature:</strong> <code>Public Function GetIAS36DefaultDaycount() As String</code><br><strong>Behavior:</strong> Calls <code>Module_Initialize</code> then returns <code>g_IAS36_Daycount</code> (falls back to <code>IAS36_DAYCOUNT_DEFAULT</code>).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None beyond possible module init assignment.<br><strong>Tests:</strong> When module default changed via <code>SetIAS36DefaultDaycount</code>, <code>Get...</code> returns that value. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_CalculateRecoverableByVIU(cashflows, discountRate, Optional asOfDate, Optional daycount) As Double</strong> — <em>VIU NPV calculator</em><br><strong>Purpose:</strong> Compute recoverable amount via Value in Use: present value of forecast cashflows using <code>NPVFromDcfEx</code> and module daycount fallback.<br><strong>Signature:</strong> <code>Public Function IAS36_CalculateRecoverableByVIU(ByVal cashflows As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> Ensures defaults (asOfDate -> Date; daycount fallback). Calls <code>NPVFromDcfEx</code> to compute PV. On errors calls <code>HandleInternalError</code> and returns 0#.<br><strong>Complexity:</strong> Dominated by <code>NPVFromDcfEx</code> (O(n) where n = number of forecast rows).<br><strong>Side-effects:</strong> None (pure calculation).<br><strong>Invariants:</strong> Returns 0 for empty forecasts or on error; deterministic given same inputs.<br><strong>Failure modes:</strong> Non-date entries handled by <code>NormalizeForecastToArray</code>; if <code>NPVFromDcfEx</code> errors, returns 0 and logs. <br><strong>Tests:</strong> Zero flows → 0; positive cashflows with known discount → match manual calculation; negative/complex inputs handled gracefully. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_CalculateRecoverableByFVLCOD(fairValue, costsToSell) As Double</strong> — <em>FVLCOD calculator</em><br><strong>Purpose:</strong> Compute fair value less costs of disposal (simple subtraction, defensive numeric coercion).<br><strong>Signature:</strong> <code>Public Function IAS36_CalculateRecoverableByFVLCOD(ByVal fairValue As Double, ByVal costsToSell As Double) As Double</code><br><strong>Behavior:</strong> Uses <code>NZDouble</code> to coerce inputs, returns <code>fairValue - costsToSell</code>. On error returns 0 and logs via <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> If inputs non-numeric, treated as 0. <br><strong>Tests:</strong> normal numeric cases, non-numeric inputs, negative costs. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_RecoverableAmount(carryingAmount, Optional cashflows, Optional discountRate, Optional fairValue, Optional costsToSell, Optional asOfDate, Optional daycount) As Object</strong> — <em>recoverable aggregator (legacy signature preserved)</em><br><strong>Purpose:</strong> Compute both VIU and FVLCOD, choose higher as recoverable, compute impairment relative to carrying amount, return Scripting.Dictionary with standardized keys used elsewhere (RecoverableAmount, VIU, FVLCOD, MethodUsed, CarryingAmount, ImpairmentLoss).<br><strong>Signature:</strong> <code>Public Function IAS36_RecoverableAmount(ByVal carryingAmount As Double, Optional ByVal cashflows As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValue As Double = 0#, Optional ByVal costsToSell As Double = 0#, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Initializes module, sets defaults, computes <code>viu</code> via <code>NPVFromDcfEx</code> when forecast present, computes <code>fvlcod</code>, selects method ("VIU" vs "FVLCOD"), sets out dictionary values, calculates impairment (rounded via <code>Round2</code>) if recoverable < carryingAmount, logs audit entry, returns dictionary. On error returns Nothing after bubbling to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> Dominated by NPV computation O(n).<br><strong>Side-effects:</strong> Calls <code>SafeLog</code> to append audit.<br><strong>Invariants:</strong> Returns numeric zeros instead of Empty where appropriate to preserve downstream expectations; legacy behavior preserved (functions that historically returned Empty should still do so — here returns Nothing on error).<br><strong>Failure modes:</strong> Missing/invalid forecasts produce VIU=0; errors set to Nothing. <br><strong>Recommended tests:</strong> Compare against manual VIU/FVLCOD selection; carry amounts equal to recoverable produce zero impairment; rounding behavior check. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_GroupAssetsIntoCGUs(assets, Optional groupingKey = "CGU") As Object</strong> — <em>grouping helper</em><br><strong>Purpose:</strong> Group asset records into CGUs by specified groupingKey; returns Dictionary of Collections keyed by group value. Preserves older behavior and supports arrays/collections/dict-like objects.<br><strong>Signature:</strong> <code>Public Function IAS36_GroupAssetsIntoCGUs(ByVal assets As Variant, Optional ByVal groupingKey As String = &quot;CGU&quot;) As Object</code><br><strong>Behavior:</strong> Defensive: returns empty Dictionary if no assets. Supports arrays (any lower bound) and collection-like objects; for each item extracts groupingKey if present else uses default "CGU_1". Builds deterministic Collections inserted in order of iteration. Uses local <code>On Error Resume Next</code> micro-blocks when probing objects.<br><strong>Complexity:</strong> O(n) where n = number of assets.<br><strong>Side-effects:</strong> None beyond returned structure.<br><strong>Invariants:</strong> Keys are strings; each value is a <code>Collection</code> whose items are the original asset objects (not copies).<br><strong>Failure modes:</strong> Non-collection inputs → returns empty dictionary. <br><strong>Tests:</strong> Arrays with different LBound values; object collections; missing groupingKey cases. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_GenerateDCF(forecast, discountRate, Optional asOfDate, Optional daycount) As Variant</strong> — <em>return DCF table array with header</em><br><strong>Purpose:</strong> Build deterministic, sorted DCF table (Date, Cashflow, DiscountFactor, PV) from various forecast shapes; useful for inspection and disclosures.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateDCF(ByVal forecast As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Variant</code><br><strong>Behavior:</strong> Validates inputs, normalizes forecast via <code>NormalizeForecastToArray</code>, computes year fractions via <code>YearFractionEx</code>, discount factors and PV per row, accumulates running PV. Returns a 2D variant array with first row headers and subsequent rows for each forecast row. Returns Empty for invalid/empty forecast. Errors routed to <code>HandleInternalError</code> and returns Empty.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Rows sorted by date ascending (via <code>NormalizeForecastToArray</code> sorting). Non-dates appear as Empty in Date column. Discount factor = 1 when discountRate <= 0.<br><strong>Failure modes:</strong> Non-date/invalid rows placed last by normalization; zero/negative rates handled. <br><strong>Tests:</strong> Known cashflow example with manual PV check; negative rates; zero discount; non-date rows. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_RunImpairmentTest(cgu, Optional discountRate=0#, Optional fairValue=0#, Optional costsToSell=0#, Optional asOfDate, Optional daycount) As Object</strong> — <em>single-CGU impairment test</em><br><strong>Purpose:</strong> Execute full impairment test for one CGU: compute total carrying, recoverable amount (VIU/FVLCOD), impairment, deterministic allocation (if impairment > 0), attach CorrelationID and return result dictionary containing core fields and Allocation dictionary.<br><strong>Signature:</strong> <code>Public Function IAS36_RunImpairmentTest(ByVal cgu As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValue As Double = 0#, Optional ByVal costsToSell As Double = 0#, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Defensive validation of <code>cgu</code>; extracts <code>Assets</code> and <code>Forecast</code>; sums carrying amounts (using <code>GetDictValueIndexed</code> and <code>NZDouble</code>); computes VIU and FVLCOD; determines recoverable and impairment (rounded); builds result dictionary with CGUID (fallback "CGU_UNKNOWN"), TotalCarrying (rounded), RecoverableAmount, MethodUsed, Impairment, VIU, FVLCOD, AsOfDate, DiscountRate, Daycount, CorrelationID via <code>GenerateCorrelationID</code>. If impairment > 0 and assets present, calls <code>AllocateImpairment</code> (PRORATA default), attaches Allocation and verifies invariant via <code>VerifyAllocationInvariant</code>. Logs via <code>SafeLog</code>. On failure returns Nothing and routes to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(n + m) where n = assets, m = forecast rows (NPV).<br><strong>Side-effects:</strong> Calls <code>AllocateImpairment</code> which mutates/creates allocation Dictionary and triggers <code>SafeLog</code> via verification. Adds CorrelationID. <br><strong>Invariants:</strong> If Allocation present, its rounded sum equals impairment (verified, fixed deterministically if not).<br><strong>Failure modes:</strong> Bad cgu input returns Nothing; per-field non-numeric values handled defensively. <br><strong>Recommended tests:</strong> Full flow with positive impairment verifying allocation sums to impairment; CGU w/o assets → no allocation; missing forecast → FVLCOD path tested. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_GenerateImpairmentJournals(testResult, impairmentAccount, assetAccountPrefix) As Variant</strong> — <em>journal generator</em><br><strong>Purpose:</strong> Convert test result Allocation into posting-ready 2D array rows [Date, DrAccount, DrAmount, CrAccount, CrAmount, Narrative]. Preserves deterministic ordering by allocation keys enumeration order (VBScript Dictionary order) which is stable in practice but not guaranteed by spec — code relies on existing Dictionary ordering.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateImpairmentJournals(ByVal testResult As Object, ByVal impairmentAccount As String, ByVal assetAccountPrefix As String) As Variant</code><br><strong>Behavior:</strong> Validates testResult and allocation presence; returns Empty if no impairment. Builds 1..n variant 2D array where each line uses <code>testResult(&quot;AsOfDate&quot;)</code>, impairmentAccount (debit), allocation amount, assetAccountPrefix & "_" & AssetID (credit), narrative includes CorrelationID. Amounts numeric via <code>NZDouble</code>. Errors routed to Handler and return Empty.<br><strong>Complexity:</strong> O(k) where k = number of allocation entries.<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Missing Allocation → Empty. AssetAccountPrefix concatenation may produce unexpected account names if AssetID contains invalid chars — callers should validate AssetID. <br><strong>Tests:</strong> Multi-asset allocation -> n rows; correlation included in narratives. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_RunBatchImpairmentTests(cguList, Optional discountRate=0#, Optional fairValueMap, Optional daycount) As Object</strong> — <em>batch runner with per-CGU resilience</em><br><strong>Purpose:</strong> Run <code>IAS36_RunImpairmentTest</code> for a collection/array of CGUs, capture per-CGU successes and per-CGU errors without aborting whole batch, attach BatchCorrelationID and return Dictionary keyed by CGUID -> result or error record.<br><strong>Signature:</strong> <code>Public Function IAS36_RunBatchImpairmentTests(ByVal cguList As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValueMap As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Creates batchCorrelation via <code>GenerateCorrelationID</code>, logs start, iterates array or object collection; for each CGU extracts optional fairValueMap entries defensively, runs <code>IAS36_RunImpairmentTest</code> inside a per-CGU error handling block (labeled PerCGUErr / PerCGUErr2). On success attaches batchCorrelation fields; on exception captures Err.Number and description into an issue record dictionary and continues. Logs finish. Returns results Dictionary. On global error calls <code>HandleInternalError</code> and returns Nothing.<br><strong>Complexity:</strong> O(B*(asset+forecast)) where B = number of CGUs. Overhead of per-CGU error handling minimal.<br><strong>Side-effects:</strong> Multiple <code>SafeLog</code> entries; no external writes. <br><strong>Invariants:</strong> Returned Dictionary contains an entry for every input CGU index/key; each entry either full result dictionary or an issue dictionary with ErrorNumber/Description. BatchCorrelation is consistent across entries.<br><strong>Failure modes:</strong> Malformed <code>fairValueMap</code> handled defensively; catastrophic error returns Nothing. <br><strong>Tests:</strong> Batch with mixed valid & invalid CGUs → successful entries and per-CGU error entries present; ensure BatchCorrelation in all entries. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_GenerateDisclosureSummary(testResult) As Object</strong> — <em>disclosure-friendly summary builder</em><br><strong>Purpose:</strong> Produce a compact dictionary with CGUID, TotalCarrying, Impairment, ImpairmentPercent, KeyAssumptions (MethodUsed, DiscountRate, Daycount), Sensitivities placeholder — intended for modStatements consumption.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateDisclosureSummary(ByVal testResult As Object) As Object</code><br><strong>Behavior:</strong> Defensive: if testResult Nothing returns dictionary with Message. Otherwise extracts values using <code>NZDoubleObjKey</code>/<code>NZStringObj</code>, computes ImpairmentPercent safely (0 if TotalCarrying=0), constructs assumptions and sensitivities dictionaries, returns out. Optionally can be persisted by modUtilities if available (comment indicates optional persistence).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None (pure transform).<br><strong>Tests:</strong> Valid testResult produces expected percentage and assumptions. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_ValidateInputPackage(pkg) As Object</strong> — <em>input package validator, non-fatal issue collector</em><br><strong>Purpose:</strong> Validate structure & minimal shape of input package (CGUID, Assets, Forecast), return Dictionary of issues where empty dictionary = OK. Caller decides fatal vs non-fatal.<br><strong>Signature:</strong> <code>Public Function IAS36_ValidateInputPackage(ByVal pkg As Object) As Object</code><br><strong>Behavior:</strong> Defensive: if pkg Nothing add PackageMissing. Checks CGUID presence, Assets presence and non-empty; iterates assets to ensure AssetID present and CarryingAmount numeric & non-negative; if Forecast present validates via <code>NormalizeForecastToArray</code>. Uses descriptive keys like <code>Asset_1_ID</code> and messages. Returns issues Dictionary. Errors route to Handler and return Nothing.<br><strong>Complexity:</strong> O(n) assets + O(m) forecast normalization.<br><strong>Side-effects:</strong> None. <br><strong>Recommended tests:</strong> Missing CGUID/Assets; assets with missing IDs; negative carrying amounts; invalid forecasts. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36SelfTest() As Boolean</strong> — <em>self-test harness</em><br><strong>Purpose:</strong> Run deterministic smoke tests covering RunImpairmentTest, allocation invariant, VIU calculation, and validation function; log results and optionally write to test results sheet if host integrates test collection.<br><strong>Signature:</strong> <code>Public Function IAS36SelfTest() As Boolean</code><br><strong>Behavior:</strong> Builds fixtures (two assets, 3-year cashflows, etc.), runs <code>IAS36_RunImpairmentTest</code>, verifies result is object, if impairment>0 verifies allocation sums to impairment, runs zero-flow case, runs <code>IAS36_ValidateInputPackage</code> negative case, logs start/finish, returns boolean <code>ok</code>. On exception returns False and calls <code>HandleInternalError</code>.<br><strong>Complexity:</strong> Moderate (runs a small batch of calculations); deterministic RNG usage minimal (<code>Rnd</code> used elsewhere in correlation fallback).<br><strong>Side-effects:</strong> Calls <code>SafeLog</code>; may create test artifacts if host integration present. <br><strong>Tests:</strong> Self-test should return True in a correctly functioning environment; intentionally break parts to ensure SelfTest catches failures. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>NPVFromDcfEx(dcf, discountRate, asOfDate, daycount) As Double</strong> — <em>robust NPV from normalized DCF</em><br><strong>Purpose:</strong> Sum PV of cashflows (normalized) using <code>YearFractionEx</code> to compute time fractions; used by VIU computations and tests.<br><strong>Signature:</strong> <code>Private Function NPVFromDcfEx(ByVal dcf As Variant, ByVal discountRate As Double, ByVal asOfDate As Variant, ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> If forecast empty returns 0. Normalizes via <code>NormalizeForecastToArray</code>. For each row compute year fraction <code>yf</code> and PV = cf / (1+discountRate)^yf (or cf when discountRate <= 0). Accumulate and return. Errors routed to <code>HandleInternalError</code> and return 0.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Deterministic given same inputs and daycount function. <br><strong>Failure modes:</strong> Bad date rows handled by normalization; extremely large exponents may risk floating precision but typical accounting ranges safe. <br><strong>Tests:</strong> Known cashflow manual PV comparison; discountRate=0 returns sum of cashflows. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>NormalizeForecastToArray(forecast) As Variant</strong> — <em>canonical forecast normalization & stable sorting</em><br><strong>Purpose:</strong> Convert heterogeneous forecast input shapes (2D arrays, arrays of rows, collections of dicts) into a stable 1-based 2D variant array [1..n,1..2], remove empty rows, coerce amounts, and sort ascending by date deterministically pushing non-dates to end. Preserves deterministic behavior across runs and versions.<br><strong>Signature:</strong> <code>Private Function NormalizeForecastToArray(ByVal forecast As Variant) As Variant</code><br><strong>Behavior:</strong> If no rows returns Empty. Copies inputs into temp array treating various shapes, compacts valid rows where Date present or numeric amount present. Builds <code>out</code> array and performs a stable bubble-sort by date: date-date comparison, non-date pushed after dates. Returns Empty if no valid rows. Uses micro error blocks when probing items.<br><strong>Complexity:</strong> O(n^2) due to bubble-sort — acceptable because forecasts are typically small; intentionally stable deterministic algorithm chosen over faster non-stable sorts for auditability.<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Output is 1-based 2D array with dates (or Empty) and numeric amounts; rows sorted with all dates first ascending then non-dates. <br><strong>Failure modes:</strong> If forecast extremely large performance may degrade; recommended to pre-validate sizes before calling. <br><strong>Tests:</strong> Provide differently ordered inputs including non-dates, confirm deterministic ordering and removal of empty rows. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>SwapForecastRows(ByRef arr As Variant, i As Long, j As Long)</strong> — <em>swap utility</em><br><strong>Purpose:</strong> Swap two rows in forecast 2D array used by bubble-sort.<br><strong>Signature:</strong> <code>Private Sub SwapForecastRows(ByRef arr As Variant, ByVal i As Long, ByVal j As Long)</code><br><strong>Behavior:</strong> Swaps date and amount pairs; trivial utility. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> small array swap correctness. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>GetForecastDateAt(forecast, idx) As Variant</strong> — <em>safe accessor for forecast date</em><br><strong>Purpose:</strong> Provide robust read from different forecast shapes using LBound awareness and object/array probing; returns Empty on failure.<br><strong>Signature:</strong> <code>Private Function GetForecastDateAt(ByVal forecast As Variant, ByVal idx As Long) As Variant</code><br><strong>Behavior:</strong> For arrays computes base + idx - 1 indexing; for objects attempts forecast(idx)(1) with error suppression. Errors return Empty. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Different forecast shapes produce expected values. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>GetForecastAmountAt(forecast, idx) As Variant</strong> — <em>safe accessor for forecast amount</em><br><strong>Purpose:</strong> As above but returns numeric amount or 0 on failure.<br><strong>Signature:</strong> <code>Private Function GetForecastAmountAt(ByVal forecast As Variant, ByVal idx As Long) As Variant</code><br><strong>Behavior:</strong> Defensive indexing; returns 0 on errors. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>YearFractionEx(d0, d1, convention) As Double</strong> — <em>daycount implementation</em><br><strong>Purpose:</strong> Compute year fraction between two dates using supported conventions: "ACT/365" (default), "ACT/360", "30/360". Non-dates produce 0; negative days produce 0 (no negative yf).<br><strong>Signature:</strong> <code>Private Function YearFractionEx(ByVal d0 As Variant, ByVal d1 As Variant, ByVal convention As String) As Double</code><br><strong>Behavior:</strong> Validates dates, computes days difference as <code>CDbl(dt1) - CDbl(dt0)</code>, applies convention formulas. "30/360" uses simple 30/360 arithmetic. Unknown convention falls back to ACT/365.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Failure modes:</strong> Input non-dates -> 0. <br><strong>Tests:</strong> Known date pairs for each convention; negative dt1 < dt0 returns 0. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>GetRowCount(arr) As Long</strong> — <em>generic row/collection counter</em><br><strong>Purpose:</strong> Provide robust count for arrays (handles arbitrary LBound/UBound) and collection-like objects; returns 0 for missing/empty inputs.<br><strong>Signature:</strong> <code>Private Function GetRowCount(ByVal arr As Variant) As Long</code><br><strong>Behavior:</strong> If IsArray uses LBound/UBound to compute count; if IsObject attempts <code>arr.count</code> with error suppression; else 0. Errors handled. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Arrays with different bounds; collections; Nothing inputs. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>GetDictValue(dictLike, key) As Variant</strong> — <em>safe dict get</em><br><strong>Purpose:</strong> Return value if object and key exists; else Empty. Thin defensive wrapper used across module.<br><strong>Signature:</strong> <code>Private Function GetDictValue(ByVal dictLike As Variant, ByVal key As String) As Variant</code><br><strong>Behavior:</strong> Uses <code>IsObject</code> -> <code>Exists</code> check with <code>On Error Resume Next</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>GetDictValueIndexed(dictArray, idx, key) As Variant</strong> — <em>safe indexed dict get</em><br><strong>Purpose:</strong> For arrays or collections of dict-like items provide safe extraction of a key from the element at index <code>idx</code> with support for arrays with non-1 LBound.<br><strong>Signature:</strong> <code>Private Function GetDictValueIndexed(ByVal dictArray As Variant, ByVal idx As Long, ByVal key As String) As Variant</code><br><strong>Behavior:</strong> Handles array and object forms; returns Empty when not present or on error. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Array-of-dicts and collection-of-dicts scenarios with missing keys. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>NZDouble(v, Optional def = 0#) As Double</strong> — <em>null-safe numeric coercion</em><br><strong>Purpose:</strong> Convert value to Double if numeric else return default. Swallows errors.<br><strong>Signature:</strong> <code>Private Function NZDouble(ByVal v As Variant, Optional ByVal def As Double = 0#) As Double</code><br><strong>Behavior:</strong> <code>IsNumeric</code> then <code>CDbl</code> else def. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Numeric strings, Null, Empty, objects. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>NZDoubleObjKey(o, key, Optional def = 0#) As Double</strong> — <em>object-key numeric fetch</em><br><strong>Purpose:</strong> If object exists and contains key, coerce numeric value via NZDouble else default.<br><strong>Signature:</strong> <code>Private Function NZDoubleObjKey(ByVal o As Object, ByVal key As String, Optional ByVal def As Double = 0#) As Double</code><br><strong>Behavior:</strong> Defensive checks for Nothing and key existence. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>NZStringObj(o, key, Optional def = "") As String</strong> — <em>object-key string fetch</em><br><strong>Purpose:</strong> Defensive extraction of string from object key; returns default otherwise.<br><strong>Signature:</strong> <code>Private Function NZStringObj(ByVal o As Object, ByVal key As String, Optional ByVal def As String = &quot;&quot;) As String</code><br><strong>Behavior:</strong> Similar to NZDoubleObjKey but returns CStr. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>NZString(v, Optional def = "") As String</strong> — <em>null/empty to string helper</em><br><strong>Purpose:</strong> Coerce variant to string or default for Null/Empty.<br><strong>Signature:</strong> <code>Private Function NZString(ByVal v As Variant, Optional ByVal def As String = &quot;&quot;) As String</code><br><strong>Behavior:</strong> Returns def for Null/Empty else CStr(v). <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>Round2(v As Double) As Double</strong> — <em>centralized rounding policy</em><br><strong>Purpose:</strong> Central rounding to 2 decimal places using <code>VBA.Round</code>. Single point of change for rounding policy (bankers vs away-from-zero note in header).<br><strong>Signature:</strong> <code>Private Function Round2(ByVal v As Double) As Double</code><br><strong>Behavior:</strong> Calls <code>VBA.Round(v,2)</code> with error suppression. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> If rounding policy needs change, modify here; maintainers should add unit tests for edge .005 cases for target policy. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>AllocateImpairment(assets, impairment, mode, weights) As Object</strong> — <em>deterministic allocation algorithm (core)</em><br><strong>Purpose:</strong> Deterministically allocate total impairment across assets according to mode: "PRORATA" (default), "EQUAL", "WEIGHTED". Returns Dictionary AssetID -> allocation (rounded 2dp). Guarantees sum-to-impairment after residual deterministic adjustment and invariant verification/fallback.<br><strong>Signature:</strong> <code>Private Function AllocateImpairment(ByVal assets As Variant, ByVal impairment As Double, ByVal mode As String, ByVal weights As Variant) As Object</code><br><strong>Behavior (detailed):</strong><br>- Defensive early exit for no assets -> empty dict.<br>- Extract arrays <code>carries()</code> and <code>ids()</code> (deterministic ordering by input iteration).<br>- Compute <code>rawAlloc()</code> based on mode: PRORATA uses carrying weights; EQUAL divides equally; WEIGHTED uses provided weights (array or dictionary) with fallback to pro-rata when weights invalid.<br>- Round each line via <code>Round2</code> and accumulate <code>sumRounded</code>.<br>- Compute <code>residual = Round2(impairment - sumRounded)</code> and if residual significant (abs>=0.005) pick deterministic index to adjust: for PRORATA choose largest carrying (tie-break lex AssetID case-insensitive); for EQUAL/WEIGHTED choose largest rawAlloc (tie-break lex smallest id). Apply residual to chosen asset and re-round.<br>- Verify final sum equals impairment (rounded). If mismatch log <code>AllocationInvariant</code> and deterministically add remaining diff to lexicographically smallest AssetID.<br>- Return Dictionary. On error calls <code>HandleInternalError</code> and returns best-effort allocations.<br><strong>Complexity:</strong> O(rc) where rc = asset count. <br><strong>Side-effects:</strong> Creates and returns Dictionary; uses <code>SafeLog</code> on invariant mismatch.<br><strong>Invariants:</strong> Sum of allocations (rounded) equals <code>impairment</code> (rounded). Tie-break deterministic to ensure reproducibility.<br><strong>Failure modes:</strong> Non-numeric carrying amounts treated as 0; weights malformed -> fallback to pro-rata. For extremely large asset counts numeric rounding may produce frequent residuals; algorithm handles by deterministic redistribution.<br><strong>Recommended tests:</strong> Multiple modes, weight dictionary vs array, tie scenarios where residual distribution deterministic, round-trip sum equality. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>IAS36_AllocateImpairment(assets, impairment, Optional mode="PRORATA", Optional weights) As Object</strong> — <em>public thin wrapper to allocation</em><br><strong>Purpose:</strong> Expose allocation algorithm preserving backward compatibility; ensures impairment is rounded to module policy before allocation and logs verification with generated correlation ID.<br><strong>Signature:</strong> <code>Public Function IAS36_AllocateImpairment(ByVal assets As Variant, ByVal impairment As Double, Optional ByVal mode As String = &quot;PRORATA&quot;, Optional ByVal weights As Variant) As Object</code><br><strong>Behavior:</strong> Round <code>impRounded = Round2(NZDouble(impairment))</code>, call <code>AllocateImpairment</code>, call <code>VerifyAllocationInvariant</code> with generated correlation and "ALLOC_PUBLIC" marker, return allocation. On error returns Nothing after <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(rc).<br><strong>Side-effects:</strong> Logs verification. <br><strong>Tests:</strong> Public wrapper returns same as private when impairment rounded; verification logs created. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>VerifyAllocationInvariant(allocations, expectedTotal, cguid, correlationID)</strong> — <em>invariant checker & auditor</em><br><strong>Purpose:</strong> Compute sum of allocation dictionary and log either OK or mismatch; non-throwing (resilient).<br><strong>Signature:</strong> <code>Private Sub VerifyAllocationInvariant(ByVal allocations As Object, ByVal expectedTotal As Double, ByVal cguid As String, ByVal correlationID As String)</code><br><strong>Behavior:</strong> Sums allocations via <code>NZDouble</code>, compares rounded sums; on mismatch logs <code>VerifyAllocationInvariant</code> with details; on OK logs <code>VerifyAllocationInvariant.OK</code>. Errors suppressed; uses <code>SafeLog</code> for audit.<br><strong>Complexity:</strong> O(k) where k = number of allocated entries. <br><strong>Side-effects:</strong> Audit logs. <br><strong>Notes:</strong> Useful for telemetry and forensic traceability in batch runs. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>SafeLog(moduleName, proc, details)</strong> — <em>structured logging wrapper</em><br><strong>Purpose:</strong> Centralized audit logging that attempts to call host <code>LogAudit</code> (by <code>Application.Run &quot;LogAudit&quot;, ...</code>) and falls back to <code>Debug.Print</code> if not available. Non-throwing to not disturb main flows.<br><strong>Signature:</strong> <code>Private Sub SafeLog(moduleName As String, proc As String, details As String)</code><br><strong>Behavior:</strong> <code>On Error Resume Next</code> + <code>Application.Run &quot;LogAudit&quot;, moduleName &amp; &quot;.&quot; &amp; proc, details</code>. If that errors, prints fallback to Immediate window. Clears Err.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls host macro if present. <br><strong>Failure modes:</strong> Host <code>LogAudit</code> absent triggers fallback. <br><strong>Tests:</strong> With and without host LogAudit hook — confirm fallback behavior. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>HandleInternalError(procName, errObj)</strong> — <em>error routing / host integration</em><br><strong>Purpose:</strong> Route internal errors to host <code>HandleError(procName, errNumber, errDescription)</code> if present; otherwise raise minimal VBA error to surface to host while avoiding uncontrolled crashes. Accepts ErrObject or numeric/string descriptors as <code>errObj</code> and extracts Number/Description accordingly.<br><strong>Signature:</strong> <code>Private Sub HandleInternalError(procName As String, ByVal errObj As Variant)</code><br><strong>Behavior:</strong> Defensive extraction of <code>errObj</code> fields (supports ErrObject, object-like, numeric, string). Attempts <code>Application.Run &quot;HandleError&quot;, procName, n, d</code>. If that succeeds returns. If host call not available, raises <code>Err.Raise vbObjectError + 513</code> with a minimal message to surface error. All internal error handling uses <code>On Error Resume Next</code> to avoid masking host behavior and ensures Err cleared where appropriate.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May raise an error if host handler not present; otherwise delegates to host. <br><strong>Failure modes:</strong> Host <code>HandleError</code> absent -> small raised error; ensure callers expect possible raised errors. <br><strong>Tests:</strong> Simulate host missing -> Err.Raise observed; with host stub -> host receives call. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>GenerateCorrelationID() As String</strong> — <em>traceability id generator with GUID fallback</em><br><strong>Purpose:</strong> Attempt to produce GUID via <code>Scriptlet.TypeLib</code>.guid; if not available, generate timestamp-based fallback string <code>&quot;CID_yyyymmddhhNNss_random&quot;</code>. Ensures traceability across logs and batch runs.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Try <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code>, strip braces; on error returns timestamp + pseudo-random component using <code>Rnd</code>. Uses <code>On Error GoTo Fallback</code> pattern. <br><strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Worst-case fallback uses timestamp & Rnd — acceptable for correlation but less globally unique. <br><strong>Tests:</strong> On typical Windows hosts GUID produced; on restricted hosts fallback format used. </td></tr><tr><td data-label="Technical Breakdown (modIAS36)"> <strong>Notes on cross-cutting behaviors & maintainability</strong><br><strong>Determinism:</strong> The module consciously chooses deterministic, stable algorithms (bubble-sort stable ordering, tie-break rules in allocations) to ensure auditability; changing tokenization/sorting/allocation rules must be accompanied by migration tests and explicit versioning. <br><strong>Error handling philosophy:</strong> Prefer targeted micro <code>On Error Resume Next</code> blocks when probing host-provided objects or optional fields; global <code>ErrHandler</code> sections route to <code>HandleInternalError</code> and return safe default (Empty, 0, Nothing) to avoid crashing host automation. <br><strong>Rounding policy:</strong> Centralized in <code>Round2</code> to allow policy switch. Add tests for .005 rounding edge cases if policy changes. <br><strong>Security & data sensitivity:</strong> Module handles financial numbers only; avoid writing PII into logs. <code>SafeLog</code> uses host <code>LogAudit</code> — ensure host implements appropriate retention and redaction for sensitive fields. <br><strong>Performance:</strong> Forecast normalization uses O(n^2) stable bubble-sort — acceptable for typical short forecasts. If high row counts expected (>1000) consider replacing with stable merge sort. <br><strong>Testing recommendations:</strong> Unit tests for token deterministic allocations, allocation residual distribution in tie cases, daycount conventions (ACT/365, ACT/360, 30/360), NPV equivalence to reference spreadsheets, per-CGU batch resilience (simulate throwing CGU), SelfTest regression gating in CI. <br><strong>Host integration checklist:</strong> Ensure host provides <code>LogAudit</code> and <code>HandleError</code> or accept fallback behaviours. Prefer host to capture <code>SafeLog</code> outputs for audit trails. <br><strong>Compatibility:</strong> Public API surface preserved: <code>IAS36_RecoverableAmount</code>, <code>IAS36_RunImpairmentTest</code>, <code>IAS36_RunBatchImpairmentTests</code>, <code>IAS36_GenerateImpairmentJournals</code>, <code>IAS36_AllocateImpairment</code> and <code>IAS36_GenerateDisclosureSummary</code> should remain stable for consumers. </td></tr></tbody></table></div><div class="row-count">Rows: 36</div></div><div class="table-caption" id="Table7" data-table="Docu_0159_07" style="margin-top:2mm;margin-left:3mm;"><strong>Table 7</strong></div>
<div class="table-wrapper" data-table-id="table-7"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modIFRS15)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modIFRS15)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Overview:</strong> This table provides a world-class, per-function technical breakdown of the <code>modIFRS15</code> VBA module you supplied. It documents purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended tests, and maintainer notes. The module implements a deterministic IFRS 15 contract pipeline: parsing/normalising contract input, deterministic allocation of transaction price (including variable consideration treatment), generation of recognition schedules, journals and disclosures, validation, batch processing and an embedded self-test harness. It relies on shared infra (modConfig, logging, auditing, modError) via best-effort calls and preserves backward-compatible public API shapes. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Module-level invariants & config keys</strong><br>- Rounding precision controlled by <code>GetConfigDouble(&quot;roundingPrecision&quot;, ...)</code> defaulting to 2 via <code>GetRoundingPrecision()</code>.<br>- Variable-consideration constraint key: <code>&quot;variableConstraintThreshold&quot;</code> (default passed into AllocateTransactionPrice).<br>- Account config keys: <code>&quot;IFRS15_RevenueAccount&quot;</code>, <code>&quot;IFRS15_ContraAccount&quot;</code> used by journal generation.<br>- Public API stable functions: <code>IFRS15_AnalyzeContract</code>, <code>IFRS15_AllocateTransactionPrice</code>, <code>IFRS15_GenerateRecognitionSchedule</code>, <code>IFRS15_GenerateJournalEntries</code>, <code>IFRS15_GenerateDisclosures</code>, <code>IFRS15_ValidateContract</code>, <code>IFRS15_BatchProcessContracts</code>, <code>IFRS15SelfTest</code>.<br>- Determinism rules: residual rounding absorbed into PO with largest <code>StandalonePrice</code>; final period receives schedule residual; allocations preserve pre-existing <code>analysis(&quot;Allocation&quot;)</code> if present (backwards compatibility). </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_AnalyzeContract( contract As Variant ) -> Object <code>|</code> Dictionary</strong><br><strong>Purpose:</strong> Normalize incoming contract input into canonical <code>analysis</code> object (dictionary) with a <code>PerformanceObligations</code> collection and key metadata required by later functions.<br><strong>Signature:</strong> <code>IFRS15_AnalyzeContract(ByVal contract As Variant) As Object</code> — returns <code>Scripting.Dictionary</code> or <code>Nothing</code> on error.<br><strong>Behavior:</strong> Validates <code>contract</code> shape, extracts <code>Lines</code> (via <code>GetContractLines</code>), iterates lines to build PO dictionaries with keys: <code>POID</code>, <code>Description</code>, <code>Quantity</code>, <code>StandalonePrice</code>, <code>RecognitionMethod</code>, <code>DeliveryDate</code>, <code>VariableConsideration</code>, <code>SourceLine</code>. Coerces/normalises numeric values, applies defensive checks (negative quantity -> abs + judgment; negative standalone -> coerced zero + judgment). Computes <code>TotalStandalone</code>, sets <code>TransactionPrice</code> and <code>ContractDate</code> when present. Initializes placeholders <code>Allocation</code>, <code>ReserveForVariable</code>, <code>AllocatedTotal</code>, <code>JudgmentsApplied</code> to preserve public shapes.<br><strong>Complexity:</strong> O(n) in number of lines.<br><strong>Side-effects:</strong> Calls <code>SafeLog</code>, may call <code>AddLocalIssueAudit</code>, pushes judgments into analysis if coercions occur.<br><strong>Invariants:</strong> Returned <code>PerformanceObligations</code> is a <code>Collection</code> of dictionaries; <code>TotalStandalone</code> matches sum of PO <code>StandalonePrice</code> values computed inside function.<br><strong>Failure modes:</strong> Missing or malformed <code>Lines</code> => returns dictionary with minimal info; unexpected object types swallowed (On Error Resume Next wrapper). Errors funnel to <code>SafeHandleError</code> and return <code>Nothing</code> only on exceptions that escape local handling.<br><strong>Security/PII:</strong> Avoids storing sensitive free-text in global logs; judgements are PII-light by design but appended to local audit if needed.<br><strong>Recommended tests:</strong> line shapes with missing fields, negative quantities/prices, variable consideration in scalar/object/array forms; ensure <code>TotalStandalone</code> and PO fields correct for representative inputs.<br><strong>Notes for maintainers:</strong> Keep token names stable (<code>POID</code>, <code>StandalonePrice</code>) to avoid breaking downstream code. Preserve existing allocation override behaviour for backward compatibility. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_AllocateTransactionPrice( analysis As Object, Optional applyVariableConsideration As Boolean = True, Optional variableConstraintThreshold As Double = 0.25 ) -> Object</strong><br><strong>Purpose:</strong> Deterministic allocation of transaction price to performance obligations, evaluating variable consideration and applying reserve rules; rounds and fixes rounding residuals deterministically.<br><strong>Signature:</strong> <code>IFRS15_AllocateTransactionPrice(ByVal analysis As Object, Optional ByVal applyVariableConsideration As Boolean = True, Optional ByVal variableConstraintThreshold As Double = 0.25) As Object</code> — returns mutated <code>analysis</code> with <code>Allocation</code>, <code>AllocatedTotal</code>, <code>ReserveForVariable</code>, and <code>JudgmentsApplied</code> updated, or <code>Nothing</code> on fatal error.<br><strong>Behavior (high-level):</strong><br>- Validates <code>analysis</code>, reads <code>TransactionPrice</code> and <code>TotalStandalone</code>.<br>- Overrides <code>variableConstraintThreshold</code> from <code>GetConfigDouble</code> if configured.<br>- Evaluates each PO's <code>VariableConsideration</code> into a deterministic <code>expectedVal</code> by supporting scalar numeric, object <code>{Method, MostLikely, Scenarios}</code>, or array of <code>{Probability, Amount}</code>.<br>- Applies reserve: if <code>expectedVal &lt;= threshold * txPrice</code> then reserve includes expected value; otherwise record judgment <code>ReserveNotApplied_AboveThreshold</code>.<br>- Compute <code>allocablePrice = TransactionPrice - reserve</code> (clamped >= 0). Build unrounded proportional shares by standalone price if <code>TotalStandalone &gt; 0</code>, else equal split. Round shares using <code>SafeRound</code> to rounding precision. Determine residual between rounded shares and rounded allocable price; absorb residual deterministically into PO with largest <code>StandalonePrice</code> (tie by lowest index). Preserve existing <code>analysis(&quot;Allocation&quot;)</code> if present (do not overwrite), recording <code>PreservedExistingAllocation</code> judgment.<br>- Ensure <code>AllocatedTotal + ReserveForVariable</code> rounded equals TransactionPrice; if mismatch, apply correction to best PO or reserve and record <code>AllocationEquationCorrection</code> or <code>ReserveEquationCorrection</code> judgments.<br><strong>Complexity:</strong> O(n) across POs; variable consideration scenario evaluation is O(m) per PO where m is number of scenarios.<br><strong>Side-effects:</strong> Mutates <code>analysis</code> (adds/sets <code>Allocation</code>, <code>AllocatedTotal</code>, <code>ReserveForVariable</code>), logs judgments and calls <code>SafeLog</code>/<code>AddJudgment</code>.<br><strong>Invariants:</strong> Final <code>SafeRound(AllocatedTotal + ReserveForVariable)</code> equals <code>SafeRound(TransactionPrice)</code>; allocation dictionary keys correspond to <code>POID</code>s.<br><strong>Failure modes:</strong> Non-numeric or malformed variable consideration objects are handled gracefully (On Error blocks); negative or zero transaction price results in judgments but allocation proceeds with zero allocable. Large roundingPrecision changes may break deterministic residual absorption—tests required when changing config.<br><strong>Tests:</strong> Scalar VCo, scenarios object, array-of-scenarios inputs; zero/negative tx price; totalStandalone = 0 (equal split); residual absorption deterministic (largest standalone wins); preservation of pre-existing allocation.<br><strong>Notes:</strong> Keep <code>SafeRound</code> precision consistent; any change to residual tie-break rule must be accompanied by migration notes because allocations can be auditable. Consider adding an explicit <code>AllocationMethod</code> tag to analysis for future traceability. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateRecognitionSchedule( analysis As Object, Optional periods As Long = 12, Optional startDate As Variant = Null ) -> Variant (2D array)</strong><br><strong>Purpose:</strong> Produce a recognition schedule matrix of revenue recognition rows (contractID, POID, periodIndex, recognitionDate, amount, method) deterministically from allocation and PO recognition methods.<br><strong>Signature:</strong> <code>IFRS15_GenerateRecognitionSchedule(ByVal analysis As Object, Optional ByVal periods As Long = 12, Optional ByVal startDate As Variant = Null) As Variant</code> — returns 2D array <code>(1..rows, 1..6)</code> or <code>Empty</code> on no rows/failure.<br><strong>Behavior:</strong><br>- Validates <code>analysis</code> and determines <code>startDate</code> precedence: provided startDate > analysis("ContractDate") > Today.<br>- Clamps <code>periods</code> to <code>[1,10000]</code> and records judgments if clamped.<br>- For each PO: determines <code>amount</code> from <code>analysis(&quot;Allocation&quot;)(POID)</code> if present else <code>PO(&quot;StandalonePrice&quot;)</code>. Rounds <code>amount</code> to roundingPrecision.<br>- If <code>RecognitionMethod</code> = <code>&quot;time&quot;</code>, evenly divide <code>amount</code> by <code>periods</code>, round per period, compute period residual <code>schResidual = amount - (perPeriodRounded * periods)</code> and place residual in final period (deterministic). For <code>&quot;point&quot;</code>, create a single row using <code>DeliveryDate</code> if valid, otherwise fallback to <code>startDate</code> and add judgment <code>FallbackDeliveryDateToStartDate</code>.<br>- Assemble rows into 2D variant array columns: ContractID, POID, PeriodIndex, Date, Amount, Method.<br><strong>Complexity:</strong> O(n * periods) where <code>n</code> = number of POs; but typical usage has small <code>periods</code> (monthly 12/36). Guard exists to prevent runaway loops for enormous <code>periods</code> (clamp at 10000).<br><strong>Side-effects:</strong> Writes judgments to <code>analysis</code> (fallbacks/clamping), <code>SafeLog</code> call.<br><strong>Invariants:</strong> Sum of schedule amounts per PO equals the PO amount (after rounding); residuals are placed in final period for time-based POs.<br><strong>Failure modes:</strong> If allocation missing, uses PO standalone price; if amounts zero/no POs returns <code>Empty</code>. Date coercion may fail silently and fallback to <code>startDate</code>.\<br><strong>Tests:</strong> time-based PO with non-divisible amount to ensure residual in final period; point-in-time with/without DeliveryDate; periods out-of-range behaviour; round-trip check that schedule sums match allocation. <br><strong>Notes:</strong> Keep date arithmetic consistent (uses <code>DateAdd(&quot;m&quot;, ...)</code>). If supporting non-monthly periods is required in future, refactor to pluggable period step. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateJournalEntries( recognitionSchedule As Variant, revenueAccount As String, contraAccount As String ) -> Variant (2D array)</strong><br><strong>Purpose:</strong> Convert recognition schedule into nominal debit/credit journal rows for posting: date, debit account, debit amount, credit account, credit amount, narrative.<br><strong>Signature:</strong> <code>IFRS15_GenerateJournalEntries(ByVal recognitionSchedule As Variant, ByVal revenueAccount As String, ByVal contraAccount As String) As Variant</code> — returns 2D variant array matching input row count or <code>Empty</code> if input empty.<br><strong>Behavior:</strong><br>- If accounts not supplied, attempts <code>GetConfigString(&quot;IFRS15_RevenueAccount&quot;, &quot;Revenue&quot;)</code> and <code>GetConfigString(&quot;IFRS15_ContraAccount&quot;, &quot;DeferredRevenue&quot;)</code> as defaults.<br>- For each row in <code>recognitionSchedule</code>, builds journal row: date, contraAccount (debit) amount, revenueAccount (credit) amount, narrative <code>&quot;Revenue recognition for &lt;POID&gt;&quot;</code>.<br><strong>Complexity:</strong> O(rows in schedule).<br><strong>Side-effects:</strong> <code>SafeLog</code> call.<br><strong>Invariants:</strong> Each journal row mirrors a schedule row and preserves amounts; numeric coercion via <code>NZDouble</code> prevents non-numeric breakdowns.<br><strong>Failure modes:</strong> Missing accounts -> default strings used; non-date schedule dates are copied verbatim. <br><strong>Tests:</strong> schedule with 0 rows -> returns Empty; account override vs config fallback; narrative correctness. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateDisclosures( analysis As Object ) -> Object (Dictionary)</strong><br><strong>Purpose:</strong> Build disclosures summarising unsatisfied performance obligations and significant judgments for reporting/disclosure consumption.<br><strong>Signature:</strong> <code>IFRS15_GenerateDisclosures(ByVal analysis As Object) As Object</code> — returns <code>Scripting.Dictionary</code> containing <code>UnsatisfiedPerformanceObligations</code> (Collection), <code>TotalUnsatisfied</code>, <code>SignificantJudgments</code> (Collection) and optionally <code>Message</code> for error cases.<br><strong>Behavior:</strong><br>- For each PO in <code>analysis(&quot;PerformanceObligations&quot;)</code>, compute <code>RemainingAmount</code> from <code>analysis(&quot;Allocation&quot;)(POID)</code> (if present) else <code>StandalonePrice</code>, round to roundingPrecision, assemble summary dict with <code>POID</code>, <code>Description</code>, <code>RemainingAmount</code> and append to results collection.<br>- Sum totals and include <code>SignificantJudgments</code> copied from <code>analysis(&quot;JudgmentsApplied&quot;)</code> if present.<br>- If <code>analysis</code> missing, returns object with message <code>&quot;No analysis supplied&quot;</code>.<br><strong>Complexity:</strong> O(n POs).<br><strong>Side-effects:</strong> <code>SafeLog</code> call.<br><strong>Invariants:</strong> TotalUnsatisfied equals sum of <code>RemainingAmount</code> values; disclosure uses PII-light judgment entries.<br><strong>Failure modes:</strong> Missing or malformed <code>analysis</code> handled gracefully by returning informative message. <br><strong>Tests:</strong> Assertions that totals equal allocation; inclusion of judgments; minimal output when analysis absent. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_ValidateContract( contract As Variant ) -> Object (Dictionary of issues)</strong><br><strong>Purpose:</strong> Lightweight validation diagnostic to identify missing/invalid contract fields before analysis.<br><strong>Signature:</strong> <code>IFRS15_ValidateContract(ByVal contract As Variant) As Object</code> — returns dictionary of issues (key => message) or <code>Nothing</code> on error.<br><strong>Behavior:</strong><br>- Checks <code>Contract</code> presence, <code>ContractID</code> recommended, <code>TransactionPrice</code> non-negative, existence of <code>Lines</code> and per-line checks: description presence, quantity numeric/non-zero, standalone price non-negative, recognition method allowed (<code>time</code>/<code>point</code>), <code>UnitPrice</code> non-negative.<br>- Uses <code>GetContractLines</code> and helper <code>Nz*</code> functions for defensive reads.<br><strong>Complexity:</strong> O(n lines).<br><strong>Side-effects:</strong> None (pure diagnostic).<br><strong>Invariants:</strong> Returns empty dictionary if no issues found; keys are stable for programmatic consumption (e.g., <code>Line_1_Description</code>).<br><strong>Failure modes:</strong> Non-array or malformed lines handled as <code>NoLines</code> issue. <br><strong>Tests:</strong> Missing ContractID, negative TransactionPrice, malformed lines, invalid recognition method. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_BatchProcessContracts( contracts As Variant ) -> Object (Dictionary results)</strong><br><strong>Purpose:</strong> Deterministic batch driver for processing multiple contracts: analyze, allocate, schedule generation; returns a dictionary mapping contract id to schedule (pure data) or failure code strings.<br><strong>Signature:</strong> <code>IFRS15_BatchProcessContracts(ByVal contracts As Variant) As Object</code> — returns <code>Scripting.Dictionary</code> keyed by deterministic contract identifier.<br><strong>Behavior:</strong><br>- Iterates <code>contracts</code> deterministically via <code>LBoundArraySafe</code>..<code>UBoundArraySafe</code>.<br>- For each contract: calls <code>IFRS15_AnalyzeContract</code>, <code>IFRS15_AllocateTransactionPrice</code>, <code>IFRS15_GenerateRecognitionSchedule</code> (12 periods default, start date from contract). Collects and stores schedule in results. Uses <code>On Error Resume Next</code> per-iteration to ensure single-contract failures don't abort entire batch; logs progress via <code>SafeLog</code>.<br><strong>Complexity:</strong> O(m * per-contract-cost) where m = number of contracts. The included perf test uses ~100 contracts to validate throughput.<br><strong>Side-effects:</strong> Logs per-contract, appends <code>SafeLog</code> and possibly <code>AppendLocalAudit</code> on failures; does NOT write to sheets (pure data).<br><strong>Invariants:</strong> Deterministic iteration order based on array bounds; results keys use <code>ContractID</code> or fallback <code>Contract_&lt;i&gt;</code> index to guarantee unique keys.<br><strong>Failure modes:</strong> Individual contract failures recorded as <code>&quot;AnalysisFailed&quot;</code> or <code>&quot;AllocationFailed&quot;</code> strings in results; entire function returns <code>Nothing</code> only on unrecoverable error (rare).<br><strong>Tests:</strong> Batch with mixture of valid/invalid contracts; performance smoke: 100 contracts as in module self-test. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15SelfTest() -> Boolean</strong><br><strong>Purpose:</strong> Embedded unit/integration self-test harness exercising core flows (analysis, allocation, schedule generation) with multiple fixtures and a lightweight performance batch; writes test summary to hidden <code>_IFRS_TestResults</code> sheet for CI/manual inspection.<br><strong>Signature:</strong> <code>IFRS15SelfTest() As Boolean</code> — returns <code>True</code> if no failures detected, else <code>False</code>.<br><strong>Behavior:</strong><br>- Creates three fixture contracts covering: (1) combined time+point recognition, (2) scalar variable consideration, (3) scenario-based variable consideration. Performs analyze -> allocate -> generate schedule and validates that <code>AllocatedTotal + Reserve</code> equals TransactionPrice and schedule sums match allocation. Runs a small perf batch (100 contracts) through <code>IFRS15_BatchProcessContracts</code> and records <code>AppendTestResults</code> to <code>_IFRS_TestResults</code> sheet. Uses <code>SafeLog</code> and <code>AddJudgment</code> to record notable events. Aggregates pass/fail counters and returns boolean accordingly.<br><strong>Complexity:</strong> Small fixed number of tests plus perf batch (O(100) contracts by default).<br><strong>Side-effects:</strong> Writes to hidden worksheet <code>_IFRS_TestResults</code> and may call <code>AppendLocalAudit</code>. Designed to be non-invasive but creates hidden sheet if absent.<br><strong>Invariants:</strong> Should be idempotent and not alter production workbook state besides adding a hidden results sheet and audit entries.<br><strong>Failure modes:</strong> If sheet creation fails (locked workbook) the function will still return boolean false and call <code>SafeHandleError</code>.<br><strong>Tests:</strong> The function itself is the test harness; maintainers should run it in CI or dev environment and inspect <code>_IFRS_TestResults</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetContractLines( contract ) -> Variant (array or Empty)</strong><br><strong>Purpose:</strong> Defensive extractor for contract <code>Lines</code> that accepts either object with <code>Lines</code> property or a bare array contract representation.<br><strong>Signature:</strong> <code>Private Function GetContractLines(ByVal contract As Variant) As Variant</code><br><strong>Behavior:</strong> Returns <code>contract(&quot;Lines&quot;)</code> if object with <code>Lines</code>, else returns contract itself if array; else <code>Empty</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Provide object-with-Lines, array contract, and invalid inputs. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EnsureAsDictionary( v ) -> Object (Dictionary)</strong><br><strong>Purpose:</strong> Convert non-object line inputs into an empty <code>Scripting.Dictionary</code> to allow uniform property access.<br><strong>Signature:</strong> <code>Private Function EnsureAsDictionary(ByVal v As Variant) As Object</code><br><strong>Behavior:</strong> If <code>v</code> is object returns it; else returns new empty <code>Scripting.Dictionary</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Critical to avoid runtime errors when consumer code assumes dictionary semantics. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Nz* helpers (NzStringFromVariant, NzDoubleFromVariant, NzDateFromVariant, NzStringDict, NzDoubleDict, NzDateDict, NzDoubleObj, NZStringObj, NZDouble)</strong><br><strong>Purpose:</strong> Defensive coercion helpers used across module to safely extract typed values from <code>Variant</code>/<code>Object</code> inputs without raising errors.<br><strong>Signatures:</strong> Each returns typed defaults when keys missing or types invalid. Eg <code>NzDoubleFromVariant(v, key, def) -&gt; Double</code>.<br><strong>Behavior:</strong> Use <code>On Error Resume Next</code>, test <code>IsObject</code>/<code>Exists</code>, type-check, convert, otherwise return default. <code>NZDouble</code> is generic numeric coerce for a value.<br><strong>Complexity:</strong> O(1) per call.<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Always returns a value of expected type (string/double/date) or provided default.<br><strong>Tests:</strong> Feeding nulls, strings, numeric strings, missing keys and verifying defaults used. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Array helpers (LBoundArraySafe, UBoundArraySafe, CountArrayElements)</strong><br><strong>Purpose:</strong> Defensive array boundary functions avoiding runtime errors when <code>arr</code> is not an array.<br><strong>Signatures:</strong> <code>LBoundArraySafe(arr) -&gt; Long</code>, <code>UBoundArraySafe(arr) -&gt; Long</code>, <code>CountArrayElements(arr) -&gt; Long</code>.<br><strong>Behavior:</strong> If <code>IsArray(arr)</code> returns respective bounds else safe sentinel values (0 / -1 / 0).<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Non-array inputs, empty arrays, 1-based/0-based arrays. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EscapeCsv( s ) -> String</strong><br><strong>Purpose:</strong> Minimal CSV escaping helper returning string with quotes doubled (for field-level CSV writing elsewhere).<br><strong>Signature:</strong> <code>Private Function EscapeCsv(ByVal s As String) As String</code>.<br><strong>Tests:</strong> Strings containing quotes. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IsProcedureAvailable( procName ) -> Boolean</strong><br><strong>Purpose:</strong> Best-effort detection whether an external procedure is callable via <code>Application.Run</code> without throwing fatal errors (used to detect external log/handler procedures).<br><strong>Signature:</strong> <code>Private Function IsProcedureAvailable(ByVal procName As String) As Boolean</code>.<br><strong>Behavior:</strong> Attempts <code>Application.Run procName</code>; inspects <code>Err.Number</code> to infer availability; clears errors and returns boolean.<br><strong>Complexity:</strong> O(1) but may have side-effects if called procedure executes; used only for detection of benign helper procs. <strong>Caution:</strong> If <code>procName</code> exists and has side-effects, running it here will execute it — this helper assumes detection entrypoints are side-effect free. <br><strong>Tests:</strong> Detect known available/unavailable procedure names in environment. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Logging & error helpers (SafeLog, SafeHandleError, AppendLocalAudit, SheetExists)</strong><br><strong>Purpose:</strong> Robust forwarding to central logging/error handler (<code>Application.Run &quot;LogAudit&quot;</code> / <code>&quot;HandleError&quot;</code>) with fallback to local append to hidden <code>_IFRS_Audit</code> sheet when calls fail. <code>SheetExists</code> used to detect/create hidden audit/test sheets.<br><strong>Signatures:</strong> <code>Private Sub SafeLog(moduleName, proc, details)</code>, <code>Private Sub SafeHandleError(procName, errNumber, errDesc)</code>, <code>Private Sub AppendLocalAudit(message)</code>, <code>Private Function SheetExists(name) As Boolean</code>.<br><strong>Behavior:</strong> Try remote logging via <code>Application.Run</code>; on failure write to workbook hidden audit sheet (creates it if missing) with timestamp, Application.UserName and truncated message. <code>SafeHandleError</code> attempts remote <code>HandleError</code> then appends fallback audit. AppendLocalAudit creates <code>_IFRS_Audit</code> (very hidden) if absent. All functions use <code>On Error Resume Next</code> to avoid cascading failures.<br><strong>Complexity:</strong> Dependent on sheet operations (O(1) for append).<br><strong>Side-effects:</strong> Writes to hidden sheets (audit/test), calls <code>Application.Run</code> which may call external add-in handlers. Designed robustly to avoid throwing.<br><strong>Security/Privacy:</strong> Audit sheet stores messages and <code>Application.UserName</code> — avoid storing sensitive data; code truncates messages to 2000 chars. <br><strong>Tests:</strong> Simulate missing <code>LogAudit</code>/<code>HandleError</code> procedures and verify <code>_IFRS_Audit</code> created and entries appended. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeRound(value, places) -> Double & GetRoundingPrecision()</strong><br><strong>Purpose:</strong> Centralised rounding with Excel worksheet ROUND fallback and config-driven precision via <code>GetConfigDouble(&quot;roundingPrecision&quot;)</code> default 2.<br><strong>Behavior:</strong> Calls <code>Application.WorksheetFunction.Round</code>; on error uses VBA <code>Round</code> fallback. <code>GetRoundingPrecision()</code> returns configured rounding precision or 2 by default. <br><strong>Complexity:</strong> O(1).<br><strong>Invariants:</strong> All monetary rounding uses this helper to maintain consistent rounding policy across module.<br><strong>Tests:</strong> Ensure SafeRound performs expected decimal rounding under different <code>roundingPrecision</code> config values. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetConfigDouble / GetConfigString</strong><br><strong>Purpose:</strong> Resilient access to global configuration via multiple possible host functions: <code>modConfig_Get</code>, <code>Config_Get</code>, <code>GetConfigValue</code>. Silent fallback to supplied default if none available.<br><strong>Behavior:</strong> Tries <code>Application.Run</code> for each candidate function name in order, returns numeric/string default on failure. Uses <code>On Error Resume Next</code> to be non-fatal. <br><strong>Complexity:</strong> O(1) per call but calls <code>Application.Run</code> which may have cost. <br><strong>Security:</strong> Avoid returning untrusted remote values without validation; calling code should sanitize as necessary. <br><strong>Tests:</strong> With/without <code>modConfig_Get</code> present; non-numeric config values. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AddJudgment( analysis, subjectPOID, issue, amount )</strong><br><strong>Purpose:</strong> Append PII-light judgment entries into <code>analysis(&quot;JudgmentsApplied&quot;)</code> Collection for audit/disclosure of model decisions (coercions, reserve choices, residual absorptions).<br><strong>Signature:</strong> <code>Private Sub AddJudgment(ByVal analysis As Object, ByVal subjectPOID As String, ByVal issue As String, ByVal amount As Double)</code><br><strong>Behavior:</strong> Ensures <code>JudgmentsApplied</code> exists (creates collection), builds a <code>Scripting.Dictionary</code> entry with <code>Timestamp</code>, <code>POID</code>, <code>Issue</code>, <code>Amount</code> (rounded), appends to collection and calls <code>SafeLog</code> with compact message. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>analysis</code> and calls <code>SafeLog</code>. <br><strong>Privacy:</strong> Entries intentionally lightweight; avoid adding sensitive long text to <code>Issue</code>. <br><strong>Tests:</strong> Ensure judgements accumulate and show in disclosures. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AppendTestResults(summary, notes)</strong><br><strong>Purpose:</strong> Write self-test summary and concatenated notes to hidden <code>_IFRS_TestResults</code> sheet for CI and manual inspection.<br><strong>Behavior:</strong> Create sheet if missing (very hidden), append row with timestamp, summary, and notes concatenated; truncates notes to 2000 chars. <br><strong>Side-effects:</strong> Writes to workbook (very hidden sheet). <br><strong>Tests:</strong> Run <code>IFRS15SelfTest</code> and inspect <code>_IFRS_TestResults</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AddLocalIssueAudit(keyOrMsg, Optional details)</strong><br><strong>Purpose:</strong> Convenience wrapper that writes local audit messages for unexpected but non-fatal issues without raising errors. Uses <code>AppendLocalAudit</code> internally.<br><strong>Behavior:</strong> Forms single-line message and appends to local audit. <br><strong>Tests:</strong> Ensure message appears in <code>_IFRS_Audit</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Maintenance, testing & operational recommendations</strong><br>- <strong>Determinism:</strong> Preserve <code>SafeRound</code>/<code>GetRoundingPrecision</code> behaviour; changing roundingPrecision or residual tie-breaker changes allocation results and is auditable — add migration note and regression tests.<br>- <strong>Config integration:</strong> Prefer a single <code>modConfig_Get</code> surface; current multi-try approach is defensive but complicates runtime tracing. Consider adding a single accessor wrapper in <code>modConfig</code> to reduce duplication.<br>- <strong>Audit trail:</strong> Judgments and AppendLocalAudit produce audit trails, but consider writing a compact JSON manifest or manifest sheet summarising inputs, config used, roundingPrecision and variableConstraintThreshold for each processed contract to speed audits and CI regression checks.<br>- <strong>Self-tests in CI:</strong> <code>IFRS15SelfTest</code> writes to workbook; in automated CI prefer a headless test harness that inspects returned booleans and avoids mutating production workbook. Consider adding a <code>IFRS15RunTestsToObject()</code> that returns structured results (no sheet writes) for CI assertion.<br>- <strong>Edge cases:</strong> Large numbers, extreme scenario probabilities, and binary/malformed <code>VariableConsideration</code> shapes should be covered by unit tests; ensure expectedVal computations are resilient to NaN/Null and that probabilities sum to <=1 (current code does not assert sum to 1 — consider adding validation and a judgment when sums deviate).<br>- <strong>Logging & privacy:</strong> Audit entries include <code>Application.UserName</code>; ensure this is acceptable in your privacy model. Avoid recording raw contract text in audit entries. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Recommended unit/integration test list (concise)</strong><br>1. Token-level: <code>IFRS15_AnalyzeContract</code> handles missing/extra fields and negative coercions.<br>2. Allocation parity: allocations + reserve rounded equals transaction price across permutations (TotalStandalone=0, >0, zero txPrice).<br>3. VariableConsideration forms: scalar, object-mostLikely, scenarios-array; threshold boundary cases (exactly threshold * txPrice).<br>4. Rounding residuals: deterministic absorption into largest standalone price (test ties by index).<br>5. Schedule correctness: time-based residual placed in final period; point-in-time uses DeliveryDate or fallback to startDate with judgment.<br>6. Journals: account fallback to config and correct narrative composition.<br>7. Batch processing: mixture of valid/invalid contracts; ensure per-contract isolation and correct result dictionary keys.<br>8. Self-test idempotence: <code>IFRS15SelfTest</code> returns boolean and appends to <code>_IFRS_TestResults</code> without corrupting workbook structure on repeated runs.<br>9. Logging fallback: simulate missing <code>LogAudit/HandleError</code> and confirm <code>_IFRS_Audit</code> created and populated. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Security & data handling notes</strong><br>- Module avoids <code>Eval</code>/<code>Execute</code> constructs; uses only safe data coercion and explicit dictionary creation.<br>- Audit sheets contain <code>Application.UserName</code> and message snippets — treat workbook access control accordingly. Consider marking audit/test sheets as very hidden (already done) and clear them in CI between runs.<br>- Captured judgments are intentionally non-PII-heavy; avoid adding full customer names, addresses, or raw contract blobs into audit messages. If required, add redaction logic. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Final summary (one paragraph)</strong><br><code>modIFRS15</code> is a compact, defensive, and deterministic VBA implementation of the IFRS 15 contract model: it normalises inputs, evaluates variable consideration with deterministic rules, allocates transaction price with reproducible rounding & residual handling, produces recognition schedules and journal rows, and provides disclosure extraction plus an embedded test harness. It favors auditability (judgments, local audit sheet), backward compatibility (preserve pre-existing allocations), and resilience to missing host functions (best-effort <code>GetConfig*</code>, <code>SafeLog</code>/<code>SafeHandleError</code>). Key maintenance risks are changes to rounding policy, residual absorption rules, and the variable-consideration interpretation — each must be accompanied by regression tests and audit traceability. </td></tr></tbody></table></div><div class="row-count">Rows: 26</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>