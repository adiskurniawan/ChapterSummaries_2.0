<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771304645">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0159_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modAudit)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modAudit)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modAudit)"> <strong>Overview:</strong> This module implements an append-only, tamper-evident audit system for an Excel Add-in. Key features: buffered writes with batch flush, atomic bulk writes, chained-entry integrity using SHA256 (system command) with CRC32 fallback, optional external hash-provider macro, rotation/export, soft PII redaction, a metadata sheet for operational state, guarded command execution, and diagnostic/verification utilities. Public API preserved: <code>InitAuditModule</code>, <code>ShutdownAuditModule</code>, <code>LogAudit</code>, <code>AppendAuditEntry</code>, <code>AppendAuditBuffered</code>, <code>FlushAuditBuffer</code>, <code>RotateAuditNow</code>, <code>ExportAuditToCSV</code>, <code>ExportAuditToJSON</code>, <code>VerifyAuditChain</code>, <code>GenerateAuditDiagnosticReport</code>, <code>FindAuditByCorrelationID</code>, <code>ReadAuditRow</code>, <code>CreateAuditSheetIfMissing</code>, <code>SetAuditFeatureFlag</code>, <code>GetAuditFeatureFlag</code>. The module is defensive: guarded CreateObject usage, many On Error Resume Next fallbacks, and non-throwing public helpers. Use this table as authoritative inline documentation for reviewers, auditors and QA. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>Constants & Module State</strong> — <em>configuration & runtime flags</em><br><strong>Purpose:</strong> Centralize runtime defaults and mutable module state.<br><strong>Signature:</strong> N/A (module-level <code>Private Const</code> + module-level <code>Private</code>/<code>Public</code> variables)<br><strong>Behavior:</strong> Declares sheet names, thresholds (<code>AUDIT_MAX_ROWS_BEFORE_ROTATE</code>, <code>AUDIT_BATCH_FLUSH_THRESHOLD</code>), runtime booleans (<code>g_enableMetaSheet</code>, <code>g_aggressiveRedaction</code>, <code>g_allowExternalHashProvider</code>, <code>g_allowCommandExecution</code>), buffers and counters. <code>HashProviderMacroName</code> is public for opt-in macro provider.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Controls flow/behavior across module. Changing flags mutates runtime behavior immediately.<br><strong>Invariants:</strong> Defaults set in <code>InitAuditModule</code>; <code>g_auditInitialized</code> indicates readiness.<br><strong>Failure modes:</strong> Uninitialized state if <code>InitAuditModule</code> never called; inconsistent flags if mutated concurrently by other code (VBA single-threaded but careful with re-entrancy).<br><strong>Tests:</strong> Verify default values after <code>InitAuditModule</code>, toggling flags affects hashing/command attempts. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>InitAuditModule()</strong> — <em>module initializer</em><br><strong>Purpose:</strong> Prepare runtime state, create meta sheet (optional), seed initial buffer entry.<br><strong>Signature:</strong> <code>Public Sub InitAuditModule()</code><br><strong>Behavior:</strong> Idempotent init: sets feature flags, creates <code>g_auditBuffer</code> collection, lifecycle counters, creates meta sheet if enabled (<code>CreateAuditMetaSheetIfMissing</code>), marks <code>g_auditInitialized = True</code>, adds <code>AuditInit</code> marker entry to buffer using <code>AddToBufferNoFlush Entry_Row(...)</code>.<br><strong>Complexity:</strong> O(1) aside from sheet creation O(#sheets).<br><strong>Side-effects:</strong> May create a hidden worksheet, populates in-memory collections.<br><strong>Invariants:</strong> After success <code>g_auditInitialized = True</code> and buffer exists.<br><strong>Failure modes:</strong> Silent failures handled via On Error Resume Next; may leave partial state if sheet creation fails. <br><strong>Tests:</strong> Call twice and assert idempotence; meta sheet created/visible very hidden; buffer contains AuditInit. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ShutdownAuditModule()</strong> — <em>clean shutdown & flush</em><br><strong>Purpose:</strong> Graceful shutdown: append shutdown entry, flush buffer, clear state, update meta sheet.<br><strong>Signature:</strong> <code>Public Sub ShutdownAuditModule()</code><br><strong>Behavior:</strong> Adds <code>AuditShutdown</code> to buffer, calls <code>FlushAuditBuffer</code>, nils collections and resets flags, updates meta sheet via <code>UpdateAuditMetaSheet</code>.<br><strong>Complexity:</strong> O(n) for flush (writes); O(1) otherwise.<br><strong>Side-effects:</strong> Writes to audit sheet, may rotate if threshold exceeded. Releases memory references.<br><strong>Invariants:</strong> After call buffer empty and <code>g_auditInitialized = False</code> (unless errors prevented flush).<br><strong>Failure modes:</strong> Flush failures produce fallback AppendAuditEntry attempts (line-by-line) and buffer clearing.<br><strong>Tests:</strong> Ensure buffer flushed, meta sheet updated, subsequent calls safe. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>SetAuditFeatureFlag(flagName, flagValue)</strong> — <em>runtime flag toggles</em><br><strong>Purpose:</strong> Toggle named feature flags at runtime and persist unknown flags into meta-sheet for operators.<br><strong>Signature:</strong> <code>Public Sub SetAuditFeatureFlag(ByVal flagName As String, ByVal flagValue As Boolean)</code><br><strong>Behavior:</strong> Lowercase flag dispatch for known flags (<code>enableMetaSheet</code>, <code>aggressiveRedaction</code>, <code>allowExternalHashProvider</code>, <code>allowCommandExecution</code>). Unknown flags are appended to meta sheet rows for operator awareness. Calls <code>UpdateAuditMetaSheet</code> at end. If <code>enableMetaSheet</code> becomes True, creates meta sheet.<br><strong>Complexity:</strong> O(1) plus O(#meta rows) when writing.<br><strong>Side-effects:</strong> Mutates module-level flags and meta sheet content.<br><strong>Invariants:</strong> Meta sheet reflects last-set values when enabled.<br><strong>Failure modes:</strong> If meta sheet protected, flag persists only in memory; code tries to record <code>MetaSheetProtected</code> event.<br><strong>Tests:</strong> Toggle each flag and verify effect (e.g., <code>g_allowCommandExecution</code> prevents <code>ComputeSHA256_System</code> from running). </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>GetAuditFeatureFlag(flagName)</strong> — <em>readback</em><br><strong>Purpose:</strong> Return current runtime value of a known feature flag.<br><strong>Signature:</strong> <code>Public Function GetAuditFeatureFlag(ByVal flagName As String) As Variant</code><br><strong>Behavior:</strong> Switch on flag name and returns boolean or Empty for unknown flags.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> Validate matches <code>SetAuditFeatureFlag</code> state. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>LogAudit(action, details)</strong> — <em>backwards-compatible convenience logger</em><br><strong>Purpose:</strong> Simple helper for high-level callers to log action/details to audit in an asynchronous-safe, buffered way.<br><strong>Signature:</strong> <code>Public Sub LogAudit(ByVal action As String, ByVal details As String)</code><br><strong>Behavior:</strong> Ensures module initialized, creates a new correlation ID, calls <code>AppendAuditBuffered Entry_Row(...)</code>. Error handler drops down to synchronous <code>AppendAuditEntry</code> fallback on failure to avoid data loss.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Adds buffer entry; may synchronously write on fallback.<br><strong>Invariants:</strong> Always attempts to record at least one trace of the logging attempt.<br><strong>Failure modes:</strong> If buffer append fails, fallback writes minimally. Silent error swallowing but fallback attempts reduce silent loss.<br><strong>Tests:</strong> Trigger normal path and error path (simulate buffer failure) and assert at least one audit row present. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>CreateAuditSheetIfMissing()</strong> — <em>ensure audit worksheet exists</em><br><strong>Purpose:</strong> Create <code>_IFRS_Audit</code> sheet with canonical header row if missing and return its Worksheet object.<br><strong>Signature:</strong> <code>Public Function CreateAuditSheetIfMissing() As Worksheet</code><br><strong>Behavior:</strong> Scans <code>ThisWorkbook.Worksheets</code> for <code>AUDIT_SHEET_NAME</code>; if not found adds worksheet after last sheet, sets header columns (TimestampUTC, CorrelationID, Module, Procedure, Severity, ErrNum, WindowsUser, ExcelUser, Action, ContextJSON, PrevHash, Hash), bolds header, hides sheet (VeryHidden). Returns <code>Nothing</code> on irrecoverable errors.<br><strong>Complexity:</strong> O(#worksheets).<br><strong>Side-effects:</strong> May create a worksheet and set its name/headers; sets visibility to very hidden.<br><strong>Invariants:</strong> Header row layout fixed; code expects exact column order elsewhere.<br><strong>Failure modes:</strong> If workbook locked or protected, sheet creation may fail and function returns Nothing. Calling code must handle Nothing.<br><strong>Tests:</strong> Remove sheet then call; verify header row exactly matches expected columns and very hidden. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>BuildCanonicalRow(prevHash, timestampUTC, correlationId, moduleName, procName, severity, errNum, winUser, xlUser, action, contextJson)</strong> — <em>canonical row serializer</em><br><strong>Purpose:</strong> Produce canonical pipe-delimited row string used for hashing and verification.<br><strong>Signature:</strong> <code>Private Function BuildCanonicalRow(... ) As String</code><br><strong>Behavior:</strong> Concatenates fields in fixed order separated by <code>|</code>. This string is the canonical input to hashing and chain verification.<br><strong>Complexity:</strong> O(total length of inputs).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Order & separator must remain stable — changing format breaks verification and must be treated as breaking change.<br><strong>Tests:</strong> Given fixed inputs, output equals expected canonical string; used end-to-end in <code>VerifyAuditChain</code>. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>AppendAuditEntry(action, details, moduleName, procName, severity, errNum, correlationId, contextJson)</strong> — <em>synchronous single-row append</em><br><strong>Purpose:</strong> Immediately write one canonical audit row to the audit sheet (used for critical fallback or immediate logging needs).<br><strong>Signature:</strong> <code>Public Sub AppendAuditEntry(ByVal action As String, ByVal details As String, Optional ByVal moduleName As String = &quot;&quot;, Optional ByVal procName As String = &quot;&quot;, Optional ByVal severity As String = &quot;Info&quot;, Optional ByVal errNum As Long = 0, Optional ByVal correlationId As String = &quot;&quot;, Optional ByVal contextJson As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Defensive: ensures sheet exists, trims/normalizes parameters, redacts context via <code>RedactSensitiveData</code>, truncates context if > <code>MAX_CONTEXT_LENGTH</code> (and writes a ContextTruncated buffer entry). Computes <code>prevHash</code> via <code>GetLastAuditHash(ws)</code>, builds canonical row string, computes entry hash via <code>ComputeEntryHash(prevHash, concatenated fields)</code>. Temporarily disables <code>Application.EnableEvents</code>, <code>ScreenUpdating</code>, sets <code>Application.Calculation</code> to manual, writes row values to nextRow columns, restores application state. If row count exceeds rotate threshold, schedules <code>RotateAuditNow</code>. If errors during write, falls back to <code>ErrHandler2</code> which writes a minimal fallback row containing failure information.<br><strong>Complexity:</strong> O(1) for single write; hash computation may be O(len(payload)).<br><strong>Side-effects:</strong> Writes to workbook; updates <code>PrevHash</code>/<code>Hash</code> cells. May call external command for SHA256 depending on flags.<br><strong>Invariants:</strong> Row columns match <code>CreateAuditSheetIfMissing</code> header order. Must be atomic relative to callers; module uses <code>Application</code> state changes to reduce side-effects but not real transactions — partial failure handled by fallback writes.<br><strong>Failure modes:</strong> Protected workbook, disk errors, or failure computing hash cause fallback to write minimal info. If <code>Application</code> state not fully restored due to unexpected error, subsequent Excel behavior could be affected (code attempts restore in error handler).<br><strong>Security:</strong> Context is redacted before write; when <code>g_aggressiveRedaction=True</code> additional redaction applies. Hash provider choices may call external processes — controlled by <code>g_allowCommandExecution</code> and <code>g_allowExternalHashProvider</code>.<br><strong>Tests:</strong> Normal append produces valid <code>Hash</code> and <code>PrevHash</code> chain; adjust <code>g_allowCommandExecution</code> to test SHA256 path vs CRC32 fallback; simulate write error (protect sheet) to validate fallback. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>EnsureBuffer()</strong> — <em>buffer collection initializer</em><br><strong>Purpose:</strong> Lazy-initialize in-memory <code>g_auditBuffer</code> collection.<br><strong>Signature:</strong> <code>Private Sub EnsureBuffer()</code><br><strong>Behavior:</strong> If <code>g_auditBuffer</code> is Nothing, creates New Collection.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Allocates Collection.<br><strong>Tests:</strong> Nil buffer then call and assert non-Nothing. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>AddToBufferNoFlush(entry)</strong> — <em>append an entry into buffer without flushing</em><br><strong>Purpose:</strong> Append validated entry to <code>g_auditBuffer</code> and optionally update meta sheet. Used internally to stage entries.<br><strong>Signature:</strong> <code>Private Sub AddToBufferNoFlush(entry As Variant)</code><br><strong>Behavior:</strong> Calls <code>EnsureBuffer</code>, <code>g_auditBuffer.Add entry</code>. If meta sheet enabled, calls <code>UpdateAuditMetaSheet</code> to reflect new buffered count. Errors swallowed (On Error Resume Next) to avoid disrupting caller flows.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates buffer collection and meta sheet.<br><strong>Failure modes:</strong> If adding fails, upstream code uses fallbacks. Silent errors are recorded via extra entries when possible. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>Entry_Row(action, details, corrId)</strong> — <em>lightweight buffer row factory</em><br><strong>Purpose:</strong> Produce standard 10-element Variant array representing a buffered entry (fields: TimestampUTC, CorrelationID, Module, Procedure, Severity, ErrNum, WindowsUser, ExcelUser, Action, ContextJSON) with safe redaction/truncation applied.<br><strong>Signature:</strong> <code>Private Function Entry_Row(ByVal action As String, ByVal details As String, ByVal corrId As String) As Variant</code><br><strong>Behavior:</strong> Populates timestamp via <code>GetUtcIsoTimestamp</code>, uses <code>RedactSensitiveData</code> for details/context, enforces <code>MAX_CONTEXT_LENGTH</code> truncation with appended <code>...[TRUNCATED]</code>, emits <code>RedactionApplied</code> entry if redaction changed original. Returns a 1-based array (1 To 10).<br><strong>Complexity:</strong> O(len(details)).<br><strong>Side-effects:</strong> May call <code>AddToBufferNoFlush</code> recursively to record redaction metadata (so minimal recursion but safe because <code>Entry_Row</code> uses <code>AddToBufferNoFlush</code> which doesn't flush).<br><strong>Invariants:</strong> Returned array fits <code>ValidateBufferEntry</code> criteria.<br><strong>Tests:</strong> Long input truncated; sensitive patterns replaced; <code>RedactionApplied</code> produced when needed. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ValidateBufferEntry(entry)</strong> — <em>buffer entry validator</em><br><strong>Purpose:</strong> Ensure array shape and minimal fields before appending to buffer or flushing.<br><strong>Signature:</strong> <code>Private Function ValidateBufferEntry(entry As Variant) As Boolean</code><br><strong>Behavior:</strong> Returns False if not an array, or UBound < 10, or missing timestamp/corrid; otherwise True.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Provide malformed arrays and ensure false, provide valid entry and ensure true. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>AppendAuditBuffered(entry)</strong> — <em>public buffered append</em><br><strong>Purpose:</strong> Public API that accepts either a pre-built buffer entry or a simple string; validates/coerces, appends to <code>g_auditBuffer</code>, and triggers <code>FlushAuditBuffer</code> when threshold reached (unless locked by <code>g_batchWriteLock</code>).<br><strong>Signature:</strong> <code>Public Sub AppendAuditBuffered(entry As Variant)</code><br><strong>Behavior:</strong> Ensures module initialized, coerces string entries into <code>Entry_Row(action, &quot;&quot;, NewCorrelationId())</code>, appends to buffer, updates meta sheet. If buffer length >= <code>AUDIT_BATCH_FLUSH_THRESHOLD</code> and not <code>g_batchWriteLock</code>, calls <code>FlushAuditBuffer</code>. Errors trigger per-entry synchronous <code>AppendAuditEntry</code> fallback attempts for each buffered entry.<br><strong>Complexity:</strong> O(1) amortized; flush path O(n) for bulk write.<br><strong>Side-effects:</strong> Mutates buffer; may cause disk I/O via <code>FlushAuditBuffer</code>.<br><strong>Invariants:</strong> Buffer grows until flush threshold, flush resets buffer to an empty collection.<br><strong>Failure modes:</strong> Bulk write failure handled by <code>BulkWriteErr</code> fallback writing each buffered entry synchronously and recording <code>FlushFallback</code> entry. Retains operational state and meta updates.<br><strong>Tests:</strong> Fill buffer to threshold, assert flush occurs and meta sheet updated; simulate BulkWriteErr by protecting sheet to exercise fallback. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>FlushAuditBuffer()</strong> — <em>bulk, atomic-ish flush of buffer to sheet</em><br><strong>Purpose:</strong> Efficiently write buffered entries in one multi-row <code>Range.Value</code> operation to reduce per-row overhead and Excel events. Compute per-row chained hashes using <code>ComputeEntryHash</code> iterating <code>prevHash</code> across buffer rows.<br><strong>Signature:</strong> <code>Public Sub FlushAuditBuffer()</code><br><strong>Behavior (detailed):</strong> Guards on <code>g_auditBuffer</code> emptiness and <code>g_batchWriteLock</code>; sets <code>g_batchWriteLock = True</code>. Adds a <code>FlushStart</code> buffer marker. Prepares <code>outArr</code> sized to buffer count × 12 columns; computes each row's canonical string and entry hash based on <code>prevHash = GetLastAuditHash(ws)</code> for the first row then chaining for subsequent rows. Performs a single <code>ws.Cells(startRow,1).Resize(n,12).Value = outArr</code> write while disabling <code>ScreenUpdating</code>, <code>EnableEvents</code>, and setting Calculation manual. On success adds <code>FlushFinish</code> marker entry and empties buffer (new Collection). On bulk write error, falls back to writing each buffered entry via <code>AppendAuditEntry</code> in loop and records <code>FlushFallback</code>. Always resets <code>g_batchWriteLock</code> in cleanup.<br><strong>Complexity:</strong> O(n * cost_of_hash) where cost_of_hash depends on <code>ComputeEntryHash</code> path (system command, macro, or CRC32). Bulk write reduces Excel overhead vs per-row writes. <br><strong>Side-effects:</strong> Writes multiple rows to workbook; may trigger rotation; updates meta sheet. May call out to external hashing utilities per row.<br><strong>Invariants:</strong> After a successful flush, buffer empty and meta sheet shows 0 buffered count. <code>PrevHash</code> chain updated consistently for appended rows.<br><strong>Failure modes:</strong> Bulk write failure (disk/full/protection) triggers per-row fallback; hashing failures silently fall back to CRC32; excessive time due to external commands may cause application sluggishness; module aims to minimize visible UI impact by disabling screen updates and calc but cannot fully guarantee atomicity across Excel restarts.<br><strong>Security:</strong> Contexts redacted before being written; Command execution for SHA256 guarded by <code>g_allowCommandExecution</code>.<br><strong>Tests:</strong> Flush with various buffer sizes; simulate <code>ComputeSHA256_System</code> success/failure; simulate write error (protect sheet) and assert fallback loop wrote rows individually; concurrency safety tests (open/close cycles). </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>RotateAuditNow()</strong> — <em>archive & truncate audit sheet</em><br><strong>Purpose:</strong> Archive current audit sheet rows (except header) to a CSV file in configured <code>AUDIT_ARCHIVE_FOLDER</code> (or TEMP/Workbook path fallback) and then delete archived rows from sheet to reclaim space and cap sheet size.<br><strong>Signature:</strong> <code>Public Sub RotateAuditNow()</code><br><strong>Behavior:</strong> Computes target folder (AUDIT_ARCHIVE_FOLDER or environment fallbacks). Ensures folder exists via <code>Scripting.FileSystemObject</code> if available, creates a temporary workbook, copies <code>ws.UsedRange</code> to temp workbook, saves as CSV to <code>fname</code> (timestamped via <code>UtcNowForFilename</code>), closes temp workbook, deletes rows 2:lastRow from main audit sheet. On save error attempts fallback to TEMP path and records <code>RotateFallback</code>. Emits <code>RotateStart</code> and <code>RotateFinish</code> buffer entries. Errors recorded via <code>AuditRotateError</code> buffer entry.<br><strong>Complexity:</strong> O(rows archived); file I/O heavy for large archives.<br><strong>Side-effects:</strong> Creates CSV file on disk; removes rows from workbook; may change workbook size/performance.<br><strong>Invariants:</strong> After successful rotate the main sheet contains only header row and <code>PrevHash</code> chain starts fresh (note: chain continuity intentionally broken by rotation; module archives include full rows so offline verification still possible).<br><strong>Failure modes:</strong> Save failures cause fallback attempts; if saving fails entirely rotation is aborted and error recorded. If disk full or permission errors occur, archive may fail. <br><strong>Tests:</strong> Archive with small & large row counts; simulate save failure by writing to protected folder to trigger fallback. Verify CSV contents equals pre-rotate data. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ExportAuditToCSV(fullPath)</strong> — <em>export current audit to CSV file</em><br><strong>Purpose:</strong> Export <code>UsedRange</code> of audit sheet to specified CSV path, returning boolean success.<br><strong>Signature:</strong> <code>Public Function ExportAuditToCSV(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong> Copies <code>ws.UsedRange</code> to a temp workbook, saves as CSV to <code>fullPath</code> (ensuring folder exists where possible). On error logs <code>ExportAuditError</code> into buffer and returns False. On success returns True.<br><strong>Complexity:</strong> O(#rows) file I/O.<br><strong>Side-effects:</strong> Writes file to disk.<br><strong>Tests:</strong> Export to writable path & to unwritable path (assert False + buffer entry). </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ExportAuditToJSON(fullPath)</strong> — <em>export audit to JSON file (UTF-8)</em><br><strong>Purpose:</strong> Serialize audit rows (header -> keys) to a JSON array and write as UTF-8 file.<br><strong>Signature:</strong> <code>Public Function ExportAuditToJSON(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong> Reads <code>UsedRange.Value</code> into variant array, constructs JSON by iterating rows and columns (first row used as keys), escapes JSON via <code>EscapeJson</code>, writes UTF-8 bytes using <code>StrToUtf8Bytes</code> and Binary file write. Logs <code>ExportAuditError</code> on failure and returns False; True on success.<br><strong>Complexity:</strong> O(rows×cols) string assembly and memory for JSON; careful with very large audits (memory may spike).<br><strong>Side-effects:</strong> Writes file to disk. JSON produced contains every cell string-escaped and quoted.<br><strong>Failure modes:</strong> Large data causing memory/timeouts; missing headers produce odd JSON but code uses first row as headers. <br><strong>Tests:</strong> Small & moderate-size exports; UTF-8 correctness (non-ASCII characters preserved). </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>VerifyAuditChain(Optional ByRef firstBadRow, Optional ByRef diagnosticCode) As Boolean</strong> — <em>chain verification</em><br><strong>Purpose:</strong> Walk the audit table sequentially verifying that each row's <code>PrevHash</code> matches running previous hash and that stored <code>Hash</code> equals <code>ComputeEntryHash(prevHash, rowData)</code>. Returns True if chain intact, otherwise False and sets <code>firstBadRow</code> and <code>diagnosticCode</code> (1=MissingPrevHash, 2=HashMismatch, 3=Malformed/Other).<br><strong>Signature:</strong> <code>Public Function VerifyAuditChain(Optional ByRef firstBadRow As Long, Optional ByRef diagnosticCode As Long) As Boolean</code><br><strong>Behavior:</strong> Loads <code>UsedRange.Value</code> to memory array for speed, iterates rows from 2..N, reconstructs <code>rowData</code> (same canonical order as BuildCanonicalRow minus prevHash field), compares expected prevHash with stored PrevHash cell; computes expectedHash via <code>ComputeEntryHash(prevHash, rowData)</code> and compares to stored hash. Halts on first mismatch returning details. On unexpected exceptions returns False with diagnosticCode 3.<br><strong>Complexity:</strong> O(rows * cost_of_hash). Because <code>ComputeEntryHash</code> may call external command per row, verify can be expensive for large sheets; flags controlling hash provider influence runtime cost. <br><strong>Side-effects:</strong> None (read-only).<br><strong>Invariants:</strong> Must use same canonical string format as used when entries written. Changing <code>ComputeEntryHash</code> algorithm will affect verification results historically.<br><strong>Failure modes:</strong> If stored <code>Hash</code> was computed with different provider/schema the compare may fail (diagnosticCode=2). If rotation broke chain intentionally, verification from archived CSV would be needed. <br><strong>Tests:</strong> Known-good chain passes; deliberately corrupt one row's Hash and assert function returns that row/diagnostic. Simulate provider mismatch (force CRC32 vs SHA256). </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>GenerateAuditDiagnosticReport(outputCsvPath, Optional startRow=2)</strong> — <em>detailed diagnostic export</em><br><strong>Purpose:</strong> Produce a row-by-row report CSV listing expected vs actual prev/hash and reason (OK, MissingPrev, HashMismatch) to aid offline investigation.<br><strong>Signature:</strong> <code>Public Function GenerateAuditDiagnosticReport(ByVal outputCsvPath As String, Optional ByVal startRow As Long = 2) As Boolean</code><br><strong>Behavior:</strong> Iterates audit rows from <code>startRow</code> to last row, computes expected hash chain using <code>ComputeEntryHash</code> and writes CSV lines: Row, ExpectedPrev, ActualPrev, ExpectedHash, ActualHash, Reason. Returns True on success; logs and returns False on errors. Writes as UTF-8 via <code>Put #fnum</code> with <code>StrToUtf8Bytes</code> usage.<br><strong>Complexity:</strong> O(rows * cost_of_hash); heavy for large datasets. <br><strong>Side-effects:</strong> Writes diagnostic CSV to disk. <br><strong>Tests:</strong> Generate report on healthy and tampered chains; confirm CSV correctness and reason categories. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>FindAuditByCorrelationID(corrId) As Long</strong> — <em>correlation lookup</em><br><strong>Purpose:</strong> Quick find first row number with given CorrelationID using <code>Range.Find</code> on column B.<br><strong>Signature:</strong> <code>Public Function FindAuditByCorrelationID(ByVal corrId As String) As Long</code><br><strong>Behavior:</strong> Uses <code>ws.Range(&quot;B:B&quot;).Find</code> with <code>LookAt:=xlWhole</code>. Returns <code>rng.Row</code> or 0 for not found or on error. Fast for single lookups but not optimized for many queries — consider building in-memory index elsewhere for bulk queries.<br><strong>Complexity:</strong> Excel search implemented internally; effectively O(#rows) but optimized in Excel. <br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> Add known row with corrId and assert returned row matches. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ReadAuditRow(sheetRow) As Object</strong> — <em>row reader -> dictionary</em><br><strong>Purpose:</strong> Return a dictionary-like object mapping column names to values for a given sheet row, or Nothing on error/invalid row.<br><strong>Signature:</strong> <code>Public Function ReadAuditRow(ByVal sheetRow As Long) As Object</code><br><strong>Behavior:</strong> Validates row range, creates <code>Scripting.Dictionary</code> (via <code>CreateObjectSafe</code>), populates keys: TimestampUTC, CorrelationID, Module, Procedure, Severity, ErrNum, WindowsUser, ExcelUser, Action, ContextJSON, PrevHash, Hash. Returns dictionary or Nothing on errors. Defensive: uses <code>NzValue</code> on cell values.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> Read known row and verify key/value types. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>GetLastAuditHash(ws) As String</strong> — <em>fetch last hash value</em><br><strong>Purpose:</strong> Return the last stored <code>Hash</code> value from the audit sheet for chaining new entries.<br><strong>Signature:</strong> <code>Private Function GetLastAuditHash(ws As Worksheet) As String</code><br><strong>Behavior:</strong> If <code>ws</code> missing uses <code>CreateAuditSheetIfMissing()</code>. Reads bottom-most used row's column 12; returns empty string if no rows. Silent on error.<br><strong>Complexity:</strong> O(1) cell read. <br><strong>Tests:</strong> Append rows then assert returned hash equals last row's Hash. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ComputeEntryHash(prevHash, rowData) As String</strong> — <em>primary hash chooser & provider dispatcher</em><br><strong>Purpose:</strong> Compute tamper-evident digest for an entry combining previous hash and canonical row data. Tries macro provider -> system SHA256 -> CRC32 fallback. Records provider usage stats.<br><strong>Signature:</strong> <code>Private Function ComputeEntryHash(ByVal prevHash As String, ByVal rowData As String) As String</code><br><strong>Behavior (policy & dispatch):</strong> Concatenates <code>payload = prevHash &amp; &quot;|&quot; &amp; rowData</code>. If <code>g_allowExternalHashProvider</code> and <code>HashProviderMacroName</code> set, attempts <code>Application.Run(HashProviderMacroName, payload)</code>. If that yields non-empty result, sets provider metadata and returns that string. Else, if <code>g_allowCommandExecution</code>, tries <code>ComputeSHA256_System(payload)</code> which writes payload to a temp file and invokes platform-specific commands (<code>certutil</code> on Windows, <code>shasum</code> or <code>openssl</code> on macOS/Linux) to compute SHA256. If successful and returns hex hash, record provider metadata and return uppercase 64-hex string. Otherwise compute <code>ComputeCRC32String(payload)</code> as fallback and record provider as "CRC32". Always increments provider counts and emits <code>HashProviderUsed</code> buffer entry.<br><strong>Complexity:</strong> O(len(payload)) plus cost of external command which can be large due to file I/O and process spawn. CRC32 path O(bytes).<br><strong>Side-effects:</strong> May spawn external process and create and delete temp file(s). Writes provider usage to buffer. May be slow if command not present and repeated for many rows.<br><strong>Invariants:</strong> Returned string is used as PrevHash for next entry; CRC32 fallback is shorter (8 hex) so format variation exists across providers — module records which provider used. Historical verification must be prepared for mixed-provider outputs.<br><strong>Failure modes:</strong> External command absent or blocked — falls back to CRC32. Macro provider may be malicious if enabled — strict opt-in required. Long audits invoking external commands per row can be slow and may block UI; consider caching or batched hashing if needed.<br><strong>Security:</strong> Running external commands is guarded by <code>g_allowCommandExecution</code>. Macro provider usage is gated via <code>g_allowExternalHashProvider</code> flag and <code>HashProviderMacroName</code> string; enabling these must be reviewed carefully. <br><strong>Tests:</strong> Unit test with <code>g_allowExternalHashProvider</code> True and a test macro (mock) returning deterministic value; with <code>g_allowCommandExecution</code> True on Windows assert <code>certutil</code> path works; forcing both off returns CRC32 and increments counts. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>IncrementHashProviderCount(providerName)</strong> — <em>provider usage counter</em><br><strong>Purpose:</strong> Tally provider usage in <code>g_hashProviderCounts</code> dictionary to expose operator metrics in meta sheet.<br><strong>Signature:</strong> <code>Private Sub IncrementHashProviderCount(ByVal providerName As String)</code><br><strong>Behavior:</strong> Safe-create dictionary, increments or initializes count. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>g_hashProviderCounts</code> and later meta sheet rows. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ComputeSHA256_System(s) As String</strong> — <em>platform command wrapper for SHA256</em><br><strong>Purpose:</strong> Attempt to compute SHA256 by writing payload to a temporary file and running platform tool(s). Returns 64-hex uppercase digest or empty string on failure.<br><strong>Signature:</strong> <code>Private Function ComputeSHA256_System(ByVal s As String) As String</code><br><strong>Behavior (detailed):</strong> Creates temp file in TEMP (fallback to workbook path); writes UTF-8 bytes via <code>StrToUtf8Bytes</code>, then branches by <code>PlatformIsWindows()</code>:<code>certutil -hashfile &lt;file&gt; SHA256</code> is used on Windows (only if <code>CertUtilAvailable()</code> is True). On non-Windows tries <code>shasum -a 256</code> then <code>openssl dgst -sha256</code> as fallbacks. Captures stdout via <code>RunCmdWithTimeout_Safe</code> with timeout; deletes temp file. Parses stdout lines to extract candidate hex strings, strips filename tokens, asterisks and spaces, returns first 64-hex candidate validated by <code>IsHexString</code>. On errors returns empty string.<br><strong>Complexity:</strong> File write + external process spawn per call — expensive for many rows.<br><strong>Side-effects:</strong> Temp file creation/deletion; executes external commands (guarded by <code>g_allowCommandExecution</code>).<br><strong>Failure modes:</strong> Command absent, lack of permissions, or commands returning localized output that parsing does not handle — returns "" to signal caller to fall back to CRC32.<br><strong>Security:</strong> Avoids logging full payload; never writes raw payload into audit logs via buffer. <br><strong>Tests:</strong> On Windows machine with certutil available, verify returned hex length 64 and IsHexString True. Simulate missing tool results in empty string. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>RunCmdWithTimeout_Safe(cmd, timeoutSeconds) As String</strong> — <em>safe command executor for stdout capture</em><br><strong>Purpose:</strong> Run OS command via <code>WScript.Shell.Exec</code> (if available) and capture StdOut with timeout, guarded by <code>g_allowCommandExecution</code> flag. Returns stdout text or empty on failure/timeouts.<br><strong>Signature:</strong> <code>Private Function RunCmdWithTimeout_Safe(ByVal cmd As String, ByVal timeoutSeconds As Long) As String</code><br><strong>Behavior:</strong> Uses <code>CreateObjectSafe(&quot;WScript.Shell&quot;)</code> to call <code>Exec</code>. Polls <code>execObj.Status</code> with <code>DoEvents</code> and a timer; if timeout reached attempts <code>execObj.Terminate</code>. Returns <code>execObj.StdOut.ReadAll</code> if available. Silent failures return empty string.<br><strong>Complexity:</strong> Blocking loop up to timeoutSeconds. <br><strong>Side-effects:</strong> Process spawn/terminate attempts; may affect responsiveness if timeout large.<br><strong>Security:</strong> Guarded by <code>g_allowCommandExecution</code>. Uses On Error handling to avoid bubbling exceptions. <br><strong>Tests:</strong> Provide simple echo command and ensure stdout captured; long-running command tested to confirm termination at timeout. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>CertUtilAvailable() As Boolean</strong> — <em>probe for certutil</em><br><strong>Purpose:</strong> Quick probe whether <code>certutil</code> is present on PATH and usable (Windows case). Uses small timeout probe to avoid long waits.<br><strong>Signature:</strong> <code>Private Function CertUtilAvailable() As Boolean</code><br><strong>Behavior:</strong> Calls <code>RunCmdWithTimeout_Safe(&quot;certutil -?&quot;, 2)</code> and inspects output presence. Respects <code>g_allowCommandExecution</code> guard. <br><strong>Complexity:</strong> O(1) external probe. <br><strong>Tests:</strong> On Windows certutil present returns True. If blocked or absent returns False. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>PlatformIsWindows() As Boolean</strong> — <em>OS probe</em><br><strong>Purpose:</strong> Determine whether running on Windows via <code>Application.OperatingSystem</code> string contains "Windows".<br><strong>Signature:</strong> <code>Private Function PlatformIsWindows() As Boolean</code><br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Verify behavior on Windows vs macOS host. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>IsHexString(s) As Boolean</strong> — <em>hex validator using RegExp</em><br><strong>Purpose:</strong> Validate candidate hash strings are hex-only (0-9A-F).<br><strong>Signature:</strong> <code>Private Function IsHexString(ByVal s As String) As Boolean</code><br><strong>Behavior:</strong> Uses <code>VBScript.RegExp</code> with pattern <code>^[0-9A-Fa-f]+$</code> to test; returns False if RegExp unavailable.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Tests:</strong> Known hex string True, non-hex False. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ComputeCRC32String(s) As String</strong> — <em>CRC32 fallback digest</em><br><strong>Purpose:</strong> Deterministic fallback hash if SHA256 is unavailable; returns 8-hex uppercase string representing CRC32 of UTF-8 bytes of payload.<br><strong>Signature:</strong> <code>Private Function ComputeCRC32String(ByVal s As String) As String</code><br><strong>Behavior:</strong> Builds CRC32 table via <code>CRC32Table()</code> (256-entry long array), iterates bytes from <code>StrToUtf8Bytes(s)</code> updating CRC with XOR and table lookups, returns padded 8-hex uppercase string. Deterministic and fast in VBA compared to spawning external processes.<br><strong>Complexity:</strong> O(len(bytes)).<br><strong>Side-effects:</strong> None. <br><strong>Security:</strong> Shorter digest increases collision risk compared to SHA256; intentionally used only as fallback and recorded. <br><strong>Tests:</strong> Confirm CRC32 outputs stable value for same payload; compare to known CRC32 vector. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>CRC32Table() As Long()</strong> — <em>table builder</em><br><strong>Purpose:</strong> Generate 256-entry CRC32 table used by ComputeCRC32String.<br><strong>Signature:</strong> <code>Private Function CRC32Table() As Long()</code><br><strong>Behavior:</strong> Standard polynomial <code>0xEDB88320</code> generation loop. <br><strong>Complexity:</strong> O(256*8).<br><strong>Tests:</strong> Validate entries for known indices (e.g., first/last). </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>StrToUtf8Bytes(s) As Byte()</strong> — <em>UTF-8 encoder (ADODB.Stream preferred)</em><br><strong>Purpose:</strong> Convert VBA <code>String</code> into UTF-8 byte array for file writes and hashing payload bytes.<br><strong>Signature:</strong> <code>Private Function StrToUtf8Bytes(ByVal s As String) As Byte()</code><br><strong>Behavior:</strong> Preferred path uses <code>ADODB.Stream</code>: set Type=2 (text), Charset="utf-8", WriteText, switch to binary and Read to get bytes. Fallback uses <code>StrConv(s, vbFromUnicode)</code> and returns byte array. This function is critical for correct SHA256/CRC computation and UTF-8 JSON output.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> Uses COM ADODB.Stream if available. <br><strong>Failure modes:</strong> If ADODB not available, fallback may produce platform-dependent conversions. <br><strong>Tests:</strong> Round-trip encode/decode tests for Unicode characters; confirm exported JSON contains UTF-8 BOM-free UTF-8 bytes. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>GetUtcIsoTimestamp() As String</strong> — <em>UTC ISO timestamp provider</em><br><strong>Purpose:</strong> Produce ISO 8601 UTC timestamp like <code>YYYY-MM-DDThh:mm:ssZ</code> using <code>GetSystemTime</code> Win32 call when available, fallback to <code>Now</code> formatted string suffixed with <code>Z</code> if call fails.<br><strong>Signature:</strong> <code>Private Function GetUtcIsoTimestamp() As String</code><br><strong>Behavior:</strong> When <code>GetSystemTime</code> API available, constructs formatted timestamp from <code>SYSTEMTIME</code>. Fallback uses <code>Format$(Now, &quot;yyyy-mm-dd\THH:nn:ss&quot;) &amp; &quot;Z&quot;</code>. Ensures consistent timestamp format for canonical row strings.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Comparing two sequential calls produce increasing times; cross-check approximate UTC correctness if possible. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>UtcNowForFilename() As String</strong> — <em>filename-safe timestamp</em><br><strong>Purpose:</strong> Generate compact timestamp for filenames derived from <code>GetUtcIsoTimestamp</code> by removing colons and dashes and replacing <code>T</code> with <code>_</code>.<br><strong>Signature:</strong> <code>Private Function UtcNowForFilename() As String</code><br><strong>Tests:</strong> Returns strings safe for filenames with no <code>:</code> or <code>-</code>. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>RedactSensitiveData(inputJson) As String</strong> — <em>PII/light redaction pipeline</em><br><strong>Purpose:</strong> Heuristic redaction of common PII tokens in JSON-like text to avoid recording secrets in audit context fields. Designed to be conservative and PII-light by default; <code>g_aggressiveRedaction</code> enables more aggressive patterns.<br><strong>Signature:</strong> <code>Private Function RedactSensitiveData(ByVal inputJson As String) As String</code><br><strong>Behavior (detailed):</strong> Fast-returns on empty input. Uses <code>VBScript.RegExp</code> (if available) with multiple global patterns applied in sequence to replace: email addresses -> <code>[REDACTED_EMAIL]</code>; SSN-like patterns -> <code>[REDACTED_SSN]</code>; long numeric sequences (cards) -> <code>[REDACTED_NUMBER]</code>; grouped card numbers -> <code>[REDACTED_NUMBER]</code>; account-like key/value numeric sequences -> <code>[REDACTED_ACCT]</code>; JWT-like three-part base64 tokens -> <code>[REDACTED_TOKEN]</code>; API key prefixes (<code>sk_</code>, <code>pk_</code>, <code>AKIA</code>, etc.) -> <code>[REDACTED_TOKEN]</code>; token-like keys <code>token|apikey|password</code> followed by blob -> <code>$1[REDACTED_TOKEN]</code>; long hex strings after key words -> <code>[REDACTED_HEX]</code>; generic long base64-like blocks -> <code>[REDACTED_BLOB]</code>. When <code>g_aggressiveRedaction</code> true additional catch-all token patterns are applied. Truncates to <code>MAX_CONTEXT_LENGTH</code> at end. Has <code>SimpleRedactFallback</code> fallback when RegExp not available.<br><strong>Complexity:</strong> O(len(input) * number_of_patterns).<br><strong>Side-effects:</strong> May produce shorter string; logs <code>RedactionApplied</code> entries via <code>AddToBufferNoFlush</code> if changed. <br><strong>Invariants:</strong> Should never produce output with raw secrets for patterns matched, but redaction is heuristic and not guaranteed to catch everything; operator must avoid sending high-sensitivity secrets into context fields. <br><strong>Failure modes:</strong> Over-redaction (loss of useful context) or under-redaction (missed patterns). Aggressive mode increases false positives. <br><strong>Tests:</strong> Inputs with emails, JWTs, API keys produce <code>[REDACTED_*]</code>; long contexts truncated; fallback path exercised when RegExp absent. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>SimpleRedactFallback(txt) As String</strong> — <em>token-based fallback redaction</em><br><strong>Purpose:</strong> Conservative string-based redaction when RegExp not available; scans for token keys and replaces value tokens with <code>[REDACTED]</code>.<br><strong>Signature:</strong> <code>Private Function SimpleRedactFallback(ByVal txt As String) As String</code><br><strong>Behavior:</strong> For a list of substring keys (<code>password=</code>, <code>token=</code>, etc.), finds and replaces adjacent token characters up to delimiting characters with <code>[REDACTED]</code>.<br><strong>Complexity:</strong> O(len(txt) * num_keys).<br><strong>Tests:</strong> Basic token replacement scenarios. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>NewCorrelationId() As String</strong> — <em>correlation ID generator (prefer GUID)</em><br><strong>Purpose:</strong> Provide a unique correlation identifier for audit lines. Prioritizes <code>Scriptlet.TypeLib</code> GUID creation; falls back to timestamp+random.<br><strong>Signature:</strong> <code>Private Function NewCorrelationId() As String</code><br><strong>Behavior:</strong> Tries <code>Scriptlet.TypeLib</code> to get <code>.guid</code> and strips braces; else uses <code>Randomize</code> and <code>Now</code> timestamp formatted to produce <code>IFRS-yyyymmddHHNNSS-&lt;random&gt;</code>. Deterministic formatting aids search & uniqueness. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Multiple calls within same second generate different suffix numbers; GUID path yields valid GUID form. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>EscapeJson(s) As String / EscapeCsv(s) As String / EscapeCsvField(s) As String</strong> — <em>text escaping utilities</em><br><strong>Purpose:</strong> Provide safe escaping for JSON and CSV output to avoid format-breaking characters.<br><strong>Signature:</strong> <code>Private Function EscapeJson(ByVal s As String) As String</code>, <code>Private Function EscapeCsv(ByVal s As String) As String</code>, <code>Private Function EscapeCsvField(ByVal s As String) As String</code><br><strong>Behavior:</strong> <code>EscapeJson</code> escapes backslash, double-quotes, slashes, and CR/LF to <code>\n</code> sequences. <code>EscapeCsv</code> doubles quotes. <code>EscapeCsvField</code> wraps field in quotes and doubles internal quotes. Used by <code>ExportAuditToJSON</code> and <code>GenerateAuditDiagnosticReport</code> to produce well-formed export files.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Tests:</strong> Strings with quotes/newlines produce properly escaped outputs. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>NzValue(v) As String</strong> — <em>safe nil->string conversion</em><br><strong>Purpose:</strong> Defensive helper for cell reads to avoid runtime type errors when cell contains Error/Null/Empty.<br><strong>Signature:</strong> <code>Private Function NzValue(v As Variant) As String</code><br><strong>Behavior:</strong> Returns "" for IsError/IsNull/IsEmpty; else <code>CStr(v)</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Pass Error/Null/Empty and confirm empty string; numeric returns string of number. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>CreateAuditMetaSheetIfMissing()</strong> — <em>ensure meta sheet exists</em><br><strong>Purpose:</strong> Create <code>_IFRS_AuditMeta</code> sheet used to present operational metadata like last flush time, buffered count, current flags, and provider counts; sheet is very hidden.<br><strong>Signature:</strong> <code>Private Function CreateAuditMetaSheetIfMissing() As Worksheet</code><br><strong>Behavior:</strong> Scan sheets for name; if missing, add worksheet, populate template rows (Key / Value, LastFlushUTC, BufferedCount, EnableMetaSheet, AggressiveRedaction), and optionally output <code>g_hashProviderCounts</code> starting at row 7. Protects by <code>xlSheetVeryHidden</code> visibility.<br><strong>Complexity:</strong> O(#worksheets + #providers) on creation and <code>UpdateAuditMetaSheet</code> updates counts. <br><strong>Side-effects:</strong> Creates/updates meta sheet. <br><strong>Failure modes:</strong> Protected workbook preventing sheet creation recorded as <code>MetaSheetProtected</code>. <br><strong>Tests:</strong> Ensure keys/values present and updated by <code>UpdateAuditMetaSheet</code>. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>UpdateAuditMetaSheet()</strong> — <em>refresh metadata state</em><br><strong>Purpose:</strong> Keep <code>_IFRS_AuditMeta</code> in sync with runtime state: last flush timestamp, buffered count, feature flags, and provider counts.<br><strong>Signature:</strong> <code>Private Sub UpdateAuditMetaSheet()</code><br><strong>Behavior:</strong> If meta sheet disabled or missing returns; if <code>ws.ProtectContents</code> true emits <code>MetaSheetProtected</code> event and skips. Writes <code>LastFlushUTC</code> via <code>GetUtcIsoTimestamp</code>, <code>BufferedCount</code> from <code>g_auditBuffer.count</code>, flags as strings, and enumerates <code>g_hashProviderCounts</code> into subsequent rows. Hides sheet and exits.<br><strong>Complexity:</strong> O(#providers).<br><strong>Side-effects:</strong> Mutates meta sheet cells. <br><strong>Tests:</strong> Set <code>g_hashProviderCounts</code> then call update; verify rows reflect counts. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>CreateObjectSafe(progId) As Object</strong> — <em>safe COM factory</em><br><strong>Purpose:</strong> Wrap <code>CreateObject</code> with On Error handling to avoid throwing if COM not present.<br><strong>Signature:</strong> <code>Private Function CreateObjectSafe(ByVal progId As String) As Object</code><br><strong>Behavior:</strong> Attempts <code>CreateObject(progId)</code> and returns Nothing on error; used throughout to guard ADODB.Stream, Scripting.Dictionary, Scriptlet.TypeLib, WScript.Shell, FileSystemObject, RegExp, etc.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Attempt to create known and unknown progIds to verify safe behavior. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>Utility notes: Performance, Security, and Recommendations</strong><br><strong>Performance:</strong> Bulk writing via <code>Range.Value = outArr</code> is efficient; however <code>ComputeEntryHash</code> may call external processes per row (expensive). For large buffered flushes consider: (a) prefer CRC32 or local VBA SHA256 implementation to avoid process spawn cost; (b) limit hash provider external calls by batching or caching repeated payloads; (c) add <code>maxParallelFetches</code>-style throttles for external IO. Tune <code>AUDIT_BATCH_FLUSH_THRESHOLD</code> and <code>AUDIT_MAX_ROWS_BEFORE_ROTATE</code> to balance IO and memory.<br><strong>Security & Privacy:</strong> Default configuration disables external macro hash providers. <code>g_allowCommandExecution</code> controls system command execution; enabling it must be an explicit, audited operator action. Redaction is heuristic; never assume it removes all secrets—application code should avoid putting raw secrets in <code>ContextJSON</code>. Macro providers must be trusted; the module records which provider produced each hash in meta sheet. Use <code>VerifyAuditChain</code> and <code>GenerateAuditDiagnosticReport</code> regularly for integrity checks. Archive files may contain sensitive redacted data — secure file permissions and rotate archives appropriately.<br><strong>Resilience:</strong> The module attempts graceful fallbacks: buffered writes, bulk write fallback to per-row sync writes, CRC32 fallback for hashing, safe CreateObject wrappers, meta-sheet protected handling. All errors are logged where possible using <code>AddToBufferNoFlush</code> so operator can inspect meta sheet for problems.<br><strong>Backward compatibility:</strong> Column order and canonical row format are contract. Changing <code>BuildCanonicalRow</code> or <code>ComputeEntryHash</code> format is breaking for historical verification — introduce schema versioning if changing.<br><strong>Testing checklist (recommended):</strong> 1) Idempotent init/shutdown cycles. 2) Buffered writes -> flush -> rotate. 3) Hash provider permutations: macro, certutil/shasum/openssl, CRC32 fallback. 4) Failure modes: protected sheet, missing ADODB, missing WScript, long payloads. 5) Redaction correctness and truncation. 6) Export to CSV/JSON UTF-8 correctness. 7) VerifyAuditChain on healthy & tampered datasets. 8) Concurrency-like stress tests: repeated flush/rotate cycles to check for resource leakage.<br><strong>Maintenance notes for engineers:</strong> - Do not change canonical row field ordering without migration and test vectors. - Carefully gate <code>g_allowExternalHashProvider</code> and <code>g_allowCommandExecution</code> via deployment checklist and CI. - Consider adding a local VBA SHA256 pure-VBA implementation or an offline worker to avoid spawning OS processes per row. - Consider adding incremental hashing (rolling Merkle-like chunks) for very large archives to speed verification. - Keep <code>AUDIT_META_SHEET_NAME</code> very hidden and protect its contents to avoid accidental operator changes. </td></tr></tbody></table></div><div class="row-count">Rows: 45</div></div><div class="table-caption" id="Table2" data-table="Docu_0159_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modBootstrap)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modBootstrap)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Overview:</strong> This table provides a world-class, per-function technical breakdown of the <code>modBootstrap</code> VBA module you supplied. Each entry documents: purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security considerations, recommended tests, and maintainers' notes. Treat as authoritative inline documentation for reviewers, auditors, and QA. This is exhaustive and precise. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_Initialize()</strong> — <em>deterministic add-in bootstrap & deferred-init scheduling</em><br><strong>Purpose:</strong> Entry point invoked on workbook open / add-in load. Initializes in-memory caches, creates metadata/audit/jobs sheets as needed, schedules a deferred init via Application.OnTime, persists bootstrap metadata, and starts light migrations and warm-ups. Designed to be idempotent and resilient to partial failures.<br><strong>Signature:</strong> <code>Public Sub AddIn_Initialize()</code> (no return)<br><strong>Behavior:</strong> Guards against re-entrancy (<code>g_bootstrapInitialized</code> / <code>g_bootstrapInitializing</code>). Initializes dictionaries (<code>g_metaBuffer</code>, <code>g_probeCache</code>, <code>g_featureCache</code>, feature dictionaries). Resets caches, computes <code>g_bootstrapId</code> using CRC32_String and timestamp + username, ensures metadata/audit/jobs/test sheets exist, writes bootstrap state via <code>PersistBootstrapState</code>, schedules deferred init by building an OnTime proc string (<code>BuildOnTimeProcString</code>) and upserting a job (<code>EnqueueOrUpdateJob</code>) then calls <code>SafeOnTimeSchedule</code>. Persists scheduling info and attempts <code>MigrateJobsSheetToV2</code>. Flushes meta buffer and audits startup. Robust On Error handling routes to <code>Bootstrap_HandleError</code> and ensures <code>g_bootstrapInitializing</code> cleared on failure.<br><strong>Complexity:</strong> O(1) amortized; sheet creation may be O(N) for workbook worksheets count but effectively constant for typical workbooks.<br><strong>Side-effects:</strong> Creates/updates hidden worksheets, writes metadata rows, schedules Application.OnTime, appends audit rows, mutates module-level globals.<br><strong>Invariants:</strong> After success <code>g_bootstrapInitialized = True</code> and persistent meta keys for bootstrap exist. Operation is idempotent: repeated calls should not duplicate scheduled jobs due to job upsert logic.<br><strong>Failure modes:</strong> OnTime scheduling may fail (handled by fallback to unqualified proc); sheet creation may fail in restricted containers; Dictionary creation can fail if scripting runtime disabled; partial persistence leads to buffered meta writes. All failures funnel to audit and <code>Bootstrap_HandleError</code>.<br><strong>Security/XSS:</strong> Stores bootstrapId and other meta values only as strings; sensitive keys are redacted by <code>WriteMetaValue</code> if marked sensitive.<br><strong>Tests:</strong> 1) Run twice and assert no duplicate scheduled jobs and idempotent state. 2) Simulate sheet-add failure (protected workbook) and verify meta buffered. 3) Verify <code>g_bootstrapId</code> format changes on new run. 4) OnTime fallback path (qualified vs unqualified proc) exercised.<br><strong>Notes for maintainers:</strong> Preserve public name/signature. Keep OnTime retry/backoff policy consistent with MAX_ONETIME constants. Avoid changing bootstrapId derivation without migration tests. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_DeferredInit()</strong> — <em>deferred warm-up, dependency probe, config load and optional self-test</em><br><strong>Purpose:</strong> Deferred background initialization run via OnTime to warm lightweight services, load feature flags/config, ensure dependencies, optionally run self-tests, and finalize bootstrap state (persist diagnostics, mark job complete).<br><strong>Signature:</strong> <code>Public Sub AddIn_DeferredInit()</code><br><strong>Behavior:</strong> Audits start, marks job running (<code>EnqueueOrUpdateJob</code>), ensures <code>g_bootstrapInitialized = True</code>, calls <code>AddIn_EnsureDependencies()</code>, attempts <code>Config_Load</code> using SafeRun wrappers, loads a specific feature flag (<code>run_selftest_on_start</code>) by checking <code>LoadFeatureFlag</code> then <code>Config_Get</code> as fallback, migrates config with <code>Config_MigrateIfNeeded</code> if available, warms <code>modAudit_Init</code> and <code>modUtilities_Init</code>, conditionally runs <code>AddIn_SelfTestStartup()</code>, persists final bootstrap state via <code>PersistBootstrapState</code>, updates job row to completed, computes and writes duration, audits completion, clears scheduled flags and flushes meta buffer. Error handling sets partial finished state and clears scheduled procedure metadata.<br><strong>Complexity:</strong> O(1) for orchestration; config load complexity depends on <code>Config_Load</code>. Self-test complexity depends on tests invoked.<br><strong>Side-effects:</strong> Calls other modules via <code>SafeRun</code>/<code>SafeRunWithResult</code>, updates meta and job sheets, may write audit/test rows, may set enabled/disabled features via <code>AddIn_DisableFeature</code> on failures.<br><strong>Invariants:</strong> Leaves bootstrap persisted with final state and diagnostics; <code>BootstrapScheduled</code> cleared on success or on error path.<br><strong>Failure modes:</strong> Dependent modules missing or failing; <code>Config_Load</code> not present; <code>SafeRun</code> calls swallow errors but log; failure sets <code>Bootstrap</code> state to partial and clears scheduling meta.<br><strong>Security:</strong> Self-test writes may attempt to write redacted sensitive keys; <code>WriteMetaValueAtomic</code> will redact keys marked sensitive.<br><strong>Tests:</strong> 1) Simulate missing <code>Config_Load</code> and verify behavior. 2) Force <code>AddIn_SelfTestStartup</code> to fail and confirm <code>AddIn_DisableFeature</code> invoked. 3) Validate job row transitions (queued->running->completed).<br><strong>Notes:</strong> This routine is the safe place to perform non-blocking heavy initializations; keep long-running or UI-blocking work out of <code>AddIn_Initialize</code>. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_Shutdown()</strong> — <em>idempotent shutdown & cancellation</em><br><strong>Purpose:</strong> Gracefully stop scheduled tasks, attempt ribbon graceful shutdown, persist final state, audit shutdown time. Intended to be safe to call multiple times.<br><strong>Signature:</strong> <code>Public Sub AddIn_Shutdown()</code><br><strong>Behavior:</strong> Calls <code>TryCancelOnTime</code> for <code>g_deferredWhen</code>/<code>g_scheduledProcedure</code>, calls <code>Ribbon_AttemptGracefulShutdown</code>, clears <code>g_bootstrapScheduled</code>, writes meta, calls <code>PersistBootstrapState</code> and adds audit row. Errors forwarded to <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(#jobs) within Ribbon_AttemptGracefulShutdown when enumerating job sheet; otherwise O(1).<br><strong>Side-effects:</strong> Cancels OnTime tasks, writes to jobs sheet and metadata, may mark scheduled jobs as cancelled/orphaned.<br><strong>Invariants:</strong> After completion <code>BootstrapScheduled</code> meta false; scheduled procedure cleared.<br><strong>Failure modes:</strong> If workbook unavailable, cancellation attempts may be partial and errors logged. On heavily concurrent Excel operations, <code>Application.OnTime</code> cancel may fail.<br><strong>Tests:</strong> 1) Schedule a job and call shutdown—assert job cancelled and job sheet updated. 2) Call shutdown multiple times — assert idempotence. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_IsInitialized()</strong> — <em>bootstrap initialised query</em><br><strong>Purpose:</strong> Return boolean indicating whether bootstrap initialization completed in this session.<br><strong>Signature:</strong> <code>Public Function AddIn_IsInitialized() As Boolean</code><br><strong>Behavior:</strong> Simply returns <code>g_bootstrapInitialized</code> value.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> Validate reflects state transitions after <code>AddIn_Initialize</code> and <code>AddIn_DeferredInit</code>. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_GetState()</strong> — <em>structured runtime state snapshot</em><br><strong>Purpose:</strong> Produce a Scripting.Dictionary containing key runtime/bootstrap state for diagnostic callers (UI, telemetry, tests).<br><strong>Signature:</strong> <code>Public Function AddIn_GetState() As Object</code> → Dictionary or Nothing on error.<br><strong>Behavior:</strong> Creates dictionary, populates keys: <code>bootstrapId</code>, <code>startUtc</code>, <code>scheduled</code>, <code>scheduledProcedure</code>, <code>enabledFeatures</code> (array via <code>ArrayFromDictSafe</code>), <code>disabledFeatures</code> (array via <code>ArrayFromDictWithValuesSafe</code>), <code>bootstrapVersion</code>, <code>lastCapabilitySnapshotUpdated</code>. Returns dictionary or Nothing on error and routes errors to <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(E) where E = number of enabled/disabled features.<br><strong>Side-effects:</strong> None (reads global state).<br><strong>Tests:</strong> Validate returned dictionary keys and that arrays mirror dictionaries. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_EnableFeature(featureName, Optional reason)</strong> — <em>enable feature flag (runtime + persist)</em><br><strong>Purpose:</strong> Mark feature enabled in session dictionary, remove it from disabled map, persist Enabled/Disabled features into metadata atomically.<br><strong>Signature:</strong> <code>Public Sub AddIn_EnableFeature(ByVal featureName As String, Optional ByVal reason As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Create <code>g_enabledFeatures</code> if missing, store reason truncated to 256 bytes. Remove key from <code>g_disabledFeatures</code> if present. Persist both dictionaries via <code>WriteMetaValueAtomic</code> into <code>EnabledFeatures</code> and <code>DisabledFeatures</code> meta keys (short capped). Errors forwarded to <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes metadata and modifies in-memory dictionaries.<br><strong>Failure modes:</strong> Meta write failure => buffered by <code>WriteMetaValueAtomic</code> and audited. <br><strong>Tests:</strong> Enable/disable cycles, verify meta persisted/truncated and dictionary consistency. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_DisableFeature(featureName, Optional reason)</strong> — <em>disable feature flag (runtime + persist)</em><br><strong>Purpose:</strong> Symmetric to AddIn_EnableFeature: mark feature disabled with reason, remove from enabled map, persist.<br><strong>Signature:</strong> <code>Public Sub AddIn_DisableFeature(ByVal featureName As String, Optional ByVal reason As String = &quot;&quot;)</code><br><strong>Notes:</strong> See EnableFeature. Tests should assert redaction/truncation behavior and persistence. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_SelfTestStartup()</strong> — <em>start-of-session self-test harness runner</em><br><strong>Purpose:</strong> Run a deterministic set of basic checks (either via <code>TestRunner_SelfTest</code> if present or internal checks: CRC32 vector, metadata R/W, sensitive key redaction) and append results to test sheet; return boolean pass/fail.<br><strong>Signature:</strong> <code>Public Function AddIn_SelfTestStartup() As Boolean</code><br><strong>Behavior:</strong> Calls <code>TestRunner_SelfTest</code> if present else runs a set of local checks (CRC32 vector validation, Write/Read meta roundtrip, sensitive key store/redaction). Appends test results to test sheet via <code>AppendTestResult</code>. If failures, disables <code>selftest</code> feature and audits result. Returns boolean ok.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes to metadata and test sheet, may call <code>AddIn_DisableFeature</code> on failure.<br><strong>Failure modes:</strong> If sheets not available, writes buffered or fallback to metadata placeholder. Watch for redaction logic sensitivity (sensitive keys).<br><strong>Tests:</strong> Force each check to fail and verify harness returns false and results appended. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_ListDependencies()</strong> — <em>declared dependency inventory</em><br><strong>Purpose:</strong> Return a dictionary enumerating optional procedural/module dependencies (used for discovery and UI). Not a dynamic probe — just static list of names and "optional" marker.<br><strong>Signature:</strong> <code>Public Function AddIn_ListDependencies() As Object</code><br><strong>Behavior:</strong> Creates dictionary and fills with keys such as <code>LogAudit</code>, <code>HandleError</code>, <code>Config_Load</code>, <code>modUtilities_Init</code>, etc. Returns dictionary or Nothing on error.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Validate presence of expected dependency keys. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>TryProbe(procName)</strong> — <em>runtime probe with attempt/backoff and cache</em><br><strong>Purpose:</strong> Best-effort probe whether a given procedure/module is callable. Caches results in <code>g_probeCache</code> for session lifetime to reduce repeated SafeRun attempts.<br><strong>Signature:</strong> <code>Public Function TryProbe(ByVal procName As String) As Boolean</code><br><strong>Behavior:</strong> Validate procName, ensure <code>g_probeCache</code> exists. If cached, return cached boolean. Otherwise attempt up to 2 attempts using <code>SafeRun(procName)</code> with 50ms Sleep backoff. Store result in <code>g_probeCache</code> and return boolean. On unexpected error set cache false.<br><strong>Complexity:</strong> O(attempts) where attempts ≤ 2; each attempt O(1) except SafeRun internals.<br><strong>Side-effects:</strong> Populates <code>g_probeCache</code> dictionary. Logs failures via AppendLocalAudit. <br><strong>Failure modes:</strong> SafeRun may throw or be slow; TryProbe swallows errors and returns False.<br><strong>Tests:</strong> Probe known-present and known-absent procs and verify caching behavior. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_EnsureDependencies()</strong> — <em>comprehensive runtime probe and capability snapshot</em><br><strong>Purpose:</strong> Probe and return a capability dictionary (excelVersion, mod availability booleans, COM object availability, OS type, signature support, etc.), persist capability snapshot via <code>PersistCapabilitySnapshot</code>.<br><strong>Signature:</strong> <code>Public Function AddIn_EnsureDependencies() As Object</code><br><strong>Behavior:</strong> Creates dictionary <code>d</code>, sets <code>excelVersion</code> and coreAvailable. Calls <code>TryProbe</code> for <code>Config_Load</code>, <code>modAudit_Init</code>, <code>modUtilities_Init</code>, <code>HandleError</code> etc. Probes FileSystemObject, ADODB.Stream, WScript.Shell through <code>CreateObjectSafe</code> for COM support, checks workbook signatures if workbook available, sets <code>hostOperatingSystem</code>, <code>isMac</code>, persists snapshot. Returns dictionary or Nothing on error.<br><strong>Complexity:</strong> O(1) per probe; overall O(P) for number of probes. <br><strong>Side-effects:</strong> Persists <code>LastCapabilitySnapshot</code> metadata, updates <code>g_probeCache</code> implicitly via TryProbe. <br><strong>Failure modes:</strong> COM creation may be blocked by security policy; signature access may throw — caught and logged. <br><strong>Tests:</strong> Simulate environment variations by disabling COM objects and ensure snapshot fields reflect results. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>LoadFeatureFlag(key, Optional defaultValue)</strong> — <em>cached feature flag loader</em><br><strong>Purpose:</strong> Return cached feature flag values with layered fallbacks: in-memory cache <code>g_featureCache</code> → <code>Config_Get</code> via SafeRun → metadata (<code>ReadMetaValue</code>) → default value.<br><strong>Signature:</strong> <code>Public Function LoadFeatureFlag(ByVal key As String, Optional ByVal defaultValue As Variant = Empty) As Variant</code><br><strong>Behavior:</strong> Validate key, check <code>g_featureCache</code>. If absent, attempt <code>SafeRunWithResult(&quot;Config_Get&quot;, key, defaultValue)</code>. If result present, cache and return. Else attempt meta key <code>FeatureFlag_&lt;key&gt;</code>. Else cache and return default. On error, cache default and return it.<br><strong>Complexity:</strong> O(1) typical; <code>Config_Get</code> complexity depends on implementer.<br><strong>Side-effects:</strong> Populates <code>g_featureCache</code> and may call external modules.<br><strong>Failure modes:</strong> <code>Config_Get</code> unavailable or throws — SafeRunWithResult returns Empty and fallback occurs. <br><strong>Tests:</strong> Coverage for cached path, Config_Get path, meta fallback, and default fallback. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_InvalidateFeatureCache(Optional key)</strong> — <em>feature cache invalidation</em><br><strong>Purpose:</strong> Clear full cache or remove a single flag from <code>g_featureCache</code> to force reload on next access.<br><strong>Signature:</strong> <code>Public Sub AddIn_InvalidateFeatureCache(Optional ByVal key As String = &quot;&quot;)</code><br><strong>Behavior:</strong> If key empty, replace <code>g_featureCache</code> with new dictionary; else remove key if exists. Errors handled by <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Invalidate single and all, verify subsequent LoadFeatureFlag triggers <code>Config_Get</code> or metadata lookup. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>InvalidateIFRS16ConfigCache(Optional key)</strong> — <em>compat shim</em><br><strong>Purpose:</strong> Public compatibility wrapper calling <code>AddIn_InvalidateFeatureCache</code> to preserve older API/name. Behavior identical to AddIn_InvalidateFeatureCache.<br><strong>Signature:</strong> <code>Public Sub InvalidateIFRS16ConfigCache(Optional ByVal key As String = &quot;&quot;)</code><br><strong>Notes:</strong> Keep to maintain API stability. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>PersistBootstrapState(status, note)</strong> — <em>atomic-ish persistence of bootstrap state to metadata sheet</em><br><strong>Purpose:</strong> Write a set of bootstrap-related meta keys into metadata sheet (or buffer if sheet missing) to capture status, note, timestamps, enabled/disabled lists, scheduled proc etc.<br><strong>Signature:</strong> <code>Private Sub PersistBootstrapState(ByVal status As String, ByVal note As String)</code><br><strong>Behavior:</strong> Ensures metadata sheet exists; writes keys via <code>WriteMetaValueAtomic</code>: <code>BootstrapId</code>, <code>BootstrapStartUtc</code>, <code>BootstrapLastStatus</code>, <code>BootstrapLastNote</code>, <code>BootstrapLastUpdated</code>, <code>EnabledFeatures</code>, <code>DisabledFeatures</code>, <code>ScheduledProcedure</code>, <code>BootstrapInitialized</code>, <code>BootstrapScheduled</code>, <code>BootstrapVersion</code>. On sheet missing buffers meta via <code>BufferMetaValue</code>.<br><strong>Complexity:</strong> O(E) where E is number of features; mostly I/O bound due to sheet writes.<br><strong>Side-effects:</strong> Metadata writes, may buffer if sheet unavailable.<br><strong>Tests:</strong> Run with and without metadata sheet; verify buffered values flush later. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>PersistCapabilitySnapshot(dict)</strong> — <em>serialize capability snapshot into meta store</em><br><strong>Purpose:</strong> Convert capability dictionary into a URL-encoded semi-colon string and write <code>LastCapabilitySnapshot</code> and timestamp meta keys.<br><strong>Signature:</strong> <code>Private Sub PersistCapabilitySnapshot(ByVal dict As Object)</code><br><strong>Behavior:</strong> Iterate keys of dict, URLEncode values, join <code>k=encoded;</code> pairs, write <code>LastCapabilitySnapshot</code> via <code>WriteMetaValueAtomic</code>. Also writes <code>LastCapabilitySnapshotUpdated</code> timestamp.<br><strong>Complexity:</strong> O(K) where K = keys in dict.<br><strong>Side-effects:</strong> metadata writes. <br><strong>Tests:</strong> Include keys with special characters to validate URLEncode correctness. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>WriteMetaValueAtomic(key, value)</strong> — <em>robust atomic-ish write with retries & buffered fallback</em><br><strong>Purpose:</strong> Attempt to write meta key/value reliably to metadata sheet using a small temp key copy strategy and retries with exponential backoff. If final failure, buffer in-memory and audit.<br><strong>Signature:</strong> <code>Private Sub WriteMetaValueAtomic(ByVal key As String, ByVal value As String)</code><br><strong>Behavior:</strong> Truncate <code>value</code> to <code>MAX_META_VALUE</code>. Use temp key <code>_tmp_&lt;key&gt;</code> and up to 4 attempts: write temp key, write final key, clear temp key, exponential backoff (SleepMs + DoEvents) on error. If still not ok, <code>BufferMetaValue</code> and <code>AppendLocalAudit</code>. Redaction (sensitive key) is handled later in WriteMetaValue. Uses On Error to continue attempts and avoids throwing.<br><strong>Complexity:</strong> Up to O(4) attempts; each attempt may be dominated by sheet write cost.<br><strong>Side-effects:</strong> Writes to metadata sheet (temporary and final keys) or buffers; appends audit on failure.<br><strong>Failure modes:</strong> Sheet not available, write permissions; leads to buffer and logged audit. <br><strong>Tests:</strong> Simulate write failures to ensure buffer path and audit message. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>WriteMetaValueAtomicDual(key, value)</strong> — <em>dual-write to primary and legacy meta keys</em><br><strong>Purpose:</strong> Convenience wrapper to write both <code>key</code> and <code>legacy_&lt;key&gt;</code> to support transitions.<br><strong>Signature:</strong> <code>Private Sub WriteMetaValueAtomicDual(ByVal key As String, ByVal value As String)</code><br><strong>Behavior:</strong> Calls <code>WriteMetaValueAtomic</code> twice (primary and <code>legacy_</code> prefixed).<br><strong>Complexity:</strong> 2x <code>WriteMetaValueAtomic</code> cost. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SleepMs(ms)</strong> — <em>cooperative sleep implementation</em><br><strong>Purpose:</strong> Busy-wait with <code>DoEvents</code> to pause for small durations (ms precision) without freezing UI permanently.<br><strong>Signature:</strong> <code>Private Sub SleepMs(ByVal ms As Long)</code><br><strong>Behavior:</strong> Compute target <code>Timer + ms/1000</code> and loop <code>DoEvents</code> until time reached. Use in retry/backoff loops.<br><strong>Complexity:</strong> O(wait ms).<br><strong>Side-effects:</strong> CPU usage and event pump; may allow other Excel events to run. <br><strong>Notes:</strong> Avoid long sleeps; use only for short backoffs. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>WriteMetaValue(key, value)</strong> — <em>write (or buffer) meta into metadata sheet, sensitive redaction</em><br><strong>Purpose:</strong> Primary routine to write a key/value into the metadata worksheet rows. Handles sensitive key redaction, buffering if sheet unavailable, and fallback logging.<br><strong>Signature:</strong> <code>Private Sub WriteMetaValue(ByVal key As String, ByVal value As String)</code><br><strong>Behavior:</strong> Ensure metadata sheet exists; truncate value to <code>MAX_META_VALUE</code>. If <code>IsSensitiveKey(key)</code> then redact value (marker) and call <code>AddSensitiveKeyMarker</code>. Use <code>Find</code> on column 1 to locate key and update or append row (rowIdx). If sheet missing, <code>BufferMetaValue</code>. On any sheet write error, buffer and <code>AppendLocalAudit</code> message. Uses On Error resilience.<br><strong>Complexity:</strong> O(N) to Find in column (Find optimised by Excel), effectively O(1) for typical rows.<br><strong>Side-effects:</strong> Mutates a hidden worksheet and <code>SensitiveKeys</code> meta when redaction applied. <br><strong>Tests:</strong> 1) Write sensitive keys like <code>oauth_token</code> and assert redaction marker present. 2) Write values longer than MAX_META_VALUE and verify truncation. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ReadMetaValue(key)</strong> — <em>read meta from metadata sheet or in-memory buffer</em><br><strong>Purpose:</strong> Fetch stored metadata value by key from metadata worksheet; if sheet absent consult <code>g_metaBuffer</code> fallback.<br><strong>Signature:</strong> <code>Private Function ReadMetaValue(ByVal key As String) As String</code><br><strong>Behavior:</strong> Use <code>EnsureMetadataSheetExists()</code>; if sheet missing, check <code>g_metaBuffer</code> dictionary; else use Range.Find on column 1; return found cell's column 2 as string or empty string on not found. Catches errors and returns empty on exceptions.<br><strong>Complexity:</strong> O(1) average (Find).<br><strong>Side-effects:</strong> None (reads).<br><strong>Tests:</strong> Roundtrip write via <code>WriteMetaValueAtomic</code> then read. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>EnsureMetadataSheetExists()</strong> — <em>create/locate metadata worksheet with robust naming & hiding</em><br><strong>Purpose:</strong> Ensure the special metadata sheet <code>_IFRS_Metadata</code> exists, create it if missing, set headers, and hide it (very hidden if possible). Return Worksheet object or Nothing if workbook inaccessible or creation fails.<br><strong>Signature:</strong> <code>Private Function EnsureMetadataSheetExists() As Worksheet</code><br><strong>Behavior:</strong> If workbook unavailable return Nothing. Attempt <code>ThisWorkbook.Worksheets(attemptName)</code> else create new worksheet after last, try to set name to <code>_IFRS_Metadata</code> and if collision/rename fails fallback to timestamped alt name. Try <code>xlSheetVeryHidden</code>, else Visible=2 (Excel constant). Ensure header "Key"/"Value" present in row1 col1/2. On failures write meta about create error and return Nothing.<br><strong>Complexity:</strong> O(1) except for workbook worksheets count. <br><strong>Side-effects:</strong> Adds hidden worksheet, may alter workbook structure. <br><strong>Failure modes:</strong> Workbook protected, disabled sheet add; returns Nothing and triggers buffer fallback. <br><strong>Tests:</strong> Creation in normal workbook, creation under restricted workbook (should buffer writes). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>EnsureJobsSheetExists()</strong> — <em>create/locate jobs worksheet and header row</em><br><strong>Purpose:</strong> Ensure <code>_IFRS_Jobs</code> exists with defined header columns for job management. Mirror ensure-metadata behavior but specific columns set for job schema.<br><strong>Signature:</strong> <code>Public Function EnsureJobsSheetExists() As Worksheet</code><br><strong>Behavior:</strong> Similar to <code>EnsureMetadataSheetExists</code> but sets header cells for job columns using <code>JOB_COL_*</code> constants. Hides sheet and returns object. On failure write meta key <code>JobsSheetCreateError</code> and return Nothing.<br><strong>Complexity/Side-effects/Tests:</strong> Same considerations as EnsureMetadataSheetExists. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>MigrateJobsSheetToV2()</strong> — <em>best-effort in-place migration to ensure createdAt/updatedAt/migrated flags</em><br><strong>Purpose:</strong> Walk job sheet rows and ensure <code>CreatedAt</code>, <code>UpdatedAt</code> and <code>v2_migrated</code> flag are present and populated; mark <code>JobsSheetV2Migrated</code> meta on success and audit migration.<br><strong>Signature:</strong> <code>Public Sub MigrateJobsSheetToV2()</code><br><strong>Behavior:</strong> Ensure jobs sheet, iterate rows 2..lastRow, set CreatedAt/UpdatedAt to Now if blank, set v2_migrated to "True" if not already, track <code>changed</code> and audit rows migrated. Silently continues on errors per-row.<br><strong>Complexity:</strong> O(R) with R = number of job rows. <br><strong>Side-effects:</strong> Mutates jobs sheet, writes meta key on migration. <br><strong>Tests:</strong> Run migration on pre-v2 simulated jobs and verify fields populated and meta key set. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>FindJobRow(jobId)</strong> — <em>lookup job row by JobId</em><br><strong>Purpose:</strong> Return row number for jobId or 0 if not found.<br><strong>Signature:</strong> <code>Private Function FindJobRow(ByVal jobId As String) As Long</code><br><strong>Behavior:</strong> Use EnsureJobsSheetExists and Range.Find on JOB_COL_ID; return found row or 0. Errors map to 0.<br><strong>Complexity:</strong> O(1) average. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>EnqueueOrUpdateJob(jobId, Handler, status, Optional scheduledAt, Optional meta)</strong> — <em>job upsert with safe merge semantics</em><br><strong>Purpose:</strong> Add or update a job row in jobs sheet with given fields; merge meta safely using <code>MergeMeta</code> if existing meta exists. If jobs sheet not available, buffer job info under <code>JobBuffer_&lt;jobId&gt;</code>.<br><strong>Signature:</strong> <code>Public Sub EnqueueOrUpdateJob(ByVal jobId As String, ByVal Handler As String, ByVal status As String, Optional ByVal scheduledAt As Variant, Optional ByVal meta As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Validate jobId, ensure job sheet or buffer. Find row or append new row and set CreatedAt when new. Set Handler, Status, ScheduledAt (date formatting), Meta (merged via MergeMeta when needed), UpdatedAt to Now, set v2_migrated true. On errors call <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(1) per upsert plus Find cost. <br><strong>Side-effects:</strong> Mutates jobs sheet or meta buffer. <br><strong>Tests:</strong> Upsert new job, update existing job with meta merging (overwrites keys), buffer path when sheet unavailable. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>UpdateJobMeta(jobId, meta)</strong> — <em>overwrite job meta and touch UpdatedAt</em><br><strong>Purpose:</strong> Replace meta for job row identified by jobId; buffer if sheet unavailable or exit if jobId missing.<br><strong>Signature:</strong> <code>Public Sub UpdateJobMeta(ByVal jobId As String, ByVal meta As String)</code><br><strong>Behavior:</strong> Ensure jobs sheet; find row; set meta and UpdatedAt; buffer if sheet missing. <br><strong>Tests:</strong> Validate metadata replacement and timestamp update. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>MergeMeta(existingMeta, newMeta)</strong> — <em>merge semicolon-delimited key=value meta strings</em><br><strong>Purpose:</strong> Parse <code>existingMeta</code> and <code>newMeta</code> (semi-colon separated key=val pairs), replace existing keys with new values, append new keys, and return serialized merged string (lower-casing keys for dedupe). Robust to malformed segments.<br><strong>Signature:</strong> <code>Private Function MergeMeta(ByVal existingMeta As String, ByVal newMeta As String) As String</code><br><strong>Behavior:</strong> Build dictionary, parse both inputs with <code>Split(&quot;;&quot; )</code> and <code>Split(&quot;=&quot;)</code> into keys/values, set dict(LCase(k)) = v for both, return <code>join</code> of <code>k=v</code> for dict.keys. On parsing error fallback to concatenation of existing and new meta.<br><strong>Complexity:</strong> O(P) where P = number of meta pairs combined. <br><strong>Side-effects:</strong> None.<br><strong>Failure modes:</strong> Malformed k/v entries; fallback behavior documented. <br><strong>Tests:</strong> Overlap keys; keys with <code>=</code> inside value handled by joining slices (SafeArraySlice). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeArraySlice(arr, startIdx)</strong> — <em>slice helper for arrays returned by Split</em><br><strong>Purpose:</strong> Return a new array of arr[startIdx..end] for use reconstructing values containing <code>=</code>. Implements defensive bounds handling.<br><strong>Signature:</strong> <code>Private Function SafeArraySlice(arr As Variant, startIdx As Long) As Variant</code><br><strong>Behavior:</strong> Iterates from startIdx to UBound(arr) copying to new string array, returns empty array on error.<br><strong>Complexity:</strong> O(n) with n = array length - startIdx. <br><strong>Tests:</strong> Ensure values with <code>=</code> are reconstructed correctly. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeOnTimeSchedule(whenTime, procString, Optional jobId)</strong> — <em>reliable Application.OnTime wrapper with retries & job meta updates</em><br><strong>Purpose:</strong> Schedule a procedure with <code>Application.OnTime</code> using up to 3 attempts and exponential backoff; update job metadata retry counts and mark orphaned when scheduling repeatedly fails; update job meta on success.<br><strong>Signature:</strong> <code>Public Function SafeOnTimeSchedule(ByVal whenTime As Date, ByVal procString As String, Optional ByVal jobId As String = &quot;&quot;) As Boolean</code> → Boolean success<br><strong>Behavior:</strong> Attempt <code>Application.OnTime</code> up to 3 times. On each failed attempt audit and SleepMs backoff doubling. If final failure and jobId provided, read job meta, increment retrycount, set onTimeFailed true and <code>proc</code> meta and <code>EnqueueOrUpdateJob</code> marking orphaned or orphaned_maxed if retry exceeded <code>MAX_ONETIME_RETRY_COUNT</code>. On success call <code>UpdateJobMetaWithProc</code> and <code>EnqueueOrUpdateJob</code> to mark scheduled. Returns boolean. Errors forwarded to <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(attempts).<br><strong>Side-effects:</strong> May update job sheet meta and append audit. <br><strong>Failure modes:</strong> OnTime may fail due to permission or host environment (Excel Online / Mac differences); job retry logic ensures not infinitely retried.<br><strong>Tests:</strong> Simulate Application.OnTime failures (mock) to validate orphaning & retry metadata. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>UpdateJobMetaWithProc(jobId, procString, whenTime)</strong> — <em>job meta helper to record scheduled proc</em><br><strong>Purpose:</strong> Read job meta and add <code>onTimeProc</code> and <code>scheduledAt</code> keys then enqueue job with scheduled state.<br><strong>Signature:</strong> <code>Private Sub UpdateJobMetaWithProc(ByVal jobId As String, ByVal procString As String, ByVal whenTime As Date)</code><br><strong>Behavior:</strong> Read existing job meta, <code>SetMetaValue</code> with keys <code>onTimeProc</code> and <code>scheduledAt</code>, call <code>EnqueueOrUpdateJob</code> with "scheduled" status. <br><strong>Tests:</strong> Verify meta keys present and job row state updated. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ReadJobMeta(jobId)</strong> — <em>read <code>Meta</code> column for a job</em><br><strong>Purpose:</strong> Return raw meta string for job row or empty string.<br><strong>Signature:</strong> <code>Private Function ReadJobMeta(ByVal jobId As String) As String</code><br><strong>Behavior:</strong> Use EnsureJobsSheetExists, FindJobRow, return JOB_COL_META cell value. Return empty on missing row or sheet. <br><strong>Tests:</strong> Roundtrip meta writes then read. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>GetMetaValue(meta, key)</strong> — <em>extract single key from semi-colon meta string</em><br><strong>Purpose:</strong> Parse <code>meta</code> string <code>k=v;k2=v2;...</code> and return the value for <code>key</code> case-insensitively, else empty string.<br><strong>Signature:</strong> <code>Private Function GetMetaValue(ByVal meta As String, ByVal key As String) As String</code><br><strong>Behavior:</strong> Splits by <code>;</code> and <code>=</code> and compares lower-cased keys; uses <code>SafeArraySlice</code> to rejoin multi-<code>=</code> values. Robust to malformed entries. <br><strong>Complexity:</strong> O(P). <br><strong>Tests:</strong> Keys absent, present, values with <code>=</code> tokens. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SetMetaValue(meta, key, val)</strong> — <em>set/replace key in semi-colon meta string, returns serialized string</em><br><strong>Purpose:</strong> Insert/update lower-cased key into meta and return new serialized meta string. Keeps other keys intact and deterministic ordering by dictionary iteration.<br><strong>Signature:</strong> <code>Private Function SetMetaValue(ByVal meta As String, ByVal key As String, ByVal val As String) As String</code><br><strong>Behavior:</strong> Use a dictionary to reconstruct meta, set <code>dict(LCase(key)) = val</code>, return joined <code>k=v</code> pairs. On error fallback to concatenation. <br><strong>Complexity:</strong> O(P). <br><strong>Tests:</strong> Replace existing key, add new key. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>BuildOnTimeProcString(kind, Optional procName)</strong> — <em>build workbook-qualified OnTime procedure string</em><br><strong>Purpose:</strong> Return either <code>&quot;&#x27;&lt;WorkbookName&gt;&#x27;!ProcName&quot;</code> or unqualified <code>ProcName</code> if workbook unavailable or on Mac (where qualified preferred false), escaping single quotes by doubling them.<br><strong>Signature:</strong> <code>Private Function BuildOnTimeProcString(ByVal kind As String, Optional ByVal procName As String = &quot;AddIn_DeferredInit&quot;) As String</code><br><strong>Behavior:</strong> If workbook available, get SafeThisWorkbookName, replace <code>&#x27;</code> with <code>&#x27;&#x27;</code>, return <code>&#x27;&lt;name&gt;&#x27;!procName</code>. If workbook unavailable, return <code>procName</code>. Uses On Error fallback.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> With workbook open and missing, assert returned strings. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>BuildJobId(seed)</strong> — <em>normalize job id or generate hashed fallback</em><br><strong>Purpose:</strong> Create deterministic short job id from seed (lower-case, spaces replaced underscores, truncated to 40). If empty, generate <code>job_&lt;hex&gt;</code> using CRC32_String of Now plus rand string.<br><strong>Signature:</strong> <code>Private Function BuildJobId(ByVal seed As String) As String</code><br><strong>Behavior:</strong> Normalizes <code>seed</code> to alphanumeric underscore, lowercases, truncates; if resulting empty builds fallback with CRC32_String. On error fallback similar. <br><strong>Complexity:</strong> O(len(seed)).<br><strong>Tests:</strong> Provide seeds with spaces and long lengths. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Bootstrap_Audit(action, message)</strong> — <em>primary bootstrap-level audit emitter with fallback</em><br><strong>Purpose:</strong> Emit structured audit entries via <code>modAudit</code> (<code>LogAudit</code>) if available, else append to local audit sheet. Includes timestamp, bootstrapId, host info and truncated message.<br><strong>Signature:</strong> <code>Private Sub Bootstrap_Audit(ByVal action As String, ByVal message As String)</code><br><strong>Behavior:</strong> Compose <code>composed</code> string with timestamp, bootstrapId, action, host OS/version and truncated message. Attempt <code>SafeRunWithResult(AUDIT_PROC_NAME, action, composed)</code> and if returns Empty then call <code>AppendLocalAudit(composed)</code>. Errors printed to Debug.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls external audit proc or writes local audit sheet. <br><strong>Tests:</strong> When <code>modAudit</code> absent should write to local audit sheet; when present should call it (mock). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CallSafeRunAudit(action, message)</strong> — <em>best-effort one-way audit call</em><br><strong>Purpose:</strong> Fire-and-forget audit through <code>SafeRun(AUDIT_PROC_NAME, ...)</code> swallowing errors. Used for non-critical audit attempts.<br><strong>Signature:</strong> <code>Private Sub CallSafeRunAudit(ByVal action As String, ByVal message As String)</code><br><strong>Behavior:</strong> Wraps <code>SafeRun</code> with error suppression. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AppendLocalAudit(message)</strong> — <em>append message to local audit worksheet (fallback)</em><br><strong>Purpose:</strong> Persist audit lines to <code>_IFRS_Audit</code> sheet with timestamp and contextual columns when <code>LogAudit</code> not available or as fallback.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAudit(ByVal message As String)</code><br><strong>Behavior:</strong> Ensure audit sheet exists or create, set header columns if missing, append row with timestamp, Application.userName, message (truncated up to 2000), bootstrapId, OS and ExcelVersion. Silently logs errors to Debug.Print on exceptions.<br><strong>Complexity:</strong> O(1) amortized. <br><strong>Side-effects:</strong> Mutates audit sheet visible or hidden. <br><strong>Tests:</strong> Append multiple lines and check content & columns. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Bootstrap_HandleError(procName, errNum, errDesc, Optional procContext)</strong> — <em>centralized error forwarding & fallback logging</em><br><strong>Purpose:</strong> Central handler to attempt forwarding error to external <code>HandleError</code> proc; if unavailable fallback to Debug.Print and <code>AppendLocalAudit</code>. Include procedure context and truncated message. Non-throwing.<br><strong>Signature:</strong> <code>Private Sub Bootstrap_HandleError(ByVal procName As String, ByVal errNum As Long, ByVal errDesc As String, Optional ByVal procContext As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Build payload string; run <code>SafeRunWithResult(ERROR_PROC_NAME, procName, errNum, Left$(errDesc, 1024), procContext)</code>. If returns non-empty exit; else Debug.Print and <code>AppendLocalAudit</code>. Allows On Error Resume Next fallback path. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Simulate <code>HandleError</code> present and absent; check fallback audit content. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Ribbon_Audit(action, message)</strong> — <em>ribbon-specific audit wrapper</em><br><strong>Purpose:</strong> Convenience to call <code>Bootstrap_Audit</code> with <code>Ribbon:</code> prefix for ribbon related events.<br><strong>Signature:</strong> <code>Public Sub Ribbon_Audit(ByVal action As String, ByVal message As String)</code><br><strong>Behavior:</strong> Calls <code>Bootstrap_Audit &quot;Ribbon:&quot; &amp; action, message</code>. On error append local audit. <br><strong>Tests:</strong> Ensure logs appear with Ribbon prefix. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Ribbon_HandleError(proc, errNum, errDesc)</strong> — <em>ribbon-specific error forwarder</em><br><strong>Purpose:</strong> Forward ribbon-related errors via <code>Bootstrap_HandleError</code> with <code>Ribbon_</code> prefix.<br><strong>Signature:</strong> <code>Public Sub Ribbon_HandleError(ByVal proc As String, ByVal errNum As Long, ByVal errDesc As String)</code><br><strong>Behavior:</strong> Calls <code>Bootstrap_HandleError &quot;Ribbon_&quot; &amp; proc, errNum, errDesc</code>. <br><strong>Tests:</strong> As above. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CallRunWithArgs(procName, ParamArray args())</strong> — <em>safe Application.Run wrapper (no result)</em><br><strong>Purpose:</strong> Invoke <code>Application.Run</code> with up to 9 parameters in a controlled way. Truncates >9 args and audits. Used to call workbook-qualified procedures reliably.<br><strong>Signature:</strong> <code>Public Sub CallRunWithArgs(ByVal procName As String, ParamArray args() As Variant)</code><br><strong>Behavior:</strong> Use helper <code>ParamCount(args)</code> to count arguments and select-case to call <code>Application.Run</code> with appropriate argument count up to 9. On >9 logs and truncates. Uses On Error Resume Next and clears Err afterwards. <br><strong>Complexity:</strong> O(1) excluding called proc time. <br><strong>Side-effects:</strong> Executes remote procedure in workbook scope. <br><strong>Tests:</strong> Call with 0..10 args to ensure correct routing and truncation behavior. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CallRunWithArgsWithResult(procName, ParamArray args())</strong> — <em>safe Application.Run wrapper (with return)</em><br><strong>Purpose:</strong> Same as <code>CallRunWithArgs</code> but returns procedure result; robust to up to 9 args and clears Err on failure returning Empty.<br><strong>Signature:</strong> <code>Public Function CallRunWithArgsWithResult(ByVal procName As String, ParamArray args() As Variant) As Variant</code><br><strong>Behavior:</strong> Similar <code>Select Case</code> logic, calls <code>Application.Run</code> and returns result. On Err sets return to Empty and clears Err. <br><strong>Tests:</strong> Verify return values and error handling for remote procs. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>RunWithArgs / RunWithArgsWithResult</strong> — <em>semantic wrappers around CallRunWithArgs / CallRunWithArgsWithResult</em><br><strong>Purpose:</strong> Public convenience wrappers maintaining naming compatibility. They delegate to Call* functions and handle error clearing. Keep behaviour identical to latter. <br><strong>Signature:</strong> <code>Public Sub RunWithArgs(...)</code>, <code>Public Function RunWithArgsWithResult(...) As Variant</code><br><strong>Notes:</strong> Maintain parity and idempotence. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ParamCount(args)</strong> — <em>robust param array length helper</em><br><strong>Purpose:</strong> Return count of elements passed in a ParamArray robustly (handles non-arrays and empty arrays).<br><strong>Signature:</strong> <code>Public Function ParamCount(ByVal args As Variant) As Long</code><br><strong>Behavior:</strong> If args not an array return 0. Otherwise compute LBound/UBound difference +1; handle errors returning 0. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Pass various ParamArray shapes; validate counts. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeRun(procName, ParamArray args())</strong> — <em>best-effort Procedure runner with qualified then unqualified attempts</em><br><strong>Purpose:</strong> Attempt to run a proc safely: preferably workbook-qualified (<code>&#x27;ThisWorkbook&#x27;!Proc</code>), otherwise unqualified proc; record audit messages if calls fail. Returns True if succeeded.<br><strong>Signature:</strong> <code>Public Function SafeRun(ByVal procName As String, ParamArray args() As Variant) As Boolean</code><br><strong>Behavior:</strong> If not Mac and workbook available attempt qualified call via <code>CallRunWithArgs</code> with <code>&quot;&#x27; &amp; SafeThisWorkbookName &amp; &#x27;!&quot; &amp; procName</code> and check Err. If not success attempt unqualified <code>CallRunWithArgs procName</code>. On success return True else append local audit messages and return False. <br><strong>Complexity:</strong> O(1) per attempt. <br><strong>Tests:</strong> Presence/absence of a qualified proc and unqualified fallbacks. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeRunWithResult(procName, ParamArray args())</strong> — <em>SafeRun variant that returns result or Empty</em><br><strong>Purpose:</strong> Attempt the same two-path approach but return procedure result or Empty on failure. Shield exceptions and produce audit if qualified or unqualified call fails.<br><strong>Signature:</strong> <code>Public Function SafeRunWithResult(ByVal procName As String, ParamArray args() As Variant) As Variant</code><br><strong>Behavior:</strong> Attempt qualified variant via <code>CallRunWithArgsWithResult</code> if workbook exists and platform not Mac; on failure try unqualified; on any Err log AppendLocalAudit and return Empty. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Verify successful and unsuccessful calls and that Empty returned on errors. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CreateObjectSafe(progId)</strong> — <em>defensive COM object creation</em><br><strong>Purpose:</strong> Wrap <code>CreateObject</code> to return <code>Nothing</code> on failure instead of raising error; used widely for optional COM features.\n<strong>Signature:</strong> <code>Private Function CreateObjectSafe(ByVal progId As String) As Object</code><br><strong>Behavior:</strong> Try <code>CreateObject(progId)</code> and return object or Nothing on error. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Keeps callers free from On Error handling. <br><strong>Tests:</strong> Attempt to create both valid and invalid progIds. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>IsMac()</strong> — <em>platform detection</em><br><strong>Purpose:</strong> Return True if <code>(Application.OperatingSystem)</code> string contains "Mac" (case-insensitive). Defensive when string empty. <br><strong>Signature:</strong> <code>Private Function IsMac() As Boolean</code><br><strong>Behavior:</strong> Get Application.OperatingSystem via SafeString and InStr check. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Validate on Mac/non-Mac values (mocking Application.OperatingSystem). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>TryCancelOnTime(whenTime, procName)</strong> — <em>best-effort OnTime cancel helper</em><br><strong>Purpose:</strong> Attempt to cancel a scheduled OnTime procedure using qualified and unqualified names; robustly logs failures.<br><strong>Signature:</strong> <code>Private Sub TryCancelOnTime(ByVal whenTime As Date, ByVal procName As String)</code><br><strong>Behavior:</strong> If procName empty default to <code>AddIn_DeferredInit</code>. If not Mac and workbook available attempt qualified cancellation with escaped workbook name; attempt unqualified cancellation as well; always attempt unqualified <code>Application.OnTime</code> last. AppendLocalAudit on failures. <br><strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Application.OnTime cancellation can fail if time or procedure mismatch; logged and not fatal. <br><strong>Tests:</strong> Schedule and cancel to verify rows and job status updated. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>IsSensitiveKey(key)</strong> — <em>simple heuristic for redaction policy</em><br><strong>Purpose:</strong> Return True for meta keys that appear to contain secrets (password, oauth, api_key, secret, token, pass, pwd, api+key). Used by <code>WriteMetaValue</code> to redact stored values and track sensitive keys.<br><strong>Signature:</strong> <code>Private Function IsSensitiveKey(ByVal key As String) As Boolean</code><br><strong>Behavior:</strong> Lowercase check for substrings; returns Boolean. <br><strong>Complexity:</strong> O(len(key)).<br><strong>Security note:</strong> Heuristic-based; may false positive/negative. Keep list updated with new key naming conventions. <br><strong>Tests:</strong> Keys like <code>oauth_token</code>, <code>API_KEY</code>, <code>user_password</code>. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddSensitiveKeyMarker(key)</strong> — <em>mark sensitive keys in meta index</em><br><strong>Purpose:</strong> Append or add <code>key</code> to meta <code>SensitiveKeys</code> list to record keys that were redacted and write <code>SensitiveKeysUpdated</code> timestamp.<br><strong>Signature:</strong> <code>Private Sub AddSensitiveKeyMarker(ByVal key As String)</code><br><strong>Behavior:</strong> Read existing <code>SensitiveKeys</code> meta (ReadMetaValue), if key not included append and write <code>SensitiveKeys</code> via <code>WriteMetaValueAtomic</code>, set <code>SensitiveKeysUpdated</code> timestamp. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Metadata writes and audit. <br><strong>Tests:</strong> Add same key twice ensures no duplicate entry. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>URLEncode(s)</strong> — <em>percent-encode helper for meta serialization</em><br><strong>Purpose:</strong> Convert string into percent-encoded representation safe for metadata serialization. Only encodes non-alphanumeric and selected safe chars (- _ . ~). Uses AscW for Unicode codepoint then hex conversion of low byte.<br><strong>Signature:</strong> <code>Private Function URLEncode(ByVal s As String) As String</code><br><strong>Behavior:</strong> Iterate characters, if in allowed set append verbatim, else append <code>%</code> + hex of (code & 0xFF). Returns encoded string. Errors fatal suppressed. <br><strong>Complexity:</strong> O(len(s)).<br><strong>Security:</strong> Simple encoding; note it drops high byte beyond &HFF (byte truncation) — acceptable for metadata but document if full UTF-8 needed.<br><strong>Tests:</strong> Strings with spaces and unicode. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_RunInternalTests()</strong> — <em>deterministic internal CI-style test runner</em><br><strong>Purpose:</strong> Run a suite of internal self-checks: CRC32_SelfCheck, metadata R/W, SafeRun negative test, OnTime simulation note, ensure CRC table idempotence, truncation tests, sensitive redaction tests; writes results to test sheet and audits completion.<br><strong>Signature:</strong> <code>Public Sub AddIn_RunInternalTests()</code><br><strong>Behavior:</strong> Build results array, call CRC32_SelfCheck, write/read meta verify, test SafeRun returns False for missing proc, check EnsureCRC32Table idempotence, write truncation test, write oauth redaction write+read test, append results via <code>AppendTestResult</code>, audit. Uses error handling to continue where possible.<br><strong>Complexity:</strong> O(T) where T small. <br><strong>Side-effects:</strong> Writes test rows and meta keys. <br><strong>Tests:</strong> This routine is itself a test harness; use to confirm module invariants after code changes. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AppendTestResult(text)</strong> — <em>append textual result to test results sheet</em><br><strong>Purpose:</strong> Ensure <code>TESTRESULTS_SHEET_NAME</code> exists and append timestamped string to it (column 1 timestamp, column 2 result). Create sheet fallback to metadata if missing.<br><strong>Signature:</strong> <code>Private Sub AppendTestResult(ByVal text As String)</code><br><strong>Behavior:</strong> Create sheet if missing, set visible/hide flags, set headers, append row. On errors Debug.Print. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>BufferMetaValue(key, value)</strong> — <em>in-memory meta buffer</em><br><strong>Purpose:</strong> Save key/value into <code>g_metaBuffer</code> dictionary when sheet write impossible. Values later flushed by <code>FlushMetaBuffer</code>.<br><strong>Signature:</strong> <code>Private Sub BufferMetaValue(ByVal key As String, ByVal value As String)</code><br><strong>Behavior:</strong> Ensure <code>g_metaBuffer</code> exists then set dict(key) = value. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Buffer values and later flush to sheet. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>FlushMetaBuffer()</strong> — <em>attempt to flush buffered meta to sheet</em><br><strong>Purpose:</strong> Iterate <code>g_metaBuffer</code> keys and call <code>WriteMetaValue</code> to persist; on successful writes remove keys from buffer. Use robust error handling to avoid partial flush failures leaving buffer consistent.<br><strong>Signature:</strong> <code>Private Sub FlushMetaBuffer()</code><br><strong>Behavior:</strong> For each key in buffer attempt <code>WriteMetaValue</code>; if success remove key; else continue. Silent on failures and logs Debug.Print on exceptions. <br><strong>Complexity:</strong> O(B) where B buffer size. <br><strong>Tests:</strong> Simulate buffered values made while sheet absent, then create sheet and call FlushMetaBuffer to persist. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CRC32_String(s)</strong> — <em>CRC32 implementation for deterministic ids</em><br><strong>Purpose:</strong> Compute CRC32 of string <code>s</code> as 32-bit unsigned value. Uses <code>EnsureCRC32Table</code> to initialize lookup table lazily. Returns 0 for empty input.<br><strong>Signature:</strong> <code>Private Function CRC32_String(ByVal s As String) As Long</code><br><strong>Behavior:</strong> Convert string to bytes via <code>StrConv</code> (vbFromUnicode), initialize CRC_TABLE, iterate bytes updating crc via table indexed by <code>(crc XOR b(i)) AND &amp;HFF</code>, and return bitwise-not result masked to 32bits. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Side-effects:</strong> Initializes CRC_TABLE on first call. <br><strong>Tests:</strong> Verify vector value for "The quick brown fox" equals <code>B74574DE</code> (module expects this). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>EnsureCRC32Table()</strong> — <em>lazy CRC32 table initializer</em><br><strong>Purpose:</strong> Build CRC_TABLE 0..255 using polynomial &HEDB88320 and set <code>CRC_TABLE_INIT</code> flag. Idempotent.<br><strong>Signature:</strong> <code>Private Sub EnsureCRC32Table()</code><br><strong>Behavior:</strong> If <code>CRC_TABLE_INIT</code> then exit; else allocate array and compute table. <br><strong>Complexity:</strong> O(1) once built; O(256*8) init cost on first call. <br><strong>Tests:</strong> Call twice to check idempotence. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>HexFromLong(l)</strong> — <em>format 32-bit long as 8-character hex</em><br><strong>Purpose:</strong> Return zero-padded 8-character uppercase hex string for Long masked to 32-bit. <br><strong>Signature:</strong> <code>Private Function HexFromLong(ByVal l As Long) As String</code><br><strong>Behavior:</strong> Compute <code>Right$(&quot;00000000&quot; &amp; Hex$(l And &amp;HFFFFFFFF), 8)</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Validate known inputs. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CRC32_SelfCheck()</strong> — <em>validate CRC32 implementation against known vector</em><br><strong>Purpose:</strong> Compute CRC32_String("The quick brown fox") and compare to expected hex constant; append test result accordingly and audit if failed.<br><strong>Signature:</strong> <code>Private Sub CRC32_SelfCheck()</code><br><strong>Behavior:</strong> Calls CRC32_String and <code>HexFromLong</code>, compares to "B74574DE", appends test result. On mismatch call Bootstrap_Audit. <br><strong>Tests:</strong> Run in CI. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_CheckOnTimeCompatibility()</strong> — <em>diagnostic helper for OnTime semantics</em><br><strong>Purpose:</strong> Return dictionary with <code>isMac</code>, <code>qualifiedPreferred</code> (not Mac), <code>scheduledProcedure</code>, <code>scheduledWhen</code> and persist <code>OnTimeQualifiedPreferred</code> meta. Used by callers to understand how to build OnTime proc strings.<br><strong>Signature:</strong> <code>Public Function AddIn_CheckOnTimeCompatibility() As Object</code><br><strong>Behavior:</strong> Populate dictionary and return, write meta, handle errors. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Validate outputs on Mac/Windows. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>EnsureAuditSheetExists() / EnsureTestSheetExists()</strong> — <em>lightweight warm-up wrappers</em><br><strong>Purpose:</strong> Ensure <code>_IFRS_Audit</code> and <code>_IFRS_TestResults</code> exist; if not, fallback to metadata sheet to avoid extra IO. These are lightweight warm-up helpers used by AddIn_Initialize to avoid heavy sheet creations in constrained environments.<br><strong>Signature:</strong> <code>Public Function EnsureAuditSheetExists() As Worksheet</code> and <code>Public Function EnsureTestSheetExists() As Worksheet</code><br><strong>Behavior:</strong> Attempt to get sheet by name and if missing either create (Audit) or fallback to metadata sheet for both (per code). Ensure headers present. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ResetCaches()</strong> — <em>clear session probe/feature caches</em><br><strong>Purpose:</strong> Reset <code>g_probeCache</code> and <code>g_featureCache</code> to new empty dictionaries for deterministic warm-up/testing behaviors.<br><strong>Signature:</strong> <code>Public Sub ResetCaches()</code><br><strong>Behavior:</strong> Reinitialize dictionaries via <code>CreateObjectSafe(&quot;Scripting.Dictionary&quot;)</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Validate that previously cached entries no longer present. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Ribbon_ReconcileJobsOnOpen()</strong> — <em>reconcile job sheet entries with OnTime on workbook open</em><br><strong>Purpose:</strong> Iterate <code>_IFRS_Jobs</code> rows and for queued/scheduled jobs attempt to re-schedule them via <code>SafeOnTimeSchedule</code>. Guard excessive future schedule ages and retry counts (<code>MAX_ONETIME_RETRY_AGE_DAYS</code>, <code>MAX_ONETIME_RETRY_COUNT</code>) to mark orphaned entries. Update job metadata/status and audit reconciliation.<br><strong>Signature:</strong> <code>Public Sub Ribbon_ReconcileJobsOnOpen()</code><br><strong>Behavior:</strong> Read jobs sheet rows; for each queued/scheduled row compute scheduledDate (use fallback of now+5s if missing), skip if scheduledDate is too far in future, check retrycount via <code>GetMetaValue</code>, if retry exceeds max set orphaned_maxed, else call <code>SafeOnTimeSchedule</code> with proc built by <code>BuildOnTimeProcString(&quot;job_proc&quot;,&quot;Ribbon_ProcessJob&quot;)</code>. Update job row status/meta and UpdatedAt. Audit final row count.<br><strong>Complexity:</strong> O(R) where R rows. <br><strong>Side-effects:</strong> Calls SafeOnTimeSchedule which may update job meta. <br><strong>Failure modes:</strong> Scheduling may fail, handled via SafeOnTimeSchedule. <br><strong>Tests:</strong> Simulate job rows with various scheduled dates and retrycounts; assert final statuses. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Ribbon_AttemptGracefulShutdown()</strong> — <em>attempt to cancel scheduled ribbon jobs at shutdown</em><br><strong>Purpose:</strong> Iterate job rows and for scheduled/queued entries try to cancel OnTime tasks with <code>TryCancelOnTime</code> then mark job cancelled or orphaned accordingly; audit intent.<br><strong>Signature:</strong> <code>Public Sub Ribbon_AttemptGracefulShutdown()</code><br><strong>Behavior:</strong> For each row with status scheduled/queued check scheduledAt, if date then call <code>TryCancelOnTime</code> for qualified <code>Ribbon_ProcessJob</code> else mark orphaned and set last error. Update UpdatedAt column. Audit completion. <br><strong>Complexity:</strong> O(R). <br><strong>Tests:</strong> Create scheduled jobs and call shutdown verifying cancellation and job sheet changes. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ArrayFromDictSafe(dict)</strong> / <strong>ArrayFromDictWithValuesSafe(dict)</strong> — <em>dictionary to array helpers</em><br><strong>Purpose:</strong> Convert Scripting.Dictionary keys to a 0-based string array; second variant returns <code>key=value</code> strings. Defensive if dict is Nothing or empty.<br><strong>Signature:</strong> <code>Private Function ArrayFromDictSafe(ByVal dict As Object) As Variant</code> and <code>Private Function ArrayFromDictWithValuesSafe(ByVal dict As Object) As Variant</code><br><strong>Behavior:</strong> Iterate dict.keys building arrays; return empty array on missing/empty. <br><strong>Complexity:</strong> O(N) keys. <br><strong>Tests:</strong> Roundtrip with dictionary. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeJoinArray(arr, sep)</strong> — <em>join wrapper for variant arrays</em><br><strong>Purpose:</strong> Join array elements using separator with defensive checks that input is array and non-empty; returns empty string otherwise.<br><strong>Signature:</strong> <code>Private Function SafeJoinArray(ByVal arr As Variant, ByVal sep As String) As String</code><br><strong>Behavior:</strong> If IsArray then Join else return "". <br><strong>Tests:</strong> Arrays and non-arrays. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeString(v)</strong> — <em>robust string coercion</em><br><strong>Purpose:</strong> Return empty string for Error/Null/Empty variants, otherwise CStr(v). Useful to avoid Type mismatch errors when reading cells or COM props.<br><strong>Signature:</strong> <code>Public Function SafeString(ByVal v As Variant) As String</code><br><strong>Behavior:</strong> Use IsError/IsNull/IsEmpty and return CStr otherwise. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Feed Error, Null, Empty, numeric, string. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>IsThisWorkbookUnavailable() / SafeThisWorkbookExists() / SafeThisWorkbookName()</strong> — <em>workbook availability utilities</em><br><strong>Purpose:</strong> Determine whether <code>ThisWorkbook</code> can be accessed and provide safe name accessor. <code>IsThisWorkbookUnavailable</code> uses On Error to attempt <code>Set tmp = ThisWorkbook</code> and returns True on error or Nothing. <code>SafeThisWorkbookExists</code> is negation; <code>SafeThisWorkbookName</code> returns workbook name or empty string when unavailable.<br><strong>Signature:</strong> <code>Private Function IsThisWorkbookUnavailable() As Boolean</code>, <code>Private Function SafeThisWorkbookExists() As Boolean</code>, <code>Private Function SafeThisWorkbookName() As String</code><br><strong>Behavior:</strong> Wrapped On Error checks; used extensively when building qualified proc strings or adding worksheets.<br><strong>Tests:</strong> Validate behaviour under different host contexts (VBA host, automated sessions). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>TruncateForAudit(s, Optional maxLen=512)</strong> — <em>truncate long audit messages safely</em><br><strong>Purpose:</strong> Ensure audit messages do not exceed configured length and append "..." when truncated.<br><strong>Signature:</strong> <code>Private Function TruncateForAudit(ByVal s As String, Optional ByVal maxLen As Long = 512) As String</code><br><strong>Behavior:</strong> If length <= maxLen return original else return Left$(s, maxLen-3) & "...". <br><strong>Tests:</strong> Strings at, below, above threshold. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Ribbon_SelfTest()</strong> — <em>deterministic ribbon-only test writing</em><br><strong>Purpose:</strong> Append 10 deterministic test rows to test sheet and audit completion. Lightweight diagnostic for Ribbon path.<br><strong>Signature:</strong> <code>Public Sub Ribbon_SelfTest()</code><br><strong>Behavior:</strong> Loop 1..10 calling <code>AppendTestResult</code> with row text and <code>Bootstrap_Audit</code> at end. <br><strong>Tests:</strong> Confirm 10 rows appended and audit present. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>End-of-module notes & global invariants</strong> — <em>operational summary</em><br><strong>Purpose:</strong> Summarize cross-cutting assumptions, invariants and recommended tests and hardening practices for the module.<br><strong>Key invariants:</strong><br>- Public API signatures (AddIn_Initialize, AddIn_DeferredInit, AddIn_Shutdown, AddIn_GetState, SafeRun/SafeRunWithResult, SafeOnTimeSchedule, AddIn_EnableFeature/AddIn_DisableFeature, AddIn_RunInternalTests) must remain stable for consumers.<br>- <code>WriteMetaValueAtomic</code> guarantees eventual persistence either to sheet or <code>g_metaBuffer</code> for a single session (durability best-effort).<br>- CRC32 vector MUST remain fixed (used for self-test): <code>&quot;The quick brown fox&quot; =&gt; B74574DE</code>.<br><strong>Security & privacy notes:</strong><br>- Sensitive key detection via <code>IsSensitiveKey</code> is heuristic — ensure server/ops do not rely solely on this; avoid storing secrets in metadata when possible. When <code>IsSensitiveKey</code> true value is truncated and <code>&quot;[REDACTED]&quot;</code> marker appended — maintain this contract across modules.<br>- Telemetry or audit payloads should be reviewed to ensure no PII leaks; <code>Bootstrap_Audit</code> composes messages with truncated content and should not include secret values (sensitive keys redaction enforced at <code>WriteMetaValue</code>).<br><strong>Performance & operational notes:</strong><br>- OnTime scheduling and cancellation are inherently host-dependent (Excel Windows desktop vs Mac vs Online); <code>BuildOnTimeProcString</code>, <code>IsMac</code>, and <code>SafeOnTimeSchedule</code> attempt to abstract difference but tests on target deployment matrix are mandatory.<br>- <code>SafeOnTimeSchedule</code> implements exponential backoff; <code>MAX_ONETIME_RETRY_COUNT</code> and <code>MAX_ONETIME_RETRY_AGE_DAYS</code> are knobs for operational policy: tune conservatively.<br>- Job sheet operations are O(R) for reconciliation and shutdown; ensure job list size remains bounded in practice. Consider periodic pruning.<br><strong>Recommended unit/integration tests (concise):</strong><br>1. Bootstrap idempotence: call <code>AddIn_Initialize</code> twice, assert no duplicate job entries and same/no inconsistent bootstrap state.<br>2. OnTime scheduling/cancellation flows including qualified/unqualified proc names under Mac/Windows environments.<br>3. Metadata atomic write retry and buffer path: simulate sheet unavailable then available and assert flush correctness.<br>4. CRC32 vector validation and CRC table idempotence.<br>5. Feature flag layering: config → meta → default; caching & invalidation semantics.<br>6. Job upsert and migrate flows (MigrateJobsSheetToV2) with createdAt/updatedAt correctness.<br>7. Sensitive key redaction end-to-end: write sensitive and confirm <code>[REDACTED]</code> marker and <code>SensitiveKeys</code> meta updated.<br>8. Error forwarding: presence and absence of <code>HandleError</code> and <code>LogAudit</code> modules produce expected fallback behaviors (AppendLocalAudit).<br>9. Self-test harness success/failure paths and recorded test results.<br>10. Race/availability tests: workbook unavailable contexts and ensure graceful buffering.<br><strong>Maintenance notes:</strong><br>- Do not change bootstrap public function names or signatures without updating external callers (ribbon XML, other modules).<br>- When altering <code>IsSensitiveKey</code> rules or <code>WriteMetaValue</code> redaction behaviour, update <code>AddIn_SelfTestStartup</code> expectations and tests. <br>- When changing worker/async scheduling semantics, add integration tests to confirm OnTime behaviour across platforms. </td></tr></tbody></table></div><div class="row-count">Rows: 75</div></div><div class="table-caption" id="Table3" data-table="Docu_0159_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modCalculations)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modCalculations)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Module overview:</strong> This table documents every notable function/sub in <code>modCalculations</code> (VBA). Each entry is authoritative per-function documentation: purpose, signature (inputs/outputs), internal behaviour, algorithmic complexity, side-effects, invariants, failure modes, security / sensitive-data considerations, recommended tests, and maintainer notes. Use as the canonical inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Constants & Enums (module-level guarantees)</strong> — <em>configuration, limits & enums</em><br><strong>Purpose:</strong> Provide stable numeric/semantic constants and enumerations used across calculations (rounding policies, depreciation methods, daycount conventions, and numeric stability limits).<br><strong>Signature:</strong> module-level <code>Const</code> and <code>Enum</code> declarations (no runtime args).<br><strong>Behavior:</strong> Define default rounding policy, tiny thresholds, max schedule rows, PV nper cap, and Enums <code>DepMethod</code>, <code>RoundingPolicy</code>, <code>dayCountConvention</code> for clear API values. These drive validation and branching throughout the module.<br><strong>Complexity:</strong> O(1) (declaration-only).<br><strong>Side-effects:</strong> None at runtime beyond compile-time constant availability.<br><strong>Invariants:</strong> Values must not change without a version bump (<code>MODCALC_VERSION</code>). Consumers depend on these numeric codes.<br><strong>Failure modes:</strong> None intrinsic; but changing numeric values is breaking. Document in migration notes when altering.<br><strong>Security:</strong> Not applicable.<br><strong>Tests:</strong> Static assertions in CI that <code>GetRoundingPrecision</code> maps policies to expected digits.<br><strong>Notes:</strong> Keep stable; add new enums only with migration guidance and <code>InvalidateModCalculationsCache</code> call if config keys added. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>InitConfigCache / InvalidateModCalculationsCache</strong> — <em>caching lifecycle</em><br><strong>Purpose:</strong> Initialize and invalidate module-level runtime caches for config and rounding precision. Ensures idempotent lazy initialization and safe cache clearing when configuration changes.<br><strong>Signature:</strong> <code>Private Sub InitConfigCache()</code> / <code>Public Sub InvalidateModCalculationsCache()</code> (no outputs).<br><strong>Behavior:</strong> <code>InitConfigCache</code> creates late-bound <code>Scripting.Dictionary</code> objects for <code>gConfigCache</code> and <code>gRoundingPrecisionCache</code> and sets a boolean. <code>InvalidateModCalculationsCache</code> removes stored entries and marks uninitialized. Both swallow errors and are idempotent.<br><strong>Complexity:</strong> O(1) for initialization; <code>Invalidate…</code> O(n) in cached entries for <code>RemoveAll</code> if present (dictionary internal).<br><strong>Side-effects:</strong> Allocates or clears dictionaries. Potential memory release. <br><strong>Invariants:</strong> After <code>InitConfigCache</code>, <code>gConfigInitialized = True</code>. <code>Invalidate…</code> resets to false. Always call <code>InitConfigCache</code> before cache reads.<br><strong>Failure modes:</strong> Late-binding dictionary creation can fail on hosts without scripting runtime — code uses <code>On Error Resume Next</code> so failure will leave caches <code>Nothing</code>. <br><strong>Security:</strong> None.<br><strong>Tests:</strong> Repeated init/invalidate cycles (100×) ensure no error, caches behave as expected. Test that <code>GetConfigValue</code> populates cache. <br><strong>Notes:</strong> Keep creation resilient for locked-down hosts — consider fallback to native VBA Collection if <code>CreateObject</code> fails. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcDepreciation</strong> — <em>convenience wrapper (SL default)</em><br><strong>Purpose:</strong> Simplified API for common straight-line depreciation using <code>CalcDepreciationEx</code> with defaults.<br><strong>Signature:</strong> <code>Public Function CalcDepreciation(cost As Double, usefulLife As Double) As Double</code> -> Double.<br><strong>Behavior:</strong> Calls <code>CalcDepreciationEx(cost, usefulLife, depStraightLine, 0,0,0, GetRoundPolicy())</code>, wrapped with error handler that routes errors to <code>HandleCalcError</code> and returns <code>0#</code> on failure.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Uses <code>HandleCalcError</code> on error (audit/log).<br><strong>Invariants:</strong> Uses configured rounding policy (via <code>GetRoundPolicy</code>).<br><strong>Failure modes:</strong> Invalid numeric inputs lead to handled error and zero return. <br><strong>Security:</strong> No sensitive data exposure. <br><strong>Tests:</strong> Compare against <code>CalcDepreciationEx</code> with explicit parameters; invalid inputs return 0 and log. <br><strong>Notes:</strong> Keep signature stable—public compatibility guarantee. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcEBITDA</strong> — <em>simple arithmetic helper</em><br><strong>Purpose:</strong> Compute revenue − expenses (lightweight helper used by tests & callers).<br><strong>Signature:</strong> <code>Public Function CalcEBITDA(revenue As Double, expenses As Double) As Double</code> -> Double.<br><strong>Behavior:</strong> Returns <code>revenue - expenses</code> with error handler to log and return 0 on failure.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None except error routing. <br><strong>Invariants:</strong> None. <br><strong>Failure modes:</strong> Numeric overflow extremely unlikely; non-numeric inputs caught by error handler. <br><strong>Tests:</strong> Basic numeric checks. <br><strong>Notes:</strong> Keep trivial and inline. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcDepreciationEx</strong> — <em>flexible per-period depreciation calculator</em><br><strong>Purpose:</strong> Core per-period depreciation calculator supporting SL, declining balance, sum-of-years, units-of-production, with robust validation and rounding.<br><strong>Signature:</strong> <code>Public Function CalcDepreciationEx(cost As Double, usefulLife As Double, method As DepMethod, Optional salvage As Double = 0, Optional unitsProduced As Double = 0, Optional unitsTotal As Double = 0, Optional rounding As RoundingPolicy = -9999) As Double</code> -> Double.<br><strong>Behavior:</strong> Validates numeric inputs; clamps salvage to [0,cost]; validates <code>usefulLife</code> (except for units-of-production); computes result per <code>Select Case</code> for each <code>DepMethod</code> with defensive guards (non-negative results; cap not exceeding cost-salvage). Applies rounding via <code>applyRounding</code>. Errors routed via <code>HandleCalcError</code> and returns 0 on failure.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Logging on invalid input. Uses config caches for rounding policy. <br><strong>Invariants:</strong> Result ≥ 0 and ≤ (cost - salvage); rounding consistent per configured policy. <br><strong>Failure modes:</strong> Non-numeric inputs → handled; <code>unitsTotal ≤ 0</code> for units-of-production → handled error. Unexpected Enum value → handled error. <br><strong>Security:</strong> No secrets; safe for audit logs due to redaction policies in <code>HandleCalcError</code>. <br><strong>Tests:</strong> Per-method correctness (SL, DB, SOY, UoP); boundary tests for salvage>cost, usefulLife=0, negative rates, large usefulLife; rounding policy variations. Include property tests asserting 0 ≤ result ≤ cost-salvage. <br><strong>Notes:</strong> Preserve signatures. If extended methods are added, ensure parity and tests. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>LeaseAmortizationSchedule</strong> — <em>amortization schedule builder (1..n rows)</em><br><strong>Purpose:</strong> Produce per-period lease amortization schedule array suitable for writing into worksheets: Period, OpeningBalance, Payment, Interest, Principal, ClosingBalance.<br><strong>Signature:</strong> <code>Public Function LeaseAmortizationSchedule(pmt As Double, ratePerPeriod As Double, periods As Long, Optional startDate As Date = 0) As Variant</code> -> 1-based 2D Variant array or Empty on error.<br><strong>Behavior:</strong> Validates <code>periods &gt; 0</code>; truncates <code>periods</code> to <code>MAX_SCHEDULE_ROWS</code> and <code>PV_MAX_NPER</code> for safety. Computes opening PV via <code>PvFromPmt(pmt, ratePerPeriod, n)</code>. Iterates 1..n building schedule with rounding via <code>applyRounding</code>. Handles near-zero rates (<code>RATE_NEAR_ZERO</code>) by zeroing interest. Ensures principal non-negative and not exceeding balance. Zeroes tiny residuals less than <code>TINY_RESIDUAL_THRESHOLD</code>. After loop, adjusts final principal to reconcile sum(principal) ≈ opening within tolerance. Returns <code>schedule</code> or <code>Empty</code> on failure; errors routed to <code>HandleCalcError</code>.<br><strong>Complexity:</strong> O(n) time and O(n) memory where n = periods (capped).<br><strong>Side-effects:</strong> None except logging; may call <code>SafeLogEx</code> when truncating/capping. Does not touch workbook directly — returns array for consumers.<br><strong>Invariants:</strong> Sum of principal ≈ opening (within tolerance); closing of last period is non-negative and zeroed if tiny. Payment value used is rounded. Schedule size limited by <code>MAX_SCHEDULE_ROWS</code> and <code>PV_MAX_NPER</code>.<br><strong>Failure modes:</strong> Extremely large <code>periods</code> truncated; rate near special values handled gracefully. Numeric instability for extreme rates (guarded by <code>RATE_NEAR_ZERO</code> and <code>PV_MAX_NPER</code>). <br><strong>Security:</strong> No sensitive outputs. <br><strong>Tests:</strong> Zero-rate schedule; tiny-rate with large nper; sum(principal) equals opening within tolerance; truncation logging when <code>periods</code> too large; various rounding policies effect on outputs. Edge-case locking: ensure last-principal adjustment correct when rounding causes mismatch. <br><strong>Notes:</strong> Return shape is 1..n,1..6 — important for consumers that expect that exact indexing; keep exact column ordering stable. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>PvFromPmt (private)</strong> — <em>robust present-value calculator</em><br><strong>Purpose:</strong> Compute PV implied by a fixed payment <code>pmt</code> given rate and nper. Handles near-zero rates and clamps nper.<br><strong>Signature:</strong> <code>Private Function PvFromPmt(pmt As Double, rate As Double, nper As Long) As Double</code> -> Double.<br><strong>Behavior:</strong> If <code>nper &lt;= 0</code> returns 0. Clamps <code>nper</code> at <code>PV_MAX_NPER</code>. For <code>Abs(rate) &lt; RATE_NEAR_ZERO</code> returns <code>pmt * n</code>. Else computes <code>pmt / rate * (1 - (1+rate)^(-n))</code>. Handles tiny denominator by returning <code>pmt * n</code>. Returns absolute value to avoid sign confusion for asset balances. Errors return 0.<br><strong>Complexity:</strong> O(1) arithmetic. <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Returns positive PV for asset contexts. <br><strong>Failure modes:</strong> Exponent overflow for extremely large n but clamped by <code>PV_MAX_NPER</code>. <br><strong>Tests:</strong> Rate=0 case, tiny rate with large n, typical mortgage-like values; ensure positive return. <br><strong>Notes:</strong> Keep sign normalization; callers expect positive opening balance. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>RecognizeRevenue</strong> — <em>linear % recognition</em><br><strong>Purpose:</strong> Recognize revenue by progress fraction (0..1) and apply rounding.<br><strong>Signature:</strong> <code>Public Function RecognizeRevenue(transactionPrice As Double, progress As Double) As Double</code> -> Double.<br><strong>Behavior:</strong> Validates <code>progress</code> numeric and within [0,1]; returns <code>applyRounding(transactionPrice * progress)</code>. On invalid inputs logs error and returns 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error routing if invalid. <br><strong>Invariants:</strong> Output between 0 and transactionPrice (subject to rounding). <br><strong>Failure modes:</strong> Out-of-range progress; non-numeric. <br><strong>Tests:</strong> progress=0,1,0.25; rounding policy effects. <br><strong>Notes:</strong> Simple but used across revenue recognition paths. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ImpairmentLoss / ImpairmentLossByNPV</strong> — <em>loss determination</em><br><strong>Purpose:</strong> Compute impairment losses by direct carrying vs recoverable (ImpairmentLoss) or via NPV of future cashflows (ImpairmentLossByNPV).<br><strong>Signature:</strong> <code>Public Function ImpairmentLoss(carryingAmount As Double, recoverableAmount As Double) As Double</code> and <code>Public Function ImpairmentLossByNPV(carryingAmount As Double, cashflows As Variant, discountRate As Double) As Double</code>.<br><strong>Behavior:</strong> <code>ImpairmentLoss</code> returns max(0, rounded(carrying - recoverable)). <code>ImpairmentLossByNPV</code> computes <code>npv = NPVFromArray(cashflows, discountRate)</code>; if NPV invalid/<=0 treat as fully impaired if below carrying; otherwise return max(0, carry - npv) with rounding. Errors are handled and logged; return 0 on failure.<br><strong>Complexity:</strong> <code>ImpairmentLoss</code> O(1). <code>ImpairmentLossByNPV</code> dominated by <code>NPVFromArray</code> complexity O(m) where m=periods in <code>cashflows</code>.<br><strong>Side-effects:</strong> Logging on invalid inputs. <br><strong>Invariants:</strong> Output ≥ 0. <br><strong>Failure modes:</strong> Invalid discount rates or cashflow arrays lead to <code>NPVFromArray</code> returning 0 and possibly treating asset as impaired depending on logic; this behaviour is intentionally conservative and must be documented to callers.<br><strong>Security:</strong> No sensitive data. <br><strong>Tests:</strong> Compare manual NPV calculations; test negative/zero NPV handling; edge-case discountRate ≤ -1 should be rejected. <br><strong>Notes:</strong> Caller should be aware of policy: 0 NPV might result in full impairment. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>NPVFromArray</strong> — <em>multi-shape NPV evaluator</em><br><strong>Purpose:</strong> Compute NPV for scalar or array cashflows; accepts arbitrary LBound/UBound and defensive validation on discountRate.<br><strong>Signature:</strong> <code>Private Function NPVFromArray(cashflows As Variant, discountRate As Double) As Double</code> -> Double.<br><strong>Behavior:</strong> Validates <code>discountRate &gt; -1</code>. If <code>cashflows</code> is array, iterates from <code>LBound</code> to <code>UBound</code>, converts each item via <code>ToDoubleSafe</code>, discounts by <code>(1+discountRate)^periodIndex</code>. For scalar input treat as a single period at period 1. Returns sum, or 0 on error with <code>HandleCalcError</code> called.<br><strong>Complexity:</strong> O(m) where m = number of periods. <br><strong>Side-effects:</strong> Calls <code>HandleCalcError</code> on invalid rate. <br><strong>Invariants:</strong> Deterministic mapping of array positions to discount periods (periodIndex = i - lb + 1). <br><strong>Failure modes:</strong> Discount rate near -1 or invalid numeric types cause early error and 0 result. <br><strong>Tests:</strong> Arrays with custom LBound/UBound, scalar path, negative/invalid rates. <br><strong>Notes:</strong> Keep indexing logic stable; callers rely on predictable mapping. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ExpectedCreditLoss / ExpectedCreditLossBatch</strong> — <em>ECL single & batch</em><br><strong>Purpose:</strong> ECL scalar: <code>exposure * pd * lgd</code> with validation and rounding. Batch: vectorized wrapper supporting ranges/arrays, normalising inputs and applying scalar ECL element-wise.<br><strong>Signature:</strong> <code>Public Function ExpectedCreditLoss(exposure As Double, pd As Double, lgd As Double) As Double</code> and <code>Public Function ExpectedCreditLossBatch(exposures As Variant, pds As Variant, lgds As Variant) As Variant</code>.<br><strong>Behavior:</strong> Scalar: validate <code>pd</code> and <code>lgd</code> in [0,1]; compute <code>applyRounding(exposure * pd * lgd)</code>. Batch: normalize inputs via <code>NormalizeArrayInput</code>, compute element-wise using <code>ToDoubleSafeIndex</code> and <code>ExpectedCreditLoss</code> for each index; returns 1-based array of Doubles or <code>Empty</code> on failure. Errors handled centrally.<br><strong>Complexity:</strong> Scalar O(1); Batch O(n) with n = max input length. <br><strong>Side-effects:</strong> None other than logging. <br><strong>Invariants:</strong> Batch output length equals max input lengths; per-element validation enforced. <br><strong>Failure modes:</strong> Non-numeric inputs => element result 0 (via underlying functions), entire function returns Empty on unhandled errors. <br><strong>Tests:</strong> PD/LGD boundaries, heterogenous input shapes (ranges, collections, scalars), batch with missing elements. <br><strong>Notes:</strong> Batch returns 1-based array — callers must expect that. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GenerateDepreciationSchedule / GenerateDepreciationScheduleEx</strong> — <em>multi-period schedules (period rows + header)</em><br><strong>Purpose:</strong> Produce per-period schedules used for reporting; <code>GenerateDepreciationSchedule</code> supports standard methods (but not units-of-production series), <code>GenerateDepreciationScheduleEx</code> consumes a units series for unit-of-production schedules.<br><strong>Signature:</strong> <code>Public Function GenerateDepreciationSchedule(cost As Double, usefulLife As Double, Optional method As DepMethod = depStraightLine, Optional salvage As Double = 0, Optional startYear As Long = 0, Optional rounding As RoundingPolicy = -9999) As Variant</code> and <code>Public Function GenerateDepreciationScheduleEx(cost As Double, unitsSeries As Variant, Optional salvage As Double = 0, Optional startYear As Long = 0, Optional rounding As RoundingPolicy = -9999) As Variant</code>.<br><strong>Behavior:</strong> Validate inputs; compute integer <code>periods</code> from <code>usefulLife</code> (SL/DB/SOY) or from <code>unitsSeries</code> length (Ex). Truncate <code>periods</code> to <code>MAX_SCHEDULE_ROWS</code> and create <code>out</code> array sized <code>0..periods,1..4</code> with header at <code>out(0,*)</code>. For each period compute <code>expense</code>, accumulate <code>acc</code>, and compute carrying amount with rounding via <code>applyRounding</code>. <code>GenerateDepreciationScheduleEx</code> normalizes <code>unitsSeries</code> via <code>NormalizePaymentsForRead</code>, computes <code>totalUnits</code>, and allocates expense proportionally per period. Logs fallback for units-of-production when not supplied (in non-Ex variant). Returns variant array or <code>Empty</code> on error.<br><strong>Complexity:</strong> O(n) time and memory where n = periods (capped). <br><strong>Side-effects:</strong> <code>SafeLogEx</code> usage for fallbacks/truncation. <br><strong>Invariants:</strong> Header at index 0; rows 1..periods follow; sum(expenses) approximates <code>cost - salvage</code> within rounding tolerance. <br><strong>Failure modes:</strong> Missing or invalid <code>unitsSeries</code> yields errors; salvage and rounding application must remain stable across runs. <br><strong>Tests:</strong> Units-of-production correctness (sum of expenses equals cost-salvage); fallback logging when UoP requested but no series present; rounding policy variations. <br><strong>Notes:</strong> Keep return shape exact; callers/writers depend on this layout. Consider adding explicit metadata shape in future (UDT). </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>DeferredTax</strong> — <em>temp difference × tax rate</em><br><strong>Purpose:</strong> Compute deferred tax from temporary difference and validated tax rate.<br><strong>Signature:</strong> <code>Public Function DeferredTax(tempDifference As Double, taxRate As Double) As Double</code> -> Double.<br><strong>Behavior:</strong> Validate numeric taxRate in [0,1], return <code>applyRounding(tempDifference * taxRate)</code>. Errors logged; return 0 on failure.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Logging on invalid input. <br><strong>Invariants:</strong> Output rounding consistent with policy. <br><strong>Failure modes:</strong> Out-of-range taxRate; non-numeric. <br><strong>Tests:</strong> taxRate=0,1,0.25; negative tempDifference allowed (creates deferred tax asset). <br><strong>Notes:</strong> Document that sign of tempDifference determines DTA vs DTL. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GetPaymentCountFromNormalized / GetPaymentAmountFromNormalized / GetPaymentDateFromNormalized</strong> — <em>helpers for normalized payment arrays</em><br><strong>Purpose:</strong> Read counts, amounts, dates from a normalized payments array produced by <code>NormalizePaymentsForRead</code> (or compatible shapes). These are small public utilities used by callers and self-tests.<br><strong>Signature:</strong> <code>Public Function GetPaymentCountFromNormalized(payments As Variant) As Long</code>, <code>Public Function GetPaymentAmountFromNormalized(payments As Variant, idx As Long) As Double</code>, <code>Public Function GetPaymentDateFromNormalized(payments As Variant, idx As Long) As Variant</code>.<br><strong>Behavior:</strong> Normalize via <code>NormalizePaymentsForRead</code>, then return safe length, amount (preferring second element if element is a 1..2 array) or date (first element if array). Returns CVErr(xlErrValue) for invalid date index in <code>GetPaymentDateFromNormalized</code>. Errors routed and default fallbacks used (0 for numbers).<br><strong>Complexity:</strong> O(1) per call (plus cost of normalization). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Indexing is 1-based relative to normalized array. <br><strong>Failure modes:</strong> Out-of-range idx -> CVErr/xlErrValue for date, 0 for numeric; callers must handle. <br><strong>Tests:</strong> Range inputs, array inputs, collection/dictionary inputs to <code>NormalizePaymentsForRead</code>. <br><strong>Notes:</strong> Keep signatures stable for external consumers. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>SafeCallCentral / SafeApplicationRun / TryExternalCall</strong> — <em>centralized safe Application.Run wrappers</em><br><strong>Purpose:</strong> Provide robust facades for calling host-level or cross-module routines (<code>Application.Run</code>, <code>modConfig.GetConfigValue</code>, external callbacks) without bubbling exceptions to UI; offer different calling styles (ParamArray-like or array param).<br><strong>Signature:</strong> <code>Private Function SafeCallCentral(procName As String, ByRef outResult As Variant, ParamArray args() As Variant) As Boolean</code>, <code>Private Function SafeApplicationRun(procName As String, ByRef outResult As Variant, Optional params As Variant) As Boolean</code>, <code>Private Function TryExternalCall(procName As String, ByRef r As Variant, ParamArray args() As Variant) As Boolean</code>.<br><strong>Behavior:</strong> <code>SafeCallCentral</code> uses <code>Application.Run</code> with explicit cases mapped to arg counts (0..8, else fallback). It wraps calls with <code>On Error</code> and returns Boolean success status while swallowing errors. <code>SafeApplicationRun</code> is a preferred facade supporting <code>params</code> as an array and converting into calls to <code>SafeCallCentral</code>. <code>TryExternalCall</code> thinly delegates to <code>SafeCallCentral</code>. All functions never raise to host UI and return True/False for success. Avoids throwing and uses defensive <code>On Error</code> blocks.<br><strong>Complexity:</strong> O(1) per call plus whatever <code>Application.Run</code> cost is. <br><strong>Side-effects:</strong> Calls external macros; may change workbook state depending on callee. Error swallowing can hide failures; callers must check boolean return value. <br><strong>Invariants:</strong> Never raises errors to host; returns boolean success and outResult when True. <br><strong>Failure modes:</strong> If <code>Application.Run</code> fails, it returns False and clears Err; some callees expecting exceptions may not behave as expected. <br><strong>Security:</strong> Calling arbitrary <code>procName</code> can be a vector — callers must ensure procName is trusted. <br><strong>Tests:</strong> Mock or stub <code>Application.Run</code> availability; verify that missing procedures result in False, not runtime errors; verify parameter passing for arrays and ParamArray styles. <br><strong>Notes:</strong> This is the central integration guard — ensure callers always check return boolean. Consider adding logging on failure for observability. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GetConfigValue / ShouldRaiseErrors / GetRoundPolicy / ShouldUseCentralRounding / GetLegacyInterestMode</strong> — <em>config accessors with caching</em><br><strong>Purpose:</strong> Provide cached, defensive access to configuration values from host or <code>modConfig</code>. Supply typed defaulting and conversion to expected types (Boolean/Long).<br><strong>Signature:</strong> <code>Private Function GetConfigValue(key As String, Optional defaultValue As Variant = Empty) As Variant</code>, others return typed values.<code>&lt;br&gt;**Behavior:** </code>GetConfigValue<code> uses </code>gConfigCache<code>, attempts </code>SafeApplicationRun("GetConfigValue", ...)<code> and </code>SafeApplicationRun("modConfig.GetConfigValue", ...)<code> fallbacks; if not available stores </code>defaultValue<code> in cache and returns it. </code>GetRoundPolicy<code> and boolean helpers convert returned Variant to expected typed values with safe defaults and error swallowing. </code>ShouldUseCentralRounding<code> controls whether central rounding helper (</code>modUtilities.ApplyRounding<code>) is invoked by </code>applyRounding<code>.&lt;br&gt;**Complexity:** O(1) per call; first time cost includes </code>Application.Run<code> overhead. &lt;br&gt;**Side-effects:** Populates </code>gConfigCache<code>. &lt;br&gt;**Invariants:** Cached values persisted until </code>InvalidateModCalculationsCache<code>. &lt;br&gt;**Failure modes:** If external config API absent, falls back to default values silently. &lt;br&gt;**Security:** Config values may affect behaviour; ensure safe defaults. &lt;br&gt;**Tests:** Simulate </code>modConfig<code> presence/absence; ensure caching works and invalidation clears cache. &lt;br&gt;**Notes:** This module assumes config keys like </code>modCalculations.RoundPolicy<code>, </code>UseCentralRounding<code>, </code>RaiseErrors<code> — document keys in </code>modConfig<code> contract.   **applyRounding / ApplySafeRound / WorksheetRound / GetRoundingPrecision** — *rounding policy &amp; implementation*&lt;br&gt;**Purpose:** Centralized, policy-driven rounding with option to delegate to a central rounding helper (</code>modUtilities<code>) when configured. Includes public alias </code>ApplySafeRound<code> and caching of precision per policy.&lt;br&gt;**Signature:** </code>Public Function applyRounding(value As Double, Optional policy As Variant) As Double<code>, </code>Public Function ApplySafeRound(value As Double, Optional policy As Variant) As Double<code>, </code>Private Function WorksheetRound(value As Double, digits As Long) As Double<code>, </code>Private Function GetRoundingPrecision(policy As Long) As Long<code>.&lt;br&gt;**Behavior:** Determine policy (param or </code>GetRoundPolicy<code>). If </code>ShouldUseCentralRounding()<code> then attempt </code>SafeApplicationRun("modUtilities.ApplyRounding",…)<code> then fallback to </code>modUtilities.Round<code>. If central rounding not available, uses </code>WorksheetRound<code> with </code>GetRoundingPrecision<code> derived from policy (cached in </code>gRoundingPrecisionCache<code>). </code>WorksheetRound<code> calls </code>Application.WorksheetFunction.Round<code> but guards in case it fails. </code>applyRounding<code> swallows errors and returns the unrounded </code>value<code> on failure. </code>GetRoundingPrecision<code> caches precision digits (e.g., 2 for financial).&lt;br&gt;**Complexity:** O(1). &lt;br&gt;**Side-effects:** May call external rounding helpers (modUtilities) if configured. Caches precision digits. &lt;br&gt;**Invariants:** Rounding behaviour deterministic for given </code>MODCALC_VERSION<code> and config; </code>applyRounding<code> should return identical results across calls for same inputs unless config changes and cache invalidated. &lt;br&gt;**Failure modes:** External central rounding routines failing will be gracefully bypassed. </code>WorksheetRound<code> dependency on Excel functions may fail in unusual hosts — code falls back to returning original value. &lt;br&gt;**Security:** No sensitive data exposure. &lt;br&gt;**Tests:** Compare central rounding vs internal rounding equivalence tests; check caching; induced failure of </code>modUtilities.ApplyRounding<code> triggers fallback path. &lt;br&gt;**Notes:** When enabling central rounding in host, validate parity to avoid small reconciliation diffs.   **Numeric helpers (ValidateNumeric, ToDoubleSafe, NZDouble, NZDoubleOrZero, ToDoubleSafeIndex)** — *defensive numeric conversions*&lt;br&gt;**Purpose:** Small helpers for safe numeric conversions and preferred defaults; centralize handling of Null/Empty/Error and provide predictable numeric fallback values to callers.&lt;br&gt;**Signature:** </code>Private Function ValidateNumeric(v As Variant) As Boolean<code>, </code>Private Function ToDoubleSafe(v As Variant, Optional defaultValue As Double = 0#) As Double<code>, </code>Private Function NZDouble(v As Variant, Optional Fallback As Double = 0#) As Double<code>, </code>Private Function NZDoubleOrZero(v As Variant) As Double<code>, </code>Private Function ToDoubleSafeIndex(arr As Variant, idx As Long) As Double<code>.&lt;br&gt;**Behavior:** </code>ValidateNumeric<code> returns True for VB numeric types, False for Error/Non-numeric. </code>ToDoubleSafe<code> returns </code>CDbl(v)<code> when numeric else </code>defaultValue<code>. </code>NZDouble<code> handles Null/Empty/Error and delegates to </code>ToDoubleSafe<code>. </code>ToDoubleSafeIndex<code> safely indexes 1-based normalized arrays and prefers second element when element is 1..2 array. All functions swallow errors. &lt;br&gt;**Complexity:** O(1). &lt;br&gt;**Side-effects:** None. &lt;br&gt;**Invariants:** Functions never raise; always return a numeric fallback in error paths. &lt;br&gt;**Failure modes:** None besides silent fallback which callers must be aware of. &lt;br&gt;**Tests:** Passing Err(), Null, Empty, arrays with different bounds, index out of range. &lt;br&gt;**Notes:** These are critical to prevent host-level UDF errors; keep behaviour stable.   **Array helpers (NormalizeArrayInput, NormalizePaymentsForRead, SafeArrayLength, SafeArrayIndex, UBoundSafe, LBoundSafe, LBoundArraySafe, UBoundArraySafe)** — *uniform array normalization &amp; safe indexing*&lt;br&gt;**Purpose:** Normalize multiple input shapes (Range, Collection, Dictionary, native array, scalar) into a predictable 1-based array or 1..2 element entries for payment semantics. Provide indexing/capacity helpers that never raise and handle odd LBound/UBound shapes.&lt;br&gt;**Signature:** </code>Private Function NormalizeArrayInput(v As Variant) As Variant<code>, </code>Public Function NormalizePaymentsForRead(payments As Variant) As Variant<code>, </code>Private Function SafeArrayLength(arr As Variant) As Long<code>, </code>Private Function SafeArrayIndex(arr As Variant, idx As Long) As Variant<code>, plus </code>UBoundSafe<code>, </code>LBoundSafe<code> and aliases.&lt;br&gt;**Behavior:** </code>NormalizeArrayInput<code> accepts Ranges (reads rows into out(1..n) and packs 2-column ranges as 1..2 arrays), Collection and Dictionary iteration, native arrays (re-base to 1..n), and scalar fallback to 1-element array. </code>NormalizePaymentsForRead<code> is stricter: always produces 1..n elements where each element is either scalar or a 1..2 1-based array </code>[label,date? , amount?]<code> (module uses first element as date/label, second as amount or Empty). </code>SafeArrayLength<code> computes length robustly across array/scalar/Empty. </code>SafeArrayIndex<code> returns element or Empty without raising. All functions swallow errors and return empty 1..0 arrays on failure.&lt;br&gt;**Complexity:** O(n) for conversions when reading Range/Collections; otherwise O(1). &lt;br&gt;**Side-effects:** None. &lt;br&gt;**Invariants:** </code>NormalizePaymentsForRead<code> guarantees each element is either scalar or 1..2 array. Consumers rely on 1-based indexing. &lt;br&gt;**Failure modes:** Dictionary iteration order is unspecified — callers expecting stable ordering must not rely on Dictionary iteration ordering; this is noted in the code. Range with &gt;2 columns truncates to first two columns for payments. &lt;br&gt;**Security:** No secrets but careful about reading arbitrary ranges; no </code>Evaluate<code> used. &lt;br&gt;**Tests:** Ranges with 1 and 2 columns; Collections; Dictionary; nested arrays; verify shapes and values, length counts, index out of bounds handling. &lt;br&gt;**Notes:** If deterministic ordering from dictionaries required, consider sorting keys or requiring a more explicit data shape.   **HandleCalcError / SafeHandleError / AppendLocalAudit / SafeLogEx / SafeLogEvent** — *error routing &amp; audit pipeline*&lt;br&gt;**Purpose:** Centralized error/audit routing that prefers structured </code>modError<code> hooks, then </code>modAudit<code> helpers, then local worksheet </code>_IFRS_Audit<code> fallback. Ensures exceptions do not bubble to UI unless </code>ShouldRaiseErrors()<code> True.&lt;br&gt;**Signature:** </code>Private Sub HandleCalcError(procName As String, Optional errNum As Long = 0, Optional errMsg As String = "")<code>, </code>Private Sub SafeHandleError(procName As String, Optional errNum As Long = 0, Optional errMsg As String = "")<code>, </code>Private Sub AppendLocalAudit(ByVal message As String)<code>, </code>Private Sub SafeLogEx(moduleName As String, proc As String, details As String)<code>, </code>Private Function SafeLogEvent(eventName As String, details As String) As Boolean<code>.&lt;br&gt;**Behavior:** </code>HandleCalcError<code> builds a small JSON-like payload and tries </code>modError.HandleError<code> or </code>HandleError<code>. If absent, calls </code>SafeLogEvent<code>, </code>modAudit.LogEx<code>, </code>modAudit.Log<code>, </code>LogAudit<code> fallbacks in order. Finally appends to </code>_IFRS_Audit<code> sheet (creates very-hidden sheet if missing) via </code>AppendLocalAudit<code>. It calls </code>GenerateCorrelationID()<code> where appropriate and truncates/redacts messages using </code>TruncateForCell<code> and </code>RedactSecrets<code>. If </code>ShouldRaiseErrors()<code> True it optionally raises Err.Raise after logging. </code>SafeHandleError<code> is non-raising wrapper. </code>SafeLogEx<code> is similar but for informational logging. </code>SafeLogEvent<code> attempts </code>modAudit.LogEvent<code> via SafeApplicationRun and returns boolean success.&lt;br&gt;**Complexity:** Logging O(1), but </code>AppendLocalAudit<code> is O(#rows) for finding last row (End(xlUp)).&lt;br&gt;**Side-effects:** May create </code>_IFRS_Audit<code> sheet (very hidden), write rows to it, call external modules. Avoids UI exceptions. &lt;br&gt;**Invariants:** Logs are capped by </code>MAX_AUDIT_MSG_LEN<code>. Any secret redaction attempted by </code>RedactSecrets<code>. &lt;br&gt;**Failure modes:** If workbook protected or sheet creation fails, append is skipped silently. If </code>ShouldRaiseErrors<code> enabled, module may raise Err.Raise and bubble. &lt;br&gt;**Security:** Avoid logging raw secrets; </code>RedactSecrets<code> does basic replacements (e.g., </code>@<code> -&gt; </code>[at]<code>) but is intentionally conservative — improve heuristics if PII ingestion occurs. &lt;br&gt;**Tests:** Simulate absence/presence of </code>modError<code> / </code>modAudit<code> and assert fallback paths executed; ensure </code>_IFRS_Audit<code> created when missing; test </code>ShouldRaiseErrors<code> toggles cause Err.Raise. &lt;br&gt;**Notes:** </code>RedactSecrets<code> is intentionally lightweight; for high-sensitivity deployments add stricter redaction.   **GenerateCorrelationID / ExtractCorrelationFromVariant / CRC32String / HexFromLong** — *correlation &amp; lightweight CRC helpers*&lt;br&gt;**Purpose:** Produce stable correlation ids for logs and job ids; small CRC helper for stable keys; hex formatting utilities.&lt;br&gt;**Signature:** </code>Public Function GenerateCorrelationID() As String<code>, </code>Public Function ExtractCorrelationFromVariant(v As Variant) As String<code>, </code>Private Function CRC32String(s As String) As Long<code>, </code>Private Function HexFromLong(n As Long) As String<code>.&lt;br&gt;**Behavior:** </code>GenerateCorrelationID<code> builds timestamp-based ID with microsecond-ish hex derived from </code>Timer<code>. </code>CRC32String<code> computes 32-bit CRC non-cryptographic for stable keys. </code>ExtractCorrelationFromVariant<code> defensively converts variant to string or empty. </code>HexFromLong<code> renders fixed 8-char hex string. All handle errors and return safe defaults on failure.&lt;br&gt;**Complexity:** CRC O(len(s)), others O(1).&lt;br&gt;**Side-effects:** None. &lt;br&gt;**Invariants:** </code>GenerateCorrelationID<code> unique enough for correlation within session; </code>CRC32String<code> output stable. &lt;br&gt;**Failure modes:** CRC loops dependent on string length — extremely long strings increase compute but still linear. &lt;br&gt;**Security:** CRC not cryptographic; do not use for integrity/auth. &lt;br&gt;**Tests:** Deterministic outputs for known inputs; uniqueness checks for </code>GenerateCorrelationID<code> across short time intervals. &lt;br&gt;**Notes:** If stronger IDs required, integrate UUID generation.   **RedactSecrets / TruncateForCell** — *basic redaction &amp; truncation helpers*&lt;br&gt;**Purpose:** Simple heuristics to reduce secret leakage in logs; truncate strings to cell-friendly length.&lt;br&gt;**Signature:** </code>Private Function RedactSecrets(msg As String) As String<code>, </code>Private Function TruncateForCell(s As String, maxLen As Long) As String<code>.&lt;br&gt;**Behavior:** </code>RedactSecrets<code> performs elementary replacements (e.g., </code>@<code> -&gt; </code>[at]<code>) and truncates to </code>MAX_AUDIT_MSG_LEN<code>. </code>TruncateForCell<code> returns truncated string with ellipsis if over limit; used prior to writing audit cells.&lt;br&gt;**Complexity:** O(len(msg)).&lt;br&gt;**Side-effects:** None. &lt;br&gt;**Invariants:** Output length ≤ </code>MAX_AUDIT_MSG_LEN<code>. &lt;br&gt;**Failure modes:** Heuristics may not catch PII — treat as best-effort. &lt;br&gt;**Security:** This is not a substitute for dedicated PII scrubbing. &lt;br&gt;**Tests:** Strings containing emails, tokens, very long texts truncated. &lt;br&gt;**Notes:** Consider expanding redaction rules for tokens and keys in high-security deployments.   **IsMac / EnsureWorksheetExists** — *platform check &amp; safe sheet creation*&lt;br&gt;**Purpose:** </code>IsMac<code> detects host OS for platform-specific behaviour; </code>EnsureWorksheetExists<code> creates or returns a Worksheet and optionally marks it </code>veryHidden<code> while guarding errors.&lt;br&gt;**Signature:** </code>Public Function IsMac() As Boolean<code>, </code>Private Function EnsureWorksheetExists(sheetName As String, Optional veryHidden As Boolean = True) As Worksheet<code>.&lt;br&gt;**Behavior:** </code>IsMac<code> checks </code>Application.OperatingSystem<code> substring; </code>EnsureWorksheetExists<code> obtains </code>ThisWorkbook<code>, attempts to find sheet, else adds it after last worksheet, sets name and </code>Visible = xlSheetVeryHidden<code> if requested; returns Nothing on failure. Both swallow errors.&lt;br&gt;**Complexity:** O(1) for </code>IsMac<code>; sheet creation costs VBA/Excel workbook object operations. &lt;br&gt;**Side-effects:** May add a worksheet. &lt;br&gt;**Invariants:** </code>EnsureWorksheetExists<code> yields a Worksheet reference or Nothing; created sheets follow naming and visibility conventions. &lt;br&gt;**Failure modes:** If workbook protection prevents adding/renaming or name collision occurs, function returns Nothing silently. &lt;br&gt;**Tests:** Create new workbook, call ensure; call with existing sheet; protected workbook behaviour. &lt;br&gt;**Notes:** Use conservative behavior for hidden sheets to avoid exposing audit logs to users.   **BuildMaturityAnalysis / ExportSheetToCsv** — *export &amp; analysis helpers*&lt;br&gt;**Purpose:** </code>BuildMaturityAnalysis<code> writes a simple maturity table into </code>_IFRS_Maturity<code> (or custom) sheet; </code>ExportSheetToCsv<code> exports a worksheet to CSV via </code>SaveAs<code> by copying to a new workbook.&lt;br&gt;**Signature:** </code>Public Function BuildMaturityAnalysis(payments As Variant, Optional outSheetName As String = "_IFRS_Maturity") As Boolean<code>, </code>Private Function ExportSheetToCsv(sheetName As String, csvPath As String) As Boolean<code>.&lt;br&gt;**Behavior:** </code>BuildMaturityAnalysis<code> normalizes </code>payments<code>, ensures sheet exists via </code>EnsureWorksheetExists<code>, clears content, writes headers and each item row with correlation id and timestamp, truncates at </code>MAX_SCHEDULE_ROWS<code>. </code>ExportSheetToCsv<code> attempts </code>Worksheets(sheetName).Copy<code> to create new workbook then </code>SaveAs<code> with </code>xlCSV<code>, handling </code>Application.DisplayAlerts<code> toggling and closing workbook. Both functions return boolean success and log on error.&lt;br&gt;**Complexity:** O(n) for writing rows. </code>ExportSheetToCsv<code> costs workbook I/O. &lt;br&gt;**Side-effects:** Add/modify workbook content; create new workbook for CSV. &lt;br&gt;**Invariants:** Output sheet contains headers in expected columns. &lt;br&gt;**Failure modes:** File system permission errors on SaveAs, workbook state changes (ActiveWorkbook) — documented as side-effect risk. &lt;br&gt;**Security:** CSV may contain unredacted values — callers must ensure earlier redaction if needed. &lt;br&gt;**Tests:** Call </code>BuildMaturityAnalysis<code> with typical ranges; test </code>ExportSheetToCsv<code> on sample sheet and verify produced file. &lt;br&gt;**Notes:** Export path handling and user prompts are kept simple; recommend callers supply validated paths.   **YearFraction** — *deterministic daycount calculations*&lt;br&gt;**Purpose:** Compute fractional year between two dates using </code>dcAct365<code> (default), </code>dcAct360<code>, or </code>dc30_360<code> (basic US 30/360 approximation).&lt;br&gt;**Signature:** </code>Public Function YearFraction(ByVal d1 As Date, ByVal d2 As Date, Optional ByVal method As dayCountConvention = dcAct365) As Double<code> -&gt; Double.&lt;br&gt;**Behavior:** If either date zero returns 0. Else computes </code>DateDiff("d", d1, d2)<code> and applies divisor 365 or 360. For </code>dc30_360<code> computes classical 30/360 with end-of-month handling as implemented. Normalizes tiny negative values to 0 if below </code>1e-12<code>. Errors return 0.&lt;br&gt;**Complexity:** O(1). &lt;br&gt;**Side-effects:** None. &lt;br&gt;**Invariants:** Output non-negative for small rounding negatives. &lt;br&gt;**Failure modes:** Date order assumptions (d2 before d1) lead negative values (then normalized only if tiny). Document that negative durations produce negative fractions unless within negligible epsilon. &lt;br&gt;**Tests:** Common date pairs for each daycount, end-of-month scenarios, tiny differences normalization. &lt;br&gt;**Notes:** Implementers requiring different 30/360 variants should extend with explicit method codes.   **CalculationsSelfTest** — *expanded deterministic self-test harness*&lt;br&gt;**Purpose:** Run deterministic module self-tests repeatedly (10×) and record results to </code>_IFRS_TestResults<code> sheet and optionally register test with </code>modTests.RegisterSelfTest<code>. Provides smoke, regression, and golden-value checks for core functions.&lt;br&gt;**Signature:** </code>Public Function CalculationsSelfTest() As Boolean<code> -&gt; Boolean PASS/FAIL.&lt;br&gt;**Behavior:** Runs a set of checks: </code>CalcDepreciationEx<code> variants, </code>CalcEBITDA<code>, </code>RecognizeRevenue<code>, </code>ExpectedCreditLoss<code>, </code>DeferredTax<code>, lease amortization basics, </code>PvFromPmt<code> under tiny rates, </code>NPVFromArray<code> scalar &amp; array, ECL boundaries, salvage clamping, units-of-production schedule sum test, </code>YearFraction<code> assertions, </code>NormalizePaymentsForRead<code> smoke. Repeats loop 10× to detect resource leaks/glitches. Writes PASS/FAIL with timestamp and </code>MODCALC_VERSION<code> to </code>_IFRS_TestResults<code> sheet (creates veryHidden sheet if absent). Attempts to register self-test with central runner via </code>SafeApplicationRun("modTests.RegisterSelfTest", ...)<code>. Logs test result via </code>SafeLogEx<code>. Returns boolean and logs via </code>HandleCalcError<code> on exceptions.&lt;br&gt;**Complexity:** O(K) where K is number of test checks; each test may execute O(n) internal operations (e.g., schedule) — overall modest but heavier than typical function call. &lt;br&gt;**Side-effects:** Writes to workbook </code>_IFRS_TestResults<code>; calls </code>modTests<code> if available; logs. &lt;br&gt;**Invariants:** Deterministic tests should remain stable across minor rounding changes — if rounding policy changes, update fixture expectations. &lt;br&gt;**Failure modes:** Tests may fail on differing rounding policy, platform arithmetic differences, or missing helper modules (modUtilities). &lt;br&gt;**Security:** Test writes into workbook — ensure test sheet is veryHidden to avoid exposing internal outputs. &lt;br&gt;**Tests:** This function is itself the test harness; CI should assert it returns True. Run under various rounding and config settings. &lt;br&gt;**Notes:** Keep tests small and deterministic; if expanding, add verbosity flags for debug-only logging.   **Job lifecycle hooks: EnqueueCalculationJob / UpdateJobMeta / FindJobRow / CancelCalculationJob / FindJobRowInSheet / ReconcileOrphanedJobs / ReconcileOrphanedJobsOnOpen** — *lightweight job integration with modRibbonCallbacks*&lt;br&gt;**Purpose:** Integrate calculation jobs with a central job sheet or ribbon-based job queue (</code>modRibbonCallbacks<code>) for background/async work via queued correlation ids. Provide best-effort fallbacks if central module not available.&lt;br&gt;**Signature:** </code>Public Function EnqueueCalculationJob(jobName As String, meta As Variant) As String<code>, </code>Public Function UpdateJobMeta(correlationId As String, meta As Variant) As Boolean<code>, </code>Public Function FindJobRow(correlationId As String) As Long<code>, </code>Public Function CancelCalculationJob(correlationId As String) As Boolean<code>, </code>Public Function FindJobRowInSheet(sheetName As String, correlationId As String) As Long<code>, </code>Private Sub ReconcileOrphanedJobs()<code>, </code>Private Sub ReconcileOrphanedJobsOnOpen()<code>.&lt;br&gt;**Behavior:** </code>EnqueueCalculationJob<code> generates </code>cid<code> via </code>GenerateCorrelationID<code> and attempts </code>modRibbonCallbacks.EnqueueJob<code>; falls back to local </code>SafeLogEx<code> and returns cid even if central enqueue missing. </code>UpdateJobMeta<code>, </code>FindJobRow<code>, </code>CancelCalculationJob<code> attempt </code>modRibbonCallbacks<code> calls via </code>SafeApplicationRun<code> and return boolean / row. </code>FindJobRowInSheet<code> searches a local jobs sheet by scanning first column. </code>ReconcileOrphanedJobs<code> and </code>ReconcileOrphanedJobsOnOpen<code> call </code>modRibbonCallbacks<code> reconciliation hooks if present; otherwise logs and skip. All functions swallow errors and return safe defaults (empty string, False, 0) on failure.&lt;br&gt;**Complexity:** </code>Enqueue<code>, </code>Update<code>, </code>FindJobRow<code> O(1) for remote call; </code>FindJobRowInSheet<code> O(r) rows scanned. </code>Reconcile<code> O(1) remote call. &lt;br&gt;**Side-effects:** May call into </code>modRibbonCallbacks<code> which can manipulate a job sheet. </code>Enqueue<code> returns cid regardless of central poster presence ensuring downstream correlation even if the central queue is missing. &lt;br&gt;**Invariants:** Returned cid must be unique (module uses </code>GenerateCorrelationID<code>). Fallback behavior logged. &lt;br&gt;**Failure modes:** Central module absence leads to local only logging and inability to cancel centrally; documented as best-effort. &lt;br&gt;**Security:** meta payload may contain sensitive data — callers should redact before passing or ensure </code>HandleCalcError<code>/audit paths scrub secrets. &lt;br&gt;**Tests:** Enqueue+FindRoundtrip when </code>modRibbonCallbacks<code> present; behavior when absent; </code>FindJobRowInSheet<code> finds rows correctly; cancellation fallback returns False when central not present. &lt;br&gt;**Notes:** Keep lightweight to avoid tight coupling; prefer idempotent job operations.   **ExtractString / ExtractString small helper** — *variant-to-string helper*&lt;br&gt;**Purpose:** Defensive conversion of variants to strings returning empty string for Error/Null to avoid downstream exceptions.&lt;br&gt;**Signature:** </code>Private Function ExtractString(v As Variant) As String<code>.&lt;br&gt;**Behavior:** If </code>IsError<code> or </code>IsNull<code> return </code>""<code> else </code>CStr(v)<code>. Swallows errors.&lt;br&gt;**Complexity:** O(1). &lt;br&gt;**Side-effects:** None. &lt;br&gt;**Invariants:** Return type string always. &lt;br&gt;**Failure modes:** Rare; always returns </code>""<code> on error. &lt;br&gt;**Tests:** Error variants and Null, numeric inputs converted to string. &lt;br&gt;**Notes:** Micro helper but avoids repeated defensive code.   **ReconcileOrphanedJobs (private) / ReconcileOrphanedJobsOnOpen** — *best-effort reconciliation hooks*&lt;br&gt;**Purpose:** Try to call central reconciliation routines present in </code>modRibbonCallbacks<code> for job cleanup on workbook open; fallback to logging if absent.&lt;br&gt;**Signature:** </code>Private Sub ReconcileOrphanedJobs()<code> and </code>Private Sub ReconcileOrphanedJobsOnOpen()<code> (no outputs).&lt;br&gt;**Behavior:** </code>SafeApplicationRun("modRibbonCallbacks.ReconcileJobsOnOpen", r)<code> attempted; on failure logs via </code>SafeLogEx<code>. Designed as best-effort with no throw semantics.&lt;br&gt;**Complexity:** O(1). &lt;br&gt;**Side-effects:** Possibly triggers central reconciliation side-effects in host job sheet. &lt;br&gt;**Invariants:** Should not raise; safe to be called from Workbook_Open. &lt;br&gt;**Failure modes:** Missing central routine -&gt; logged only. &lt;br&gt;**Tests:** Call when central reconciliation exists and when not. &lt;br&gt;**Notes:** Hook to be wired to host Workbook_Open shim if desired.   **Export &amp; developer guidance comments** — *module-level maintenance notes*&lt;br&gt;**Purpose:** Provide maintainers explicit guidance: preserve public API, call </code>InvalidateModCalculationsCache<code> when adding config, avoid Select/Activate, limit schedule rows, and self-test hooks. Also points to possible improvements (typed UDTs, central rounding consistency, job reconcilers).&lt;br&gt;**Behavior &amp; Notes:** These are comments within the module — not executable. They are the authoritative implementation guidance for future maintainers. &lt;br&gt;**Tests / CI:** Ensure </code>CalculationsSelfTest<code> executed in CI; add API surface checker asserting public functions remain. &lt;br&gt;**Notes:** Always update </code>MODCALC_VERSION<code> after behaviour-affecting changes.   **Security, logging &amp; operational summary (module-level)** — *concise summary of security decisions &amp; operational behaviour*&lt;br&gt;**Purpose:** Explain cross-cutting behaviours: defensive error swallowing by default (non-UI raising), redaction attempt before audit writes, centralized rounding delegation with graceful fallback, caching of config values, and conservative numeric clamps to avoid overflows or runaway loops.&lt;br&gt;**Behavior:** Module routes errors to </code>modError<code>/</code>modAudit<code> when available; otherwise uses local </code>_IFRS_Audit<code>. Rounding may call host </code>modUtilities<code> if configured. Schedules are capped by </code>MAX_SCHEDULE_ROWS<code> and </code>PV_MAX_NPER<code>. Numeric conversion helpers centralize fallback behaviour to avoid </code>#VALUE!<code> or host exceptions.&lt;br&gt;**Complexity &amp; Performance:** Most heavy operations are O(n) linear with schedule length or input arrays and are capped to prevent denial-of-service via large ranges. Prefer callers to batch and use variant arrays for worksheet IO. &lt;br&gt;**Failure modes:** External dependencies (modConfig, modAudit, modUtilities, modRibbonCallbacks) are optional — module falls back to local behaviour but loses central features (telemetry, job-based cancellation). &lt;br&gt;**Security:** </code>RedactSecrets<code> is best-effort; do not rely on it for compliance. Audit messages truncated to </code>MAX_AUDIT_MSG_LEN<code>. &lt;br&gt;**Recommended Tests:** Full list (concise): tokenizer-equivalent tests not applicable; instead: 1) Rounding parity across policies, 2) schedule sums and last-principal adjustment, 3) PvFromPmt tiny-rate behaviour, 4) NPVWithArray various index bases &amp; negative rates, 5) NormalizePaymentsForRead shapes (Range/Collection/Dictionary), 6) Error routing fallbacks (modError absent), 7) Config cache invalidation, 8) SelfTest pass/fail under multiple config permutations, 9) Job enqueue/find/cancel fallbacks, 10) Audit sheet creation &amp; truncation behaviour. &lt;br&gt;**Maintenance notes:** When modifying numeric algorithms (tokenizers not present here), add numeric regression tests and increment </code>MODCALC_VERSION`. Keep public signatures unchanged unless coordinated with migration plan. </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><div class="table-caption" id="Table4" data-table="Docu_0159_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modConfig)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modConfig)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modConfig)"> <strong>Module overview & constants</strong> — <em>central config, persistence, migration, and feature-flag utilities</em><br><strong>Purpose:</strong> Encapsulates loading/saving configuration XML (CustomXMLPart preferred, worksheet fallback), feature-flag typed getters/setters, migration registry and deterministic migration runner, checksum helpers, secret delegation, safe write policies (write-through / write-back with debounce), audit delegation, and a self-test harness. Exposes a stable public API used by the AddIn lifecycle (bootstrap, ribbon callbacks, domain modules).<br><strong>Public constants:</strong> <code>CFG_ROOT_NAME</code>,<code>CFG_PART_KEY</code>,<code>CFG_SCHEMA_PROP</code>,<code>CFG_CHECKSUM_PROP</code>, audit & delegate names, canonical feature-flag keys, default boolean flags, <code>AUDIT_MESSAGE_MAX_LEN</code>.<br><strong>Module state:</strong> Migration registry, scripting/ADODB availability flags, initialization guard, in-memory cache (<code>CacheXml</code> / <code>CacheTimestamp</code> / <code>CacheDirty</code>), write policy and debounce fields, <code>ModuleLock</code>, <code>TestModeEnabled</code>, <code>LastValidationError</code>, <code>RibbonInvalidateCallbacks</code>.<br><strong>Security notes:</strong> Defaults safer-by-default (no plaintext secret persist), delegated audit and secret access via <code>TryRunReturn</code> to allow centralized policy. All XML inserts use escaping. Avoids <code>innerHTML</code>-style operations (VBA DOM not used).<br><strong>Recommended tests:</strong> Module init permutations, both CustomXML and sheet fallback persistence, write-back debounce behavior, migration happy/failure paths, checksum mismatch scenario. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>LogAuditLocal(action, message, Optional correlationId, Optional meta)</strong> — <em>safe, non-raising audit delegate</em><br><strong>Purpose:</strong> Write audit entries preferring <code>modAudit.LogAudit</code>, falling back to top-level <code>LogAudit</code>, then to Immediate Window. Prevents raising errors to callers.<br><strong>Signature:</strong> <code>Private Sub LogAuditLocal(ByVal action As String, ByVal message As String, Optional ByVal correlationId As String = &quot;&quot;, Optional ByVal meta As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Truncates message to <code>AUDIT_MESSAGE_MAX_LEN</code>, calls <code>TryRunReturn(AUDIT_PROC_NAME, ...)</code> then <code>TryRunReturn(&quot;LogAudit&quot;, ...)</code>. If both return Empty, writes <code>Debug.Print</code>. Swallows errors via <code>On Error Resume Next</code> so audit never throws.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call external modules; may reveal partial information to Immediate Window (non-secure).<br><strong>Failure modes:</strong> Delegates missing → fallback; if delegate throws, errors suppressed. <br><strong>Security:</strong> Avoids writing full secrets (message trimmed). Ensure meta/correlation not contain PII before calling. <br><strong>Tests:</strong> Force delegate missing, ensure no exception and Immediate Window message appears; verify truncation. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>LoadConfigXML()</strong> — <em>load authoritative config XML (checksum-verified)</em><br><strong>Purpose:</strong> Retrieve configuration XML from the preferred store: CustomXMLPart (checked against stored checksum) or sheet fallback. Caches value in memory for TTL.<br><strong>Signature:</strong> <code>Public Function LoadConfigXML() As String</code><br><strong>Behavior:</strong> If <code>ModuleLock</code> and <code>CacheXml</code> non-empty return cache. Calls <code>FindConfigPart()</code>; if no CustomXMLPart found uses <code>FallbackLoadFromSheet()</code>. If found, computes checksum via <code>ComputeChecksumForCustomXMLPart(part)</code> and compares against stored <code>CFG_CHECKSUM_PROP</code> document property (if present). On mismatch performs <code>BackupConfigXML</code> and logs audit, returns empty string. On success sets cache fields and returns <code>part.xml</code>. On error returns empty and logs via <code>LogAuditLocal</code>.<br><strong>Complexity:</strong> O(n) where n is CustomXML part enumeration + checksum computation cost (which may be O(bytes) for CRC/SHA).<br><strong>Side-effects:</strong> Reads CustomXMLParts and CustomDocumentProperties; may call backup or audit on mismatch. Updates in-memory cache. <br><strong>Invariants:</strong> If checksum property exists, returned XML must match it. Cache updated on successful load. <br><strong>Failure modes:</strong> Absence of parts → fallback; checksum mismatch → returns empty; IO/COM errors swallowed and audited. <br><strong>Security:</strong> Uses computed checksum to detect tampering; ensure certificate utility availability not assumed. <br><strong>Tests:</strong> Part present with matching checksum; checksum mismatch leads to backup & empty return; fallback to sheet when no parts. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>LoadConfig()</strong> — <em>backwards-compatible alias</em><br><strong>Purpose:</strong> Compatibility wrapper for older callers.<br><strong>Signature:</strong> <code>Public Function LoadConfig() As String</code> — returns <code>LoadConfigXML()</code>.<br><strong>Behavior/Complexity/Tests:</strong> trivial alias. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetConfigCached(Optional forceRefresh As Boolean = False)</strong> — <em>cached accessor with TTL</em><br><strong>Purpose:</strong> Return in-memory cached config if valid; optionally force reload.<br><strong>Signature:</strong> <code>Public Function GetConfigCached(Optional ByVal forceRefresh As Boolean = False) As String</code><br><strong>Behavior:</strong> Ensures module initialized. If cache present and TTL not expired (or TTL=0 indicates infinite) and not forceRefresh, returns cached value; otherwise calls <code>LoadConfigXML()</code> to refresh cache. Updates <code>CacheTimestamp</code> and <code>CacheDirty=false</code> on refresh. Logs on error.<br><strong>Complexity:</strong> O(1) for cache hit; cost of <code>LoadConfigXML()</code> on miss. <br><strong>Side-effects:</strong> May trigger load and checksum/path checks. <br><strong>Invariants:</strong> Cache TTL honored. <br><strong>Failure modes:</strong> Load failure returns empty; error audited. <br><strong>Tests:</strong> TTL behavior, forceRefresh true forces reload. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>InvalidateConfigCache()</strong> — <em>clear in-memory cache</em><br><strong>Purpose:</strong> Immediately clear <code>CacheXml</code>/<code>CacheTimestamp</code>/<code>CacheDirty</code>.<br><strong>Signature:</strong> <code>Public Sub InvalidateConfigCache()</code><br><strong>Behavior:</strong> Sets cache fields to empty / zero. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> After invalidation subsequent <code>GetConfigCached</code> triggers reload. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SetCacheTTL(seconds As Long)</strong> — <em>configure TTL</em><br><strong>Purpose:</strong> Set <code>CacheTTLSeconds</code> (0 means infinite).<br><strong>Signature:</strong> <code>Public Sub SetCacheTTL(ByVal seconds As Long)</code><br><strong>Behavior:</strong> Validation: negative → clamp to 0. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Negative values set to 0. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SetWriteDebounce(seconds As Long)</strong> — <em>configure debounce interval for write-back</em><br><strong>Purpose:</strong> Sets <code>WriteDebounceSeconds</code> used when <code>WritePolicy=write_back</code> to delay persistent writes.<br><strong>Signature:</strong> <code>Public Sub SetWriteDebounce(ByVal seconds As Long)</code><br><strong>Behavior:</strong> Clamps negative to 0. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Debounce only used by <code>SetSetting</code>/<code>FeatureFlag_SetTyped</code> logic. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SetWritePolicy(policy As String)</strong> — <em>choose write-through vs write-back</em><br><strong>Purpose:</strong> Configure persistence semantics: immediate (write-through) or cached (write-back).<br><strong>Signature:</strong> <code>Public Sub SetWritePolicy(ByVal policy As String)</code><br><strong>Behavior:</strong> Accepts <code>WRITE_POLICY_WRITE_BACK</code> (case-insensitive) => use write-back; otherwise defaults to write-through. Ignores empty input. <br><strong>Complexity:</strong> O(1).<br><strong>Security/Operational:</strong> write-back increases chance of cache loss on crash; write-through is safer but slower. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExportConfigToFile(fullPath As String) As Boolean</strong> — <em>atomic export via temp file</em><br><strong>Purpose:</strong> Export current config (cached) to an external file with atomic semantics (temp->rename) and safe fallbacks (FileSystemObject copy).<br><strong>Signature:</strong> <code>Public Function ExportConfigToFile(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong> Reads <code>GetConfigCached()</code>. If empty, returns False. Builds temp path via <code>GetSafeTempFolder()</code> (fall back to workbook path / DefaultFilePath), writes binary file using <code>Open For Binary</code> and <code>Put</code>. Attempts <code>KillSafe</code> of destination then <code>Name tmpFile As fullPath</code> (atomic rename). If rename fails uses <code>Scripting.FileSystemObject.CopyFile</code>. Deletes temp on success. Logs and returns True/False. Uses randomized suffix for temp file uniqueness. <br><strong>Complexity:</strong> O(bytes) for writing. <br><strong>Side-effects:</strong> Creates temp files; may call <code>KillSafe</code> and FSO. <br><strong>Failure modes:</strong> IO permission errors, no safe temp folder; errors audited and temp cleaned. <br><strong>Tests:</strong> Export to writable path; simulate write-permission failure. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExportConfigFile(fullPath As String)</strong> — <em>alias for ExportConfigToFile</em><br><strong>Purpose:</strong> Backwards-compatible wrapper. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ImportConfigFromFile(fullPath As String) As Boolean</strong> — <em>atomic import + validation</em><br><strong>Purpose:</strong> Import config XML from an external file into the live config store (validated before persist).<br><strong>Signature:</strong> <code>Public Function ImportConfigFromFile(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong> Reads entire file as binary to string. If empty returns False. Calls <code>ValidateConfigXML_Explain(xml)</code>. On validation failure logs and returns False. Otherwise calls <code>SaveConfigXML(xml)</code> to persist. On error logs details and returns False. Uses correlation id in audit messages. <br><strong>Complexity:</strong> O(bytes). <br><strong>Side-effects:</strong> May change CustomXMLParts via <code>SaveConfigXML</code>. <br><strong>Failure modes:</strong> File missing/permissions; invalid XML; Save failure. <br><strong>Tests:</strong> Round-trip export/import. Simulate invalid xml to ensure rejection. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>FeatureFlag_GetTyped(key) / FeatureFlag_Get / FeatureFlag_IsEnabled</strong> — <em>typed feature flag readers with expiry</em><br><strong>Purpose:</strong> Read feature-flag entries from config XML with optional type and expiry extraction. <code>FeatureFlag_GetTyped</code> returns <code>(value, type, expiryDate)</code> as Variant(1..3); <code>FeatureFlag_Get</code> returns raw value; <code>FeatureFlag_IsEnabled</code> returns boolean using type parsing and expiry check.<br><strong>Signatures:</strong> <code>Public Function FeatureFlag_GetTyped(ByVal key As String) As Variant</code> / <code>Public Function FeatureFlag_Get(ByVal key As String) As Variant</code> / <code>Public Function FeatureFlag_IsEnabled(ByVal key As String) As Boolean</code><br><strong>Behavior:</strong> Performs string search on cached XML for <code>key=&quot;...&quot;</code> then extracts <code>value=&quot;...&quot;</code>, optional <code>type=&quot;...&quot;</code> and <code>expires=&quot;...&quot;</code>. Converts <code>expires</code> to Date if possible. <code>IsEnabled</code> converts value string to boolean (<code>&quot;true&quot;</code>, <code>&quot;1&quot;</code> -> True) and checks expiry. All operations defensive; on missing data returns Empty / False. Uses <code>EscapeXml</code> when building search pattern. <br><strong>Complexity:</strong> O(len(xml)). <br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> XML malformed or not present → returns Empty/False silently. <br><strong>Tests:</strong> Flag present with expiry in past -> false, present with <code>&quot;true&quot;</code> -> true, absent -> Empty/False. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Config_GetSecret / Config_SetSecret</strong> — <em>delegated secret accessors</em><br><strong>Purpose:</strong> Provide secret retrieval and persistence via <code>modSecurity</code> delegate or fallback functions; avoid storing secrets locally if not allowed.<br><strong>Signatures:</strong> <code>Public Function Config_GetSecret(ByVal key As String) As String</code> / <code>Public Function Config_SetSecret(ByVal key As String, ByVal secretValue As String) As Boolean</code><br><strong>Behavior:</strong> Attempts <code>TryRunReturn(&quot;modSecurity.Config_GetSecret&quot;, key)</code> or top-level <code>Config_GetSecret</code>. <code>Config_SetSecret</code> tries <code>modSecurity.Config_SetSecret</code> then top-level <code>Config_SetSecret</code>. If no delegate available refuses to persist and logs audit (returns False). Silent error handling. <br><strong>Complexity:</strong> O(1) per delegate call. <br><strong>Security:</strong> Ensures secrets not persisted plaintext by default — module refuses to persist when no delegate. Logging must not contain secret material. <br><strong>Tests:</strong> Provide fake <code>modSecurity</code> module; ensure delegation works; ensure default refusal when delegate absent. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetLastValidationError()</strong> — <em>last validation reason</em><br><strong>Purpose:</strong> Return <code>LastValidationError</code> from last validation run. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Migration registry: RegisterMigration / RegisterBuiltInMigrations / BuildMigrationPath / RunMigrations</strong> — <em>deterministic migration framework</em><br><strong>Purpose:</strong> Allow registration of named migration routines and deterministic building of migration path from <code>currentVersion</code> to <code>targetVersion</code>. Built-in registration runs at init. <code>RunMigrations</code> applies each migration routine in order; optional <code>commit</code> persists result via <code>SaveConfigXML</code>.<br><strong>Signatures:</strong> <code>Public Sub RegisterMigration(fromVersion, toVersion, routineName)</code>, <code>Private Sub RegisterBuiltInMigrations()</code>, <code>Private Function BuildMigrationPath(currentVersion, targetVersion) As Collection</code>, <code>Public Function RunMigrations(currentXml, targetVersion, Optional commit=False) As String</code><br><strong>Behavior:</strong> Uses <code>Scripting.Dictionary</code> (<code>MigrationRegistry</code>) if available. <code>RegisterBuiltInMigrations</code> adds <code>1.0.0|1.1.0</code> -> <code>Migrate_v1_0_0_to_v1_1_0</code>. <code>BuildMigrationPath</code> walks registry greedily picking smallest <code>toVersion</code> candidate from <code>cur</code> until target reached (guards with safety counter). <code>RunMigrations</code> resolves path and for known routine <code>Migrate_v1_0_0_to_v1_1_0</code> calls locally, otherwise uses <code>TryRunReturn</code> to invoke external routine; any failure aborts with empty string and audit. If <code>commit</code> True, <code>SaveConfigXML</code> attempted; on failure returns empty string. <br><strong>Complexity:</strong> Building path O(#migrations) loop; applying routines cost depends on routine. <br><strong>Side-effects:</strong> May call external routines; may persist config when <code>commit=True</code>. <br><strong>Invariants:</strong> MigrationRegistry contains deduped keys; <code>BuildMigrationPath</code> returns Nothing when no path found. <br><strong>Failure modes:</strong> Registry unavailable -> migrations disabled; external routine uncallable -> abort; infinite loop guarded by safety limit (100). <br><strong>Tests:</strong> Register synthetic migrations and verify path selection; test direct mapping and multi-step path. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Migrate_v1_0_0_to_v1_1_0(currentXml) As String</strong> — <em>concrete migration implementation</em><br><strong>Purpose:</strong> Transform v1.0.0 -> v1.1.0 by updating <code>&lt;SchemaVersion&gt;</code> element and annotating <code>&lt;Templates&gt;</code> with version attribute if present.<br><strong>Signature:</strong> <code>Private Function Migrate_v1_0_0_to_v1_1_0(ByVal currentXml As String) As String</code><br><strong>Behavior:</strong> Extracts old version, replaces <code>&lt;SchemaVersion&gt;</code> value with <code>1.1.0</code> or injects element if missing. Replaces <code>&lt;Templates&gt;</code> → <code>&lt;Templates version=&quot;1.1.0&quot;&gt;</code> if present. Returns transformed XML or empty on error. <br><strong>Complexity:</strong> O(len(xml)).<br><strong>Failure modes:</strong> If input XML malformed, returns empty and logs. <br><strong>Tests:</strong> Input with and without <code>&lt;SchemaVersion&gt;</code> and <code>&lt;Templates&gt;</code> tags ensures correct insertion/replacement. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Checksum helpers: ComputeChecksumForCustomXMLPart / ComputeSHA256_UsingCertUtil / ComputeCRC32String / CRC32Table</strong> — <em>hybrid checksum strategy with system fallback</em><br><strong>Purpose:</strong> Provide robust checksum for CustomXMLPart: prefer SHA256 via <code>certutil</code> command when available, otherwise fallback to CRC32 of UTF-8 bytes. Normalizes to lowercase hex string.<br><strong>Signatures:</strong> <code>Private Function ComputeChecksumForCustomXMLPart(part As CustomXMLPart) As String</code>, <code>Private Function ComputeSHA256_UsingCertUtil(ByVal s As String) As String</code>, <code>Private Function ComputeCRC32String(ByVal s As String) As String</code>, <code>Private Function CRC32Table() As Long()</code><br><strong>Behavior:</strong> <code>ComputeChecksumForCustomXMLPart</code> attempts <code>ComputeSHA256_UsingCertUtil(part.xml)</code>; on empty fallback to <code>ComputeCRC32String(part.xml)</code> and logs fallback. <code>ComputeSHA256_UsingCertUtil</code> writes string to temp file, spawns <code>cmd /c certutil -hashfile &quot;&lt;file&gt;&quot; SHA256</code> via WScript.Shell.Exec, waits up to 10s, reads StdOut, parses hex line of length ≥64 and returns first 64 hex chars cleaned; attempts robust cleaning. <code>ComputeCRC32String</code> converts string to UTF-8 bytes via <code>StrToUtf8Bytes</code>, iterates CRC32 using table (returns hex zero-padded 8 chars). <code>CRC32Table</code> builds standard 256-entry table. <br><strong>Complexity:</strong> O(bytes) for hashing; <code>certutil</code> external call cost unknown. <br><strong>Side-effects:</strong> Creates and deletes temp files; invokes external process (requires Windows <code>certutil</code> and WScript Shell). May set <code>ADODBAvailable</code> earlier checked. <br><strong>Security:</strong> External process call increases attack surface; temp file contains XML contents — ensure temp folder choice is secure and ephemeral; ensure secrets not written to disk. <br><strong>Failure modes:</strong> No <code>WScript.Shell</code>, <code>certutil</code>, or command fails → fallback to CRC32. Non-hex output parsing tolerant. <br><strong>Tests:</strong> Provide known inputs and compare to known SHA256/CRC32; test <code>certutil</code> unavailable path. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>StrToUtf8Bytes(s) As Byte()</strong> — <em>safe string -> UTF-8 bytes conversion with ADODB fallback</em><br><strong>Purpose:</strong> Convert VBA Unicode string to UTF-8 byte array. Uses <code>ADODB.Stream</code> when available (recommended), else <code>StrConv(..., vbFromUnicode)</code> fallback (ANSI).<br><strong>Signature:</strong> <code>Private Function StrToUtf8Bytes(ByVal s As String) As Byte()</code><br><strong>Behavior:</strong> Attempts ADODB Stream (<code>Type=2</code>, <code>Charset=&quot;utf-8&quot;</code>, write text, then switch to binary and <code>Read</code>). On error uses <code>StrConv(s, vbFromUnicode)</code> and returns result. Properly closes stream on error. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Failure modes:</strong> ADODB unavailable -> fallback ANSI (may lose characters). <br><strong>Tests:</strong> Unicode strings with non-ASCII characters must round-trip when ADODB present; otherwise document fallback limitation. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>EscapeXml(s) As String</strong> — <em>defensive XML attribute/content escaping</em><br><strong>Purpose:</strong> Replace <code>&amp; &lt; &gt; &quot; &#x27;</code> with XML entities for safe injection into attribute values and contents when building XML strings manually.<br><strong>Signature:</strong> <code>Private Function EscapeXml(ByVal s As String) As String</code><br><strong>Behavior:</strong> Simple replacement chain with <code>Replace</code>. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Security:</strong> Centralized escaping reduces injection risk; must be applied consistently when injecting into XML attribute or text. <br><strong>Tests:</strong> Strings with <code>&amp;</code> and <code>&quot;</code> should be escaped to <code>&amp;amp;</code> and <code>&amp;quot;</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>PropExists(propName) As Boolean</strong> — <em>safe CustomDocumentProperty existence probe</em><br><strong>Purpose:</strong> Determine presence of a CustomDocumentProperty without raising an exception.<br><strong>Signature:</strong> <code>Private Function PropExists(ByVal propName As String) As Boolean</code><br><strong>Behavior:</strong> Tries <code>ThisWorkbook.CustomDocumentProperties(propName)</code>, returns True on no error, False otherwise. Clears error state. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Property present/absent cases. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetThisAddinSchemaVersion() As String</strong> — <em>module-local schema version</em><br><strong>Purpose:</strong> Returns <code>&quot;1.1.0&quot;</code> as the add-in schema version. Centralizes version string. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetSafeTempFolder() As String</strong> — <em>heuristic safe temp folder selection</em><br><strong>Purpose:</strong> Return a plausible temp directory: checks <code>TEMP</code>, <code>TMP</code> env vars, <code>ThisWorkbook.path</code>, <code>Application.DefaultFilePath</code>, and on Mac attempts <code>MacScript</code> POSIX temp. Returns first valid candidate.<br><strong>Signature:</strong> <code>Private Function GetSafeTempFolder() As String</code><br><strong>Behavior:</strong> Adds candidates into Collection, returns first non-empty. Defensive with On Error Resume Next for each call. <br><strong>Complexity:</strong> O(#candidates). <br><strong>Failure modes:</strong> MacScript may fail on Windows; returns empty string if none found. <br><strong>Tests:</strong> Simulate different environments (Windows/Mac) by mocking Environ and Application.DefaultFilePath. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetCorrelationId() As String</strong> — <em>stable request id generator (GUID preferred)</em><br><strong>Purpose:</strong> Provide a correlation id for audits and backups. Prefers GUID via <code>Scriptlet.TypeLib</code> otherwise uses timestamp+random suffix.<br><strong>Signature:</strong> <code>Private Function GetCorrelationId() As String</code><br><strong>Behavior:</strong> Attempts <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code>, strips braces and lowercases. On error uses <code>Format(Now, &quot;yyyymmdd_HHNNSS&quot;) &amp; &quot;_&quot; &amp; random6</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Security/Privacy:</strong> Non-identifying; GUID is random. <br><strong>Tests:</strong> Ensure deterministic format and uniqueness across multiple calls. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>EnsureModuleInitialized()</strong> — <em>idempotent init and capability probes</em><br><strong>Purpose:</strong> Initialize <code>MigrationRegistry</code>, test availability of <code>Scripting.Dictionary</code> and <code>ADODB.Stream</code>, set defaults (CacheTTLSeconds=60, WritePolicy write-through, WriteDebounceSeconds=0).<br><strong>Signature:</strong> <code>Private Sub EnsureModuleInitialized()</code><br><strong>Behavior:</strong> If not initialized, calls <code>RegisterBuiltInMigrations</code> and probes <code>Scripting.Dictionary</code> and <code>ADODB.Stream</code>, sets flags, Randomize, and sets <code>ModuleInitialized=True</code>. Logs missing capabilities. <br><strong>Complexity:</strong> O(1) with small COM probes. <br><strong>Side-effects:</strong> Creates objects transiently. <br><strong>Tests:</strong> Run on systems with/without Scripting/ADODB. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>AppendChangeHistory(action, oldValue, newValue, correlationId)</strong> — <em>append auditable change row to a workbook worksheet</em><br><strong>Purpose:</strong> Maintain local human-readable change log in worksheet <code>_IFRS_ConfigHistory</code> with timestamp, user, action, redacted old/new, correlation id.<br><strong>Signature:</strong> <code>Private Sub AppendChangeHistory(ByVal action As String, ByVal oldValue As String, ByVal newValue As String, ByVal correlationId As String)</code><br><strong>Behavior:</strong> Ensures <code>_IFRS_ConfigHistory</code> sheet exists (creates and headers if needed), appends row with sanitized values by <code>RedactSecrets</code>. Errors logged via <code>LogAuditLocal</code>. <br><strong>Complexity:</strong> O(1) per append (worksheet row append). <br><strong>Security:</strong> Redacts common tokens (<code>password=</code>, <code>secret=</code>) and truncates long values to 200 chars. Not a replacement for secure audit storage; sheet accessible to users. <br><strong>Tests:</strong> Append entries and inspect row contents & redaction. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RedactSecrets(v) As String</strong> — <em>simple secret redaction utility</em><br><strong>Purpose:</strong> Replace <code>password=</code>/<code>secret=</code> patterns with <code>[REDACTED]</code> and truncate long strings >200 chars.<br><strong>Signature:</strong> <code>Private Function RedactSecrets(ByVal v As String) As String</code><br><strong>Behavior:</strong> Case-insensitive replace and truncation. Lightweight heuristic—not exhaustive. <br><strong>Security:</strong> Heuristic redaction only; avoid relying on it for compliance. <br><strong>Tests:</strong> Strings containing <code>password=abc</code> become <code>password=[REDACTED]</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>FallbackSaveToSheet(xml) / FallbackLoadFromSheet()</strong> — <em>sheet-based persistence fallback</em><br><strong>Purpose:</strong> Save/load config XML to a workbook worksheet <code>_IFRS_ConfigSheet</code> when CustomXMLParts unavailable. Used as best-effort persistence for legacy or constrained environments.<br><strong>Signatures:</strong> <code>Private Function FallbackSaveToSheet(ByVal xml As String) As Boolean</code> / <code>Private Function FallbackLoadFromSheet() As String</code><br><strong>Behavior:</strong> Creates worksheet if missing, saves XML into cell A2. Load reads A2. Errors logged. <br><strong>Complexity:</strong> O(len(xml)) for writing cell; may be limited by cell size / workbook constraints. <br><strong>Failure modes:</strong> Very large XML may exceed cell limits; sheet visible to users (not secure). <br><strong>Tests:</strong> Write and read back identical payload. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>BackupConfigXML(xml)</strong> — <em>write backup file to safe temp folder</em><br><strong>Purpose:</strong> Persist a copy of config XML to a timestamped file in safe folder for forensic recovery on errors (used on checksum mismatch or save failure).<br><strong>Signature:</strong> <code>Private Sub BackupConfigXML(ByVal xml As String)</code><br><strong>Behavior:</strong> Writes binary file using <code>GetSafeTempFolder()</code> with randomized suffix; logs backup path via <code>LogAuditLocal</code>. Errors logged. <br><strong>Complexity:</strong> O(bytes). <br><strong>Security:</strong> Backup may contain secrets; backups are stored on local filesystem—must be handled per policy. <br><strong>Tests:</strong> Confirm backup file created and named pattern matches expectations. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>HandleConfigError(proc, msg)</strong> — <em>defensive error handler with audit + modError integration</em><br><strong>Purpose:</strong> Centralized error reporting for critical failures: logs audit, calls <code>modError.HandleError</code> if available, and raises a vbObjectError error including correlation id.<br><strong>Signature:</strong> <code>Private Sub HandleConfigError(ByVal proc As String, ByVal msg As String)</code><br><strong>Behavior:</strong> Retrieves <code>GetCorrelationId()</code>, logs via <code>LogAuditLocal</code>, calls <code>SafeCallModErrorHandle</code> if error handler available, then raises <code>Err.Raise vbObjectError + 9000, proc, msg &amp; &quot; | correlation=&quot; &amp; correlationId</code>. Uses <code>On Error Resume Next</code> to avoid failure during error flow. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Simulate a config error and observe audit + modError invocation + raised error. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsErrorHandlerAvailable() / SafeCallModErrorHandle(proc, msg)</strong> — <em>probe & safe invocation for modError</em><br><strong>Purpose:</strong> Probe availability of <code>modError</code> error handler and call it safely without raising further errors.<br><strong>Signatures:</strong> <code>Private Function IsErrorHandlerAvailable() As Boolean</code> / <code>Private Sub SafeCallModErrorHandle(ByVal proc As String, ByVal msg As String)</code><br><strong>Behavior:</strong> Uses <code>TryRunReturn(&quot;modError_Probe_HandleError&quot;)</code> probe to detect handler presence; <code>SafeCallModErrorHandle</code> attempts <code>TryRunReturn(&quot;modError.HandleError&quot;, proc, msg)</code> or legacy <code>modError_HandleError</code> and swallows errors. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Confirm probe detects handler when present. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>KillSafe(fname)</strong> — <em>safe file delete wrapper</em><br><strong>Purpose:</strong> Delete file without raising errors. <br><strong>Behavior:</strong> <code>On Error Resume Next</code> then <code>Kill fname</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsHexString(s, expectedLen)</strong> — <em>hex validation helper</em><br><strong>Purpose:</strong> Check whether string contains only hex characters of required length.<br><strong>Signature:</strong> <code>Private Function IsHexString(ByVal s As String, ByVal expectedLen As Long) As Boolean</code><br><strong>Behavior:</strong> Length and per-char membership test. <br><strong>Complexity:</strong> O(n). <br><strong>Tests:</strong> Validate known hex and non-hex strings. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsArrayAllocatedByte(arr() As Byte) As Boolean</strong> — <em>array allocation probe</em><br><strong>Purpose:</strong> Detect whether byte array is allocated without raising. Uses <code>LBound</code> in On Error context. <br><strong>Behavior:</strong> Returns True if <code>LBound(arr)</code> accessible; else False. Useful for <code>StrToUtf8Bytes</code> fallback detection. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SafeClearConfig()</strong> — <em>remove IFRS CustomXMLParts + doc props + invalidate cache</em><br><strong>Purpose:</strong> Cleanly remove stored config parts and config-related document properties; clear cache and append change history entry. Intended for admin resets and safe teardown.<br><strong>Signature:</strong> <code>Public Sub SafeClearConfig()</code><br><strong>Behavior:</strong> Iterates <code>ThisWorkbook.CustomXMLParts</code> backward, deletes parts containing <code>&lt;IFRSConfig</code>. Deletes <code>CFG_CHECKSUM_PROP</code> and <code>CFG_SCHEMA_PROP</code> document properties if exist. Calls <code>InvalidateConfigCache</code> and <code>AppendChangeHistory</code>. Errors logged. <br><strong>Complexity:</strong> O(#parts). <br><strong>Failure modes:</strong> Partial deletion if errors occur; errors audited. <br><strong>Tests:</strong> Create parts and props, call SafeClearConfig, verify absence. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>CreateDefaultConfigXML(schemaVersion) As String</strong> — <em>produce minimal default config skeleton</em><br><strong>Purpose:</strong> Create a small initial config XML with provided <code>schemaVersion</code> and empty sections for COAMappings, FeatureFlags, Settings, Templates.<br><strong>Signature:</strong> <code>Private Function CreateDefaultConfigXML(ByVal schemaVersion As String) As String</code><br><strong>Behavior:</strong> String-concatenation building well-formed XML declaration and root. <br><strong>Complexity:</strong> O(1). <br><strong>Notes:</strong> Used when live config absent and callers need default. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExtractSchemaVersionFromXML(xml) As String</strong> — <em>naive string-based extraction of SchemaVersion</em><br><strong>Purpose:</strong> Extract textual content of first <code>&lt;SchemaVersion&gt;</code> element using simple string search (not XML parser).<br><strong>Signature:</strong> <code>Private Function ExtractSchemaVersionFromXML(ByVal xml As String) As String</code><br><strong>Behavior:</strong> Finds <code>&lt;SchemaVersion&gt;</code> start and <code>&lt;/SchemaVersion&gt;</code> end and returns interior substring; returns empty string if absent. <br><strong>Complexity:</strong> O(len(xml)). <br><strong>Failure modes:</strong> If XML has namespaces or varied casing, still works (vbTextCompare used elsewhere when searching). Not robust against malformed XML. <br><strong>Tests:</strong> Inputs with/without/duplicated SchemaVersion. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>FindConfigPart() As CustomXMLPart</strong> — <em>lookup best candidate CustomXMLPart</em><br><strong>Purpose:</strong> Locate the CustomXMLPart containing <code>CFG_ROOT_NAME</code> and match stored checksum property if present; otherwise return the first match.<br><strong>Signature:</strong> <code>Private Function FindConfigPart() As CustomXMLPart</code><br><strong>Behavior:</strong> If <code>CFG_CHECKSUM_PROP</code> exists, iterate parts looking for <code>&lt;IFRSConfig</code> and compute checksum for each via <code>ComputeChecksumForCustomXMLPart</code>; if checksum matches stored prop return that part; if not found logs and returns Nothing. If checksum prop absent, return first part with root name. Defensive error handling throughout. <br><strong>Complexity:</strong> O(#parts * checksum cost). <br><strong>Side-effects:</strong> Calls ComputeChecksum which may invoke certutil or CRC. <br><strong>Failure modes:</strong> No parts → returns Nothing; checksum mismatch → audited and Nothing. <br><strong>Tests:</strong> Multiple parts with same root; verify checksum selection. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>TryRunReturn(procName, ParamArray args()) As Variant</strong> — <em>robust cross-module call helper with ParamArray expansion</em><br><strong>Purpose:</strong> Call <code>Application.Run(procName, ...)</code> with up to 9 args safely and return result or <code>Empty</code> on error. Prevents callers from raising if callee missing or errors. Works around <code>ParamArray</code> UBound/LBound quirks with defensive checks.<br><strong>Signature:</strong> <code>Public Function TryRunReturn(ByVal procName As String, ParamArray args() As Variant) As Variant</code><br><strong>Behavior:</strong> Counts args via <code>(UBound(args)-LBound(args)+1)</code> inside error-handling. Uses <code>Select Case</code> to call <code>Application.Run</code> with specific arity (0..9). If <code>Err.Number=0</code> returns <code>ret</code> else clears error and returns <code>Empty</code>. Entire function guarded with <code>On Error GoTo ErrHandler</code> and final fallback returns Empty. <br><strong>Complexity:</strong> O(1) per call. <br><strong>Side-effects:</strong> Invokes arbitrary procedure names in host environment—caller must ensure safe names. <br><strong>Failure modes / Security:</strong> If <code>Application.Run</code> points to hostile/buggy macro, it will run — caller should use only trusted proc names. Errors suppressed and return Empty. <br><strong>Tests:</strong> Call known existing sub and non-existent name; ensure return vs Empty. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetSetting(key) / GetSettingTyped / SetSettingTyped / SetSetting</strong> — <em>key/value accessors for Settings stored in XML with delegate fallback</em><br><strong>Purpose:</strong> Retrieve and set configuration key-values. Prefer <code>modUtilities.GetSetting/SetSetting</code> delegates; otherwise operate on cached XML content. <code>GetSettingTyped</code> and <code>SetSettingTyped</code> provide typed conversions for boolean/int/double.<br><strong>Signatures:</strong> <code>Public Function GetSetting(ByVal key As String) As Variant</code>, <code>Public Function GetSettingTyped(ByVal key As String, Optional ByVal valueType As String = &quot;string&quot;) As Variant</code>, <code>Public Function SetSettingTyped(ByVal key As String, ByVal value As Variant, Optional ByVal valueType As String = &quot;string&quot;) As Boolean</code>, <code>Public Function SetSetting(ByVal key As String, ByVal val As Variant) As Boolean</code><br><strong>Behavior (Get):</strong> Tries delegate <code>modUtilities.GetSetting</code> then <code>GetSetting</code> top-level; if not present, string-search XML cached for <code>&lt;Setting key=&quot;...&quot; value=&quot;...&quot;/&gt;</code> and returns raw value or Empty. (Uses <code>EscapeXml</code> when constructing pattern). <br><strong>Behavior (Set):</strong> Tries delegate <code>modUtilities.SetSetting</code> then top-level. If no delegate, ensures module initialized, obtains cached XML (or default), validates via <code>ValidateSettingKeyValue</code>, then updates XML: if present modifies <code>value</code> attribute in-place; else inserts new <code>&lt;Setting&gt;</code> node into <code>&lt;Settings&gt;</code> or injects <code>&lt;Settings&gt;</code> if missing. Updates <code>CacheXml</code>, <code>CacheTimestamp</code>, <code>CacheDirty</code>, <code>LastWriteTimestamp</code>. For <code>WritePolicy=write_back</code> and <code>WriteDebounceSeconds&gt;0</code> returns success without persisting; for write-through calls <code>SaveConfigXML(xml)</code> immediately. Robust error handling and audit logging. <code>SetSettingTyped</code> converts typed values to canonical string representation before calling <code>SetSetting</code>.<br><strong>Complexity:</strong> O(len(xml)) for searches and string replacements. <br><strong>Side-effects:</strong> May mutate cache and persist CustomXMLParts (write-through). <br><strong>Invariants:</strong> <code>ValidateSettingKeyValue</code> enforced for known keys (rounding/daycount). <br><strong>Failure modes:</strong> Invalid key/value -> validation failure & return False; persistence failure logged. <br><strong>Tests:</strong> Typed set/get round-trips; validation rejects out-of-range rounding; write-back debounce prevents immediate Save. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SaveConfigXML(configXml) As Boolean</strong> — <em>atomic commit to CustomXMLParts with checksum & fallback</em><br><strong>Purpose:</strong> Persist XML to CustomXMLParts atomically: add new part, delete other IFRS parts, set checksum & schema doc properties. If CustomXMLParts unavailable, fallback to sheet persistence and still set document properties where possible. Ensures cache consistency and backups on commit failures.<br><strong>Signature:</strong> <code>Public Function SaveConfigXML(ByVal configXml As String) As Boolean</code><br><strong>Behavior (high level):</strong> Validates non-empty and calls <code>ValidateConfigXML_Explain</code>; aborts on invalid. Sets <code>ModuleLock=True</code> to prevent concurrent reads. Attempts to <code>ThisWorkbook.CustomXMLParts.Add(configXml)</code>. If that fails, uses <code>FallbackSaveToSheet</code> then writes <code>CFG_CHECKSUM_PROP</code> and <code>CFG_SCHEMA_PROP</code> (CRC32 checksum) as CustomDocumentProperties if possible and returns True. If new part created, computes checksum via <code>ComputeChecksumForCustomXMLPart(newPart)</code>. If missing or empty -> commit fail. Iterates all <code>CustomXMLParts</code> and deletes any other IFRS root parts (ensures single authoritative part). Safely adds/updates <code>CFG_CHECKSUM_PROP</code> and <code>CFG_SCHEMA_PROP</code>. Restores cache fields and returns True. On any commit error restores original cache, sets <code>CacheDirty=True</code>, <code>ModuleLock=False</code>, calls <code>BackupConfigXML</code>, logs audit, and returns False. Uses <code>On Error</code> handlers for robust rollback. <br><strong>Complexity:</strong> O(#parts * checksum cost + bytes write). <br><strong>Side-effects:</strong> Creates/deletes CustomXMLParts and document properties; creates backups on failures. <br><strong>Failure modes:</strong> inability to write parts or doc props triggers fallback to sheet or commit fail with backup. Race conditions with concurrent writers guarded by <code>ModuleLock</code> but workbook-level concurrency (other processes) not fully prevented. <br><strong>Security:</strong> When writing to sheet fallback, data is visible; checksum may leak structure info but not content. <br><strong>Tests:</strong> Successful commit path; failure path when Add fails -> sheet fallback; checksum mismatch and backup invoked on commit error. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ValidateConfigXML_Explain(xml) As Boolean</strong> — <em>schema-lite validator with targeted key checks</em><br><strong>Purpose:</strong> Validate presence of XML declaration, root <code>&lt;IFRSConfig&gt;</code>, <code>&lt;SchemaVersion&gt;</code>, and pragmatic checks for known setting keys (rounding precision integer 0..10 and day-count allowed list). Returns boolean and sets <code>LastValidationError</code> with explanatory text on failure.<br><strong>Signature:</strong> <code>Public Function ValidateConfigXML_Explain(ByVal xml As String) As Boolean</code><br><strong>Behavior:</strong> Performs string searches for <code>&lt;?xml</code> and <code>&lt;IFRSConfig</code> then finds <code>&lt;SchemaVersion&gt;</code> content. Optionally checks <code>&lt;Settings&gt;</code> presence but allows absence. Validates <code>KEY_ROUNDING_PRECISION</code> numeric range and <code>KEY_DAY_COUNT</code> allowed list by locating <code>key=&quot;...&quot;</code> and extracting <code>value=&quot;...&quot;</code> substring. On any invalid condition sets <code>LastValidationError</code> and returns False. Errors during validation set <code>LastValidationError</code> accordingly. <br><strong>Complexity:</strong> O(len(xml)). <br><strong>Limitations:</strong> Not a full XML schema validator — uses simple substring operations and will fail for namespaced or complex XML forms. <br><strong>Tests:</strong> Empty xml, missing declaration, missing root, missing schema, invalid rounding/daycount produce appropriate error messages. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>FeatureFlag_SetTyped(key, value, Optional valueType="string", Optional expires)</strong> — <em>set / insert feature flag with debounce/policy</em><br><strong>Purpose:</strong> Add or update a <code>&lt;Flag key=... value=... type=... expires=.../&gt;</code> in <code>&lt;FeatureFlags&gt;</code> in cached XML; persist according to <code>WritePolicy</code>/debounce.<br><strong>Signature:</strong> <code>Public Function FeatureFlag_SetTyped(ByVal key As String, ByVal value As Variant, Optional ByVal valueType As String = &quot;string&quot;, Optional ByVal expires As Variant) As Boolean</code><br><strong>Behavior:</strong> Loads cached XML (or default), finds <code>&lt;Flag key=&quot;...&quot;&gt;</code> and updates <code>value</code>, <code>type</code> and <code>expires</code> attributes in-place, or inserts a new <code>&lt;Flag&gt;</code> fragment inside <code>&lt;FeatureFlags&gt;</code> or creates <code>&lt;FeatureFlags&gt;</code> block if missing. Updates cache and sets <code>CacheDirty</code>. If <code>WritePolicy==WRITE_POLICY_WRITE_THROUGH</code> calls <code>SaveConfigXML(xml)</code> synchronously. For write-back returns True and defers persistence. Uses <code>EscapeXml</code> for inserted attributes. Errors audited. <br><strong>Complexity:</strong> O(len(xml)). <br><strong>Failure modes:</strong> SaveConfigXML failure on write-through logged. <br><strong>Tests:</strong> Insert new flag, update existing, expiry handling. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>FeatureFlag_Set(key, value) As Boolean</strong> — <em>simple wrapper</em><br><strong>Purpose:</strong> Call <code>FeatureFlag_SetTyped(key, value, &quot;string&quot;)</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RunMigrations(currentXml, targetVersion, Optional commit=False) As String</strong> — <em>apply registered migration chain</em><br><strong>Purpose:</strong> See Migration registry above — performs migration routines sequentially, optionally persists result when <code>commit=True</code>, and returns migrated XML string or empty on failure. <br><strong>Notes:</strong> Uses <code>TryRunReturn</code> for external routines and special-cases local <code>Migrate_v1_0_0_to_v1_1_0</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>FlushPendingWrites() As Boolean</strong> — <em>persist cached write-back changes</em><br><strong>Purpose:</strong> When <code>WritePolicy=write_back</code> persist <code>CacheXml</code> if <code>CacheDirty</code> True by calling <code>SaveConfigXML(CacheXml)</code>. No-op (returns True) if nothing to flush or if policy not write_back. <br><strong>Signature:</strong> <code>Public Function FlushPendingWrites() As Boolean</code><br><strong>Behavior:</strong> Returns False on Save failure and logs audit. <br><strong>Tests:</strong> Set write-back policy, set setting, ensure FlushPendingWrites persists. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>InvalidateRibbon()</strong> — <em>attempt to invalidate ribbon via delegates</em><br><strong>Purpose:</strong> Call <code>modRibbon.Invalidate</code> or <code>modRibbonCallbacks.Invalidate</code> via <code>TryRunReturn</code>, otherwise set <code>RibbonInvalidateCallbacks=True</code> to instruct caller to refresh ribbon later. <br><strong>Signature:</strong> <code>Public Sub InvalidateRibbon()</code><br><strong>Behavior:</strong> Non-raising; checks both delegate names and falls back to boolean flag. <br><strong>Tests:</strong> With/without ribbon module present ensure no exception. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SetTestMode(enable, Optional deterministicSeed=123456)</strong> — <em>toggle deterministic randomness for tests</em><br><strong>Purpose:</strong> When enabled set <code>Randomize deterministicSeed</code>; otherwise <code>Randomize</code> with system seed. Sets <code>TestModeEnabled</code> flag. <br><strong>Signature:</strong> <code>Public Sub SetTestMode(ByVal enable As Boolean, Optional ByVal deterministicSeed As Long = 123456)</code> </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ResetToDefaults(Optional commit=True) As Boolean</strong> — <em>clear config and write default skeleton</em><br><strong>Purpose:</strong> Delete current config (calls <code>SafeClearConfig</code>) and write default XML with <code>GetThisAddinSchemaVersion</code>. If <code>commit=True</code>, persists immediately via <code>SaveConfigXML</code>, else populates cache and marks dirty.<br><strong>Signature:</strong> <code>Public Function ResetToDefaults(Optional ByVal commit As Boolean = True) As Boolean</code><br><strong>Behavior:</strong> Calls <code>SafeClearConfig</code>, builds <code>CreateDefaultConfigXML</code>, persists according to <code>commit</code>. Errors audited. <br><strong>Tests:</strong> Reset with commit True writes CustomXMLPart or fallback sheet; without commit leaves cache dirty only. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RunConfigSelfTests()</strong> — <em>expanded self-test harness writing results to <code>_IFRS_TestResults</code> sheet</em><br><strong>Purpose:</strong> Automated smoke tests for core module functionality: save/load default, feature flag set/get, setting set/get, typed setters, flush pending writes, fallback sheet presence, export/import round-trip. Appends <code>AppendChangeHistory</code> at end. Writes results into <code>_IFRS_TestResults</code> rows with timestamp, test name, pass/fail and details.<br><strong>Signature:</strong> <code>Public Sub RunConfigSelfTests()</code><br><strong>Behavior:</strong> Ensures module initialized, creates/clears <code>_IFRS_TestResults</code> sheet, runs series of tests including export/import using <code>GetSafeTempFolder</code>, records pass/fail strings and details, handles errors, logs audit on failure. <br><strong>Complexity:</strong> Composite of underlying calls (IO/networkless). <br><strong>Side-effects:</strong> Will modify workbook (create sheets, write temp files). <br><strong>Tests:</strong> Designed to be tests themselves; run to validate environment. <br><strong>Notes:</strong> May fail on locked workbook or restricted environment. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ValidateSettingKeyValue(key, val) As Boolean</strong> — <em>pragmatic per-key validation</em><br><strong>Purpose:</strong> Validate specific known settings: <code>KEY_ROUNDING_PRECISION</code> (integer 0..10) and <code>KEY_DAY_COUNT</code> (allowed enumeration). Returns True if valid. Sets <code>LastValidationError</code> on failure.<br><strong>Signature:</strong> <code>Private Function ValidateSettingKeyValue(ByVal key As String, ByVal val As Variant) As Boolean</code><br><strong>Behavior:</strong> Performs numeric and allowed-list checks; silent success otherwise. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Out-of-range rounding and invalid daycount produce rejection. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Implementation notes & operational guidance</strong> — <em>important maintenance and security guidance</em><br><strong>Key operational tradeoffs:</strong><br>- <strong>Write policy:</strong> default is write-through (safer). Write-back with debounce improves performance but requires callers to call <code>FlushPendingWrites()</code> periodically (e.g., on AddIn shutdown).<br>- <strong>Checksum strategy:</strong> SHA256 via <code>certutil</code> is preferred but may be unavailable; CRC32 fallback chosen for portability but has weaker collision resistance. Consider shipping an internal SHA256 implementation to avoid external process dependence.<br>- <strong>Secrets:</strong> <code>Config_SetSecret</code> refuses to persist when no <code>modSecurity</code> delegate is available; this is deliberate. Ensure <code>modSecurity</code> implements secure storage. Do not store secrets in sheet fallback.<br>- <strong>XML parsing:</strong> Module uses string searches rather than an XML parser (fast, zero-dependency) — this demands careful discipline on XML shape and escaping. If config complexity grows, move to MSXML DOM with schema validation. <br><strong>Recommended tests (concise):</strong> 1) CustomXMLParts present/absent flows, 2) Checksum mismatch & backup, 3) Write-back + debounce + FlushPendingWrites, 4) Migration happy/path-fail cases, 5) Export/Import round-trip, 6) Certutil absent path, 7) Secret delegation acceptance/refusal, 8) Self-test harness success on a clean workbook. <br><strong>Maintenance notes:</strong> Keep tokenizer/parsing patterns stable; avoid changing XML attribute formatting without migration. When modifying worker-like behavior or external process calls increment a module capability/version flag and add unit tests for both environment permutations. </td></tr></tbody></table></div><div class="row-count">Rows: 52</div></div><div class="table-caption" id="Table5" data-table="Docu_0159_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modDataInput)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modDataInput)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Overview:</strong> Exhaustive per-function technical breakdown of the <code>modDataInput</code> VBA module from <code>IFRSToolkit.xlam</code>. Each entry documents: purpose, signature (inputs/outputs), internal behavior, complexity, side-effects, invariants, failure modes, security/path considerations, recommended tests, and maintainer notes. Use as authoritative inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Module constants & caches</strong> — <em>module configuration & transient caches</em><br><strong>Purpose:</strong> Centralize magic strings, feature thresholds, and in-memory caches used across the module.<br><strong>Key values:</strong> <code>STAGING_SHEET_NAME</code>, <code>STAGING_SCHEMA_TOKEN</code>, <code>IMPORT_PREVIEW_SHEET</code>, <code>IMPORT_ERRORS_SHEET</code>, <code>IMPORT_BACKUP_PREFIX</code>, <code>IMPORT_LOCK_SHEET</code>, <code>DEFAULT_IMPORT_DEST_SHEET</code>, <code>ROWID_HEADER</code>, <code>STREAMING_THRESHOLD_BYTES</code>, <code>MAX_OPEN_RETRIES</code>, <code>OPEN_RETRY_WAIT_MS</code>, <code>MODULE_SCHEMA_VERSION</code>.<br><strong>Behavior:</strong> Read-only constants drive naming and policy decisions. <code>g_cacheColumnMap</code> and <code>g_cacheConfig</code> are <code>Scripting.Dictionary</code> transient caches created on-demand by <code>EnsureCachesInit</code>.<br><strong>Complexity:</strong> O(1) access.<br><strong>Side-effects:</strong> memory allocation for caches.<br><strong>Invariants:</strong> constants never change at runtime; caches reset by <code>InvalidateDataInputCache</code>.<br><strong>Tests:</strong> Verify constant values and cache lifecycle (init, add, invalidate).<br><strong>Notes:</strong> Keep schema/version constant bumped on breaking changes. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>EnsureCachesInit</strong> — <em>ensure dictionaries exist</em><br><strong>Purpose:</strong> Lazily initialize <code>g_cacheColumnMap</code> and <code>g_cacheConfig</code> dictionaries used by other helpers.<br><strong>Signature:</strong> <code>Private Sub EnsureCachesInit()</code> → none.<br><strong>Behavior:</strong> Creates <code>Scripting.Dictionary</code> instances if <code>Nothing</code>. Uses <code>On Error Resume Next</code> defensively to avoid failing initialization in restricted environments.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Allocates dictionaries in module scope.<br><strong>Invariants:</strong> After call, <code>g_cacheColumnMap</code> and <code>g_cacheConfig</code> are objects (or remained Nothing if creation fails).<br><strong>Failure modes:</strong> COM object creation failure (no scripting runtime) — callers must handle <code>Nothing</code> gracefully.<br><strong>Tests:</strong> Run on fresh host where dictionaries unavailable; assert no runtime error and dictionaries created when permitted.<br><strong>Notes:</strong> Keep minimal and tolerant to support Excel macro security modes. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>InvalidateDataInputCache</strong> — <em>invalidate cached config & column map</em><br><strong>Purpose:</strong> Clear module transient caches to force re-read of configuration and mapping (useful in tests, reload, config change flows).<br><strong>Signature:</strong> <code>Public Sub InvalidateDataInputCache()</code> → none.<br><strong>Behavior:</strong> If caches exist, calls <code>RemoveAll</code> and sets module variables to <code>Nothing</code>.<br><strong>Complexity:</strong> O(n) where n = keys in caches (dictionary removal).<br><strong>Side-effects:</strong> Frees cached data; next config access triggers <code>GetConfigValue</code> lookups.<br><strong>Invariants:</strong> After call, caches are <code>Nothing</code>.<br><strong>Tests:</strong> Populate caches, call invalidate, assert caches cleared. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>TryRunReturn</strong> — <em>robust Application.Run wrapper</em><br><strong>Purpose:</strong> Safely call arbitrary public procedures (other modules) via <code>Application.Run</code> while protecting callers from missing procs or runtime errors. Used to call <code>modConfig</code>, <code>modAudit</code>, <code>modUtilities</code>, etc., without hard dependency.<br><strong>Signature:</strong> <code>Private Function TryRunReturn(ByVal procName As String, ParamArray pArgs() As Variant) As Variant</code> → returns procedure return variant or <code>Empty</code> on failure.<br><strong>Behavior:</strong> Counts args, calls <code>Application.Run</code> with up to 9 args via <code>Select Case</code>. Uses error handler to swallow exceptions and return <code>Empty</code> on failure.<br><strong>Complexity:</strong> O(1) overhead per call plus callee cost. <br><strong>Side-effects:</strong> May execute arbitrary code. <br><strong>Invariants:</strong> Never raises to caller; failure == <code>Empty</code>.<br><strong>Failure modes:</strong> Limitations: only supports up to 9 args explicitly; extra args fallback to call with no args. Caller must treat <code>Empty</code> as "not available" or failure. <br><strong>Security:</strong> Calling arbitrary procs via name can be risky if procName is user-controlled — callers must not pass untrusted strings. <br><strong>Tests:</strong> Stub missing modules and ensure <code>Empty</code> returned; verify success when target proc present. <br><strong>Notes:</strong> Keep in sync if more args needed (rare). </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SafeLog</strong> — <em>multi-fallback logging</em><br><strong>Purpose:</strong> Attempt to write audit/log messages to centralized logging (modAudit), fallback to ribbon callbacks, then to local audit sheet. Sanitizes message via <code>RedactSecrets</code>.<br><strong>Signature:</strong> <code>Private Sub SafeLog(ByVal source As String, ByVal message As String, Optional ByVal level As String = &quot;INFO&quot;)</code><br><strong>Behavior:</strong> Tries <code>modAudit.LogEvent</code>, <code>modAudit.LogAudit</code>, then <code>modRibbonCallbacks.LogEvent</code> via <code>TryRunReturn</code>. If none available or they fail, calls <code>AppendLocalAudit</code>. Wraps errors; logs failures to Immediate Window if unable to persist.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes to external modules or worksheet <code>_IFRS_Audit</code> (creates if missing).<br><strong>Invariants:</strong> Message redaction applied before any external calls.<br><strong>Failure modes:</strong> Non-availability of host modules; file/worksheet write errors. <br><strong>Security:</strong> Redacts common secret tokens; pattern list in module. <br><strong>Tests:</strong> Simulate absence of modAudit and modRibbonCallbacks; verify local audit created and entries written. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>GetConfigValue</strong> — <em>cached multi-fallback configuration reader</em><br><strong>Purpose:</strong> Centralized config getter. Tries multiple <code>modConfig</code> interfaces and caches results for session performance.<br><strong>Signature:</strong> <code>Private Function GetConfigValue(ByVal key As String, Optional ByVal defaultVal As Variant = Empty) As Variant</code><br><strong>Behavior:</strong> Ensures caches, returns cached value if exists. Otherwise calls a sequence of <code>modConfig</code> entry points via <code>TryRunReturn</code> (<code>GetSetting</code>, <code>Get</code>, <code>ReadConfig</code>, <code>GetValue</code>). Caches successful result in <code>g_cacheConfig</code>. If none found returns <code>defaultVal</code> or <code>Empty</code> depending on arguments. Error-handling channels to <code>ErrHandler</code> returning default.<br><strong>Complexity:</strong> O(1) read; first-read cost includes inter-module call overhead. <br><strong>Side-effects:</strong> Populates <code>g_cacheConfig</code>. <br><strong>Invariants:</strong> Cached entries stable for current session until invalidated. <br><strong>Failure modes:</strong> <code>modConfig</code> missing or throwing — function returns default/Empty. <br><strong>Tests:</strong> Validate caching (two calls -> second uses cache), behavior when <code>modConfig</code> missing. <br><strong>Notes:</strong> Avoid caching secrets; callers should not assume mutable config updates without invalidation. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>HandleError</strong> — <em>centralized error funnel to modError / local audit</em><br><strong>Purpose:</strong> Top-level error reporter which tries <code>modError.HandleError</code> with correlation IDs and falls back to <code>AppendLocalAudit</code>.<br><strong>Signature:</strong> <code>Public Sub HandleError(ByVal routineName As String, ByVal errNum As Long, ByVal errDesc As String, Optional ByVal correlationId As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Formats a redacted message, tries <code>modError.HandleError</code> (two variants), else appends to local audit. Protected by <code>On Error</code> handlers to avoid cascading failures.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> External logging to modError or local audit sheet. <br><strong>Invariants:</strong> Never re-raises; guaranteed to swallow errors. <br><strong>Tests:</strong> Force run-time error, verify <code>HandleError</code> logs and returns without propagation. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SafeHandleError</strong> — <em>light wrapper</em><br><strong>Purpose:</strong> Convenience wrapper for <code>HandleError</code> called internally without correlation id.<br><strong>Signature:</strong> <code>Private Sub SafeHandleError(ByVal routineName As String, ByVal errNum As Long, ByVal errDesc As String)</code><br><strong>Behavior:</strong> Calls <code>HandleError</code> under <code>On Error Resume Next</code> to avoid failure loops. <br><strong>Notes:</strong> Use when an error occurs inside internal helpers. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>AppendLocalAudit</strong> — <em>local audit writer into workbook</em><br><strong>Purpose:</strong> Ensure audit trail persisted to <code>_IFRS_Audit</code> worksheet when centralized logging unavailable.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAudit(ByVal message As String)</code><br><strong>Behavior:</strong> Resolves target workbook (Active or ThisWorkbook), creates <code>_IFRS_Audit</code> sheet (very hidden), seeds headers, appends timestamp + message. Falls back to <code>Debug.Print</code> if workbook unavailable. <br><strong>Complexity:</strong> O(1) per append; sheet row lookup O(lastRow).<br><strong>Side-effects:</strong> Creates/updates hidden worksheet; may increase workbook size over time. <br><strong>Invariants:</strong> Audit sheet created with headers if absent. <br><strong>Failure modes:</strong> Protected workbook, insufficient permissions, disk issues on save. <br><strong>Tests:</strong> Simulate workbook with/without sheet and verify append; simulate no workbook (headless) and verify <code>Debug.Print</code>. <br><strong>Notes:</strong> Consider rolling or size cap in future. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>RedactSecrets</strong> — <em>PII/secret redactor for logs</em><br><strong>Purpose:</strong> Replace common secret patterns in log messages with <code>[REDACTED]</code> to avoid leaking credentials to logs or telemetry.<br><strong>Signature:</strong> <code>Private Function RedactSecrets(ByVal s As String) As String</code><br><strong>Behavior:</strong> Lowercases copy and scans for patterns <code>password=, pwd=, secret=, token=, apikey=, api_key=</code> and replaces following token up to whitespace with <code>[REDACTED]</code>. Iteratively updates string.<br><strong>Complexity:</strong> O(n * p) where p=pattern count; small constant. <br><strong>Invariants:</strong> Does not attempt deep PII detection; only pattern-based redaction. <br><strong>Failure modes:</strong> Non-space-delimited secrets (JSON values with quotes) may not be fully redacted; still useful. <br><strong>Tests:</strong> Feed strings with patterns and assert redaction. <br><strong>Notes:</strong> Extend patterns if new keys used. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ToDateSafe</strong> — <em>defensive date parser</em><br><strong>Purpose:</strong> Convert various date representations to VBA <code>Date</code> reliably, with fallback default. Accepts numeric/date and string forms (ISO, delimited).<br><strong>Signature:</strong> <code>Public Function ToDateSafe(ByVal val As Variant, Optional ByVal defaultVal As Date = 0) As Date</code><br><strong>Behavior:</strong> If <code>IsDate</code> returns True, uses <code>CDate</code>. Else converts <code>val</code> to string, trims, tries <code>CDate</code>; on failure strips separators and attempts <code>DateSerial</code> when digits >= 8 (<code>YYYYMMDD</code>), else returns <code>defaultVal</code>. Errors funnel to <code>HandleError</code>.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Ambiguous short dates; depends on system locale for <code>CDate</code>. <br><strong>Tests:</strong> Strings <code>2020-12-31</code>, <code>20201231</code>, <code>2020/12/31T00:00</code> produce expected Date; invalid returns default. <br><strong>Notes:</strong> Useful for imported date columns with varying formats. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ToDoubleSafe / NZDoubleOrZero</strong> — <em>defensive numeric parsing</em><br><strong>Purpose:</strong> Convert heterogeneous numeric strings to <code>Double</code> with robust handling of locale decimal separators and fallbacks.<br><strong>Signature:</strong> <code>Public Function ToDoubleSafe(ByVal val As Variant, Optional ByVal defaultVal As Double = 0#) As Double</code> and <code>Public Function NZDoubleOrZero(ByVal v As Variant) As Double</code>.<br><strong>Behavior:</strong> If <code>IsNumeric</code>, cast. Else trim string, attempt <code>CDbl</code>; if fails, swap comma/dot and try again. Returns <code>defaultVal</code> on failure. <code>NZDoubleOrZero</code> is convenience wrapper for <code>0</code> default.<br><strong>Complexity:</strong> O(len).<br><strong>Failure modes:</strong> Non-numeric strings or localized formats beyond simple swaps (e.g., spaces as thousand separators) may still fail. <br><strong>Tests:</strong> <code>&quot;1,234.56&quot;</code> and <code>&quot;1.234,56&quot;</code> loop produce expected double with the swap heuristic. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>LoadColumnMapFromConfig / GetColumnMapping</strong> — <em>column mapping loader</em><br><strong>Purpose:</strong> Load user-configured column header mappings from <code>modConfig</code> into <code>g_cacheColumnMap</code> to support flexible source schemas.<br><strong>Signature:</strong> <code>Private Sub LoadColumnMapFromConfig()</code> and <code>Public Function GetColumnMapping(ByVal logicalName As String) As String</code>.<br><strong>Behavior:</strong> <code>LoadColumnMapFromConfig</code> looks for keys <code>DataInput.ColumnMap.account|desc|balance|date</code> and stores mappings keyed by logical name (<code>account</code>, etc.). <code>GetColumnMapping</code> returns the configured header name or empty string. Tolerant to missing <code>modConfig</code> by using <code>GetConfigValue</code> fallback chain.<br><strong>Complexity:</strong> O(k) where k=number of mapped keys. <br><strong>Side-effects:</strong> populates <code>g_cacheColumnMap</code>. <br><strong>Tests:</strong> Set config values, call loader, assert mapping returned. <br><strong>Notes:</strong> Keep mapping names stable; used widely in schema validation. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SafeInvokeProgressCallback</strong> — <em>progress UI updater</em><br><strong>Purpose:</strong> Notify UI (Ribbon or modUtilities) of progress with multi-fallback calls; tolerant to missing implementations.<br><strong>Signature:</strong> <code>Private Sub SafeInvokeProgressCallback(ByVal token As String, ByVal pct As Long, Optional ByVal message As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Tries <code>Ribbon_ProgressCallback</code>, <code>modRibbonCallbacks.Progress</code>, <code>modUtilities.ProgressCallback</code> via <code>TryRunReturn</code>. Silently ignores failures. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call external UI code. <br><strong>Tests:</strong> Use stubbed callbacks to verify invocation. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>EnqueueImportJob / StoreJobMetadata</strong> — <em>job scheduling + metadata persistence</em><br><strong>Purpose:</strong> Provide a safe interface for queuing import jobs (via ribbon job scheduler or utilities), and persist job metadata into <code>_IFRS_Jobs</code> sheet for auditing.<br><strong>Signature:</strong> <code>Public Function EnqueueImportJob(ByVal jobId As String, ByVal handlerProcName As String, Optional ByVal whenUtc As Variant) As Boolean</code> and <code>Private Sub StoreJobMetadata(ByVal jobId As String, ByVal Handler As String, ByVal whenUtc As Variant, ByVal enqueued As Boolean, ByVal corrId As String)</code>.<br><strong>Behavior:</strong> Validates inputs; tries <code>modRibbonCallbacks.EnqueueJob</code>, <code>modUtilities.EnqueueJob</code> via <code>TryRunReturn</code>. If no enqueuer, runs handler inline with <code>Application.Run</code>. Logs result and stores metadata to <code>_IFRS_Jobs</code> via <code>SafeGetWorksheet</code>/<code>SafeCreateSheet</code>. Uses correlation ID generated by <code>GenerateCorrelationID</code>.<br><strong>Complexity:</strong> O(1) + persistent write. <br><strong>Side-effects:</strong> Adds audit row to <code>_IFRS_Jobs</code>, possible immediate job execution. <br><strong>Invariants:</strong> <code>StoreJobMetadata</code> always attempts a best-effort write and hides sheet. <br><strong>Failure modes:</strong> Failure to create sheet or workbook write errors; inline run may raise exceptions (caught). <br><strong>Tests:</strong> Stub enqueuers and verify metadata persisted; test inline-run fallback. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>CreateSampleTemplate / AddSampleTemplateToCustomXML / ExportSampleTemplateCSV</strong> — <em>sample assets creators</em><br><strong>Purpose:</strong> Provide sample template sheet, store sample template into CustomXMLParts, and export CSV for user onboarding and tests.<br><strong>Signature:</strong> <code>Public Sub CreateSampleTemplate(Optional ByVal wb As Workbook = Nothing)</code>; <code>Private Sub AddSampleTemplateToCustomXML(ByVal wb As Workbook)</code>; <code>Public Function ExportSampleTemplateCSV(ByVal fullPath As String) As Boolean</code>.<br><strong>Behavior:</strong> <code>CreateSampleTemplate</code> creates <code>_IFRS_SampleTemplate</code> sheet with columns <code>account, desc, balance, date</code> and sample row. Adds CustomXML part with sample template. <code>ExportSampleTemplateCSV</code> writes a simple CSV to allowed path. All functions use <code>SafeCreateSheet</code>, <code>SafeLog</code> and error funnels.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes sheets, CustomXMLParts, and files. <br><strong>Security:</strong> <code>ExportSampleTemplateCSV</code> uses <code>IsAllowedPath</code> before writing. <br><strong>Tests:</strong> Verify sheet content, presence of CustomXMLPart, and CSV file content. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>GetDayCountConvention</strong> — <em>config getter for day-count</em><br><strong>Purpose:</strong> Return configured day-count convention (defaults to "ACT/365").<br><strong>Signature:</strong> <code>Public Function GetDayCountConvention(Optional ByVal defaultConvention As String = &quot;ACT/365&quot;) As String</code>.<br><strong>Behavior:</strong> Calls <code>GetConfigValue(&quot;DataInput.DayCountConvention&quot;)</code> and returns default if empty. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Set config and verify returned value. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ValidateInputSchema</strong> — <em>schema-driven validation of in-memory arrays</em><br><strong>Purpose:</strong> Validate a 2D array (as read from sheet/CSV/JSON) against scheme rules (required headers and per-row rules). Used for early input sanity checks before staging commit.<br><strong>Signature:</strong> <code>Public Function ValidateInputSchema(ByVal inputArr As Variant, ByVal schemaName As String) As Object</code> → returns <code>Scripting.Dictionary</code> mapping header/row -> error messages; returns empty dict when no errors.<br><strong>Behavior (detailed):</strong> Normalizes array to 1-based 2D via <code>Normalize2DArrayTo1Based_Flexible</code>, builds header map, applies <code>g_cacheColumnMap</code> mappings, then enforces <code>rules</code> (<code>account</code> required, <code>balance</code> required,numeric,nonzero). Validates each row and calls <code>ValidateCOA</code> for account column. Adds per-row error messages keyed by row index. Uses <code>HandleError</code> on exceptions and returns <code>Nothing</code> on catastrophic failures.<br><strong>Complexity:</strong> O(r*c) where r=rows, c=columns. <br><strong>Side-effects:</strong> None (pure validation) except calls to <code>ValidateCOA</code> and possible external error handlers. <br><strong>Invariants:</strong> Returned dictionary uses string keys for row numbers or "header". <br><strong>Failure modes:</strong> Malformed arrays, huge arrays (memory), missing <code>ValidateCOA</code> implementations — <code>ValidateCOA</code> in module is simple but may be overridden externally in future. <br><strong>Tests:</strong> Small arrays with missing headers and invalid numeric values; ensure errors reported with correct row keys. <br><strong>Notes:</strong> <code>schemaName</code> currently unused; future extension point for multiple schemas. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>CollectDiagnostics</strong> — <em>light diagnostics snapshot for staging</em><br><strong>Purpose:</strong> Produce a small diagnostics dictionary describing staging state (rows read, issues count, correlation id, elapsed time). Useful for telemetry and troubleshooting.<br><strong>Signature:</strong> <code>Public Function CollectDiagnostics(ByVal stagingWs As Worksheet) As Object</code> → returns <code>Scripting.Dictionary</code> with keys <code>ok, rowsRead, issuesCount, corrId, timeTaken</code>.<br><strong>Behavior:</strong> Counts rows in staging sheet; creates new correlation id; measures time; returns dictionary. Errors forwarded to <code>HandleError</code> and function returns <code>Nothing</code> on failure.<br><strong>Complexity:</strong> O(1) reads; O(rows) to compute <code>rowsRead</code> (cell-based). <br><strong>Tests:</strong> Call with a staging sheet containing data; assert diagnostic values. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>PlanMigrateExistingInputs</strong> — <em>migration hook stub</em><br><strong>Purpose:</strong> Logging stub to indicate migration plan and schema version; extension point for future migrations.<br><strong>Signature:</strong> <code>Public Sub PlanMigrateExistingInputs()</code><br><strong>Behavior:</strong> Calls <code>SafeLog</code> with module schema version. <br><strong>Tests:</strong> Verify log entry created. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>DataInputSelfTests / DataInput_SelfTest / DataInputSelfTests_OneIteration</strong> — <em>self-test harness</em><br><strong>Purpose:</strong> Provide deterministic self-checks to verify core I/O, CSV parsing, staging sheet creation, atomic write fallback, and JSON-read path.<br><strong>Signature:</strong> <code>Public Function DataInputSelfTests() As Boolean</code>, <code>Public Function DataInput_SelfTest() As Boolean</code>, <code>Private Function DataInputSelfTests_OneIteration() As Boolean</code>.<br><strong>Behavior:</strong> Runs repeated iterations checking <code>SplitCsvLine_Strict</code>, staging creation <code>CreateOrEnsureStagingSheet</code>, <code>WriteArrayToSheetAtomic</code>, reading back ranges, atomic write attempt via <code>modUtilities.AtomicWriteFile</code> (best-effort), writing / reading JSON via <code>ReadJsonToArray</code>. Writes results to hidden <code>_IFRS_TestResults</code> sheet. Logs result. Designed to be non-destructive. <br><strong>Complexity:</strong> O(k) small. <br><strong>Side-effects:</strong> Creates hidden test sheets and temporary files. <br><strong>Tests:</strong> Self-tests by running <code>DataInput_SelfTest</code>. <br><strong>Notes:</strong> Keep tests deterministic and idempotent; avoid leaving temporary files. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ImportTrialBalance / ValidateCOA (public compatibility)</strong> — <em>backwards-compatible public surface</em><br><strong>Purpose:</strong> Preserve legacy public API surface used by other add-in callers. <code>ImportTrialBalance</code> delegates to advanced import; <code>ValidateCOA</code> provides trivial validation for account codes (placeholder for external override or extension).<br><strong>Signature:</strong> <code>Public Sub ImportTrialBalance()</code>; <code>Public Function ValidateCOA(accountCode As String) As Boolean</code>.<br><strong>Behavior:</strong> <code>ImportTrialBalance</code> calls <code>ImportTrialBalanceAdvanced(&quot;sheet&quot;, &quot;&quot;, Nothing, &quot;&quot;, False)</code>. <code>ValidateCOA</code> returns <code>True</code> when accountCode non-empty (simple rule). Both swallow errors and call <code>HandleError</code> on exception.<br><strong>Complexity:</strong> O(1) (delegation).<br><strong>Notes:</strong> Keep signatures stable for compatibility. Implement stricter validation in <code>modSecurity</code> or external registry if needed. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ImportTrialBalanceAdvanced</strong> — <em>main import orchestration</em><br><strong>Purpose:</strong> Full, hardened import pipeline supporting multiple source types (<code>sheet</code>, <code>csv</code>, <code>workbook</code>, <code>json</code>, <code>powerquery</code>), staging, preview, validation, optional dry-run, and commit with atomic save and lock management. This is the module's central orchestration function.<br><strong>Signature:</strong> <code>Public Sub ImportTrialBalanceAdvanced(Optional ByVal sourceType As String = &quot;sheet&quot;, Optional ByVal sourcePath As String = &quot;&quot;, Optional ByVal targetWb As Workbook = Nothing, Optional ByVal profileName As String = &quot;&quot;, Optional ByVal dryRun As Boolean = False, Optional ByVal allowOverwrite As Boolean = False)</code> → none; error handling internal and via <code>HandleError</code>.<br><strong>Behavior (stepwise):</strong><br>- Reentrancy guard via <code>g_isRunning</code>. Acquire correlation id. Resolve target workbook. Acquire import lock using <code>AcquireImportLock</code>.<br>- Switch on <code>sourceType</code>: call functions to read data into <code>arrData</code>: <code>ReadFromActiveSheetToArray</code>, <code>ReadCsvToArray</code>, <code>ReadWorkbookRangeToArray</code>, <code>ReadJsonToArray</code>, <code>ReadFromPowerQueryStub</code>.<br>- Validate <code>arrData</code> non-empty; progress callback 20%.<br>- Create staging sheet <code>CreateOrEnsureStagingSheet</code>, <code>WriteArrayToSheetAtomic</code> to staging, progress 50%.<br>- Ensure staging schema (<code>EnsureStagingSchema</code>), assign stable row IDs (<code>AssignStableRowIDs</code>), preview (<code>PreviewImport</code>) and validate <code>ValidateStagingSheetSchemaDriven</code>. If validation errors, write errors sheet (<code>WriteErrorsToSheet</code>) and abort (unless dry run). Progress 80% on success.<br>- If <code>dryRun</code> log and exit. Otherwise <code>CommitStagingToDestination</code> (backups, overwrite policies, <code>SaveWorkbookAsAtomic</code> fallback) and progress 100%.<br>- Finally, release lock and clear running flag in all exit paths. Errors funnel to <code>HandleError</code> with correlation id where appropriate.<br><strong>Complexity:</strong> Dominated by read step and write steps O(rows*cols). <br><strong>Side-effects:</strong> Creates/updates staging and preview sheets, errors sheet, destination sheet, backups, optional atomic save to disk, job metadata and audit entries. <br><strong>Invariants:</strong> Ensures import lock acquired before write; always attempts to release lock on exit. <code>g_isRunning</code> prevents re-entrancy. <br><strong>Failure modes / recovery:</strong> Read failures, policy blocks (IsAllowedPath), validation errors, sheet creation failures, disk save errors. All are handled by logging and <code>HandleError</code>, with dry-run option for safe checks. If lock not released due to unexpected host crash, lock includes timestamp; <code>AcquireImportLock</code> will delete locks older than 60 mins. <br><strong>Security / Policy:</strong> All external path operations call <code>IsAllowedPath</code> before reading/writing. Macro security verification attempted via <code>TryRunReturn(&quot;modSecurity.Security_VerifyMacroSettings&quot;)</code> in workbook reads. <br><strong>Recommended tests:</strong> End-to-end flows for each <code>sourceType</code>, dry-run vs commit paths, concurrency lock testing, invalid CSV/JSON inputs, path policy denial, atomic save fallback. <br><strong>Notes:</strong> This function must remain stable in signature (back-compat). For very large imports, consider chunked processing or an async job model via <code>EnqueueImportJob</code>. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadFromActiveSheetToArray</strong> — <em>sheet read to variant array</em><br><strong>Purpose:</strong> Read data from a named worksheet into a VBA 2D array via <code>UsedRange</code> → quick path for <code>sourceType=&quot;sheet&quot;</code>.<br><strong>Signature:</strong> <code>Private Function ReadFromActiveSheetToArray(ByVal wb As Workbook, ByVal sheetName As String) As Variant</code> → <code>Variant</code> array or <code>Empty</code>.<br><strong>Behavior:</strong> <code>SafeGetWorksheet</code> to resolve sheet; obtains <code>UsedRange</code> and returns <code>.Value</code>. Defensive error handling returns <code>Empty</code> on failure.<br><strong>Complexity:</strong> O(rows*cols) to marshal array. <br><strong>Failure modes:</strong> No sheet or empty used range returns <code>Empty</code>. <br><strong>Tests:</strong> Named sheet with data -> correct array. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadCsvToArray</strong> — <em>robust CSV reader returning 2D VBA array</em><br><strong>Purpose:</strong> Read CSV from disk into normalized 2D variant array with robust quoted-field parsing, multi-line quoted records, and BOM/newline normalizations.<br><strong>Signature:</strong> <code>Public Function ReadCsvToArray(ByVal fullPath As String) As Variant</code> → 2D variant array or <code>Empty</code>.<br><strong>Behavior (detailed):</strong><br>- Policy check <code>IsAllowedPath</code>. Open file binary, read file length, read bytes using <code>ReadBinaryStreamAsString</code>. Close file. Normalize BOM and newlines via <code>NormalizeTextNewlinesAndBOM</code>.<br>- Build logical CSV records with <code>BuildCsvLogicalRecords</code> to handle quoted embedded newlines. Determine max columns by splitting each logical record with <code>SplitCsvLine_Strict</code>. Allocate <code>out(1..rCount,1..cMax)</code> and fill from tokenized lines.<br>- Return <code>out</code> or <code>Empty</code> on failure; errors call <code>HandleError</code>.<br><strong>Complexity:</strong> O(n) where n = file bytes plus tokenization cost. Memory O(n) for full file content and resultant array. <br><strong>Side-effects:</strong> None beyond file read. <br><strong>Invariants:</strong> Output always 1-based 2D array; empty input returns <code>Empty</code>. <br><strong>Failure modes:</strong> Huge files causing memory exhaustion; non-UTF8 binary content; inconsistent quoting (malformed CSV) will be partially parsed but may produce unexpected fields.<br><strong>Security:</strong> Path must be allowed. <br><strong>Recommended tests:</strong> Quoted records with embedded newlines, double quotes escaping, various BOMs (UTF-8/UTF-16 LE/BE), extremely wide rows, empty files, and very large files (streaming consideration). <br><strong>Notes:</strong> This is synchronous and memory-bound; for >3MB consider streaming approach in future. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadBinaryStreamAsString</strong> — <em>binary-to-string reader</em><br><strong>Purpose:</strong> Read binary file in blocks into a single VBA string buffer (used by CSV/JSON readers).<br><strong>Signature:</strong> <code>Private Function ReadBinaryStreamAsString(ByVal fnum As Long, ByVal totalBytes As Long) As String</code><br><strong>Behavior:</strong> Loop reading <code>blockSize</code> (65,536 bytes) using <code>Get #fnum</code> into pre-sized <code>Space$()</code> buffer and concatenating to <code>result</code>. Returns string. <br><strong>Complexity:</strong> O(totalBytes) with repeated string concatenation (risk: <code>&amp;</code> operator in VBA can be O(n^2) for many concatenations).<br><strong>Failure modes:</strong> Large files cause slow concatenation and memory pressure. <br><strong>Tests:</strong> Small and medium files; profile performance. <br><strong>Notes:</strong> Consider <code>Byte</code> array accumulation with <code>StrConv</code> to avoid repeated reallocations for very large files. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>NormalizeTextNewlinesAndBOM</strong> — <em>BOM + newline normalizer</em><br><strong>Purpose:</strong> Normalize common BOM encodings (UTF-8 BOM, UTF-16 LE/BE signature) to plain string and normalize CRLF/CR to LF for CSV/JSON parsing reliability.<br><strong>Signature:</strong> <code>Private Function NormalizeTextNewlinesAndBOM(ByVal txt As String) As String</code><br><strong>Behavior:</strong> Detects byte-order marks by looking at <code>Asc</code> of first bytes and strips BOM and null chars for UTF-16, strips UTF-8 BOM. Replaces CRLF and CR with LF. <br><strong>Complexity:</strong> O(len(txt)).<br><strong>Tests:</strong> Files with UTF-8 BOM, UTF-16 LE/BE BOMs, and mixed newlines. <br><strong>Notes:</strong> Limited to simple BOM heuristics; binary files may confuse heuristics. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>BuildCsvLogicalRecords</strong> — <em>emits logical CSV record strings honoring quotes</em><br><strong>Purpose:</strong> Convert a flat file string into a <code>Collection</code> of logical CSV records where quoted fields containing embedded newlines are preserved as single records.<br><strong>Signature:</strong> <code>Private Function BuildCsvLogicalRecords(ByVal raw As String) As Collection</code><br><strong>Behavior:</strong> Iterates characters, toggling <code>inQuotes</code> at unescaped <code>&quot;</code>. When encountering LF and <code>inQuotes</code> is False, closes record. Handles doubled <code>&quot;&quot;</code> escapes as literal <code>&quot;</code> inside quoted field. Returns <code>Collection</code> of strings with trailing LF removed. <br><strong>Complexity:</strong> O(n).<br><strong>Failure modes:</strong> Malformed CSV with unmatched quotes yields last buffer added if non-empty. <br><strong>Tests:</strong> Records with embedded newlines and escaped quotes. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SplitCsvLine_Strict</strong> — <em>tokenize single CSV line into fields</em><br><strong>Purpose:</strong> Split a CSV logical-record string into fields with strict quote-handling and trimming for unquoted fields.<br><strong>Signature:</strong> <code>Private Function SplitCsvLine_Strict(ByVal line As String) As String()</code> → zero-based 1D string array.<br><strong>Behavior:</strong> Parses char-by-char, handles quoted fields, double-quote escaping, trims non-quoted fields, preserves inner commas in quoted fields. Returns array of fields. On error returns <code>Array(&quot;&quot;)</code> and logs error. <br><strong>Complexity:</strong> O(len(line)).<br><strong>Tests:</strong> Quoted/unquoted combo, trailing blank fields, fields with doubled quotes. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadWorkbookRangeToArray / FilenameOnly</strong> — <em>read another workbook's first sheet usedrange</em><br><strong>Purpose:</strong> Open another workbook (path), read first worksheet <code>UsedRange</code> into 2D array and close workbook (ReadOnly) with retries to handle transient lock conditions.<br><strong>Signature:</strong> <code>Public Function ReadWorkbookRangeToArray(ByVal workbookPath As String) As Variant</code> and helper <code>Private Function FilenameOnly(ByVal path As String) As String</code>.<br><strong>Behavior:</strong> Verifies <code>IsAllowedPath</code>, calls <code>modSecurity.Security_VerifyMacroSettings</code> if available, attempts to find Workbooks(wbNameOnly) or open with <code>Workbooks.Open</code> up to <code>MAX_OPEN_RETRIES</code> with <code>SleepMs</code> between attempts. Returns <code>.UsedRange.Value</code>. Ensures <code>srcWb.Close SaveChanges:=False</code> when opened by this function. <br><strong>Complexity:</strong> IO-bound; retries increase latency. <br><strong>Side-effects:</strong> Opens workbooks; may trigger macros in opened workbook depending on settings. <br><strong>Security:</strong> Macro verification step attempted; <code>IsAllowedPath</code> enforced. <br><strong>Failure modes:</strong> Locked files, password-protected workbooks, unsupported file formats. <br><strong>Tests:</strong> Read sample workbook, test retry logic by locking file (simulate). </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadJsonToArray / JsonArrayToVBAArray</strong> — <em>robust-ish JSON array reader into 2D array</em><br><strong>Purpose:</strong> Read JSON file that is expected to be an array of objects or arrays and return a 2D VBA array suitable for staging; provides a fallback parser if RegExp available and simple object flattening.<br><strong>Signature:</strong> <code>Public Function ReadJsonToArray(ByVal fullPath As String) As Variant</code> and <code>Private Function JsonArrayToVBAArray(ByVal txt As String) As Variant</code>.<br><strong>Behavior:</strong> Reads file binary, normalizes whitespace, checks that top-level is <code>[...]</code>. If contains <code>{</code>, attempts to manually parse object tokens using <code>VBScript.RegExp</code> (if available) to produce header set and list of object dictionaries, then converts to rows and columns. If content appears to be a pure array-of-arrays, delegates to <code>JsonArrayToVBAArray</code>. Returns <code>Empty</code> if unparsable. <br><strong>Complexity:</strong> O(n) over text. <br><strong>Limitations:</strong> This is a light-weight, brittle JSON parser — not safe for complex nested structures, escaped characters, or arrays-of-mixed-objects; relies on <code>RegExp</code> heuristic or naive splitting. <br><strong>Security:</strong> Input JSON must be trusted; parser may mishandle escaped quotes. <br><strong>Recommended tests:</strong> Simple array-of-objects and array-of-arrays, nested arrays (should fail), presence of <code>null/true/false/numbers</code> handling. <br><strong>Notes:</strong> Prefer using a robust JSON parser via <code>modUtilities</code> or VBScript JSON if available; current implementation is best-effort. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadFromPowerQueryStub</strong> — <em>placeholder for PQ integration</em><br><strong>Purpose:</strong> Placeholder for future Power Query integration; currently returns <code>Empty</code> to indicate unsupported source.<br><strong>Signature:</strong> <code>Private Function ReadFromPowerQueryStub(ByVal profileName As String) As Variant</code>.<br><strong>Notes:</strong> Implementers should replace stub with actual PQ read logic or hook to modUtilities. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SafeGetWorksheet / SafeCreateSheet / CreateOrEnsureStagingSheet</strong> — <em>worksheet resolution & staging creation</em><br><strong>Purpose:</strong> Safe helpers to get or create worksheets (visible or very hidden) and to find pre-existing staging sheet or a sheet that contains <code>STAGING_SCHEMA_TOKEN</code> in cell A1 and re-use it by un-hiding and renaming. <code>CreateOrEnsureStagingSheet</code> returns an existing staging sheet or adds a new one via <code>SafeCreateSheet</code>.<br><strong>Signature:</strong> <code>Public Function SafeGetWorksheet(ByVal wbOrTarget As Variant, Optional ByVal sheetName As String = &quot;&quot;) As Worksheet</code>, <code>Private Function SafeCreateSheet(ByVal wb As Workbook, ByVal sheetName As String, Optional ByVal veryHidden As Boolean = False) As Worksheet</code>, <code>Private Function CreateOrEnsureStagingSheet(ByVal wb As Workbook) As Worksheet</code>.<br><strong>Behavior:</strong> Uses <code>ResolveWorkbook</code>, defensive <code>On Error Resume Next</code> to avoid breaking if worksheet access is restricted. <code>CreateOrEnsureStagingSheet</code> also scans <code>wb.Worksheets</code> for <code>xlSheetVeryHidden</code> sheets with <code>STAGING_SCHEMA_TOKEN</code> in cell(1,1) to re-use previously stored staging sheets. <br><strong>Complexity:</strong> O(sheets) for scanning. <br><strong>Side-effects:</strong> May un-hide and rename hidden sheets. <br><strong>Invariants:</strong> Staging sheet named <code>STAGING_SHEET_NAME</code> and contains <code>STAGING_SCHEMA_TOKEN</code> in cell A1. <br><strong>Tests:</strong> Create hidden sheet with token and verify re-use; create new staging sheet path. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>EnsureStagingSchema</strong> — <em>place schema token & adjust layout</em><br><strong>Purpose:</strong> Ensure staging sheet contains token in cell A1 and moves header row down if necessary to guarantee header at row1 and data start at row2. Preserves the previous token if present.<br><strong>Signature:</strong> <code>Private Sub EnsureStagingSchema(ByVal stagingWs As Worksheet)</code><br><strong>Behavior:</strong> Sets <code>STAGING_SCHEMA_TOKEN</code> in <code>Cells(1,1)</code>. If <code>Cells(1,2)</code> non-empty, shifts used range down by one row to keep token. Toggles <code>Application.ScreenUpdating</code> and <code>EnableEvents</code> to avoid flicker. <br><strong>Complexity:</strong> O(range size) for copy operations. <br><strong>Failure modes:</strong> Large used ranges could be expensive; ensure events restored on error. <br><strong>Tests:</strong> Data in sheet with/without existing token; verify token placed and data shifted properly. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>WriteArrayToSheetAtomic</strong> — <em>atomic-style array-to-worksheet writer</em><br><strong>Purpose:</strong> Efficiently write a 2D array into a worksheet range in a single assignment to avoid cell-by-cell loops and to minimize event overhead; uses screen/update toggles for atomic-like effect within Excel object model.<br><strong>Signature:</strong> <code>Private Sub WriteArrayToSheetAtomic(ByVal ws As Worksheet, ByVal arr As Variant, Optional ByVal trimEmptyCols As Boolean = False)</code><br><strong>Behavior:</strong> Normalizes array to 1-based 2D via <code>Normalize2DArrayTo1Based_Flexible</code>, computes dimensions, toggles <code>Application.ScreenUpdating</code> and <code>EnableEvents</code>, and writes to <code>ws.Range(...).Value = a1</code>. On error restores application state and logs error. For non-array input writes scalar to A1. <br><strong>Complexity:</strong> O(r*c) for array marshalling, but single COM write faster than cell loops. <br><strong>Side-effects:</strong> Replaces cell values within target range. <br><strong>Tests:</strong> Arrays with variance in bounds (0-based, 1-based, 1D) and scalar inputs; ensure application state restored on error. <br><strong>Notes:</strong> This is the recommended bulk-write path. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Normalize2DArrayTo1Based_Flexible / GetArrayDimensions</strong> — <em>array shape normalizer</em><br><strong>Purpose:</strong> Convert inputs of variable shapes (scalar, 1D array, 2D array with arbitrary lower bounds) to a 1-based 2D array suitable for <code>Range.Value</code> assignments; <code>GetArrayDimensions</code> helps identify shape.<br><strong>Signatures:</strong> <code>Private Function Normalize2DArrayTo1Based_Flexible(ByVal arr As Variant) As Variant</code>, <code>Private Function GetArrayDimensions(ByVal arr As Variant) As Long</code>.<br><strong>Behavior:</strong> If scalar, wraps into 1x1 array. If 1D, maps into 1xN array. If 2D, re-indexes into 1..rows,1..cols. If unsupported, raises error. Errors captured and returned as-is. <br><strong>Complexity:</strong> O(n) copy to normalized array. <br><strong>Tests:</strong> Provide arrays with LBound <> 1 and verify normalized result; provide 1D arrays and scalars. <br><strong>Notes:</strong> Essential for robust input handling from various readers. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>AssignStableRowIDs / GetUtcStampForId</strong> — <em>generate deterministic RowIDs</em><br><strong>Purpose:</strong> Ensure each staging row has stable unique identifier <code>IFRS_RowID</code> to enable traceability across operations and error reporting.<br><strong>Signature:</strong> <code>Private Sub AssignStableRowIDs(ByVal stagingWs As Worksheet, ByVal correlationId As String)</code>, <code>Private Function GetUtcStampForId() As String</code>.<br><strong>Behavior:</strong> Locates <code>ROWID_HEADER</code> column or creates it. Iterates data rows and assigns IDs of the form <code>RB-&lt;utcstamp&gt;-&lt;row&gt;-&lt;6digitRandom&gt;</code>. Avoids collisions by tracking <code>existingIds</code> in dictionary. Uses <code>Application.TimeZone</code> to compute UTC stamp if available; random seed with <code>Randomize</code>. Logs assignment. <br><strong>Complexity:</strong> O(rows). <br><strong>Side-effects:</strong> Writes <code>IFRS_RowID</code> into staging sheet. <br><strong>Invariants:</strong> New IDs unique within sheet. <br><strong>Tests:</strong> Re-run function and ensure existing IDs preserved; check uniqueness for many rows. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>PreviewImport</strong> — <em>create visible preview sheet for user</em><br><strong>Purpose:</strong> Produce a limited preview (<code>rowsToShow</code>, default 50) from staging into <code>_IFRS_Preview</code> sheet and activate it for user inspection during import pipeline.<br><strong>Signature:</strong> <code>Private Sub PreviewImport(ByVal stagingWs As Worksheet, Optional ByVal rowsToShow As Long = 50, Optional ByVal correlationId As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Copies the top <code>rowsToShow</code> rows (including headers) from staging used range into preview sheet, makes it visible and activates it. Logs creation. <br><strong>Complexity:</strong> O(rowsToShow * cols). <br><strong>Side-effects:</strong> Creates/updates <code>_IFRS_Preview</code> visible sheet and activates it (may change user's view). <br><strong>Tests:</strong> Preview with fewer rows than requested, sheet activation, and state preservation. <br><strong>Notes:</strong> Avoid activating sheet in headless automation; consider optional flag to suppress activation. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>CommitStagingToDestination</strong> — <em>move staging into destination sheet with backup & atomic save</em><br><strong>Purpose:</strong> Final commit step which copies staging used range to destination sheet name (<code>TrialBalance</code> default), optionally creates a backup (very hidden), and triggers atomic workbook save path if configured.<br><strong>Signature:</strong> <code>Private Sub CommitStagingToDestination(ByVal wb As Workbook, ByVal stagingWs As Worksheet, ByVal destSheetName As String, ByVal allowOverwrite As Boolean, ByVal correlationId As String)</code><br><strong>Behavior (detailed):</strong> Validates staging not empty, checks if destination exists and if <code>allowOverwrite</code> false -> error. If destination exists and overwrite allowed, creates a backup copy with prefix <code>IMPORT_BACKUP_PREFIX + destSheetName + timestamp</code>, hides backup very hidden. If destination missing creates sheet. Clears destination and writes staging <code>UsedRange.Value</code> into destination via range assignment. Attempts atomic save if <code>DataInput.AtomicSave.Path</code> configured by calling <code>SaveWorkbookAsAtomic</code>. Logs commit. On error uses <code>HandleError</code>.<br><strong>Complexity:</strong> O(r*c) copy. <br><strong>Side-effects:</strong> Creates backup sheet, renames staging sheet to include <code>_COMMITTED_</code> suffix, creates file save if <code>AtomicSave.Path</code> configured. <br><strong>Invariants:</strong> Backup created before overwrite. <br><strong>Failure modes / recovery:</strong> Save failure logged; if commit incompletely applied, earlier backup provides recovery path. <br><strong>Security:</strong> Path saved validated via <code>IsAllowedPath</code>. <br><strong>Tests:</strong> Destination exists/not exists, overwrite false -> error; overwrite true -> backup created, commit applied; atomic save path configured -> attempt occurs. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ValidateStagingSheetSchemaDriven</strong> — <em>sheet-level validation of staging data</em><br><strong>Purpose:</strong> Validate staging sheet rows using header detection and per-row rules, produce detailed error dictionary keyed by row number.<br><strong>Signature:</strong> <code>Private Function ValidateStagingSheetSchemaDriven(ByVal stagingWs As Worksheet, ByVal correlationId As String) As Object</code> → <code>Scripting.Dictionary</code> mapping row->error string.<br><strong>Behavior:</strong> Reads headers from row1, applies <code>g_cacheColumnMap</code> header mapping, verifies required headers (<code>account</code>, <code>balance</code>), then iterates rows starting at 2 and validates <code>required</code>, <code>numeric</code>, and <code>nonzero</code> rules. Calls <code>ValidateCOA</code> for account values. Aggregates per-row error messages and returns dictionary. <br><strong>Complexity:</strong> O(rows * rules). <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Create staging with missing headers and invalid rows to verify errors returned with correct row keys. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>WriteErrorsToSheet</strong> — <em>persist validation errors for user</em><br><strong>Purpose:</strong> Write validation errors dictionary into <code>_IFRS_ImportErrors</code> worksheet for user remediation, including corresponding <code>IFRS_RowID</code> when available.<br><strong>Signature:</strong> <code>Private Sub WriteErrorsToSheet(ByVal wb As Workbook, ByVal errorsDict As Object, Optional ByVal correlationId As String = &quot;&quot;, Optional ByVal stagingWs As Worksheet = Nothing)</code><br><strong>Behavior:</strong> Creates or clears <code>_IFRS_ImportErrors</code>, writes header columns <code>Row, Error, IFRS_RowID</code>, iterates errors dictionary and writes each error row. Attempts to locate <code>IFRS_RowID</code> column in staging and include value. Shows the errors sheet and logs. <br><strong>Complexity:</strong> O(errors.count). <br><strong>Side-effects:</strong> Creates visible error sheet; may expose sensitive row content to user. <br><strong>Tests:</strong> Provide error dictionary and stagingWs with rowids and assert correct content. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>DetectDuplicatesInStaging</strong> — <em>duplicate detection via key columns</em><br><strong>Purpose:</strong> Identify duplicate records in staging based on configurable key columns (defaults to <code>account,balance</code>) and return dictionary mapping composite key to collection of row indices.<br><strong>Signature:</strong> <code>Public Function DetectDuplicatesInStaging(ByVal stagingWs As Worksheet, Optional ByVal keyColumns As Variant) As Object</code> → <code>Scripting.Dictionary</code> of <code>Collection</code> of row numbers.<br><strong>Behavior:</strong> Builds headers map, iterates rows, builds composite <code>keyVal</code> for configured columns, groups rows into <code>Collection</code> per key. Returns dictionary where <code>result(key).Add r</code>. If no duplicates present, each collection size=1. <br><strong>Complexity:</strong> O(rows * keyColumns). <br><strong>Tests:</strong> Duplicate rows across different columns; default keys and custom keyColumns. <br><strong>Notes:</strong> Caller should post-process to return only keys with count>1. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>AcquireImportLock / ReleaseImportLock</strong> — <em>simple workbook-scoped lock sheet mechanism</em><br><strong>Purpose:</strong> Prevent concurrent imports by creating a hidden workbook worksheet named <code>_IFRS_ImportLock</code> containing owner correlation id and timestamp; release by deleting sheet when owner matches or no corrId provided.<br><strong>Signature:</strong> <code>Private Function AcquireImportLock(ByVal wb As Workbook, ByVal correlationId As String) As Boolean</code>, <code>Private Sub ReleaseImportLock(ByVal wb As Workbook, ByVal correlationId As String)</code>.<br><strong>Behavior:</strong> If lock sheet exists, reads timestamp and owner id; if age > 60 minutes deletes stale lock and allows new acquire; otherwise acquisition fails. On acquire creates hidden lock sheet, writes timestamp and correlationId. <code>ReleaseImportLock</code> deletes lock sheet if owner matches or correlationId blank. All operations wrapped in error handling; uses <code>Application.DisplayAlerts</code> toggles when deleting. <br><strong>Complexity:</strong> O(1). <br><strong>Failure modes:</strong> Hidden sheet deletion permission denied; lock not released if process crashes — stale lock cleanup uses age heuristic. <br><strong>Tests:</strong> Acquire when no existing lock, attempt to acquire when lock present and <60min -> fail; lock older than 60min -> replaced. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>IsAllowedPath</strong> — <em>path policy enforcement</em><br><strong>Purpose:</strong> Centralized path policy to allow/deny file system operations. Uses <code>modSecurity</code> hooks when available and default heuristics to block system paths (<code>C:\Windows</code>, <code>/etc</code>).<br><strong>Signature:</strong> <code>Private Function IsAllowedPath(ByVal path As String) As Boolean</code><br><strong>Behavior:</strong> Tries <code>modSecurity.Security_AllowExportToPath</code> and <code>modSecurity.Security_AllowPath</code> via <code>TryRunReturn</code>. If not available, lowercases path and rejects paths containing <code>c:\windows</code> or <code>/etc</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Security:</strong> Primary defense against writes/read to privileged paths; callers must call before IO. <br><strong>Tests:</strong> Various allowed/forbidden paths and with modSecurity stub returning True/False. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ResolveTargetWorkbook / ResolveWorkbook / Nz</strong> — <em>utility resolvers</em><br><strong>Purpose:</strong> Helpers to resolve target workbook parameter (accepts workbook object or uses <code>ActiveWorkbook</code>/<code>ThisWorkbook</code>), gracefully handle workbook references by name, and provide <code>Nz</code> shorthand for null/empty replacement.<br><strong>Signatures:</strong> <code>Private Function ResolveTargetWorkbook(Optional ByVal targetWb As Workbook = Nothing) As Workbook</code>, <code>Private Function ResolveWorkbook(ByVal wbOrTarget As Variant) As Workbook</code>, <code>Private Function Nz(v As Variant, Optional ByVal alt As Variant = &quot;&quot;) As Variant</code>.<br><strong>Behavior:</strong> Accept various input shapes and return appropriate workbook object; <code>Nz</code> replaces Error/Null/Empty/Blank string with alt. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Pass workbook object, workbook name, empty and verify resolution. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SleepMs / GenerateCorrelationID</strong> — <em>timers and correlation ids</em><br><strong>Purpose:</strong> Utility functions for small waits and creating unique correlation IDs for tracing.<br><strong>Signatures:</strong> <code>Private Sub SleepMs(ms As Long)</code> and <code>Private Function GenerateCorrelationID() As String</code>.<br><strong>Behavior:</strong> <code>SleepMs</code> busy-waits while calling <code>DoEvents</code> using <code>Timer</code> (or <code>Date</code> for non-VBA7) to pause for short intervals. <code>GenerateCorrelationID</code> formats <code>Now</code> timestamp with random 6-digit suffix to produce <code>CID-yyyymmddHHMMSS-XXXXXX</code>. <br><strong>Complexity:</strong> Sleep is O(ms) CPU time. <br><strong>Failure modes:</strong> Busy wait may block UI thread; use sparingly. <br><strong>Tests:</strong> Confirm correlation IDs are unique across calls. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ParseBackupTimestamp</strong> — <em>parse timestamp from backup naming convention</em><br><strong>Purpose:</strong> Parse timestamp portion of backup sheet name suffix used in backups created during commit to compute <code>Date</code> object for ordering or cleanup.<br><strong>Signature:</strong> <code>Private Function ParseBackupTimestamp(ByVal part As String) As Date</code><br><strong>Behavior:</strong> Accepts formats like <code>yyyymmdd_HHNNSS</code> or concatenated <code>yyyymmddHHNNSS</code>, splits into date and time components, converts using <code>DateSerial</code> / <code>TimeSerial</code>. Returns 0 (empty date) on parse failure. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Valid and invalid suffix strings. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SimpleRangeChecksum / SafeModDoubleToLong</strong> — <em>range checksum utility</em><br><strong>Purpose:</strong> Compute a cheap checksum for a range (sum of lengths of cell stringified values) and reduce to 32-bit long safely. Useful for change detection heuristics.<br><strong>Signature:</strong> <code>Private Function SimpleRangeChecksum(ByVal rng As Range) As Long</code>, <code>Private Function SafeModDoubleToLong(ByVal val As Double, ByVal modVal As Long) As Long</code>.<br><strong>Behavior:</strong> Iterate array from <code>rng.Value</code> sum lengths of <code>CStr(Nz(cell,&quot;&quot;))</code> and reduce via <code>SafeModDoubleToLong</code> to a signed long. <code>SafeModDoubleToLong</code> computes remainder robustly even for large double values. <br><strong>Complexity:</strong> O(cells). <br><strong>Tests:</strong> Ranges with known content produce deterministic checksum; overflow handling confirmed. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SaveWorkbookAsAtomic</strong> — <em>atomic workbook save helper with modUtilities fallback</em><br><strong>Purpose:</strong> Save workbook to disk robustly using <code>modUtilities.AtomicSaveWorkbookAs</code> if available, otherwise fallback to <code>wb.SaveCopyAs</code> (best-effort). Returns boolean success flag.<br><strong>Signature:</strong> <code>Private Function SaveWorkbookAsAtomic(ByVal wb As Workbook, ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong> Tries <code>TryRunReturn(&quot;modUtilities.AtomicSaveWorkbookAs&quot;, wb, fullPath)</code> and returns <code>CBool(r)</code> if present. Else attempts <code>wb.SaveCopyAs</code> and interprets Err.Number to set boolean. Errors funnel to <code>HandleError</code>. <br><strong>Complexity:</strong> IO-bound. <br><strong>Side-effects:</strong> Writes to disk. <br><strong>Security:</strong> Caller must ensure <code>IsAllowedPath</code> used before invoking. <br><strong>Tests:</strong> Simulate presence/absence of <code>modUtilities</code>, ensure returned value consistent. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>WriteIntegrationTestPlan</strong> — <em>integration test artifact writer</em><br><strong>Purpose:</strong> Create <code>_IFRS_IntegrationTests</code> hidden sheet with steps for manual integration testing to help QA and support engineers.<br><strong>Signature:</strong> <code>Private Sub WriteIntegrationTestPlan()</code><br><strong>Behavior:</strong> Writes structured steps and expectations, hides the sheet. <br><strong>Notes:</strong> Keep in step with actual behavior changes; useful for release verification. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>RibbonInvalidate</strong> — <em>trigger ribbon refresh</em><br><strong>Purpose:</strong> Invalidate ribbon UI via either <code>Ribbon_Invalidate</code> or <code>modRibbonCallbacks.Invalidate</code> if available to reflect state changes.<br><strong>Signature:</strong> <code>Private Sub RibbonInvalidate()</code><br><strong>Behavior:</strong> Calls <code>TryRunReturn</code> on the two possible entrypoints; tolerant if neither exists. <br><strong>Tests:</strong> Ensure calls propagate to ribbon callbacks when present. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SecurityVerifyMacroSettings</strong> — <em>macro setting verification wrapper</em><br><strong>Purpose:</strong> Ask <code>modSecurity</code> to verify macro/security settings exist; defaults to True if module inaccessible.<br><strong>Signature:</strong> <code>Private Function SecurityVerifyMacroSettings() As Boolean</code><br><strong>Behavior:</strong> Calls <code>TryRunReturn(&quot;modSecurity.Security_VerifyMacroSettings&quot;)</code>; if available returns its boolean; else returns True by default. Errors reported to <code>HandleError</code>. <br><strong>Notes:</strong> This is a light safety check; do not rely solely on it for enforcement. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Detect notable cross-cutting behaviors & risks</strong> — <em>global module properties</em><br><strong>Purpose:</strong> Summarize how the module interacts with other modules and host environment.<br><strong>Behavior & dependencies:</strong> Heavy use of <code>TryRunReturn</code> to call: <code>modConfig</code>, <code>modUtilities</code> (Atomic write, Progress, EnqueueJob), <code>modAudit</code>, <code>modRibbonCallbacks</code>, and <code>modSecurity</code>. Uses workbook-level hidden sheets for locks, backups, audit, tests. All I/O operations check <code>IsAllowedPath</code> and attempt <code>modSecurity</code> hooks. Uses very-hidden sheets (<code>xlSheetVeryHidden</code>) to reduce accidental user interference.<br><strong>Performance considerations:</strong> <code>ReadCsvToArray</code> and <code>ReadBinaryStreamAsString</code> use full-file reads and repeated string concatenation — may be memory- and CPU-intensive for very large files. Consider streaming reads or byte-array accumulation for >5–10MB files. <br><strong>Robustness:</strong> Extensive <code>On Error</code> and defensive wrappers; central <code>HandleError</code> funnels errors. Good for high-availability add-in contexts. <br><strong>Security & privacy:</strong> Redaction applied to logs; path policies enforced via <code>IsAllowedPath</code>, but core module trusts <code>modSecurity</code> when available. Review telemetry and file writes for PII leakage. <br><strong>Tests recommended (integration + unit):</strong><br>- Unit: <code>Normalize2DArrayTo1Based_Flexible</code>, CSV parsing (quotes, embedded newlines), JSON parsing heuristics, <code>AssignStableRowIDs</code> uniqueness, <code>RedactSecrets</code> patterns.<br>- Integration: full <code>ImportTrialBalanceAdvanced</code> flows for <code>sheet</code>, <code>csv</code>, <code>workbook</code>, <code>json</code>, dry-run vs commit, concurrency lock tests, atomic save enabled/disabled, journal/backup created.<br>- Stress: large CSV (10MB+), many columns, very wide rows to measure memory behavior.<br>- Security: path allow/deny tests with <code>modSecurity</code> stubbed to True/False; macro verification flows.<br><strong>Maintenance notes:</strong><br>- Preserve public API signatures: <code>ImportTrialBalance</code> and <code>ValidateCOA</code> must remain stable.<br>- When changing tokenizer/CSV heuristics (SplitCsvLine), add compatibility tests for edge-case CSVs.<br>- Consider replacing naive JSON parsing with a robust JSON parser (VBScript JSON or a COM-enabled library) to safely handle nested structures.<br>- Replace <code>ReadBinaryStreamAsString</code> concatenation with byte-array accumulation for large-file performance.<br>- Add <code>maxParallelFetches</code> / streaming file reader if importing many large files.<br>- Log correlation IDs on all IO and long-running steps to aid support and debugging. </td></tr></tbody></table></div><div class="row-count">Rows: 54</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>