<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1766816636">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li>
<li class="toc-item"><a class="toc-link" href="#Table6">Table 6</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0159_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown (modError.bas)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown (modError.bas)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Module Name</strong><br>modError.bas </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Overview:</strong><br>Deterministic, backward-compatible centralized error handling and lightweight structured logging for the IFRS Excel Add-in. Exposes a compact public API that preserves legacy behavior (raises original Err.Number after logging and user notification) while adding structured audit entries, a seeded error catalog, stable correlation IDs, and defensive fallbacks for locked-down environments (no Dictionary, no Scriptlet GUID, no native Sleep). Designed to be robust in the face of missing host services (LogAudit, NewCorrelationID) and to never allow logging to raise to callers. Intended invariants: public signatures remain stable; numeric error codes keep meaning across releases; logging must be best-effort and non-throwing. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>IFRS_ErrorSeverity (Enum)</strong> — <em>error severity levels</em><br><strong>Purpose:</strong> Provide a compact severity scale used across the module and by callers for branching (UI, audit, automation).<br><strong>Definition:</strong> <code>sevInfo = 1, sevWarning = 2, sevError = 3, sevCritical = 4</code><br><strong>Signature/Usage:</strong> used as parameter & stored in <code>IFRS_Error.severity</code>.<br><strong>Behavior:</strong> Simple numeric enum for comparisons (e.g., <code>If e.severity &gt;= sevCritical Then ...</code>).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Values must remain stable across builds (used for telemetry / audit filters).<br><strong>Failure modes:</strong> None intrinsic; mis-mapping on upgrades will change behavior of critical handlers.<br><strong>Tests:</strong> Assert comparison semantics and that severity constants are expected integers. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>IFRS_Error (Type)</strong> — <em>structured error record</em><br><strong>Purpose:</strong> Encapsulate error metadata for logging and downstream consumption (audit, telemetry, UI).<br><strong>Fields:</strong> <code>procName As String, errNum As Long, internalMsg As String, userMsg As String, severity As IFRS_ErrorSeverity, correlationID As String, contextJson As String, TimeStamp As Date</code><br><strong>Behavior:</strong> Populated by <code>HandleError</code> (or helpers) then forwarded to <code>SafeLogStructuredError</code> and to the legacy <code>Err.Raise</code>. Not marshalled beyond strings/dates inside module. Timestamp set to Now at creation.<br><strong>Complexity:</strong> O(1) allocation/copy. <br><strong>Side-effects:</strong> None by itself; used to produce audit entry and UI reaction.<br><strong>Invariants:</strong> <code>TimeStamp</code> must reflect time of error capture; <code>correlationID</code> must be non-empty after <code>HandleError</code> returns.<br><strong>Tests:</strong> Create sample IFRS_Error and assert fields set and truncated/escaped by logger as expected. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Module-level state / constants</strong> — <em>g_errorCatalog, flags, truncation constants</em><br><strong>Purpose:</strong> Persistent helpers to seed and query a message catalog and to control truncation of logged fields.<br><strong>Elements:</strong> <code>g_errorCatalog As Object</code> (Scripting.Dictionary when available), <code>g_catalogInitialized As Boolean</code>, <code>g_catalogAvailable As Boolean</code>, <code>g_randomized As Boolean</code>; constants <code>MAX_LOG_INTERNAL=800</code>, <code>MAX_LOG_USER=400</code>, <code>MAX_LOG_CONTEXT=800</code>.<br><strong>Behavior:</strong> Catalog initialization is attempted once per process; availability flag guides no-op behaviour when Dictionary unavailable. Truncation constants ensure predictable audit payload sizes. <code>g_randomized</code> guarantees <code>Randomize</code> is invoked once per session for fallback correlation ID suffix variation.<br><strong>Complexity:</strong> initialization O(N seeded items) when available; subsequent lookups O(1).<br><strong>Side-effects:</strong> Uses CreateObject which can fail in restricted hosts; code defensively sets <code>g_catalogAvailable=False</code> when that happens.<br><strong>Invariants:</strong> After first call to <code>EnsureCatalogInitialized</code>, <code>g_catalogInitialized=True</code> even if catalog unavailable (prevents repeated heavy attempts).<br><strong>Tests:</strong> Run initialization in environment with/without Scripting.Dictionary; confirm flags and counts behave. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>EnsureCatalogInitialized()</strong> — <em>one-shot catalog setup with graceful fallback</em><br><strong>Purpose:</strong> Create and populate the error catalog (Scripting.Dictionary) if available; ensure <code>Randomize</code> called once; mark initialization completed even on failure (deterministic behaviour across re-loads).<br><strong>Signature:</strong> <code>Private Sub EnsureCatalogInitialized()</code><br><strong>Behavior:</strong><br>- If already initialized, exit early.<br>- Attempt <code>CreateObject(&quot;Scripting.Dictionary&quot;)</code> under <code>On Error Resume Next</code>.<br>- If created, set <code>g_catalogAvailable = True</code>, remove any previous items, and call <code>addCatalogItem</code> repeatedly to seed codes and messages.<br>- If not available, set <code>g_catalogAvailable = False</code> and keep <code>g_errorCatalog = Nothing</code> (catalog lookup functions then return empty strings).<br>- Call <code>Randomize</code> once (guarded by <code>g_randomized</code>).<br><strong>Complexity:</strong> O(M) where M is number of seeded items (constant here).<br><strong>Side-effects:</strong> May call COM; may run with Err.Number non-zero which is cleared; safe for restricted hosts.<br><strong>Invariants:</strong> After first call, <code>g_catalogInitialized=True</code> always; consistent seeded content when dictionary exists.<br><strong>Failure modes:</strong> COM creation failure (handled), partial population (if an error occurs mid-seed) — module clears and proceeds defensively.<br><strong>Security:</strong> No external input used. <br><strong>Tests:</strong> Simulate success/failure paths; assert Idempotency and that post-initialization flags reflect environment. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>addCatalogItem(code, userMsg, remediation, Optional severity)</strong> — <em>safe catalog insertion</em><br><strong>Purpose:</strong> Insert a catalog entry into <code>g_errorCatalog</code> only when dictionary is available; no-op otherwise so missing Scripting runtime doesn't break callers.<br><strong>Signature:</strong> <code>Private Sub addCatalogItem(code As Long, userMsg As String, remediation As String, Optional severity As IFRS_ErrorSeverity)</code><br><strong>Behavior:</strong> Creates a small Scripting.Dictionary object <code>item</code> with keys <code>UserMessage</code>, <code>Remediation</code>, <code>DefaultSeverity</code> and stores it at <code>g_errorCatalog(CStr(code))</code>. Wrapped in <code>On Error Resume Next</code> and returns silently on any failure.<br><strong>Complexity:</strong> O(1) per item. <br><strong>Side-effects:</strong> Allocates COM objects (dictionary) when available; safe no-op otherwise.<br><strong>Invariants:</strong> Only invoked from initialization; duplicate keys are replaced (dictionary semantics).<br><strong>Failure modes:</strong> COM failure → no-op. <br><strong>Tests:</strong> With Scripting.Dictionary present, confirm retrieval by <code>GetUserMessageFromCatalog</code>. With dictionary absent, ensure no exception. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>HandleError(procName, errNum, Optional errMsg, Optional severity, Optional userMsg, Optional contextJson)</strong> — <em>core public handler preserving legacy flow</em><br><strong>Purpose:</strong> Centralized error capture: build structured <code>IFRS_Error</code>, choose user message (catalog override or param), ensure correlation ID, write structured audit log, show critical MsgBox when needed, then re-raise the original error (legacy behavior). Backwards-compatible signature: callers using <code>HandleError(procName, errNum, errMsg)</code> remain valid.<br><strong>Signature:</strong> <code>Public Sub HandleError(procName As String, errNum As Long, Optional errMsg As String = &quot;&quot;, Optional severity As IFRS_ErrorSeverity = sevError, Optional userMsg As String = &quot;&quot;, Optional contextJson As String = &quot;&quot;)</code><br><strong>Behavior (step-by-step):</strong><br>1. Call <code>EnsureCatalogInitialized</code> (one-shot) to enable catalog lookups.<br>2. Populate <code>IFRS_Error e</code> fields: <code>procName</code> defaulting to "Unknown", <code>errNum</code>, <code>internalMsg</code> chosen from <code>errMsg</code> or <code>GetInternalFallbackMessage(errNum)</code>, <code>severity</code> assigned from param and potentially elevated by catalog default severity if catalog has stronger severity.<br>3. Choose <code>userMsg</code>: prefer explicit <code>userMsg</code> param; else <code>GetUserMessageFromCatalog(errNum)</code>; fallback to generic message when none exists.<br>4. Generate <code>correlationID</code>: first attempt <code>Application.Run(&quot;NewCorrelationID&quot;)</code> safely (guarded with <code>On Error Resume Next</code>); if that fails or returns empty, call <code>GenerateCorrelationID()</code>.<br>5. Call <code>SafeLogStructuredError e</code> to produce compact escaped JSON string and pass to <code>LogAudit(&quot;Error&quot;, details)</code> in a best-effort fashion (must not raise).<br>6. If severity >= <code>sevCritical</code> show a <code>MsgBox</code> (guarded by error handlers so it cannot raise outward).<br>7. Finally, <code>Err.Raise errNum, procName, e.userMsg</code> to preserve legacy exception flow for callers/tests.<br><strong>Complexity:</strong> O(1) CPU per invocation; catalog lookup O(1) if available. Logging cost proportional to truncated string lengths (constant bounded by MAX_LOG_* constants).<br><strong>Side-effects:</strong> Calls Application.Run (external macro), COM (dictionary), LogAudit (external), and may show UI message box. Alters global <code>Err</code> state by <code>Err.Raise</code> (legacy behavior).<br><strong>Invariants:</strong> After return (or raising), a structured audit attempt was made and correlationID is non-empty. <code>Err.Raise</code> ensures calling code sees an error with original <code>errNum</code> and <code>userMsg</code> as Description.<br><strong>Failure modes:</strong><br>- Application.Run may throw (handled).<br>- LogAudit missing or failing — SafeLogStructuredError guards against exceptions so no propagation occurs.<br>- If <code>Err.Raise</code> itself fails unusually, host behavior follows VBA semantics; module does not suppress final raise.<br><strong>Security:</strong> <code>contextJson</code> and messages are trimmed and escaped before logging to prevent log injection. Avoid including PII in <code>contextJson</code> per privacy policies.<br><strong>Recommended tests:</strong> Simulate cases: (a) catalog present/absent; (b) <code>NewCorrelationID</code> present/absent; (c) severity levels including critical to assert MsgBox executed (can be tested with a headless hook stub); (d) confirm <code>Err.Number</code> equals provided <code>errNum</code> after call; (e) audit string format validated (escaped JSON).<br><strong>Notes for maintainers:</strong> Keep signature stable. Do not change final <code>Err.Raise</code> behavior since external code depends on legacy Err.Number/Description semantics. Ensure <code>LogAudit</code> contract exists and is non-blocking. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>RaiseIFRSError(procName, errNum, Optional internalMsg, Optional contextJson)</strong> — <em>shorthand wrapper</em><br><strong>Purpose:</strong> Convenience wrapper preserving older API shape that calls <code>HandleError</code> with <code>sevError</code> and empty user message (catalog will supply if present).<br><strong>Signature:</strong> <code>Public Sub RaiseIFRSError(procName As String, errNum As Long, Optional internalMsg As String = &quot;&quot;, Optional contextJson As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Delegates to <code>HandleError</code> with <code>sevError</code> and blank <code>userMsg</code> so catalog mapping is used. Maintains legacy call sites. <br><strong>Complexity/side-effects/failure modes:</strong> Same as <code>HandleError</code>.<br><strong>Tests:</strong> Call wrapper and assert same raise and audit outcomes as direct <code>HandleError</code>. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>GetUserMessageFromCatalog(errNum)</strong> — <em>defensive catalog read for user-facing message</em><br><strong>Purpose:</strong> Return catalog UserMessage or empty string if unavailable. Strictly defensive (no exceptions to caller).<br><strong>Signature:</strong> <code>Private Function GetUserMessageFromCatalog(errNum As Long) As String</code><br><strong>Behavior:</strong> Calls <code>EnsureCatalogInitialized</code>. If dictionary available and <code>g_errorCatalog.Exists(CStr(errNum))</code> returns stored <code>&quot;UserMessage&quot;</code>. Else returns empty string. Wrapped in <code>On Error Resume Next</code> to swallow COM errors.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Never raises; returns "" when no mapping. <br><strong>Tests:</strong> With seeded catalog verify known code returns correct message; absent catalog returns "". </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>GetRemediationFromCatalog(errNum)</strong> — <em>defensive catalog read for remediation text</em><br><strong>Purpose:</strong> Return remediation guidance string from catalog; defensive no-exception contract identical to <code>GetUserMessageFromCatalog</code> but returns <code>&quot;Remediation&quot;</code>.<br><strong>Signature:</strong> <code>Private Function GetRemediationFromCatalog(errNum As Long) As String</code><br><strong>Complexity/Testing/Notes:</strong> Same as <code>GetUserMessageFromCatalog</code>. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>GetInternalFallbackMessage(errNum)</strong> — <em>fallback internal message</em><br><strong>Purpose:</strong> Provide a minimal internal message if no <code>errMsg</code> passed to <code>HandleError</code> (keeps internalMsg non-empty).<br><strong>Signature:</strong> <code>Private Function GetInternalFallbackMessage(errNum As Long) As String</code><br><strong>Behavior:</strong> Returns <code>&quot;Error code &quot; &amp; CStr(errNum)</code> — deterministic and safe.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Ensure simple formatting. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>SafeLogStructuredError(e As IFRS_Error)</strong> — <em>build escaped compact JSON and call LogAudit</em><br><strong>Purpose:</strong> Centralized serialization of <code>IFRS_Error</code> into a compact JSON-like escaped payload (bounded by truncation constants) and best-effort call to <code>LogAudit(&quot;Error&quot;, details)</code> without propagating exceptions.<br><strong>Signature:</strong> <code>Private Sub SafeLogStructuredError(e As IFRS_Error)</code><br><strong>Behavior (detailed):</strong><br>- Use <code>TruncateString</code> to limit fields: CorrelationID(120), Proc(200), Internal(MAX_LOG_INTERNAL), User(MAX_LOG_USER), Context(MAX_LOG_CONTEXT). Truncation is performed BEFORE escaping to guarantee payload size limits.<br>- Use <code>EscapeForJson</code> to remove/escape control characters, backslashes, quotes, normalize newlines & tabs, and strip non-printables.<br>- Build a compact JSON-like string (all values double-quoted and escaped); timestamp formatted <code>&quot;yyyy-mm-dd HH:nn:ss&quot;</code> via <code>Format$</code>.<br>- Call <code>On Error Resume Next</code> then <code>LogAudit(&quot;Error&quot;, details)</code> (LogAudit is an external function expected to exist in project); swallow errors and <code>Err.Clear</code> afterwards. No throw to caller.<br><strong>Complexity:</strong> O(L) where L is bounded by constants; effectively constant-time.<br><strong>Side-effects:</strong> Calls external <code>LogAudit</code>. May allocate temporary strings sized by truncation constants.<br><strong>Invariants:</strong> Output not larger than truncation limits + JSON punctuation. Must not raise under any circumstances.<br><strong>Failure modes:</strong> If <code>LogAudit</code> not present or raises, errors are swallowed — but audit is then lost; consider instrumenting an alternate persistent fallback if needed.<br><strong>Security:</strong> Fields are escaped to avoid log injection; still avoid logging PII in <code>contextJson</code>.<br><strong>Tests:</strong> Provide <code>IFRS_Error</code> with suspicious characters and assert output contains escaped characters, respects truncation, and that <code>LogAudit</code> was invoked (mock). </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>CTypeOrDefault(v, Optional defaultVal)</strong> — <em>safe numeric cast to severity</em><br><strong>Purpose:</strong> Defensive cast of potentially-variant <code>DefaultSeverity</code> retrieved from catalog item to <code>IFRS_ErrorSeverity</code>, with bounds checking and fallback default.<br><strong>Signature:</strong> <code>Private Function CTypeOrDefault(v As Variant, Optional defaultVal As IFRS_ErrorSeverity = sevError) As IFRS_ErrorSeverity</code><br><strong>Behavior:</strong> Uses <code>IsNumeric</code>, <code>CLng</code> in <code>On Error Resume Next</code> and validates numeric range between <code>sevInfo</code> and <code>sevCritical</code>. Returns <code>defaultVal</code> on failure. Clears <code>Err</code> before exit.<br><strong>Complexity:</strong> O(1).<br><strong>Invariants:</strong> Always returns a valid severity constant. <br><strong>Tests:</strong> Pass numeric, string numeric, invalid string, missing key. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>TruncateString(s, maxLen)</strong> — <em>defensive truncation with ellipsis</em><br><strong>Purpose:</strong> Truncate long strings to <code>maxLen</code> (preserve small tail) and append "..." when <code>maxLen&gt;3</code> to indicate truncation. Used prior to escaping to keep payload predictable.<br><strong>Signature:</strong> <code>Private Function TruncateString(ByVal s As String, ByVal maxLen As Long) As String</code><br><strong>Behavior:</strong> If <code>Len(s) &lt;= maxLen</code> return s. Else return <code>Left$(s, maxLen-3) &amp; &quot;...&quot;</code> when <code>maxLen&gt;3</code>, else <code>Left$(s,maxLen)</code>.<br><strong>Complexity:</strong> O(maxLen).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Edge cases: maxLen <=3; maxLen longer than s; multibyte characters (VBA deals with character counts). </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>EscapeForJson(s)</strong> — <em>safe JSON-ish escaping + control filtering</em><br><strong>Purpose:</strong> Escape user/internal strings for safe inclusion inside the compact JSON-like payload: escape backslashes and double quotes, convert CR/LF to <code>\n</code>, replace tabs with a space, and remove non-printable characters (preserve LF). Also normalizes characters via <code>AscW</code> check to replace control codes with space.<br><strong>Signature:</strong> <code>Private Function EscapeForJson(ByVal s As String) As String</code><br><strong>Behavior (detailed):</strong><br>- <code>Replace(s, &quot;\&quot;, &quot;\\&quot;)</code> then <code>Replace(Chr(34), &quot;\&quot; &amp; Chr(34))</code>.<br>- Normalize newlines: <code>vbCrLf</code>, <code>vbCr</code>, <code>vbLf</code> to <code>\n</code>; tabs replaced with single space.<br>- Iterate characters and preserve only LF or characters with <code>AscW &gt;= 32</code>; others replaced with space. This prevents binary/control bytes from corrupting JSON payload.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> None. <br><strong>Security:</strong> Prevents log injection and unstable JSON chars. Does not perform Unicode \uXXXX escapes; keeps printable Unicode characters intact (suitable for audit).<br><strong>Failure modes:</strong> Very long strings handled because truncation done prior to escaping; if <code>AscW</code> fails on surrogate pairs, behavior depends on host; tests recommended.<br><strong>Tests:</strong> Strings with quotes, backslashes, CR/LF, tabs, and control chars should be escaped/normalized; non-ASCII chars should be preserved if printable. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>GenerateCorrelationID()</strong> — <em>project override -> Scriptlet GUID -> timestamp+random fallback</em><br><strong>Purpose:</strong> Produce a reasonably-unique correlation identifier for logs so multi-step flows can be grouped. Prefer platform GUID, but provide deterministic fallback when unavailable (useful on locked-down Excel runtimes).<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong><br>- Try <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code> and remove <code>{}</code> if successful, prefix with <code>IFRS-&lt;yyyymmddHHMMSS&gt;-&lt;guid&gt;</code>.<br>- If Scriptlet fails, ensure <code>Randomize</code> called and produce <code>&quot;IFRS-&lt;yyyymmddHHMMSS&gt;-&lt;randomSuffix&gt;&quot;</code> where suffix is <code>CLng(Abs(Rnd * 1000000#))</code>—ensures variation across runs. Uses <code>Now</code> formatted to year-month-day/time components.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> COM create attempt; <code>Randomize</code> call modifies global RNG state once only (guarded by <code>g_randomized</code>).<br><strong>Security/privacy:</strong> Correlation ID contains timestamp and GUID/random; avoid embedding user-identifiable information in correlation ID. <br><strong>Failure modes:</strong> CreateObject may fail (handled). Random fallback ok for correlation needs but not cryptographically secure. <br><strong>Tests:</strong> Verify GUID path returns GUID pattern; fallback path returns timestamp-suffix and uniqueness across successive calls. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>RetryOperationByName(functionName, attempts, delayMs, Optional lastErrNum)</strong> — <em>best-effort retry wrapper for named public routines</em><br><strong>Purpose:</strong> Generic retry helper that invokes a function by name via <code>Application.Run</code> up to <code>attempts</code> times with <code>delayMs</code> between attempts. Accepts heterogeneous return types: vbBoolean true, numeric non-zero, non-empty string, or non-Nothing object all treated as success. Returns Boolean indicating success and optionally last error number via <code>ByRef lastErrNum</code>.<br><strong>Signature:</strong> <code>Public Function RetryOperationByName(ByVal functionName As String, ByVal attempts As Long, ByVal delayMs As Long, Optional ByRef lastErrNum As Long) As Boolean</code><br><strong>Behavior:</strong><br>- Input validation: at least one attempt.<br>- Loop: <code>Application.Run(functionName)</code> under <code>On Error Resume Next</code>; examine <code>Err.Number</code> and <code>result</code>'s <code>VarType</code> to decide success. On success exit with True. On failure wait <code>SleepMs(delayMs)</code> and retry. Returns final boolean and last error number seen when calls fail.<br><strong>Complexity:</strong> O(attempts) * cost of invoked function. <br><strong>Side-effects:</strong> Calls external macro(s) and uses SleepMs which may DoEvents (reentrant host code).<br><strong>Invariants:</strong> Does not throw; returns False on persistent failure. <code>lastErrNum</code> is 0 when success or populated with last <code>Err.Number</code> when failure.<br><strong>Failure modes / gotchas:</strong><br>- <code>Application.Run</code> can call arbitrary user code which may be long-running, modal, or may change application state; retried calls may have side-effects.<br>- Delay uses <code>SleepMs</code> which may pump messages (DoEvents), enabling reentrancy; callers should ensure this is acceptable.<br><strong>Tests:</strong> Create sample macro that toggles success after N invocations and assert RetryOperationByName behavior. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Sleep declaration (conditional) & SleepMs(ms)</strong> — <em>host-safe sleep with native attempt</em><br><strong>Purpose:</strong> Provide a short blocking sleep utility that prefers native <code>Sleep</code> when available (declared via conditional compile for VBA7/Win64) and otherwise falls back to a <code>DoEvents</code> loop using <code>DateAdd</code> to avoid busy-waiting. This is used by retry helper to avoid tight loops while remaining host-safe.<br><strong>Signature:</strong> <code>Private Sub SleepMs(ByVal ms As Long)</code> (uses <code>SleepWin</code> declare when available).<br><strong>Behavior:</strong><br>- If <code>ms &lt;= 0</code> exit.<br>- Try calling <code>SleepWin ms</code> (declared in conditional compilation). If it errors (not present), fallback to computing <code>endTime = DateAdd(&quot;s&quot;, ms / 1000#, Now)</code> and loop <code>Do While Now &lt; endTime: DoEvents: Loop</code>.<br><strong>Complexity:</strong> Time-blocking for ms duration; CPU usage minimal because DoEvents yields. <br><strong>Side-effects:</strong> <code>DoEvents</code> permits other events/macros to run — may enable reentrancy; <code>SleepWin</code> does not pump messages. <br><strong>Safety/Failure modes:</strong> On UI-less automation or protected hosts, DoEvents may be restricted or slow — the function guards with <code>On Error Resume Next</code>. <br><strong>Tests:</strong> Sleep short durations and measure wall-clock; test native and fallback path via conditional compilation or by forcing native declare to be missing. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Test_Injection_RaiseSampleError()</strong> — <em>test/fault injection helper</em><br><strong>Purpose:</strong> Developer test hook that creates a structured error and raises it so unit tests or integration tests can validate audit/logging and legacy raise behavior. Useful for CI and diagnostics.<br><strong>Signature:</strong> <code>Public Sub Test_Injection_RaiseSampleError()</code><br><strong>Behavior:</strong> Calls <code>HandleError &quot;modError._Test_Injection_RaiseSampleError&quot;, 9999, &quot;Injected test error&quot;, sevError, &quot;Test error (injection)&quot;, &quot;{&quot;&quot;test&quot;&quot;:true}&quot;</code>. Because <code>HandleError</code> raises, callers will see Err.Number 9999; audit entry should be written.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Produces audit entry via <code>LogAudit</code> and raises Err.Number 9999. <br><strong>Tests:</strong> Called by automated tests to validate logging and raise semantics. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Public accessors for tests / read-only information</strong> — <em>GetUserFacingMessage, GetRemediationSteps, IsErrorCatalogInitialized, IsErrorCatalogAvailable, GetCatalogItemCount</em><br><strong>Purpose:</strong> Provide safe, read-only access to catalog state for unit tests and diagnostics without exposing mutable internals. Keep deterministic behavior across restricted hosts.<br><strong>Signatures:</strong><br>- <code>Public Function GetUserFacingMessage(errNum As Long) As String</code><br>- <code>Public Function GetRemediationSteps(errNum As Long) As String</code><br>- <code>Public Function IsErrorCatalogInitialized() As Boolean</code><br>- <code>Public Function IsErrorCatalogAvailable() As Boolean</code><br>- <code>Public Function GetCatalogItemCount() As Long</code><br><strong>Behavior:</strong> Thin wrappers around the internal lookup functions and state variables, defensively returning defaults when catalog absent. <code>GetUserFacingMessage</code> returns fallback <code>&quot;An error occurred. See audit log.&quot;</code> when empty.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Unit tests should assert correct returns when catalog seeded vs when unavailable. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Maintenance & compatibility notes (module-level)</strong><br><strong>Purpose:</strong> Guidance and constraints for maintainers to preserve deterministic behavior and avoid regressions.<br><strong>Key points:</strong><br>- <strong>API stability:</strong> Do not change <code>HandleError</code> signature or <code>RaiseIFRSError</code> semantics; callers expect <code>Err.Raise errNum, procName, userMsg</code> at the end.<br>- <strong>Error numbers:</strong> Preserve existing error code meanings (numeric constants) — changing codes breaks telemetry and documentation.<br>- <strong>Catalog availability:</strong> <code>EnsureCatalogInitialized</code> intentionally sets <code>g_catalogInitialized = True</code> even if dictionary is unavailable — preserve this one-shot behavior to avoid repeated COM attempts on constrained hosts.<br>- <strong>External hooks:</strong> <code>LogAudit</code> and optional <code>NewCorrelationID</code> are external contract points. Changes to their expected behavior must be coordinated across project. Implement a test stub for <code>LogAudit</code> in CI to validate logging path. <br>- <strong>DoEvents reentrancy:</strong> SleepMs fallback uses <code>DoEvents</code> and can permit reentrant code; avoid calling high-risk host operations from within RetryOperationByName unless reentrancy is acceptable.<br>- <strong>Truncation & escaping:</strong> Truncate BEFORE escaping — rely on <code>MAX_LOG_*</code> constants for predictable audit payload sizing. If fields need to be larger in telemetry later, increase constants and coordinate with server-side schema.<br>- <strong>Security / privacy:</strong> Avoid logging PII into <code>contextJson</code>; ensure downstream audit pipelines treat <code>contextJson</code> as untrusted. Use <code>EscapeForJson</code> to avoid injection into the stored audit payload. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Failure & recovery scenarios (recommended operational behavior)</strong><br><strong>Typical failure cases & module behavior:</strong><br>- Scripting.Dictionary missing → catalog lookups return empty strings; HandleError still performs logging and raises the original Err.Number. No failure escapes module.<br>- Scriptlet.TypeLib GUID unavailable → timestamp+random fallback used for correlation ID (non-crypto).<br>- <code>LogAudit</code> missing or throwing → swallowed by <code>SafeLogStructuredError</code> and no exception propagates; audit lost but application flow preserved.<br>- <code>Application.Run(&quot;NewCorrelationID&quot;)</code> errors → silently ignored and fallback used.<br><strong>Recommendation:</strong> Monitor for missing audit entries in telemetry and provide admin guidance to ensure LogAudit deployed. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Recommended test matrix (concise prioritized list)</strong><br>1. <strong>Catalog presence matrix</strong>: run with Scripting.Dictionary available and unavailable; assert <code>GetCatalogItemCount</code> and <code>GetUserFacingMessage</code> behavior.<br>2. <strong>HandleError end-to-end</strong>: Call with explicit userMsg vs without; assert audit content (escaped/truncated), correlation ID format, and final <code>Err.Number</code> matches input.<br>3. <strong>Critical severity flow</strong>: use sevCritical and assert <code>MsgBox</code> invocation path (mock or intercept).<br>4. <strong>Correlation ID paths</strong>: with <code>NewCorrelationID</code> defined (Application.Run returns a value), with Scriptlet.TypeLib available, and with neither to validate all branches.<br>5. <strong>SleepMs & RetryOperationByName</strong>: stub a function that fails N-1 times then succeeds; assert retry respects attempts and sleep behavior (use mocking to avoid long sleeps).<br>6. <strong>Escape & truncation</strong>: pass long strings and control characters as <code>contextJson</code> and verify audit payload size and escaping correctness.<br>7. <strong>Audit resilience</strong>: make <code>LogAudit</code> throw and assert <code>HandleError</code> does not propagate error and still raises original <code>Err.Number</code> afterwards. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Security, privacy & compliance notes</strong><br>- All logged fields are escaped via <code>EscapeForJson</code> and truncated to defend against log injection and excessive payloads. Nevertheless: do not place sensitive personal data (PII) in <code>contextJson</code> — redact before calling <code>HandleError</code> or implement a centralized sanitizer.<br>- Correlation IDs are non-secret; do not treat as authentication tokens. If stronger entropy is required, integrate secure GUIDs from a trusted cryptographic library or server-side issued IDs.<br>- Ensure <code>LogAudit</code> destination is secure and that logs are access-controlled and retained according to your compliance requirements. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Final maintainer checklist / recommended improvements</strong><br>- Add optional pluggable <code>ILogAudit</code> interface (project-level public method) so tests can inject a mock audit sink instead of depending on a global <code>LogAudit</code> name and allow async-safe queuing.<br>- If audit volume grows, consider switching <code>LogAudit</code> to an append-queue model and ensure it never blocks main thread (log queue + background flush).<br>- Document the canonical list of error codes in a single external CSV for cross-team reference. Keep <code>MAX_LOG_*</code> constants in sync with server-side ingestion limits.<br>- Add unit test harness that stubs <code>Application.Run</code> and <code>LogAudit</code> to validate all branches and ensure <code>HandleError</code> is covered by automated tests. </td></tr></tbody></table></div><div class="row-count">Rows: 26</div></div><div class="table-caption" id="Table2" data-table="Docu_0159_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical breakdown (modExport)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical breakdown (modExport)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modExport)"> <strong>Overview:</strong><br>This module implements robust export utilities for the IFRS Excel add-in: PDF, CSV, XLSX, CustomXML, ZIP packaging and a high-level package flow. It emphasizes atomic I/O (prefer modUtilities helpers when present), predictable boolean public APIs (except legacy <code>ExportToPDF</code>), centralized audit integration, conservative security/policy checks for sensitive exports, retry/backoff for flaky network/locked files, and clear error-code space. Use this file as the authoritative spec for maintenance, tests and refactors. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Constants & Error Codes</strong> — <em>module configuration and reserved error space</em><br><strong>Purpose:</strong> Define error numeric base, legacy raise offset and named module errors used by <code>LocalHandleError</code> and public APIs.<br><strong>Details:</strong> <code>EXPORT_ERR_BASE = 2100</code> reserved; specific errors (2100..2399) mapped to names (NO_WORKBOOK, DEST_NOT_WRITABLE, etc.). <code>EXPORT_ERR_LEGACY_RAISE = 21000</code> used when raising to preserve legacy behavior. <code>EXPORT_ERR_MAX_RETRIES = 4</code> controls retry loops.<br><strong>Notes:</strong> Keep mapping stable — external code/tests may depend on numeric values. Add new errors only inside reserved block and document. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportToPDF</strong> — <em>legacy Sub kept for backward compatibility (raise-on-failure)</em><br><strong>Purpose:</strong> Preserve historical <code>Sub ExportToPDF(fileName, targetWb)</code> behavior that raises on failure for callers relying on Err.Raise semantics.<br><strong>Signature:</strong> <code>Public Sub ExportToPDF(Optional ByVal fileName As String = &quot;&quot;, Optional ByVal targetWb As Workbook = Nothing)</code><br><strong>Behavior:</strong> Calls <code>ExportToPDFEx</code>; if it returns False, raises <code>vbObjectError + EXPORT_ERR_LEGACY_RAISE</code>. Errors forwarded to <code>LocalHandleError</code> in ErrHandler.<br><strong>Complexity:</strong> O(1) wrapper.<br><strong>Side-effects:</strong> May raise runtime error; logs via <code>LocalHandleError</code> on exceptions.<br><strong>Invariants:</strong> Does not change export behavior; must keep raise semantics.<br><strong>Failure modes:</strong> Wrapped function returning False leads to Err.Raise; ensure callers expecting raise still function. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportToPDFEx</strong> — <em>safe boolean PDF export with atomic move & retries</em><br><strong>Purpose:</strong> Export workbook to PDF with temporary file strategy, exponential backoff retries, atomic move (Name preferred, Copy fallback), and audit logging. Returns True/False rather than raising to enable programmatic handling.<br><strong>Signature:</strong> <code>Public Function ExportToPDFEx(Optional fileName As String = &quot;&quot;, Optional targetWb As Workbook = Nothing) As Boolean</code><br><strong>Behavior (detailed):</strong><br>- Resolve workbook via <code>ResolveWorkbookSafe</code>.<br>- Compute destination path (provided or derived from workbook name + folder fallback).<br>- Verify destination writable via <code>EnsureFolderWritableForFile</code>.<br>- Build a unique temp filename in same folder <code>ifrs_pdf_temp_yyyymmdd_HHNNSS_&lt;cid&gt;.pdf</code>.<br>- Loop up to <code>maxAttempts=3</code>: delete any leftover temp, call <code>wb.ExportAsFixedFormat Type:=xlTypePDF</code> to write temp file, verify via <code>FileExistsAndNonEmpty</code>, then attempt atomic move: <code>Name</code> (fast same-volume) else <code>FileSystemObject.CopyFile</code> and delete temp. If final file valid -> success; otherwise log and backoff (SleepMs with exponential wait).<br>- Always attempt to cleanup temp file.<br>- On success, <code>SafeLogAuditWithMeta</code> invoked with duration and attemptCount.<br><strong>Complexity:</strong> Network/disk bound — cost proportional to PDF generation time and move operations. Loops up to 3 retries; overall O(retries * exportTime).<br><strong>Side-effects:</strong> Creates temporary files, final PDF; calls <code>SafeLogAuditWithMeta</code> and <code>LocalHandleError</code> on failure.<br><strong>Invariants:</strong> If returns True, export file exists and non-empty at <code>exportName</code> (verified before returning).<br><strong>Failure modes:</strong> <code>ExportAsFixedFormat</code> can fail silently or throw (printer drivers, invalid print areas); Name may fail across volumes; access denied on destination; transient network/locked files cause retries.<br><strong>Security:</strong> None specific to PDF content, but audit/logs may include path names — redaction via <code>SafeLogAuditWithMeta</code> respects modSecurity/modConfig hooks.<br><strong>Tests:</strong> Export small workbook -> file exists; simulate locked destination (open by other process) -> function returns False and logs; temp leftover cleaned; attemptCount recorded; race when destination exists overwritten. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportWorksheetToCsv</strong> — <em>export specified worksheet to CSV (UTF-8 default)</em><br><strong>Purpose:</strong> Export a worksheet's UsedRange to CSV with quoting rules and UTF-8 encoding where possible. Backwards-compatible signature (optional wb, sheetName, fullPath) and boolean return.<br><strong>Signature:</strong> <code>Public Function ExportWorksheetToCsv(Optional targetWb As Workbook = Nothing, Optional sheetName As String = &quot;&quot;, Optional fullPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook and sheet (active sheet if sheetName omitted) via <code>SafeGetWorksheet</code> and <code>ResolveWorkbookSafe</code>.<br>- Compute default path if <code>fullPath</code> omitted (wb.path or Application.DefaultFilePath or USERPROFILE).<br>- Ensure destination writable via <code>EnsureFolderWritableForFile</code>.<br>- Retrieve <code>ws.UsedRange</code> and fail with <code>EXPORT_ERR_SHEET_NO_USED_RANGE</code> if empty.<br>- Call <code>TryExportRangeToCsvWithOptions(rng, fullPath, True)</code> which prefers centralized <code>ExportRangeToCsv</code> if present or falls back to <code>WriteRangeToCsvFallbackWithEncoding</code>.<br>- On success, write audit entry via <code>SafeLogAuditWithMeta</code> including sheet name.<br><strong>Complexity:</strong> O(rows * cols) to serialize cells. Memory usage proportional to CSV string size (module builds full string in sb variable).<br><strong>Side-effects:</strong> May create file at <code>fullPath</code>; logs audit.<br><strong>Invariants:</strong> CSV uses CRLF line endings, CSV quoting for fields containing commas, quotes and embedded newlines; internal newlines normalized to LF inside fields before wrapping.<br><strong>Failure modes:</strong> Large sheets may produce huge memory usage; cell types (objects, errors) converted to empty strings; ADODB fallback used for UTF-8 may not exist on stripped-down hosts.<br><strong>Security:</strong> Use <code>TryAtomicWriteFileWithEncoding</code> to avoid partial writes exposing sensitive data. Audit redaction applies.<br><strong>Tests:</strong> 1) small table export; 2) cells with embedded quotes/newlines; 3) very large sheet memory behavior; 4) missing UsedRange path returns False and logs. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportWorkbookAsXlsx</strong> — <em>atomic save of workbook as .xlsx with verification</em><br><strong>Purpose:</strong> Save a live workbook as a flattened .xlsx file using atomic-save helpers; verify existence and size, and log audit; returns True/False.<br><strong>Signature:</strong> <code>Public Function ExportWorkbookAsXlsx(Optional targetWb As Workbook = Nothing, Optional fullPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook; determine default target path if none provided.<br>- Ensure destination folder writable.<br>- Call <code>TryAtomicSaveWorkbookAsWithVerification(wb, fullPath)</code> which attempts <code>AtomicSaveWorkbookAs</code> via <code>Application.Run</code> or fallback to <code>SaveCopyAs</code> then copy; includes retry/backoff up to <code>EXPORT_ERR_MAX_RETRIES</code>.<br>- On success log <code>SafeLogAuditWithMeta</code> with duration and attempt count; return True.<br><strong>Complexity:</strong> Save cost dominated by Excel SaveCopyAs; retries increase time. Disk I/O bound.<br><strong>Side-effects:</strong> Creates .xlsx file; may create temp SaveCopyAs file and remove it.<br><strong>Invariants:</strong> On success file exists and non-empty; workbook not modified by function (uses SaveCopyAs).<br><strong>Failure modes:</strong> SaveCopyAs can fail for network paths, locked files, or insufficient disk; atomic helper absent on older deployments -> fallbacks invoked. Permission errors surfaced via <code>LocalHandleError</code>.<br><strong>Tests:</strong> Simple workbook save; test on network share and simulate locked destination; verify temp cleanup and attempts count in audit. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportCustomXMLPart</strong> — <em>export named CustomXMLPart with policy checks and UTF-8 write</em><br><strong>Purpose:</strong> Extract a CustomXMLPart identified by a root element and write it to disk with optional schema/version comment; deny exports if policy indicates secrets.<br><strong>Signature:</strong> <code>Public Function ExportCustomXMLPart(ByVal rootElement As String, ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Validate args non-empty.<br>- Read XML via <code>TryReadCustomXMLPart(rootElement)</code> which calls centralized <code>ReadCustomXMLPart</code> if present or fallback iterating <code>ThisWorkbook.CustomXMLParts</code>.<br>- If XML empty -> <code>EXPORT_ERR_CUSTOMXML_NOENT</code>.<br>- If content contains tokens like <code>&quot;password&quot;</code> or <code>&quot;secret&quot;</code> then call <code>CheckCustomXmlPolicy(rootElement, xml)</code> which queries <code>modSecurity_CheckCustomXmlExport</code> via <code>Application.Run</code> or uses conservative default (deny when suspicious tokens present). If denied -> error <code>EXPORT_ERR_CUSTOMXML_POLICY_DENY</code>.<br>- Prepend a small header comment (cid + timestamp) after XML declaration when present, not changing XML structure otherwise.<br>- Ensure folder writable and call <code>TryAtomicWriteFileWithEncoding(fullPath, xml, True)</code> (UTF-8 preferred). On success log audit.<br><strong>Complexity:</strong> O(size of XML) I/O bound.<br><strong>Side-effects:</strong> Writes file; logs audit; invokes security hooks.<br><strong>Invariants:</strong> Exported XML includes a non-invasive header comment; secrets are not exported by default.<br><strong>Failure modes:</strong> Policy function absent -> conservative default; ADODB writing may fail. Caller must handle False. <br><strong>Security:</strong> Highest sensitivity — uses <code>modSecurity</code> hook. Tests must include PII/secret detection and ensure denial path works. Recommended to add unit test that attempts to export known secret patterns. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CreateZipFromFiles</strong> — <em>create cross-platform zip package from list of files</em><br><strong>Purpose:</strong> Create a ZIP archive containing provided full paths, with bootstrap empty zip, platform-specific shells used for adding files, and integrity heuristics. Overwrites existing zipPath if present.<br><strong>Signature:</strong> <code>Public Function CreateZipFromFiles(ByVal files As Collection, ByVal zipPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Validate inputs: non-empty collection and zipPath.<br>- Ensure destination folder writable and create folder.<br>- Remove existing zip if present; create minimal empty zip bootstrap (write PKZIP EOCD with zeros) so Shell.Namespace recognizes container.<br>- Branch: <code>IsMacOS</code> -> call <code>ExecShellZipOnMac(files, zipPath)</code> which shells out to <code>zip -j -q</code>; else <code>ExecShellZipOnWindows(files, zipPath)</code> which uses <code>Shell.Application</code> <code>Namespace.CopyHere</code> to add files and monitors size stabilization via <code>WaitForZipStable</code>.<br>- If creation fails, return <code>EXPORT_ERR_ZIP_CREATE_FAIL</code>. Validate final zip non-empty; audit log.<br><strong>Complexity:</strong> O(#files) per addition plus platform zip command costs; Windows Shell copy is asynchronous and requires Wait loops.<br><strong>Side-effects:</strong> Writes zip file; may call external shell (security considerations for file paths).<br><strong>Invariants:</strong> Resulting zip contains added files when function returns True; bootstrap coding required for Windows Shell API.<br><strong>Failure modes:</strong> Shell utilities missing on Mac/Windows, long waits for <code>CopyHere</code> completion, permission issues, files that do not exist skipped silently. If no files added -> <code>EXPORT_ERR_ZIP_EMPTY</code>.<br><strong>Security:</strong> Paths quoted via <code>QuotePathForShell</code> on Mac; on Windows <code>Shell.Namespace.CopyHere</code> performs background operations — avoid passing untrusted shell metacharacters. Tests: small set of files, many files, missing files, file names with quotes/spaces/unicode, ensure zip valid. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportPackage</strong> — <em>high level package: PDF + XLSX + Audit + optional files -> ZIP</em><br><strong>Purpose:</strong> Convenience function to assemble common exports (PDF, XLSX, Audit CSV) plus caller-supplied files into a ZIP package. Returns boolean success.<br><strong>Signature:</strong> <code>Public Function ExportPackage(Optional ByVal filesToInclude As Collection = Nothing, Optional ByVal zipPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve active workbook; compute default zipPath if omitted.<br>- Produce PDF via legacy <code>ExportToPDF</code> (preserved raise semantics — wrapped in <code>On Error Resume Next</code>). Add to tmpFiles collection if created.<br>- Export XLSX via <code>ExportWorkbookAsXlsx</code> and audit CSV via <code>ExportAuditToCSV</code> adding created files to collection when present and non-empty.<br>- Append any caller-supplied files after verifying existence and non-empty.<br>- If no files collected -> <code>EXPORT_ERR_ZIP_NO_FILES</code> error.<br>- Create ZIP via <code>CreateZipFromFiles(tmpFiles, zipPath)</code> and log audit on success.<br><strong>Complexity:</strong> Sum of constituent operations (PDF/XLSX/CSV + zip). Risk of partial success scenarios.<br><strong>Side-effects:</strong> Creates multiple files, possibly leaves temporary artifacts if intermediate exports fail. Audit logged.<br><strong>Invariants:</strong> On True return, <code>zipPath</code> exists and contains at least one file. Caller should clean temporary files if desired.<br><strong>Failure modes:</strong> Any constituent export failing leaves package incomplete — callers should inspect audit logs. Tests: end-to-end package creation; missing optional files; verify zip contains expected members. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportAuditToCSV</strong> — <em>export audit trail to CSV with central hook fallback</em><br><strong>Purpose:</strong> Attempt to call centralized <code>ExportAuditToCSV_Central</code> via <code>Application.Run</code>; fallback to scanning workbook for audit sheets and export them as CSV using <code>ExportWorksheetToCsv</code>.<br><strong>Signature:</strong> <code>Public Function ExportAuditToCSV(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Default <code>fullPath</code> to TEMP if omitted.<br>- Try <code>Application.Run(&quot;ExportAuditToCSV_Central&quot;, fullPath)</code>; if returns boolean, use it and log audit.<br>- Else scan <code>ThisWorkbook</code> for known audit sheet names (various casings) via <code>SafeGetWorksheet</code>. If none found, search any sheet where name contains <code>&quot;audit&quot;</code> case-insensitively.<br>- If found, call <code>ExportWorksheetToCsv(wb, nameFound, fullPath)</code> and log audit on success.<br><strong>Complexity:</strong> O(#sheets) for search; CSV export complexity as previously.<br><strong>Side-effects:</strong> Writes audit CSV; may call external central routine. <br><strong>Invariants:</strong> Exports the first suitable audit sheet. <br><strong>Failure modes:</strong> Central routine may throw; fallback may not find audit sheet -> returns False with <code>2400</code> error. Tests: central hook present/absent; sheet detection casing; exports file content correctness. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportSelfTest</strong> — <em>module self-test orchestration</em><br><strong>Purpose:</strong> Perform deterministic smoke tests: export test CSV, export XLSX, create package zip; used for CI/manual verification. Returns Boolean overall result.<br><strong>Signature:</strong> <code>Public Function ExportSelfTest() As Boolean</code><br><strong>Behavior:</strong><br>- Build <code>_IFRS_TestResults</code> folder under workbook path or TEMP. Ensure folder exists.<br>- Ensure a <code>TST_Export_Sheet</code> exists (create if missing) with deterministic sample values.<br>- Call <code>ExportWorksheetToCsv</code>, <code>ExportWorkbookAsXlsx</code>, and <code>CreateZipFromFiles</code> on the produced artifacts. Aggregate boolean results; log via <code>SafeLogAuditWithMeta</code>.<br><strong>Complexity:</strong> Same as composed operations.<br><strong>Side-effects:</strong> Creates sample files and zip; logs audit.<br><strong>Invariants:</strong> No external state consistent changes (only files).<br><strong>Tests:</strong> This function itself is test harness; run on varied environments including network drives. Clean-up not provided — tests should clean artifacts where appropriate. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ResolveWorkbookSafe</strong> — <em>workbook resolver with fallbacks</em><br><strong>Purpose:</strong> Return supplied workbook, else ActiveWorkbook, else ThisWorkbook; safe against errors.<br><strong>Signature:</strong> <code>Private Function ResolveWorkbookSafe(Optional ByVal suppliedWb As Workbook = Nothing) As Workbook</code><br><strong>Behavior:</strong> Uses <code>On Error Resume Next</code> to avoid runtime errors, returns first valid workbook. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Notes:</strong> Keep minimal; used by all public export entrypoints to standardize workbook selection. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>LocalHandleError</strong> — <em>centralized error invocation with graceful fallback</em><br><strong>Purpose:</strong> Invoke centralized <code>HandleError</code> if present; otherwise write local audit and raise module-specific error preserving legacy raise semantics. Central point for error mapping and audit fallback.<br><strong>Signature:</strong> <code>Private Sub LocalHandleError(ByVal proc As String, ByVal errNum As Long, ByVal errDesc As String)</code><br><strong>Behavior:</strong><br>- Attempt <code>Application.Run(&quot;HandleError&quot;, proc, errNum, errDesc)</code> and consider error handled if it returns without Err.Number.<br>- If no central handler, call <code>SafeLogAudit &quot;Error&quot;, proc &amp; &quot; | &quot; &amp; CStr(errNum) &amp; &quot; | &quot; &amp; errDesc</code> then raise <code>vbObjectError + EXPORT_ERR_LEGACY_RAISE + (Abs(errNum) Mod 1000)</code> to preserve legacy numeric space. Err.Raise wrapped in <code>On Error Resume Next</code> to avoid secondary unhandled exceptions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls audit and possibly raises an error. <br><strong>Notes:</strong> Do not change numeric mapping logic without considering external callers. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>SafeLogAudit</strong> — <em>best-effort audit writer with fallback to local temp log</em><br><strong>Purpose:</strong> Attempt <code>Application.Run &quot;LogAudit&quot;, category, message</code>. If that fails, append to a local <code>ifrs_local_audit.log</code> in TEMP. Non-blocking best-effort telemetry.<br><strong>Signature:</strong> <code>Private Sub SafeLogAudit(ByVal category As String, ByVal message As String)</code><br><strong>Behavior:</strong> Try central audit hook; if error, write timestamped line to temp file via VB file I/O. <br><strong>Complexity:</strong> O(1) file append. <br><strong>Side-effects:</strong> Writes to disk. <br><strong>Notes:</strong> Keep minimal and robust; do not let logging throw. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>SafeLogAuditWithMeta</strong> — <em>audit writer with metadata and redaction hooks</em><br><strong>Purpose:</strong> Emit richer audit entries (path, workbook name, extra info, duration, retries, correlation id) and request redaction decision from modSecurity/modConfig. Use <code>LogAudit</code> central hook when available and fallback to <code>SafeLogAudit</code> otherwise.<br><strong>Signature:</strong> <code>Private Sub SafeLogAuditWithMeta(ByVal category As String, ByVal message As String, ByVal targetPath As String, Optional ByVal wb As Workbook = Nothing, Optional ByVal extra As String = &quot;&quot;, Optional ByVal durationMs As Long = -1, Optional ByVal retries As Long = -1)</code><br><strong>Behavior:</strong> Build <code>metaMsg</code> concatenating fields, call <code>modSecurity_ShouldRedactAudit(metaMsg)</code> via <code>Application.Run</code> and if boolean true perform simple redaction heuristics (mask userprofile, replace slashes etc.). Then call <code>Application.Run &quot;LogAudit&quot;, category, metaMsg, cid</code> and fallback to <code>SafeLogAudit</code> on error.<br><strong>Complexity:</strong> O(1) string ops and a best-effort call.<br><strong>Side-effects:</strong> May mutate message (redaction) and call central services. <br><strong>Security:</strong> Critical for PII protection; maintain conservative default. Unit tests should assert redaction behavior when the hook returns True. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>GenerateCorrelationID</strong> — <em>correlation ID generator with GUID fallback</em><br><strong>Purpose:</strong> Create a correlation id using <code>Scriptlet.TypeLib</code> GUID when available; fallback to deterministic pseudo-id based on timestamp + random number.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Uses <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code> if available else <code>&quot;CID-&quot; &amp; Format(Now, ...) &amp; &quot;-&quot; &amp; random</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Correlation ID used in audits for traceability; prefer GUID path when available. Keep stable format. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ChooseFolderFallback</strong> — <em>determine default folder for exports</em><br><strong>Purpose:</strong> Pick export folder from workbook path > Application.DefaultFilePath > USERPROFILE > TEMP in that order.<br><strong>Signature:</strong> <code>Private Function ChooseFolderFallback(ByVal wb As Workbook) As String</code><br><strong>Behavior:</strong> Return first non-empty candidate. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Centralizes fallback logic for consistent behavior across export functions. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>EnsureFolderWritableForFile / IsFolderWritable / SafeFolderCreate</strong> — <em>folder writability checks & safe create</em><br><strong>Purpose:</strong> Provide robust checks that the folder exists and is writable (create if missing) by attempting a small binary write test file and deleting it. <code>EnsureFolderWritableForFile</code> extracts folder path from full file path and calls <code>IsFolderWritable</code>.<br><strong>Signatures:</strong> <code>Private Function EnsureFolderWritableForFile(ByVal filepath As String) As Boolean</code>, <code>Private Function IsFolderWritable(ByVal folderPath As String) As Boolean</code>, <code>Private Sub SafeFolderCreate(ByVal folderPath As String)</code><br><strong>Behavior:</strong><code>IsFolderWritable</code> creates folder if not exists, writes temporary <code>&quot;IFRS&quot;</code> test file then deletes; returns success boolean. <code>SafeFolderCreate</code> wraps FSO <code>CreateFolder</code> with <code>On Error Resume Next</code>.<br><strong>Complexity:</strong> O(1) I/O. <br><strong>Failure modes:</strong> On network shares write test may pass but subsequent writes may fail; this is best-effort. Tests should run on network path, restricted folder, and local folder. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Atomic write & save helper wrappers</strong> — <em>TryAtomicWriteFile / TryAtomicWriteFileWithEncoding / TryAtomicWriteFileWithVerification</em><br><strong>Purpose:</strong> Prefer centralized <code>AtomicWriteFile</code> from <code>modUtilities</code> when present; otherwise use local fallbacks that write to a temp file and move or use ADODB.Stream for UTF-8. Verification wrapper checks file non-zero size.<br><strong>Signatures:</strong> <code>Private Function TryAtomicWriteFile(fullPath, contents) As Boolean</code>, <code>TryAtomicWriteFileWithEncoding(fullPath, contents, useUtf8)</code>, <code>TryAtomicWriteFileWithVerification(fullPath, contents)</code><br><strong>Behavior:</strong> Attempt <code>Application.Run(&quot;AtomicWriteFile&quot;, ...)</code>. If not available, call <code>WriteTextFileAtomicFallback</code> or <code>WriteUtf8FileAtomicFallback</code>. Verification checks FSO file size > 0. Errors caught and converted to False. <br><strong>Complexity:</strong> O(file_size) I/O. <br><strong>Side-effects:</strong> Creates temp files and moves them into place. <br><strong>Invariants:</strong> On True return, final file exists and non-empty. <br><strong>Tests:</strong> Absence/presence of <code>AtomicWriteFile</code> hook; simulate ADODB absent; verify atomic move semantics across volumes (Name fails, Copy fallback). </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>WriteTextFileAtomicFallback</strong> — <em>binary write temp -> move fallback (not strict UTF-8)</em><br><strong>Purpose:</strong> Generic fallback writing raw bytes to temp file then Name/Copy to destination. Useful when ADODB not present and UTF-8 not strictly required.<br><strong>Signature:</strong> <code>Private Function WriteTextFileAtomicFallback(fullPath, contents) As Boolean</code><br><strong>Behavior:</strong> Create tmp file with timestamp+cid; Open For Binary Access Write; Put contents; Close; attempt Name fullPath else CopyFile; return FileExistsAndNonEmpty(fullPath).<br><strong>Complexity:</strong> O(file_size).<br><strong>Failure modes:</strong> Unicode conversion not handled; binary blob may mis-encode; prefer UTF-8 helper when required. Tests: simple ASCII content success; Unicode content may show BOM issues. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>WriteUtf8FileAtomicFallback</strong> — <em>ADODB.Stream UTF-8 writer fallback with BOM fallback</em><br><strong>Purpose:</strong> Write UTF-8 reliably using <code>ADODB.Stream</code> when available; else write BOM + contents as fallback and move atomically.<br><strong>Signature:</strong> <code>Private Function WriteUtf8FileAtomicFallback(fullPath, contents, useUtf8) As Boolean</code><br><strong>Behavior:</strong> Attempt <code>CreateObject(&quot;ADODB.Stream&quot;)</code>, set <code>.Type=2</code>, <code>.Charset=&quot;utf-8&quot;</code>, <code>.WriteText contents</code>, <code>.SaveToFile tmpPath</code>. If ADODB unavailable, write BOM + contents to tmpPath using Binary I/O. Then move/Name to fullPath (Copy fallback). Clean tmp on errors. Return True if file exists and non-empty.<br><strong>Complexity:</strong> O(file_size).<br><strong>Failure modes:</strong> ADODB absent or restricted; fallback adds BOM which some consumers may not expect. Tests: UTF-8 content roundtrip; verify BOM presence when ADODB absent. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>TryAtomicSaveWorkbookAs / TryAtomicSaveWorkbookAsWithVerification</strong> — <em>atomic SaveCopyAs fallback with retries</em><br><strong>Purpose:</strong> Prefer <code>AtomicSaveWorkbookAs</code> via modUtilities; fallback to <code>Workbook.SaveCopyAs tmp</code> then copy to destination. Verification wrapper retries with exponential backoff to handle locked/network paths.<br><strong>Signature:</strong> <code>Private Function TryAtomicSaveWorkbookAs(wb, fullPath) As Boolean</code>, <code>TryAtomicSaveWorkbookAsWithVerification(wb, fullPath) As Boolean</code><br><strong>Behavior:</strong> Attempt centralized helper; else <code>wb.SaveCopyAs tmp</code> then FSO <code>CopyFile tmp -&gt; fullPath</code>. Verification checks final file exists and non-zero size. Retries up to <code>EXPORT_ERR_MAX_RETRIES</code>.<br><strong>Complexity:</strong> SaveCopyAs cost + copy; retries multiply cost. <br><strong>Failure modes:</strong> SaveCopyAs can fail for unsaved workbook, or if workbook is too large. Tests: saved/unsaved workbooks, network destinations, locked destinations. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CSV fallback writer: TryExportRangeToCsvWithOptions / WriteRangeToCsvFallbackWithEncoding</strong> — <em>serialize Range to CSV and write atomically</em><br><strong>Purpose:</strong> Use centralized <code>ExportRangeToCsv</code> when present; otherwise iterate cells, escape quotes, normalize newlines inside cells to LF, quote fields with commas/newlines/quotes, join rows with CRLF and write via <code>TryAtomicWriteFileWithEncoding</code> (UTF-8 preferred).<br><strong>Signature:</strong> <code>Private Function TryExportRangeToCsvWithOptions(rng, fullPath, useUtf8) As Boolean</code>, <code>Private Function WriteRangeToCsvFallbackWithEncoding(rng, fullPath, useUtf8) As Boolean</code><br><strong>Behavior:</strong> Build full CSV string in-memory (sb), then call atomic writer. Properly handles errors with <code>On Error</code> pattern. <br><strong>Complexity:</strong> O(rows*cols + total_chars). Memory heavy for large ranges; consider streaming when necessary.<br><strong>Failure modes:</strong> Very large ranges may exhaust memory; ADODB may not be present. Tests: fields with quotes/newlines/commas; empty/errored cells; very large sheet performance. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CustomXML helpers: TryReadCustomXMLPart / ReadCustomXMLPartFallback / CheckCustomXmlPolicy</strong> — <em>read & policy-check XML parts</em><br><strong>Purpose:</strong> Read CustomXMLPart via centralized <code>ReadCustomXMLPart</code> hook if present; fallback by scanning <code>ThisWorkbook.CustomXMLParts</code>. <code>CheckCustomXmlPolicy</code> calls <code>modSecurity_CheckCustomXmlExport</code> to allow/deny export or falls back to conservative deny if suspicious tokens found.<br><strong>Signatures:</strong> <code>Private Function TryReadCustomXMLPart(rootElement) As String</code>, <code>Private Function ReadCustomXMLPartFallback(rootElement) As String</code>, <code>Private Function CheckCustomXmlPolicy(rootElement, xml) As Boolean</code><br><strong>Behavior:</strong> Fallback scans <code>ThisWorkbook.CustomXMLParts</code> searching <code>InStr(cxp.xml, &quot;&lt;&quot; &amp; rootElement) &gt; 0</code>. Policy function invoked via <code>Application.Run</code> when available; defaults to deny on presence of <code>&quot;password&quot;</code> or <code>&quot;secret&quot;</code> tokens. <br><strong>Complexity:</strong> O(#customParts * size). <br><strong>Security:</strong> Conservative default denies export of suspicious content. Unit tests must verify both hook present and absent behaviors, and matching substring search correctness. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Platform & ZIP helpers: IsMacOS / ExecShellZipOnMac / ExecShellZipOnWindows / QuotePathForShell / WaitForZipStable</strong><br><strong>Purpose:</strong> Abstract platform details for zipping files: Mac uses <code>MacScript(&quot;do shell script ...&quot;)</code> with <code>zip -j -q</code>, Windows uses <code>Shell.Application</code> COM to <code>CopyHere</code> into zip container and <code>WaitForZipStable</code> to observe size stalls.<br><strong>Signatures:</strong> <code>Private Function IsMacOS() As Boolean</code>, <code>Private Function ExecShellZipOnMac(files, zipPath) As Boolean</code>, <code>Private Function ExecShellZipOnWindows(files, zipPath) As Boolean</code>, <code>Private Function QuotePathForShell(p) As String</code>, <code>Private Function WaitForZipStable(zipPath, timeoutMs) As Boolean</code><br><strong>Behavior highlights:</strong><br>- <code>IsMacOS</code> checks <code>Application.OperatingSystem</code> string.<br>- <code>ExecShellZipOnMac</code> builds shell command quoting paths via <code>QuotePathForShell</code> and invokes via <code>MacScript</code> (returns False on error).<br>- <code>ExecShellZipOnWindows</code> uses <code>Shell.Namespace(zipPath).CopyHere filepath</code> for each file and polls <code>WaitForZipStable</code> (checks file size changes and a <code>stableCounter</code> threshold) to heuristically wait until the copy completes. Returns whether final zip exists and non-empty.<br><strong>Complexity:</strong> Copy operations are asynchronous on Windows; <code>WaitForZipStable</code> loops <code>DoEvents</code> and checks file size until stable or timeout. <br><strong>Failure modes & Security:</strong> Shell command injection risk for Mac if quoting not correct — <code>QuotePathForShell</code> replaces <code>&quot;</code> with <code>\&quot;</code> and wraps with quotes. On Windows, <code>Shell.Namespace</code> may be unavailable for some zipped formats or if zip is blocked by ACLs. Tests: filenames with spaces/quotes/unicode; long lists; network paths; zip stability timeouts. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Utility helpers: SafeFileName / FileExistsAndNonEmpty / SafeGetWorksheet / SleepMs</strong><br><strong>Purpose & signatures:</strong><br>- <code>SafeFileName(s) -&gt; String</code>: sanitize invalid filename characters by replacing with <code>_</code>.<br>- <code>FileExistsAndNonEmpty(path) -&gt; Boolean</code>: FSO existence and size > 0 check.<br>- <code>SafeGetWorksheet(wb,sheetName) -&gt; Worksheet</code>: case-insensitive search for worksheet by name.<br>- <code>SleepMs(ms)</code>: busy wait using <code>Timer</code> + <code>DoEvents</code> for cross-platform short waits.<br><strong>Behavior:</strong> Small helpers used pervasively. <br><strong>Complexity:</strong> O(1) for string ops, O(1) for FSO checks. <br><strong>Notes:</strong> <code>SleepMs</code> processes events (DoEvents) — be cautious when called inside tight UI contexts. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Design & maintenance notes (module-level)</strong><br>- <strong>Public surface:</strong> stable boolean-returning functions (<code>ExportToPDFEx</code>, <code>ExportWorksheetToCsv</code>, <code>ExportWorkbookAsXlsx</code>, <code>ExportCustomXMLPart</code>, <code>CreateZipFromFiles</code>, <code>ExportPackage</code>, <code>ExportAuditToCSV</code>, <code>ExportSelfTest</code>) plus legacy <code>ExportToPDF</code> (raise). Maintain signatures for backward compatibility.<br>- <strong>Use central hooks when available:</strong> <code>AtomicWriteFile</code>, <code>AtomicSaveWorkbookAs</code>, <code>ExportRangeToCsv</code>, <code>ReadCustomXMLPart</code>, <code>HandleError</code>, <code>LogAudit</code>, <code>modSecurity_*</code> and <code>modConfig_Get</code>. All <code>Application.Run</code> calls are best-effort — fallbacks exist to remain self-contained.<br>- <strong>Error handling:</strong> All public functions catch errors and call <code>LocalHandleError</code>. <code>LocalHandleError</code> prefers central <code>HandleError</code> and otherwise logs and raises within module error space. Keep error numbers stable to avoid breaking external error handling. <br>- <strong>Security:</strong> CustomXML exports are policy-checked; audit redaction hook used; avoid writing secrets. Ensure <code>SafeLogAuditWithMeta</code> redaction heuristics are updated if new PII patterns emerge.<br>- <strong>Atomicity & correctness:</strong> Prefer atomic helpers; fallback strategies use temp file -> Name / Copy pattern. Ensure temp files created in same target folder when possible to avoid cross-volume <code>Name</code> failure. Revoke or cleanup temp artifacts on error paths. <br>- <strong>Platform differences:</strong> Windows zip via Shell.Application is asynchronous; Mac uses CLI zip. Test both platforms. ADODB availability affects UTF-8 writing. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Recommended tests (condensed)</strong><br>1. PDF export: success path; locked destination -> retry/backoff and logged failure; temp file cleanup. 2. CSV export: embedded quotes/newlines/commas; large ranges for memory. 3. XLSX export: atomic save verification on local and network drives; SaveCopyAs fallback. 4. CustomXML: export allowed/denied by <code>modSecurity</code> hook and fallback; header injection correctness. 5. ZIP creation: files with special chars, many files, Windows Shell asynchronous behavior and <code>WaitForZipStable</code> timing edge cases. 6. Audit: central <code>LogAudit</code> present and absent; <code>SafeLogAuditWithMeta</code> redaction test. 7. Atomic write helpers: ADODB present/absent, cross-volume move (Name vs Copy). 8. SelfTest: run in CI on clean VM and assert deterministic outputs. 9. Error mapping: intentional faults produce expected <code>EXPORT_ERR_*</code> codes and <code>LocalHandleError</code> raise semantics. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Maintenance notes for engineers</strong><br>- Do not change exported function signatures; provide new overloads as <code>*Ex</code> functions. <br>- When altering token strings used for secret detection (<code>&quot;password&quot;</code>, <code>&quot;secret&quot;</code>), update tests and document policy implications. <br>- Prefer adding centralized helpers in <code>modUtilities</code> rather than changing fallbacks here; keep <code>Application.Run</code> hooks thin and tolerant. <br>- When adjusting worker/async behavior (e.g., better Windows zip integration), preserve current fallback behavior for older deployments. <br>- Add CI checks to run <code>ExportSelfTest</code> on supported platforms periodically. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Final summary (one paragraph)</strong><br><code>modExport</code> is a defensive, production-oriented export module built for reliability and compatibility: it prioritizes atomic writes, centralized hook usage, policy-guided CustomXML exports, cross-platform ZIP creation, and exhaustive fallbacks. Public functions return booleans except the preserved legacy sub that raises; all failures funnel through <code>LocalHandleError</code> and <code>SafeLogAuditWithMeta</code>, which attempt centralized handling and otherwise perform local audit + conservative raises. Key maintenance areas: keep error codes stable, test ADODB/ADP/COM availability paths, and strengthen CustomXML policy hooks to avoid accidental secrets exfiltration. </td></tr></tbody></table></div><div class="row-count">Rows: 30</div></div><div class="table-caption" id="Table3" data-table="Docu_0159_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module Name</strong><br>modIAS36.bas<br><strong>Module Version</strong>2025.12.25-Rev3<br><strong>Purpose (module level):</strong> Hardened IAS 36 impairment framework: recoverable amount (VIU & FVLCOD), CGU grouping, deterministic DCF/NPV builder with pluggable daycount conventions, deterministic allocation & journal generator, disclosure summary builder, defensive validation, structured audit logging and predictable error handling. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Module_Initialize()</strong> — <em>module defaults initializer</em><br><strong>Purpose:</strong> Ensure module-level defaults (g_IAS36_Daycount) are set before any operation.<br><strong>Signature:</strong> <code>Private Sub Module_Initialize()</code><br><strong>Behavior:</strong> Idempotent micro-error-block: sets <code>g_IAS36_Daycount</code> to <code>IAS36_DAYCOUNT_DEFAULT</code> if unset. Swallows transient errors, clears Err. Designed to be cheap and safe to call at start of public functions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates module-level variable <code>g_IAS36_Daycount</code> if previously empty.<br><strong>Invariants:</strong> After successful call <code>g_IAS36_Daycount</code> != vbNullString.<br><strong>Failure modes:</strong> If Application environment prevents assignment (unlikely), it silently leaves existing value; errors cleared. Host should catch only systemic failures.<br><strong>Tests:</strong> Ensure repeated calls preserve same default; set g_IAS36_Daycount externally and call — value should remain. </td></tr><tr><td data-label="Technical Breakdown"> <strong>SetIAS36DefaultDaycount(convention As String)</strong> — <em>change module default daycount</em><br><strong>Purpose:</strong> Allow host to change default daycount ("ACT/365", "ACT/360", "30/360") with validation and audit logging.<br><strong>Signature:</strong> <code>Public Sub SetIAS36DefaultDaycount(ByVal convention As String)</code><br><strong>Behavior:</strong> Calls <code>Module_Initialize</code>, validates input (case-insensitive); if valid sets <code>g_IAS36_Daycount</code> to canonical upper-case; if invalid logs via <code>SafeLog</code> and retains previous default. Errors routed to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Updates <code>g_IAS36_Daycount</code> and writes audit on invalid values.<br><strong>Invariants:</strong> Only allowed values stored; invalid input does not change default.<br><strong>Failure modes:</strong> Passing empty string does nothing. Host errors in <code>SafeLog</code> are safe (fallback to Debug.Print).<br><strong>Recommended tests:</strong> Valid/invalid values; repeated set; ensure <code>GetIAS36DefaultDaycount</code> returns expected value. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetIAS36DefaultDaycount() As String</strong> — <em>read module default</em><br><strong>Purpose:</strong> Return currently configured default daycount (ensures initialization).<br><strong>Signature:</strong> <code>Public Function GetIAS36DefaultDaycount() As String</code><br><strong>Behavior:</strong> Calls <code>Module_Initialize</code> then returns <code>g_IAS36_Daycount</code> (falls back to <code>IAS36_DAYCOUNT_DEFAULT</code>).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None beyond possible module init assignment.<br><strong>Tests:</strong> When module default changed via <code>SetIAS36DefaultDaycount</code>, <code>Get...</code> returns that value. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_CalculateRecoverableByVIU(cashflows, discountRate, Optional asOfDate, Optional daycount) As Double</strong> — <em>VIU NPV calculator</em><br><strong>Purpose:</strong> Compute recoverable amount via Value in Use: present value of forecast cashflows using <code>NPVFromDcfEx</code> and module daycount fallback.<br><strong>Signature:</strong> <code>Public Function IAS36_CalculateRecoverableByVIU(ByVal cashflows As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> Ensures defaults (asOfDate -> Date; daycount fallback). Calls <code>NPVFromDcfEx</code> to compute PV. On errors calls <code>HandleInternalError</code> and returns 0#.<br><strong>Complexity:</strong> Dominated by <code>NPVFromDcfEx</code> (O(n) where n = number of forecast rows).<br><strong>Side-effects:</strong> None (pure calculation).<br><strong>Invariants:</strong> Returns 0 for empty forecasts or on error; deterministic given same inputs.<br><strong>Failure modes:</strong> Non-date entries handled by <code>NormalizeForecastToArray</code>; if <code>NPVFromDcfEx</code> errors, returns 0 and logs. <br><strong>Tests:</strong> Zero flows → 0; positive cashflows with known discount → match manual calculation; negative/complex inputs handled gracefully. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_CalculateRecoverableByFVLCOD(fairValue, costsToSell) As Double</strong> — <em>FVLCOD calculator</em><br><strong>Purpose:</strong> Compute fair value less costs of disposal (simple subtraction, defensive numeric coercion).<br><strong>Signature:</strong> <code>Public Function IAS36_CalculateRecoverableByFVLCOD(ByVal fairValue As Double, ByVal costsToSell As Double) As Double</code><br><strong>Behavior:</strong> Uses <code>NZDouble</code> to coerce inputs, returns <code>fairValue - costsToSell</code>. On error returns 0 and logs via <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> If inputs non-numeric, treated as 0. <br><strong>Tests:</strong> normal numeric cases, non-numeric inputs, negative costs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_RecoverableAmount(carryingAmount, Optional cashflows, Optional discountRate, Optional fairValue, Optional costsToSell, Optional asOfDate, Optional daycount) As Object</strong> — <em>recoverable aggregator (legacy signature preserved)</em><br><strong>Purpose:</strong> Compute both VIU and FVLCOD, choose higher as recoverable, compute impairment relative to carrying amount, return Scripting.Dictionary with standardized keys used elsewhere (RecoverableAmount, VIU, FVLCOD, MethodUsed, CarryingAmount, ImpairmentLoss).<br><strong>Signature:</strong> <code>Public Function IAS36_RecoverableAmount(ByVal carryingAmount As Double, Optional ByVal cashflows As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValue As Double = 0#, Optional ByVal costsToSell As Double = 0#, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Initializes module, sets defaults, computes <code>viu</code> via <code>NPVFromDcfEx</code> when forecast present, computes <code>fvlcod</code>, selects method ("VIU" vs "FVLCOD"), sets out dictionary values, calculates impairment (rounded via <code>Round2</code>) if recoverable < carryingAmount, logs audit entry, returns dictionary. On error returns Nothing after bubbling to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> Dominated by NPV computation O(n).<br><strong>Side-effects:</strong> Calls <code>SafeLog</code> to append audit.<br><strong>Invariants:</strong> Returns numeric zeros instead of Empty where appropriate to preserve downstream expectations; legacy behavior preserved (functions that historically returned Empty should still do so — here returns Nothing on error).<br><strong>Failure modes:</strong> Missing/invalid forecasts produce VIU=0; errors set to Nothing. <br><strong>Recommended tests:</strong> Compare against manual VIU/FVLCOD selection; carry amounts equal to recoverable produce zero impairment; rounding behavior check. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_GroupAssetsIntoCGUs(assets, Optional groupingKey = "CGU") As Object</strong> — <em>grouping helper</em><br><strong>Purpose:</strong> Group asset records into CGUs by specified groupingKey; returns Dictionary of Collections keyed by group value. Preserves older behavior and supports arrays/collections/dict-like objects.<br><strong>Signature:</strong> <code>Public Function IAS36_GroupAssetsIntoCGUs(ByVal assets As Variant, Optional ByVal groupingKey As String = &quot;CGU&quot;) As Object</code><br><strong>Behavior:</strong> Defensive: returns empty Dictionary if no assets. Supports arrays (any lower bound) and collection-like objects; for each item extracts groupingKey if present else uses default "CGU_1". Builds deterministic Collections inserted in order of iteration. Uses local <code>On Error Resume Next</code> micro-blocks when probing objects.<br><strong>Complexity:</strong> O(n) where n = number of assets.<br><strong>Side-effects:</strong> None beyond returned structure.<br><strong>Invariants:</strong> Keys are strings; each value is a <code>Collection</code> whose items are the original asset objects (not copies).<br><strong>Failure modes:</strong> Non-collection inputs → returns empty dictionary. <br><strong>Tests:</strong> Arrays with different LBound values; object collections; missing groupingKey cases. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_GenerateDCF(forecast, discountRate, Optional asOfDate, Optional daycount) As Variant</strong> — <em>return DCF table array with header</em><br><strong>Purpose:</strong> Build deterministic, sorted DCF table (Date, Cashflow, DiscountFactor, PV) from various forecast shapes; useful for inspection and disclosures.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateDCF(ByVal forecast As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Variant</code><br><strong>Behavior:</strong> Validates inputs, normalizes forecast via <code>NormalizeForecastToArray</code>, computes year fractions via <code>YearFractionEx</code>, discount factors and PV per row, accumulates running PV. Returns a 2D variant array with first row headers and subsequent rows for each forecast row. Returns Empty for invalid/empty forecast. Errors routed to <code>HandleInternalError</code> and returns Empty.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Rows sorted by date ascending (via <code>NormalizeForecastToArray</code> sorting). Non-dates appear as Empty in Date column. Discount factor = 1 when discountRate <= 0.<br><strong>Failure modes:</strong> Non-date/invalid rows placed last by normalization; zero/negative rates handled. <br><strong>Tests:</strong> Known cashflow example with manual PV check; negative rates; zero discount; non-date rows. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_RunImpairmentTest(cgu, Optional discountRate=0#, Optional fairValue=0#, Optional costsToSell=0#, Optional asOfDate, Optional daycount) As Object</strong> — <em>single-CGU impairment test</em><br><strong>Purpose:</strong> Execute full impairment test for one CGU: compute total carrying, recoverable amount (VIU/FVLCOD), impairment, deterministic allocation (if impairment > 0), attach CorrelationID and return result dictionary containing core fields and Allocation dictionary.<br><strong>Signature:</strong> <code>Public Function IAS36_RunImpairmentTest(ByVal cgu As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValue As Double = 0#, Optional ByVal costsToSell As Double = 0#, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Defensive validation of <code>cgu</code>; extracts <code>Assets</code> and <code>Forecast</code>; sums carrying amounts (using <code>GetDictValueIndexed</code> and <code>NZDouble</code>); computes VIU and FVLCOD; determines recoverable and impairment (rounded); builds result dictionary with CGUID (fallback "CGU_UNKNOWN"), TotalCarrying (rounded), RecoverableAmount, MethodUsed, Impairment, VIU, FVLCOD, AsOfDate, DiscountRate, Daycount, CorrelationID via <code>GenerateCorrelationID</code>. If impairment > 0 and assets present, calls <code>AllocateImpairment</code> (PRORATA default), attaches Allocation and verifies invariant via <code>VerifyAllocationInvariant</code>. Logs via <code>SafeLog</code>. On failure returns Nothing and routes to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(n + m) where n = assets, m = forecast rows (NPV).<br><strong>Side-effects:</strong> Calls <code>AllocateImpairment</code> which mutates/creates allocation Dictionary and triggers <code>SafeLog</code> via verification. Adds CorrelationID. <br><strong>Invariants:</strong> If Allocation present, its rounded sum equals impairment (verified, fixed deterministically if not).<br><strong>Failure modes:</strong> Bad cgu input returns Nothing; per-field non-numeric values handled defensively. <br><strong>Recommended tests:</strong> Full flow with positive impairment verifying allocation sums to impairment; CGU w/o assets → no allocation; missing forecast → FVLCOD path tested. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_GenerateImpairmentJournals(testResult, impairmentAccount, assetAccountPrefix) As Variant</strong> — <em>journal generator</em><br><strong>Purpose:</strong> Convert test result Allocation into posting-ready 2D array rows [Date, DrAccount, DrAmount, CrAccount, CrAmount, Narrative]. Preserves deterministic ordering by allocation keys enumeration order (VBScript Dictionary order) which is stable in practice but not guaranteed by spec — code relies on existing Dictionary ordering.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateImpairmentJournals(ByVal testResult As Object, ByVal impairmentAccount As String, ByVal assetAccountPrefix As String) As Variant</code><br><strong>Behavior:</strong> Validates testResult and allocation presence; returns Empty if no impairment. Builds 1..n variant 2D array where each line uses <code>testResult(&quot;AsOfDate&quot;)</code>, impairmentAccount (debit), allocation amount, assetAccountPrefix & "_" & AssetID (credit), narrative includes CorrelationID. Amounts numeric via <code>NZDouble</code>. Errors routed to Handler and return Empty.<br><strong>Complexity:</strong> O(k) where k = number of allocation entries.<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Missing Allocation → Empty. AssetAccountPrefix concatenation may produce unexpected account names if AssetID contains invalid chars — callers should validate AssetID. <br><strong>Tests:</strong> Multi-asset allocation -> n rows; correlation included in narratives. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_RunBatchImpairmentTests(cguList, Optional discountRate=0#, Optional fairValueMap, Optional daycount) As Object</strong> — <em>batch runner with per-CGU resilience</em><br><strong>Purpose:</strong> Run <code>IAS36_RunImpairmentTest</code> for a collection/array of CGUs, capture per-CGU successes and per-CGU errors without aborting whole batch, attach BatchCorrelationID and return Dictionary keyed by CGUID -> result or error record.<br><strong>Signature:</strong> <code>Public Function IAS36_RunBatchImpairmentTests(ByVal cguList As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValueMap As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Creates batchCorrelation via <code>GenerateCorrelationID</code>, logs start, iterates array or object collection; for each CGU extracts optional fairValueMap entries defensively, runs <code>IAS36_RunImpairmentTest</code> inside a per-CGU error handling block (labeled PerCGUErr / PerCGUErr2). On success attaches batchCorrelation fields; on exception captures Err.Number and description into an issue record dictionary and continues. Logs finish. Returns results Dictionary. On global error calls <code>HandleInternalError</code> and returns Nothing.<br><strong>Complexity:</strong> O(B*(asset+forecast)) where B = number of CGUs. Overhead of per-CGU error handling minimal.<br><strong>Side-effects:</strong> Multiple <code>SafeLog</code> entries; no external writes. <br><strong>Invariants:</strong> Returned Dictionary contains an entry for every input CGU index/key; each entry either full result dictionary or an issue dictionary with ErrorNumber/Description. BatchCorrelation is consistent across entries.<br><strong>Failure modes:</strong> Malformed <code>fairValueMap</code> handled defensively; catastrophic error returns Nothing. <br><strong>Tests:</strong> Batch with mixed valid & invalid CGUs → successful entries and per-CGU error entries present; ensure BatchCorrelation in all entries. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_GenerateDisclosureSummary(testResult) As Object</strong> — <em>disclosure-friendly summary builder</em><br><strong>Purpose:</strong> Produce a compact dictionary with CGUID, TotalCarrying, Impairment, ImpairmentPercent, KeyAssumptions (MethodUsed, DiscountRate, Daycount), Sensitivities placeholder — intended for modStatements consumption.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateDisclosureSummary(ByVal testResult As Object) As Object</code><br><strong>Behavior:</strong> Defensive: if testResult Nothing returns dictionary with Message. Otherwise extracts values using <code>NZDoubleObjKey</code>/<code>NZStringObj</code>, computes ImpairmentPercent safely (0 if TotalCarrying=0), constructs assumptions and sensitivities dictionaries, returns out. Optionally can be persisted by modUtilities if available (comment indicates optional persistence).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None (pure transform).<br><strong>Tests:</strong> Valid testResult produces expected percentage and assumptions. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_ValidateInputPackage(pkg) As Object</strong> — <em>input package validator, non-fatal issue collector</em><br><strong>Purpose:</strong> Validate structure & minimal shape of input package (CGUID, Assets, Forecast), return Dictionary of issues where empty dictionary = OK. Caller decides fatal vs non-fatal.<br><strong>Signature:</strong> <code>Public Function IAS36_ValidateInputPackage(ByVal pkg As Object) As Object</code><br><strong>Behavior:</strong> Defensive: if pkg Nothing add PackageMissing. Checks CGUID presence, Assets presence and non-empty; iterates assets to ensure AssetID present and CarryingAmount numeric & non-negative; if Forecast present validates via <code>NormalizeForecastToArray</code>. Uses descriptive keys like <code>Asset_1_ID</code> and messages. Returns issues Dictionary. Errors route to Handler and return Nothing.<br><strong>Complexity:</strong> O(n) assets + O(m) forecast normalization.<br><strong>Side-effects:</strong> None. <br><strong>Recommended tests:</strong> Missing CGUID/Assets; assets with missing IDs; negative carrying amounts; invalid forecasts. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36SelfTest() As Boolean</strong> — <em>self-test harness</em><br><strong>Purpose:</strong> Run deterministic smoke tests covering RunImpairmentTest, allocation invariant, VIU calculation, and validation function; log results and optionally write to test results sheet if host integrates test collection.<br><strong>Signature:</strong> <code>Public Function IAS36SelfTest() As Boolean</code><br><strong>Behavior:</strong> Builds fixtures (two assets, 3-year cashflows, etc.), runs <code>IAS36_RunImpairmentTest</code>, verifies result is object, if impairment>0 verifies allocation sums to impairment, runs zero-flow case, runs <code>IAS36_ValidateInputPackage</code> negative case, logs start/finish, returns boolean <code>ok</code>. On exception returns False and calls <code>HandleInternalError</code>.<br><strong>Complexity:</strong> Moderate (runs a small batch of calculations); deterministic RNG usage minimal (<code>Rnd</code> used elsewhere in correlation fallback).<br><strong>Side-effects:</strong> Calls <code>SafeLog</code>; may create test artifacts if host integration present. <br><strong>Tests:</strong> Self-test should return True in a correctly functioning environment; intentionally break parts to ensure SelfTest catches failures. </td></tr><tr><td data-label="Technical Breakdown"> <strong>NPVFromDcfEx(dcf, discountRate, asOfDate, daycount) As Double</strong> — <em>robust NPV from normalized DCF</em><br><strong>Purpose:</strong> Sum PV of cashflows (normalized) using <code>YearFractionEx</code> to compute time fractions; used by VIU computations and tests.<br><strong>Signature:</strong> <code>Private Function NPVFromDcfEx(ByVal dcf As Variant, ByVal discountRate As Double, ByVal asOfDate As Variant, ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> If forecast empty returns 0. Normalizes via <code>NormalizeForecastToArray</code>. For each row compute year fraction <code>yf</code> and PV = cf / (1+discountRate)^yf (or cf when discountRate <= 0). Accumulate and return. Errors routed to <code>HandleInternalError</code> and return 0.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Deterministic given same inputs and daycount function. <br><strong>Failure modes:</strong> Bad date rows handled by normalization; extremely large exponents may risk floating precision but typical accounting ranges safe. <br><strong>Tests:</strong> Known cashflow manual PV comparison; discountRate=0 returns sum of cashflows. </td></tr><tr><td data-label="Technical Breakdown"> <strong>NormalizeForecastToArray(forecast) As Variant</strong> — <em>canonical forecast normalization & stable sorting</em><br><strong>Purpose:</strong> Convert heterogeneous forecast input shapes (2D arrays, arrays of rows, collections of dicts) into a stable 1-based 2D variant array [1..n,1..2], remove empty rows, coerce amounts, and sort ascending by date deterministically pushing non-dates to end. Preserves deterministic behavior across runs and versions.<br><strong>Signature:</strong> <code>Private Function NormalizeForecastToArray(ByVal forecast As Variant) As Variant</code><br><strong>Behavior:</strong> If no rows returns Empty. Copies inputs into temp array treating various shapes, compacts valid rows where Date present or numeric amount present. Builds <code>out</code> array and performs a stable bubble-sort by date: date-date comparison, non-date pushed after dates. Returns Empty if no valid rows. Uses micro error blocks when probing items.<br><strong>Complexity:</strong> O(n^2) due to bubble-sort — acceptable because forecasts are typically small; intentionally stable deterministic algorithm chosen over faster non-stable sorts for auditability.<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Output is 1-based 2D array with dates (or Empty) and numeric amounts; rows sorted with all dates first ascending then non-dates. <br><strong>Failure modes:</strong> If forecast extremely large performance may degrade; recommended to pre-validate sizes before calling. <br><strong>Tests:</strong> Provide differently ordered inputs including non-dates, confirm deterministic ordering and removal of empty rows. </td></tr><tr><td data-label="Technical Breakdown"> <strong>SwapForecastRows(ByRef arr As Variant, i As Long, j As Long)</strong> — <em>swap utility</em><br><strong>Purpose:</strong> Swap two rows in forecast 2D array used by bubble-sort.<br><strong>Signature:</strong> <code>Private Sub SwapForecastRows(ByRef arr As Variant, ByVal i As Long, ByVal j As Long)</code><br><strong>Behavior:</strong> Swaps date and amount pairs; trivial utility. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> small array swap correctness. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetForecastDateAt(forecast, idx) As Variant</strong> — <em>safe accessor for forecast date</em><br><strong>Purpose:</strong> Provide robust read from different forecast shapes using LBound awareness and object/array probing; returns Empty on failure.<br><strong>Signature:</strong> <code>Private Function GetForecastDateAt(ByVal forecast As Variant, ByVal idx As Long) As Variant</code><br><strong>Behavior:</strong> For arrays computes base + idx - 1 indexing; for objects attempts forecast(idx)(1) with error suppression. Errors return Empty. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Different forecast shapes produce expected values. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetForecastAmountAt(forecast, idx) As Variant</strong> — <em>safe accessor for forecast amount</em><br><strong>Purpose:</strong> As above but returns numeric amount or 0 on failure.<br><strong>Signature:</strong> <code>Private Function GetForecastAmountAt(ByVal forecast As Variant, ByVal idx As Long) As Variant</code><br><strong>Behavior:</strong> Defensive indexing; returns 0 on errors. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>YearFractionEx(d0, d1, convention) As Double</strong> — <em>daycount implementation</em><br><strong>Purpose:</strong> Compute year fraction between two dates using supported conventions: "ACT/365" (default), "ACT/360", "30/360". Non-dates produce 0; negative days produce 0 (no negative yf).<br><strong>Signature:</strong> <code>Private Function YearFractionEx(ByVal d0 As Variant, ByVal d1 As Variant, ByVal convention As String) As Double</code><br><strong>Behavior:</strong> Validates dates, computes days difference as <code>CDbl(dt1) - CDbl(dt0)</code>, applies convention formulas. "30/360" uses simple 30/360 arithmetic. Unknown convention falls back to ACT/365.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Failure modes:</strong> Input non-dates -> 0. <br><strong>Tests:</strong> Known date pairs for each convention; negative dt1 < dt0 returns 0. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetRowCount(arr) As Long</strong> — <em>generic row/collection counter</em><br><strong>Purpose:</strong> Provide robust count for arrays (handles arbitrary LBound/UBound) and collection-like objects; returns 0 for missing/empty inputs.<br><strong>Signature:</strong> <code>Private Function GetRowCount(ByVal arr As Variant) As Long</code><br><strong>Behavior:</strong> If IsArray uses LBound/UBound to compute count; if IsObject attempts <code>arr.count</code> with error suppression; else 0. Errors handled. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Arrays with different bounds; collections; Nothing inputs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetDictValue(dictLike, key) As Variant</strong> — <em>safe dict get</em><br><strong>Purpose:</strong> Return value if object and key exists; else Empty. Thin defensive wrapper used across module.<br><strong>Signature:</strong> <code>Private Function GetDictValue(ByVal dictLike As Variant, ByVal key As String) As Variant</code><br><strong>Behavior:</strong> Uses <code>IsObject</code> -> <code>Exists</code> check with <code>On Error Resume Next</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetDictValueIndexed(dictArray, idx, key) As Variant</strong> — <em>safe indexed dict get</em><br><strong>Purpose:</strong> For arrays or collections of dict-like items provide safe extraction of a key from the element at index <code>idx</code> with support for arrays with non-1 LBound.<br><strong>Signature:</strong> <code>Private Function GetDictValueIndexed(ByVal dictArray As Variant, ByVal idx As Long, ByVal key As String) As Variant</code><br><strong>Behavior:</strong> Handles array and object forms; returns Empty when not present or on error. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Array-of-dicts and collection-of-dicts scenarios with missing keys. </td></tr><tr><td data-label="Technical Breakdown"> <strong>NZDouble(v, Optional def = 0#) As Double</strong> — <em>null-safe numeric coercion</em><br><strong>Purpose:</strong> Convert value to Double if numeric else return default. Swallows errors.<br><strong>Signature:</strong> <code>Private Function NZDouble(ByVal v As Variant, Optional ByVal def As Double = 0#) As Double</code><br><strong>Behavior:</strong> <code>IsNumeric</code> then <code>CDbl</code> else def. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Numeric strings, Null, Empty, objects. </td></tr><tr><td data-label="Technical Breakdown"> <strong>NZDoubleObjKey(o, key, Optional def = 0#) As Double</strong> — <em>object-key numeric fetch</em><br><strong>Purpose:</strong> If object exists and contains key, coerce numeric value via NZDouble else default.<br><strong>Signature:</strong> <code>Private Function NZDoubleObjKey(ByVal o As Object, ByVal key As String, Optional ByVal def As Double = 0#) As Double</code><br><strong>Behavior:</strong> Defensive checks for Nothing and key existence. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>NZStringObj(o, key, Optional def = "") As String</strong> — <em>object-key string fetch</em><br><strong>Purpose:</strong> Defensive extraction of string from object key; returns default otherwise.<br><strong>Signature:</strong> <code>Private Function NZStringObj(ByVal o As Object, ByVal key As String, Optional ByVal def As String = &quot;&quot;) As String</code><br><strong>Behavior:</strong> Similar to NZDoubleObjKey but returns CStr. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>NZString(v, Optional def = "") As String</strong> — <em>null/empty to string helper</em><br><strong>Purpose:</strong> Coerce variant to string or default for Null/Empty.<br><strong>Signature:</strong> <code>Private Function NZString(ByVal v As Variant, Optional ByVal def As String = &quot;&quot;) As String</code><br><strong>Behavior:</strong> Returns def for Null/Empty else CStr(v). <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Round2(v As Double) As Double</strong> — <em>centralized rounding policy</em><br><strong>Purpose:</strong> Central rounding to 2 decimal places using <code>VBA.Round</code>. Single point of change for rounding policy (bankers vs away-from-zero note in header).<br><strong>Signature:</strong> <code>Private Function Round2(ByVal v As Double) As Double</code><br><strong>Behavior:</strong> Calls <code>VBA.Round(v,2)</code> with error suppression. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> If rounding policy needs change, modify here; maintainers should add unit tests for edge .005 cases for target policy. </td></tr><tr><td data-label="Technical Breakdown"> <strong>AllocateImpairment(assets, impairment, mode, weights) As Object</strong> — <em>deterministic allocation algorithm (core)</em><br><strong>Purpose:</strong> Deterministically allocate total impairment across assets according to mode: "PRORATA" (default), "EQUAL", "WEIGHTED". Returns Dictionary AssetID -> allocation (rounded 2dp). Guarantees sum-to-impairment after residual deterministic adjustment and invariant verification/fallback.<br><strong>Signature:</strong> <code>Private Function AllocateImpairment(ByVal assets As Variant, ByVal impairment As Double, ByVal mode As String, ByVal weights As Variant) As Object</code><br><strong>Behavior (detailed):</strong><br>- Defensive early exit for no assets -> empty dict.<br>- Extract arrays <code>carries()</code> and <code>ids()</code> (deterministic ordering by input iteration).<br>- Compute <code>rawAlloc()</code> based on mode: PRORATA uses carrying weights; EQUAL divides equally; WEIGHTED uses provided weights (array or dictionary) with fallback to pro-rata when weights invalid.<br>- Round each line via <code>Round2</code> and accumulate <code>sumRounded</code>.<br>- Compute <code>residual = Round2(impairment - sumRounded)</code> and if residual significant (abs>=0.005) pick deterministic index to adjust: for PRORATA choose largest carrying (tie-break lex AssetID case-insensitive); for EQUAL/WEIGHTED choose largest rawAlloc (tie-break lex smallest id). Apply residual to chosen asset and re-round.<br>- Verify final sum equals impairment (rounded). If mismatch log <code>AllocationInvariant</code> and deterministically add remaining diff to lexicographically smallest AssetID.<br>- Return Dictionary. On error calls <code>HandleInternalError</code> and returns best-effort allocations.<br><strong>Complexity:</strong> O(rc) where rc = asset count. <br><strong>Side-effects:</strong> Creates and returns Dictionary; uses <code>SafeLog</code> on invariant mismatch.<br><strong>Invariants:</strong> Sum of allocations (rounded) equals <code>impairment</code> (rounded). Tie-break deterministic to ensure reproducibility.<br><strong>Failure modes:</strong> Non-numeric carrying amounts treated as 0; weights malformed -> fallback to pro-rata. For extremely large asset counts numeric rounding may produce frequent residuals; algorithm handles by deterministic redistribution.<br><strong>Recommended tests:</strong> Multiple modes, weight dictionary vs array, tie scenarios where residual distribution deterministic, round-trip sum equality. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_AllocateImpairment(assets, impairment, Optional mode="PRORATA", Optional weights) As Object</strong> — <em>public thin wrapper to allocation</em><br><strong>Purpose:</strong> Expose allocation algorithm preserving backward compatibility; ensures impairment is rounded to module policy before allocation and logs verification with generated correlation ID.<br><strong>Signature:</strong> <code>Public Function IAS36_AllocateImpairment(ByVal assets As Variant, ByVal impairment As Double, Optional ByVal mode As String = &quot;PRORATA&quot;, Optional ByVal weights As Variant) As Object</code><br><strong>Behavior:</strong> Round <code>impRounded = Round2(NZDouble(impairment))</code>, call <code>AllocateImpairment</code>, call <code>VerifyAllocationInvariant</code> with generated correlation and "ALLOC_PUBLIC" marker, return allocation. On error returns Nothing after <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(rc).<br><strong>Side-effects:</strong> Logs verification. <br><strong>Tests:</strong> Public wrapper returns same as private when impairment rounded; verification logs created. </td></tr><tr><td data-label="Technical Breakdown"> <strong>VerifyAllocationInvariant(allocations, expectedTotal, cguid, correlationID)</strong> — <em>invariant checker & auditor</em><br><strong>Purpose:</strong> Compute sum of allocation dictionary and log either OK or mismatch; non-throwing (resilient).<br><strong>Signature:</strong> <code>Private Sub VerifyAllocationInvariant(ByVal allocations As Object, ByVal expectedTotal As Double, ByVal cguid As String, ByVal correlationID As String)</code><br><strong>Behavior:</strong> Sums allocations via <code>NZDouble</code>, compares rounded sums; on mismatch logs <code>VerifyAllocationInvariant</code> with details; on OK logs <code>VerifyAllocationInvariant.OK</code>. Errors suppressed; uses <code>SafeLog</code> for audit.<br><strong>Complexity:</strong> O(k) where k = number of allocated entries. <br><strong>Side-effects:</strong> Audit logs. <br><strong>Notes:</strong> Useful for telemetry and forensic traceability in batch runs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>SafeLog(moduleName, proc, details)</strong> — <em>structured logging wrapper</em><br><strong>Purpose:</strong> Centralized audit logging that attempts to call host <code>LogAudit</code> (by <code>Application.Run &quot;LogAudit&quot;, ...</code>) and falls back to <code>Debug.Print</code> if not available. Non-throwing to not disturb main flows.<br><strong>Signature:</strong> <code>Private Sub SafeLog(moduleName As String, proc As String, details As String)</code><br><strong>Behavior:</strong> <code>On Error Resume Next</code> + <code>Application.Run &quot;LogAudit&quot;, moduleName &amp; &quot;.&quot; &amp; proc, details</code>. If that errors, prints fallback to Immediate window. Clears Err.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls host macro if present. <br><strong>Failure modes:</strong> Host <code>LogAudit</code> absent triggers fallback. <br><strong>Tests:</strong> With and without host LogAudit hook — confirm fallback behavior. </td></tr><tr><td data-label="Technical Breakdown"> <strong>HandleInternalError(procName, errObj)</strong> — <em>error routing / host integration</em><br><strong>Purpose:</strong> Route internal errors to host <code>HandleError(procName, errNumber, errDescription)</code> if present; otherwise raise minimal VBA error to surface to host while avoiding uncontrolled crashes. Accepts ErrObject or numeric/string descriptors as <code>errObj</code> and extracts Number/Description accordingly.<br><strong>Signature:</strong> <code>Private Sub HandleInternalError(procName As String, ByVal errObj As Variant)</code><br><strong>Behavior:</strong> Defensive extraction of <code>errObj</code> fields (supports ErrObject, object-like, numeric, string). Attempts <code>Application.Run &quot;HandleError&quot;, procName, n, d</code>. If that succeeds returns. If host call not available, raises <code>Err.Raise vbObjectError + 513</code> with a minimal message to surface error. All internal error handling uses <code>On Error Resume Next</code> to avoid masking host behavior and ensures Err cleared where appropriate.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May raise an error if host handler not present; otherwise delegates to host. <br><strong>Failure modes:</strong> Host <code>HandleError</code> absent -> small raised error; ensure callers expect possible raised errors. <br><strong>Tests:</strong> Simulate host missing -> Err.Raise observed; with host stub -> host receives call. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GenerateCorrelationID() As String</strong> — <em>traceability id generator with GUID fallback</em><br><strong>Purpose:</strong> Attempt to produce GUID via <code>Scriptlet.TypeLib</code>.guid; if not available, generate timestamp-based fallback string <code>&quot;CID_yyyymmddhhNNss_random&quot;</code>. Ensures traceability across logs and batch runs.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Try <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code>, strip braces; on error returns timestamp + pseudo-random component using <code>Rnd</code>. Uses <code>On Error GoTo Fallback</code> pattern. <br><strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Worst-case fallback uses timestamp & Rnd — acceptable for correlation but less globally unique. <br><strong>Tests:</strong> On typical Windows hosts GUID produced; on restricted hosts fallback format used. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Notes on cross-cutting behaviors & maintainability</strong><br><strong>Determinism:</strong> The module consciously chooses deterministic, stable algorithms (bubble-sort stable ordering, tie-break rules in allocations) to ensure auditability; changing tokenization/sorting/allocation rules must be accompanied by migration tests and explicit versioning. <br><strong>Error handling philosophy:</strong> Prefer targeted micro <code>On Error Resume Next</code> blocks when probing host-provided objects or optional fields; global <code>ErrHandler</code> sections route to <code>HandleInternalError</code> and return safe default (Empty, 0, Nothing) to avoid crashing host automation. <br><strong>Rounding policy:</strong> Centralized in <code>Round2</code> to allow policy switch. Add tests for .005 rounding edge cases if policy changes. <br><strong>Security & data sensitivity:</strong> Module handles financial numbers only; avoid writing PII into logs. <code>SafeLog</code> uses host <code>LogAudit</code> — ensure host implements appropriate retention and redaction for sensitive fields. <br><strong>Performance:</strong> Forecast normalization uses O(n^2) stable bubble-sort — acceptable for typical short forecasts. If high row counts expected (>1000) consider replacing with stable merge sort. <br><strong>Testing recommendations:</strong> Unit tests for token deterministic allocations, allocation residual distribution in tie cases, daycount conventions (ACT/365, ACT/360, 30/360), NPV equivalence to reference spreadsheets, per-CGU batch resilience (simulate throwing CGU), SelfTest regression gating in CI. <br><strong>Host integration checklist:</strong> Ensure host provides <code>LogAudit</code> and <code>HandleError</code> or accept fallback behaviours. Prefer host to capture <code>SafeLog</code> outputs for audit trails. <br><strong>Compatibility:</strong> Public API surface preserved: <code>IAS36_RecoverableAmount</code>, <code>IAS36_RunImpairmentTest</code>, <code>IAS36_RunBatchImpairmentTests</code>, <code>IAS36_GenerateImpairmentJournals</code>, <code>IAS36_AllocateImpairment</code> and <code>IAS36_GenerateDisclosureSummary</code> should remain stable for consumers. </td></tr></tbody></table></div><div class="row-count">Rows: 36</div></div><div class="table-caption" id="Table4" data-table="Docu_0159_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modIFRS15)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modIFRS15)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Overview:</strong> This table provides a world-class, per-function technical breakdown of the <code>modIFRS15</code> VBA module you supplied. It documents purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended tests, and maintainer notes. The module implements a deterministic IFRS 15 contract pipeline: parsing/normalising contract input, deterministic allocation of transaction price (including variable consideration treatment), generation of recognition schedules, journals and disclosures, validation, batch processing and an embedded self-test harness. It relies on shared infra (modConfig, logging, auditing, modError) via best-effort calls and preserves backward-compatible public API shapes. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Module-level invariants & config keys</strong><br>- Rounding precision controlled by <code>GetConfigDouble(&quot;roundingPrecision&quot;, ...)</code> defaulting to 2 via <code>GetRoundingPrecision()</code>.<br>- Variable-consideration constraint key: <code>&quot;variableConstraintThreshold&quot;</code> (default passed into AllocateTransactionPrice).<br>- Account config keys: <code>&quot;IFRS15_RevenueAccount&quot;</code>, <code>&quot;IFRS15_ContraAccount&quot;</code> used by journal generation.<br>- Public API stable functions: <code>IFRS15_AnalyzeContract</code>, <code>IFRS15_AllocateTransactionPrice</code>, <code>IFRS15_GenerateRecognitionSchedule</code>, <code>IFRS15_GenerateJournalEntries</code>, <code>IFRS15_GenerateDisclosures</code>, <code>IFRS15_ValidateContract</code>, <code>IFRS15_BatchProcessContracts</code>, <code>IFRS15SelfTest</code>.<br>- Determinism rules: residual rounding absorbed into PO with largest <code>StandalonePrice</code>; final period receives schedule residual; allocations preserve pre-existing <code>analysis(&quot;Allocation&quot;)</code> if present (backwards compatibility). </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_AnalyzeContract( contract As Variant ) -> Object <code>|</code> Dictionary</strong><br><strong>Purpose:</strong> Normalize incoming contract input into canonical <code>analysis</code> object (dictionary) with a <code>PerformanceObligations</code> collection and key metadata required by later functions.<br><strong>Signature:</strong> <code>IFRS15_AnalyzeContract(ByVal contract As Variant) As Object</code> — returns <code>Scripting.Dictionary</code> or <code>Nothing</code> on error.<br><strong>Behavior:</strong> Validates <code>contract</code> shape, extracts <code>Lines</code> (via <code>GetContractLines</code>), iterates lines to build PO dictionaries with keys: <code>POID</code>, <code>Description</code>, <code>Quantity</code>, <code>StandalonePrice</code>, <code>RecognitionMethod</code>, <code>DeliveryDate</code>, <code>VariableConsideration</code>, <code>SourceLine</code>. Coerces/normalises numeric values, applies defensive checks (negative quantity -> abs + judgment; negative standalone -> coerced zero + judgment). Computes <code>TotalStandalone</code>, sets <code>TransactionPrice</code> and <code>ContractDate</code> when present. Initializes placeholders <code>Allocation</code>, <code>ReserveForVariable</code>, <code>AllocatedTotal</code>, <code>JudgmentsApplied</code> to preserve public shapes.<br><strong>Complexity:</strong> O(n) in number of lines.<br><strong>Side-effects:</strong> Calls <code>SafeLog</code>, may call <code>AddLocalIssueAudit</code>, pushes judgments into analysis if coercions occur.<br><strong>Invariants:</strong> Returned <code>PerformanceObligations</code> is a <code>Collection</code> of dictionaries; <code>TotalStandalone</code> matches sum of PO <code>StandalonePrice</code> values computed inside function.<br><strong>Failure modes:</strong> Missing or malformed <code>Lines</code> => returns dictionary with minimal info; unexpected object types swallowed (On Error Resume Next wrapper). Errors funnel to <code>SafeHandleError</code> and return <code>Nothing</code> only on exceptions that escape local handling.<br><strong>Security/PII:</strong> Avoids storing sensitive free-text in global logs; judgements are PII-light by design but appended to local audit if needed.<br><strong>Recommended tests:</strong> line shapes with missing fields, negative quantities/prices, variable consideration in scalar/object/array forms; ensure <code>TotalStandalone</code> and PO fields correct for representative inputs.<br><strong>Notes for maintainers:</strong> Keep token names stable (<code>POID</code>, <code>StandalonePrice</code>) to avoid breaking downstream code. Preserve existing allocation override behaviour for backward compatibility. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_AllocateTransactionPrice( analysis As Object, Optional applyVariableConsideration As Boolean = True, Optional variableConstraintThreshold As Double = 0.25 ) -> Object</strong><br><strong>Purpose:</strong> Deterministic allocation of transaction price to performance obligations, evaluating variable consideration and applying reserve rules; rounds and fixes rounding residuals deterministically.<br><strong>Signature:</strong> <code>IFRS15_AllocateTransactionPrice(ByVal analysis As Object, Optional ByVal applyVariableConsideration As Boolean = True, Optional ByVal variableConstraintThreshold As Double = 0.25) As Object</code> — returns mutated <code>analysis</code> with <code>Allocation</code>, <code>AllocatedTotal</code>, <code>ReserveForVariable</code>, and <code>JudgmentsApplied</code> updated, or <code>Nothing</code> on fatal error.<br><strong>Behavior (high-level):</strong><br>- Validates <code>analysis</code>, reads <code>TransactionPrice</code> and <code>TotalStandalone</code>.<br>- Overrides <code>variableConstraintThreshold</code> from <code>GetConfigDouble</code> if configured.<br>- Evaluates each PO's <code>VariableConsideration</code> into a deterministic <code>expectedVal</code> by supporting scalar numeric, object <code>{Method, MostLikely, Scenarios}</code>, or array of <code>{Probability, Amount}</code>.<br>- Applies reserve: if <code>expectedVal &lt;= threshold * txPrice</code> then reserve includes expected value; otherwise record judgment <code>ReserveNotApplied_AboveThreshold</code>.<br>- Compute <code>allocablePrice = TransactionPrice - reserve</code> (clamped >= 0). Build unrounded proportional shares by standalone price if <code>TotalStandalone &gt; 0</code>, else equal split. Round shares using <code>SafeRound</code> to rounding precision. Determine residual between rounded shares and rounded allocable price; absorb residual deterministically into PO with largest <code>StandalonePrice</code> (tie by lowest index). Preserve existing <code>analysis(&quot;Allocation&quot;)</code> if present (do not overwrite), recording <code>PreservedExistingAllocation</code> judgment.<br>- Ensure <code>AllocatedTotal + ReserveForVariable</code> rounded equals TransactionPrice; if mismatch, apply correction to best PO or reserve and record <code>AllocationEquationCorrection</code> or <code>ReserveEquationCorrection</code> judgments.<br><strong>Complexity:</strong> O(n) across POs; variable consideration scenario evaluation is O(m) per PO where m is number of scenarios.<br><strong>Side-effects:</strong> Mutates <code>analysis</code> (adds/sets <code>Allocation</code>, <code>AllocatedTotal</code>, <code>ReserveForVariable</code>), logs judgments and calls <code>SafeLog</code>/<code>AddJudgment</code>.<br><strong>Invariants:</strong> Final <code>SafeRound(AllocatedTotal + ReserveForVariable)</code> equals <code>SafeRound(TransactionPrice)</code>; allocation dictionary keys correspond to <code>POID</code>s.<br><strong>Failure modes:</strong> Non-numeric or malformed variable consideration objects are handled gracefully (On Error blocks); negative or zero transaction price results in judgments but allocation proceeds with zero allocable. Large roundingPrecision changes may break deterministic residual absorption—tests required when changing config.<br><strong>Tests:</strong> Scalar VCo, scenarios object, array-of-scenarios inputs; zero/negative tx price; totalStandalone = 0 (equal split); residual absorption deterministic (largest standalone wins); preservation of pre-existing allocation.<br><strong>Notes:</strong> Keep <code>SafeRound</code> precision consistent; any change to residual tie-break rule must be accompanied by migration notes because allocations can be auditable. Consider adding an explicit <code>AllocationMethod</code> tag to analysis for future traceability. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateRecognitionSchedule( analysis As Object, Optional periods As Long = 12, Optional startDate As Variant = Null ) -> Variant (2D array)</strong><br><strong>Purpose:</strong> Produce a recognition schedule matrix of revenue recognition rows (contractID, POID, periodIndex, recognitionDate, amount, method) deterministically from allocation and PO recognition methods.<br><strong>Signature:</strong> <code>IFRS15_GenerateRecognitionSchedule(ByVal analysis As Object, Optional ByVal periods As Long = 12, Optional ByVal startDate As Variant = Null) As Variant</code> — returns 2D array <code>(1..rows, 1..6)</code> or <code>Empty</code> on no rows/failure.<br><strong>Behavior:</strong><br>- Validates <code>analysis</code> and determines <code>startDate</code> precedence: provided startDate > analysis("ContractDate") > Today.<br>- Clamps <code>periods</code> to <code>[1,10000]</code> and records judgments if clamped.<br>- For each PO: determines <code>amount</code> from <code>analysis(&quot;Allocation&quot;)(POID)</code> if present else <code>PO(&quot;StandalonePrice&quot;)</code>. Rounds <code>amount</code> to roundingPrecision.<br>- If <code>RecognitionMethod</code> = <code>&quot;time&quot;</code>, evenly divide <code>amount</code> by <code>periods</code>, round per period, compute period residual <code>schResidual = amount - (perPeriodRounded * periods)</code> and place residual in final period (deterministic). For <code>&quot;point&quot;</code>, create a single row using <code>DeliveryDate</code> if valid, otherwise fallback to <code>startDate</code> and add judgment <code>FallbackDeliveryDateToStartDate</code>.<br>- Assemble rows into 2D variant array columns: ContractID, POID, PeriodIndex, Date, Amount, Method.<br><strong>Complexity:</strong> O(n * periods) where <code>n</code> = number of POs; but typical usage has small <code>periods</code> (monthly 12/36). Guard exists to prevent runaway loops for enormous <code>periods</code> (clamp at 10000).<br><strong>Side-effects:</strong> Writes judgments to <code>analysis</code> (fallbacks/clamping), <code>SafeLog</code> call.<br><strong>Invariants:</strong> Sum of schedule amounts per PO equals the PO amount (after rounding); residuals are placed in final period for time-based POs.<br><strong>Failure modes:</strong> If allocation missing, uses PO standalone price; if amounts zero/no POs returns <code>Empty</code>. Date coercion may fail silently and fallback to <code>startDate</code>.\<br><strong>Tests:</strong> time-based PO with non-divisible amount to ensure residual in final period; point-in-time with/without DeliveryDate; periods out-of-range behaviour; round-trip check that schedule sums match allocation. <br><strong>Notes:</strong> Keep date arithmetic consistent (uses <code>DateAdd(&quot;m&quot;, ...)</code>). If supporting non-monthly periods is required in future, refactor to pluggable period step. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateJournalEntries( recognitionSchedule As Variant, revenueAccount As String, contraAccount As String ) -> Variant (2D array)</strong><br><strong>Purpose:</strong> Convert recognition schedule into nominal debit/credit journal rows for posting: date, debit account, debit amount, credit account, credit amount, narrative.<br><strong>Signature:</strong> <code>IFRS15_GenerateJournalEntries(ByVal recognitionSchedule As Variant, ByVal revenueAccount As String, ByVal contraAccount As String) As Variant</code> — returns 2D variant array matching input row count or <code>Empty</code> if input empty.<br><strong>Behavior:</strong><br>- If accounts not supplied, attempts <code>GetConfigString(&quot;IFRS15_RevenueAccount&quot;, &quot;Revenue&quot;)</code> and <code>GetConfigString(&quot;IFRS15_ContraAccount&quot;, &quot;DeferredRevenue&quot;)</code> as defaults.<br>- For each row in <code>recognitionSchedule</code>, builds journal row: date, contraAccount (debit) amount, revenueAccount (credit) amount, narrative <code>&quot;Revenue recognition for &lt;POID&gt;&quot;</code>.<br><strong>Complexity:</strong> O(rows in schedule).<br><strong>Side-effects:</strong> <code>SafeLog</code> call.<br><strong>Invariants:</strong> Each journal row mirrors a schedule row and preserves amounts; numeric coercion via <code>NZDouble</code> prevents non-numeric breakdowns.<br><strong>Failure modes:</strong> Missing accounts -> default strings used; non-date schedule dates are copied verbatim. <br><strong>Tests:</strong> schedule with 0 rows -> returns Empty; account override vs config fallback; narrative correctness. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_GenerateDisclosures( analysis As Object ) -> Object (Dictionary)</strong><br><strong>Purpose:</strong> Build disclosures summarising unsatisfied performance obligations and significant judgments for reporting/disclosure consumption.<br><strong>Signature:</strong> <code>IFRS15_GenerateDisclosures(ByVal analysis As Object) As Object</code> — returns <code>Scripting.Dictionary</code> containing <code>UnsatisfiedPerformanceObligations</code> (Collection), <code>TotalUnsatisfied</code>, <code>SignificantJudgments</code> (Collection) and optionally <code>Message</code> for error cases.<br><strong>Behavior:</strong><br>- For each PO in <code>analysis(&quot;PerformanceObligations&quot;)</code>, compute <code>RemainingAmount</code> from <code>analysis(&quot;Allocation&quot;)(POID)</code> (if present) else <code>StandalonePrice</code>, round to roundingPrecision, assemble summary dict with <code>POID</code>, <code>Description</code>, <code>RemainingAmount</code> and append to results collection.<br>- Sum totals and include <code>SignificantJudgments</code> copied from <code>analysis(&quot;JudgmentsApplied&quot;)</code> if present.<br>- If <code>analysis</code> missing, returns object with message <code>&quot;No analysis supplied&quot;</code>.<br><strong>Complexity:</strong> O(n POs).<br><strong>Side-effects:</strong> <code>SafeLog</code> call.<br><strong>Invariants:</strong> TotalUnsatisfied equals sum of <code>RemainingAmount</code> values; disclosure uses PII-light judgment entries.<br><strong>Failure modes:</strong> Missing or malformed <code>analysis</code> handled gracefully by returning informative message. <br><strong>Tests:</strong> Assertions that totals equal allocation; inclusion of judgments; minimal output when analysis absent. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_ValidateContract( contract As Variant ) -> Object (Dictionary of issues)</strong><br><strong>Purpose:</strong> Lightweight validation diagnostic to identify missing/invalid contract fields before analysis.<br><strong>Signature:</strong> <code>IFRS15_ValidateContract(ByVal contract As Variant) As Object</code> — returns dictionary of issues (key => message) or <code>Nothing</code> on error.<br><strong>Behavior:</strong><br>- Checks <code>Contract</code> presence, <code>ContractID</code> recommended, <code>TransactionPrice</code> non-negative, existence of <code>Lines</code> and per-line checks: description presence, quantity numeric/non-zero, standalone price non-negative, recognition method allowed (<code>time</code>/<code>point</code>), <code>UnitPrice</code> non-negative.<br>- Uses <code>GetContractLines</code> and helper <code>Nz*</code> functions for defensive reads.<br><strong>Complexity:</strong> O(n lines).<br><strong>Side-effects:</strong> None (pure diagnostic).<br><strong>Invariants:</strong> Returns empty dictionary if no issues found; keys are stable for programmatic consumption (e.g., <code>Line_1_Description</code>).<br><strong>Failure modes:</strong> Non-array or malformed lines handled as <code>NoLines</code> issue. <br><strong>Tests:</strong> Missing ContractID, negative TransactionPrice, malformed lines, invalid recognition method. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15_BatchProcessContracts( contracts As Variant ) -> Object (Dictionary results)</strong><br><strong>Purpose:</strong> Deterministic batch driver for processing multiple contracts: analyze, allocate, schedule generation; returns a dictionary mapping contract id to schedule (pure data) or failure code strings.<br><strong>Signature:</strong> <code>IFRS15_BatchProcessContracts(ByVal contracts As Variant) As Object</code> — returns <code>Scripting.Dictionary</code> keyed by deterministic contract identifier.<br><strong>Behavior:</strong><br>- Iterates <code>contracts</code> deterministically via <code>LBoundArraySafe</code>..<code>UBoundArraySafe</code>.<br>- For each contract: calls <code>IFRS15_AnalyzeContract</code>, <code>IFRS15_AllocateTransactionPrice</code>, <code>IFRS15_GenerateRecognitionSchedule</code> (12 periods default, start date from contract). Collects and stores schedule in results. Uses <code>On Error Resume Next</code> per-iteration to ensure single-contract failures don't abort entire batch; logs progress via <code>SafeLog</code>.<br><strong>Complexity:</strong> O(m * per-contract-cost) where m = number of contracts. The included perf test uses ~100 contracts to validate throughput.<br><strong>Side-effects:</strong> Logs per-contract, appends <code>SafeLog</code> and possibly <code>AppendLocalAudit</code> on failures; does NOT write to sheets (pure data).<br><strong>Invariants:</strong> Deterministic iteration order based on array bounds; results keys use <code>ContractID</code> or fallback <code>Contract_&lt;i&gt;</code> index to guarantee unique keys.<br><strong>Failure modes:</strong> Individual contract failures recorded as <code>&quot;AnalysisFailed&quot;</code> or <code>&quot;AllocationFailed&quot;</code> strings in results; entire function returns <code>Nothing</code> only on unrecoverable error (rare).<br><strong>Tests:</strong> Batch with mixture of valid/invalid contracts; performance smoke: 100 contracts as in module self-test. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IFRS15SelfTest() -> Boolean</strong><br><strong>Purpose:</strong> Embedded unit/integration self-test harness exercising core flows (analysis, allocation, schedule generation) with multiple fixtures and a lightweight performance batch; writes test summary to hidden <code>_IFRS_TestResults</code> sheet for CI/manual inspection.<br><strong>Signature:</strong> <code>IFRS15SelfTest() As Boolean</code> — returns <code>True</code> if no failures detected, else <code>False</code>.<br><strong>Behavior:</strong><br>- Creates three fixture contracts covering: (1) combined time+point recognition, (2) scalar variable consideration, (3) scenario-based variable consideration. Performs analyze -> allocate -> generate schedule and validates that <code>AllocatedTotal + Reserve</code> equals TransactionPrice and schedule sums match allocation. Runs a small perf batch (100 contracts) through <code>IFRS15_BatchProcessContracts</code> and records <code>AppendTestResults</code> to <code>_IFRS_TestResults</code> sheet. Uses <code>SafeLog</code> and <code>AddJudgment</code> to record notable events. Aggregates pass/fail counters and returns boolean accordingly.<br><strong>Complexity:</strong> Small fixed number of tests plus perf batch (O(100) contracts by default).<br><strong>Side-effects:</strong> Writes to hidden worksheet <code>_IFRS_TestResults</code> and may call <code>AppendLocalAudit</code>. Designed to be non-invasive but creates hidden sheet if absent.<br><strong>Invariants:</strong> Should be idempotent and not alter production workbook state besides adding a hidden results sheet and audit entries.<br><strong>Failure modes:</strong> If sheet creation fails (locked workbook) the function will still return boolean false and call <code>SafeHandleError</code>.<br><strong>Tests:</strong> The function itself is the test harness; maintainers should run it in CI or dev environment and inspect <code>_IFRS_TestResults</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetContractLines( contract ) -> Variant (array or Empty)</strong><br><strong>Purpose:</strong> Defensive extractor for contract <code>Lines</code> that accepts either object with <code>Lines</code> property or a bare array contract representation.<br><strong>Signature:</strong> <code>Private Function GetContractLines(ByVal contract As Variant) As Variant</code><br><strong>Behavior:</strong> Returns <code>contract(&quot;Lines&quot;)</code> if object with <code>Lines</code>, else returns contract itself if array; else <code>Empty</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Provide object-with-Lines, array contract, and invalid inputs. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EnsureAsDictionary( v ) -> Object (Dictionary)</strong><br><strong>Purpose:</strong> Convert non-object line inputs into an empty <code>Scripting.Dictionary</code> to allow uniform property access.<br><strong>Signature:</strong> <code>Private Function EnsureAsDictionary(ByVal v As Variant) As Object</code><br><strong>Behavior:</strong> If <code>v</code> is object returns it; else returns new empty <code>Scripting.Dictionary</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Critical to avoid runtime errors when consumer code assumes dictionary semantics. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Nz* helpers (NzStringFromVariant, NzDoubleFromVariant, NzDateFromVariant, NzStringDict, NzDoubleDict, NzDateDict, NzDoubleObj, NZStringObj, NZDouble)</strong><br><strong>Purpose:</strong> Defensive coercion helpers used across module to safely extract typed values from <code>Variant</code>/<code>Object</code> inputs without raising errors.<br><strong>Signatures:</strong> Each returns typed defaults when keys missing or types invalid. Eg <code>NzDoubleFromVariant(v, key, def) -&gt; Double</code>.<br><strong>Behavior:</strong> Use <code>On Error Resume Next</code>, test <code>IsObject</code>/<code>Exists</code>, type-check, convert, otherwise return default. <code>NZDouble</code> is generic numeric coerce for a value.<br><strong>Complexity:</strong> O(1) per call.<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Always returns a value of expected type (string/double/date) or provided default.<br><strong>Tests:</strong> Feeding nulls, strings, numeric strings, missing keys and verifying defaults used. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Array helpers (LBoundArraySafe, UBoundArraySafe, CountArrayElements)</strong><br><strong>Purpose:</strong> Defensive array boundary functions avoiding runtime errors when <code>arr</code> is not an array.<br><strong>Signatures:</strong> <code>LBoundArraySafe(arr) -&gt; Long</code>, <code>UBoundArraySafe(arr) -&gt; Long</code>, <code>CountArrayElements(arr) -&gt; Long</code>.<br><strong>Behavior:</strong> If <code>IsArray(arr)</code> returns respective bounds else safe sentinel values (0 / -1 / 0).<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Non-array inputs, empty arrays, 1-based/0-based arrays. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>EscapeCsv( s ) -> String</strong><br><strong>Purpose:</strong> Minimal CSV escaping helper returning string with quotes doubled (for field-level CSV writing elsewhere).<br><strong>Signature:</strong> <code>Private Function EscapeCsv(ByVal s As String) As String</code>.<br><strong>Tests:</strong> Strings containing quotes. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>IsProcedureAvailable( procName ) -> Boolean</strong><br><strong>Purpose:</strong> Best-effort detection whether an external procedure is callable via <code>Application.Run</code> without throwing fatal errors (used to detect external log/handler procedures).<br><strong>Signature:</strong> <code>Private Function IsProcedureAvailable(ByVal procName As String) As Boolean</code>.<br><strong>Behavior:</strong> Attempts <code>Application.Run procName</code>; inspects <code>Err.Number</code> to infer availability; clears errors and returns boolean.<br><strong>Complexity:</strong> O(1) but may have side-effects if called procedure executes; used only for detection of benign helper procs. <strong>Caution:</strong> If <code>procName</code> exists and has side-effects, running it here will execute it — this helper assumes detection entrypoints are side-effect free. <br><strong>Tests:</strong> Detect known available/unavailable procedure names in environment. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Logging & error helpers (SafeLog, SafeHandleError, AppendLocalAudit, SheetExists)</strong><br><strong>Purpose:</strong> Robust forwarding to central logging/error handler (<code>Application.Run &quot;LogAudit&quot;</code> / <code>&quot;HandleError&quot;</code>) with fallback to local append to hidden <code>_IFRS_Audit</code> sheet when calls fail. <code>SheetExists</code> used to detect/create hidden audit/test sheets.<br><strong>Signatures:</strong> <code>Private Sub SafeLog(moduleName, proc, details)</code>, <code>Private Sub SafeHandleError(procName, errNumber, errDesc)</code>, <code>Private Sub AppendLocalAudit(message)</code>, <code>Private Function SheetExists(name) As Boolean</code>.<br><strong>Behavior:</strong> Try remote logging via <code>Application.Run</code>; on failure write to workbook hidden audit sheet (creates it if missing) with timestamp, Application.UserName and truncated message. <code>SafeHandleError</code> attempts remote <code>HandleError</code> then appends fallback audit. AppendLocalAudit creates <code>_IFRS_Audit</code> (very hidden) if absent. All functions use <code>On Error Resume Next</code> to avoid cascading failures.<br><strong>Complexity:</strong> Dependent on sheet operations (O(1) for append).<br><strong>Side-effects:</strong> Writes to hidden sheets (audit/test), calls <code>Application.Run</code> which may call external add-in handlers. Designed robustly to avoid throwing.<br><strong>Security/Privacy:</strong> Audit sheet stores messages and <code>Application.UserName</code> — avoid storing sensitive data; code truncates messages to 2000 chars. <br><strong>Tests:</strong> Simulate missing <code>LogAudit</code>/<code>HandleError</code> procedures and verify <code>_IFRS_Audit</code> created and entries appended. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>SafeRound(value, places) -> Double & GetRoundingPrecision()</strong><br><strong>Purpose:</strong> Centralised rounding with Excel worksheet ROUND fallback and config-driven precision via <code>GetConfigDouble(&quot;roundingPrecision&quot;)</code> default 2.<br><strong>Behavior:</strong> Calls <code>Application.WorksheetFunction.Round</code>; on error uses VBA <code>Round</code> fallback. <code>GetRoundingPrecision()</code> returns configured rounding precision or 2 by default. <br><strong>Complexity:</strong> O(1).<br><strong>Invariants:</strong> All monetary rounding uses this helper to maintain consistent rounding policy across module.<br><strong>Tests:</strong> Ensure SafeRound performs expected decimal rounding under different <code>roundingPrecision</code> config values. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>GetConfigDouble / GetConfigString</strong><br><strong>Purpose:</strong> Resilient access to global configuration via multiple possible host functions: <code>modConfig_Get</code>, <code>Config_Get</code>, <code>GetConfigValue</code>. Silent fallback to supplied default if none available.<br><strong>Behavior:</strong> Tries <code>Application.Run</code> for each candidate function name in order, returns numeric/string default on failure. Uses <code>On Error Resume Next</code> to be non-fatal. <br><strong>Complexity:</strong> O(1) per call but calls <code>Application.Run</code> which may have cost. <br><strong>Security:</strong> Avoid returning untrusted remote values without validation; calling code should sanitize as necessary. <br><strong>Tests:</strong> With/without <code>modConfig_Get</code> present; non-numeric config values. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AddJudgment( analysis, subjectPOID, issue, amount )</strong><br><strong>Purpose:</strong> Append PII-light judgment entries into <code>analysis(&quot;JudgmentsApplied&quot;)</code> Collection for audit/disclosure of model decisions (coercions, reserve choices, residual absorptions).<br><strong>Signature:</strong> <code>Private Sub AddJudgment(ByVal analysis As Object, ByVal subjectPOID As String, ByVal issue As String, ByVal amount As Double)</code><br><strong>Behavior:</strong> Ensures <code>JudgmentsApplied</code> exists (creates collection), builds a <code>Scripting.Dictionary</code> entry with <code>Timestamp</code>, <code>POID</code>, <code>Issue</code>, <code>Amount</code> (rounded), appends to collection and calls <code>SafeLog</code> with compact message. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>analysis</code> and calls <code>SafeLog</code>. <br><strong>Privacy:</strong> Entries intentionally lightweight; avoid adding sensitive long text to <code>Issue</code>. <br><strong>Tests:</strong> Ensure judgements accumulate and show in disclosures. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AppendTestResults(summary, notes)</strong><br><strong>Purpose:</strong> Write self-test summary and concatenated notes to hidden <code>_IFRS_TestResults</code> sheet for CI and manual inspection.<br><strong>Behavior:</strong> Create sheet if missing (very hidden), append row with timestamp, summary, and notes concatenated; truncates notes to 2000 chars. <br><strong>Side-effects:</strong> Writes to workbook (very hidden sheet). <br><strong>Tests:</strong> Run <code>IFRS15SelfTest</code> and inspect <code>_IFRS_TestResults</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>AddLocalIssueAudit(keyOrMsg, Optional details)</strong><br><strong>Purpose:</strong> Convenience wrapper that writes local audit messages for unexpected but non-fatal issues without raising errors. Uses <code>AppendLocalAudit</code> internally.<br><strong>Behavior:</strong> Forms single-line message and appends to local audit. <br><strong>Tests:</strong> Ensure message appears in <code>_IFRS_Audit</code>. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Maintenance, testing & operational recommendations</strong><br>- <strong>Determinism:</strong> Preserve <code>SafeRound</code>/<code>GetRoundingPrecision</code> behaviour; changing roundingPrecision or residual tie-breaker changes allocation results and is auditable — add migration note and regression tests.<br>- <strong>Config integration:</strong> Prefer a single <code>modConfig_Get</code> surface; current multi-try approach is defensive but complicates runtime tracing. Consider adding a single accessor wrapper in <code>modConfig</code> to reduce duplication.<br>- <strong>Audit trail:</strong> Judgments and AppendLocalAudit produce audit trails, but consider writing a compact JSON manifest or manifest sheet summarising inputs, config used, roundingPrecision and variableConstraintThreshold for each processed contract to speed audits and CI regression checks.<br>- <strong>Self-tests in CI:</strong> <code>IFRS15SelfTest</code> writes to workbook; in automated CI prefer a headless test harness that inspects returned booleans and avoids mutating production workbook. Consider adding a <code>IFRS15RunTestsToObject()</code> that returns structured results (no sheet writes) for CI assertion.<br>- <strong>Edge cases:</strong> Large numbers, extreme scenario probabilities, and binary/malformed <code>VariableConsideration</code> shapes should be covered by unit tests; ensure expectedVal computations are resilient to NaN/Null and that probabilities sum to <=1 (current code does not assert sum to 1 — consider adding validation and a judgment when sums deviate).<br>- <strong>Logging & privacy:</strong> Audit entries include <code>Application.UserName</code>; ensure this is acceptable in your privacy model. Avoid recording raw contract text in audit entries. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Recommended unit/integration test list (concise)</strong><br>1. Token-level: <code>IFRS15_AnalyzeContract</code> handles missing/extra fields and negative coercions.<br>2. Allocation parity: allocations + reserve rounded equals transaction price across permutations (TotalStandalone=0, >0, zero txPrice).<br>3. VariableConsideration forms: scalar, object-mostLikely, scenarios-array; threshold boundary cases (exactly threshold * txPrice).<br>4. Rounding residuals: deterministic absorption into largest standalone price (test ties by index).<br>5. Schedule correctness: time-based residual placed in final period; point-in-time uses DeliveryDate or fallback to startDate with judgment.<br>6. Journals: account fallback to config and correct narrative composition.<br>7. Batch processing: mixture of valid/invalid contracts; ensure per-contract isolation and correct result dictionary keys.<br>8. Self-test idempotence: <code>IFRS15SelfTest</code> returns boolean and appends to <code>_IFRS_TestResults</code> without corrupting workbook structure on repeated runs.<br>9. Logging fallback: simulate missing <code>LogAudit/HandleError</code> and confirm <code>_IFRS_Audit</code> created and populated. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Security & data handling notes</strong><br>- Module avoids <code>Eval</code>/<code>Execute</code> constructs; uses only safe data coercion and explicit dictionary creation.<br>- Audit sheets contain <code>Application.UserName</code> and message snippets — treat workbook access control accordingly. Consider marking audit/test sheets as very hidden (already done) and clear them in CI between runs.<br>- Captured judgments are intentionally non-PII-heavy; avoid adding full customer names, addresses, or raw contract blobs into audit messages. If required, add redaction logic. </td></tr><tr><td data-label="Technical breakdown (modIFRS15)"> <strong>Final summary (one paragraph)</strong><br><code>modIFRS15</code> is a compact, defensive, and deterministic VBA implementation of the IFRS 15 contract model: it normalises inputs, evaluates variable consideration with deterministic rules, allocates transaction price with reproducible rounding & residual handling, produces recognition schedules and journal rows, and provides disclosure extraction plus an embedded test harness. It favors auditability (judgments, local audit sheet), backward compatibility (preserve pre-existing allocations), and resilience to missing host functions (best-effort <code>GetConfig*</code>, <code>SafeLog</code>/<code>SafeHandleError</code>). Key maintenance risks are changes to rounding policy, residual absorption rules, and the variable-consideration interpretation — each must be accompanied by regression tests and audit traceability. </td></tr></tbody></table></div><div class="row-count">Rows: 26</div></div><div class="table-caption" id="Table5" data-table="Docu_0159_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical breakdown (modIFRS16.bas)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical breakdown (modIFRS16.bas)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>Overview:</strong> This table documents a world-class, per-function technical breakdown of the <code>modIFRS16</code> VBA module you provided. Each entry records: purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security/robustness considerations, recommended tests, and maintainer notes. Use as authoritative inline documentation for reviewers, auditors and QA. This is exhaustive and precise. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16_InitialMeasurement(payments, discountRate, commencementDate, Optional initialDirectCosts=0, Optional leaseIncentives=0, Optional restorationCosts=0, Optional asOfDate)</strong> — <em>initial lease liability and ROU asset builder</em><br><strong>Purpose:</strong> Compute present value of lease payments (liability) and ROU asset (liability ± initial costs/incentives) with deterministic daycount, rounding and structured logging/correlation.<br><strong>Signature:</strong> <code>-&gt; Variant (Scripting.Dictionary on success, Dictionary of issues on validation failure, CVErr on runtime error)</code><br><strong>Behavior:</strong> Extracts/creates correlation id; validates key inputs (commencementDate, discountRate); normalizes <code>payments</code> via <code>NormalizePaymentsForRead</code>; early returns validation issues as dictionary (and logs via <code>SafeHandleError</code>); computes PV using <code>ComputePVofPayments</code> with <code>asOfDate</code> defaulting to commencementDate; sums ROU = liability + initialDirectCosts + restorationCosts - leaseIncentives; applies <code>ApplySafeRound</code> with <code>GetRoundingPrecision</code> for output values; populates an output dictionary with inputs, outputs, corr id; logs via <code>SafeLogEx</code> and returns dictionary.<br><strong>Complexity:</strong> O(n) where n = payment count (ComputePV loop). Overhead for NormalizePayments depends on input shape.<br><strong>Side-effects:</strong> Calls logging (<code>SafeLogEx</code>), possibly <code>SafeHandleError</code> on validation; may call external shims via <code>TryApplicationRun</code> from helpers; no sheet writes directly.<br><strong>Invariants:</strong> Returned numeric fields are rounded to configured precision; correlation id always present in returned dict; on validation failure returns structured dictionary of issues (not error/CVErr) so callers must check for object type.<br><strong>Failure modes:</strong> Invalid inputs cause issues dictionary return (expected). Unexpected runtime error goes to ErrHandler -> <code>SafeHandleError</code> and returns <code>CVErr(xlErrValue)</code>. External shim failures (modUtilities) are handled by fallbacks (NormalizePaymentsForRead / ApplySafeRound).<br><strong>Security/Robustness:</strong> Does not execute arbitrary code. Uses deterministic <code>YearFraction</code> for discounting. All external calls are shimmed via <code>TryApplicationRun</code> with safe fallbacks. Correlation id used for traceability.<br><strong>Recommended tests:</strong> 2D/1D/Collection/Dictionary payment shapes; zero discount (liability == sum of payments); negative/zero payments; asOfDate missing; rounding precision effect; correlation propagation when payments contain CorrelationId.<br><strong>Notes for maintainers:</strong> Keep <code>NormalizePaymentsForRead</code> parity if moved to modUtilities. Changing token names in returned dictionary is a breaking API change. Preserve error-return contract (dict on validation, CVErr on exceptions). </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16_GenerateSchedule(payments, initialLiability, discountRate, leaseTermPeriods, Optional periodDates, Optional rouOpening=0, Optional rouUsefulPeriods=0)</strong> — <em>periodic amortization & ROU depreciation schedule generator</em><br><strong>Purpose:</strong> Produce deterministic schedule array (legacy 10-column shape) for periods = leaseTermPeriods or payment count. Includes interest, principal, closing liability, ROU depreciation and ROU closing values.<br><strong>Signature:</strong> <code>-&gt; Variant (2D Variant array with headings row at row 0; Empty on early errors)</code><br><strong>Behavior:</strong> Extracts correlation, normalizes payments, decides <code>periods</code> (leaseTermPeriods or nPayments), preallocates <code>out(0..periods,1..10)</code> (header row at index 0), loops 1..periods computing: payment amount, date (optionally overridden by <code>periodDates</code>), deterministic year fraction (<code>YearFraction</code>) from first non-empty payment date to period date, interest = opening <em> discountRate </em> yf (or opening<em>rate if yf<=0), principal = payment - interest floored at 0, closing = opening - principal with rounding/near-zero tolerance, depreciation = rouOpen / rouUsefulPeriods (rounded), rouClose = rouOpen - depreciation floored at 0; writes rounded values to out array and advances opening/rouOpen. Logs operation and returns array.<br><strong>Complexity:</strong> O(periods) where periods is lease term or payment count. Memory O(periods).<br><strong>Side-effects:</strong> <code>SafeLogEx</code> call. Uses <code>NormalizePaymentsForRead</code> and helper SafeArrayIndex routines which may call external shims. No worksheet writes.<br><strong>Invariants:</strong> Column layout fixed; index origin uses 1..periods with header at 0 to preserve legacy signature. <code>GetRoundingPrecision()</code> governs rounding. <code>rouUsefulPeriods</code> defaulting to periods assures depreciation is defined.<br><strong>Failure modes:</strong> Missing payments + leaseTermPeriods <=0 returns Empty. Invalid dates cause <code>YearFraction</code> to yield 0 so interest computed as opening</em>rate (fallback). Large negative payments/principal will be floored to 0. Caller must expect Empty on ErrHandler (logs error).<br><strong>Tests:</strong> Compare schedule counts vs input periods; validate zero discount (interest=0); negative principal protection (principal >= 0); depreciation sum equals rouOpening (with rounding drift check); behavior when <code>periodDates</code> provided vs using payment dates.<br><strong>Notes:</strong> Keep header row at index 0 for compatibility with consumers; if migrating to object model, maintain a converter for legacy consumers. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16_RecalculateLiabilityOnModification(payments, oldLiability, newDiscountRate, Optional asOfDate)</strong> — <em>revaluation on modification / change in discount rate</em><br><strong>Purpose:</strong> Compute PV with newDiscountRate as of <code>asOfDate</code> and return old/new liability and delta, rounded and correlated.<br><strong>Signature:</strong> <code>-&gt; Variant (Scripting.Dictionary or CVErr on exception)</code><br><strong>Behavior:</strong> Normalize payments, compute new PV via <code>ComputePVofPayments</code> using <code>asOfDate</code> (defaults to Date), compute delta = newPV - oldLiability, build dictionary with OldLiability, NewLiability, Delta (rounded), CorrelationId, log via <code>SafeLogEx</code>, return dictionary.<br><strong>Complexity:</strong> O(n) for PV calculation.<br><strong>Side-effects:</strong> <code>SafeLogEx</code> and potential external shim calls.<br><strong>Invariants:</strong> Values rounded to configured precision; CorrelationId present.<br><strong>Failure modes:</strong> Invalid payments produce newPV=0 via ComputePV fallback; unexpected runtime error returns CVErr(xlErrValue) after logging.<br><strong>Tests:</strong> Change discount rates (higher -> liability lower), negative oldLiability input handling, rounding deltas, correlation propagation. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16_GenerateJournalEntries(schedule, liabilityAccount, rouAccount, interestAccount, depreciationAccount)</strong> — <em>journal entry row builder (periodic entries)</em><br><strong>Purpose:</strong> From schedule array produce journal rows (Date, DebitAccount, DebitAmt, CreditAccount, CreditAmt, Memo) for interest accrual, principal repayment and ROU depreciation. Keeps conservative row estimate and trims unused rows.<br><strong>Signature:</strong> <code>-&gt; Variant (2D Variant array rows 1..m, 1..6) or Empty</code><br><strong>Behavior:</strong> Validates schedule, preallocates <code>temp</code> rows up to <code>n * 3</code>, iterates schedule rows, for each period creates up to 3 journal lines when abs(amount) > tiny threshold (based on rounding precision + 4 decimals); uses <code>ApplySafeRound</code> for amounts, constructs memo containing period number, increments row index; after loop <code>ReDim Preserve</code> to actual row count, returns array; logs row count.<br><strong>Complexity:</strong> O(n) where n = periods. Memory linear in output rows.<br><strong>Side-effects:</strong> <code>SafeLogEx</code> call.<br><strong>Invariants:</strong> Each journal row is balanced (debit amount == credit amount) per line; amounts rounded to rounding precision; memos formatted consistently.<br><strong>Failure modes:</strong> If no rows generated returns Empty. Invalid schedule (non-array) returns Empty. Unexpected errors logged and function returns Empty.<br><strong>Tests:</strong> Schedule with zero interest/depreciation -> Empty; rounding small amounts to zero; balanced rows check; correct account mapping strings used. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16_GenerateDisclosure(schedule)</strong> — <em>summary disclosure dataset builder</em><br><strong>Purpose:</strong> Produce disclosure dictionary with total interest expense, total depreciation, period count and maturity analysis (array of closing liabilities), and correlation id.<br><strong>Signature:</strong> <code>-&gt; Variant (Scripting.Dictionary) or Nothing on fatal error</code><br><strong>Behavior:</strong> Sums schedule columns 5 (interest) and 9 (depreciation) across rows, applies <code>ApplySafeRound</code> with rounding precision, constructs <code>MaturityAnalysis</code> via <code>BuildMaturityAnalysis</code>, sets <code>PeriodCount</code>, <code>CorrelationId</code>, logs and returns dict. If schedule empty returns dict with "Message" and correlation id.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> Logging (<code>SafeLogEx</code>).<br><strong>Invariants:</strong> Totals and counts deterministic given schedule; <code>MaturityAnalysis</code> preserves legacy shape (headers + rows).<br><strong>Failure modes:</strong> Invalid schedule yields Nothing and logs an error. Partial numeric errors fallback via <code>NZDouble</code>.<br><strong>Tests:</strong> Totals equal sum of schedule values; period count correct; maturity analysis shape validated. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16_CalculateIBR(Optional currency="USD", Optional jurisdiction="default")</strong> — <em>simple fallback IBR calculator / stub</em><br><strong>Purpose:</strong> Provide an internal default implied borrowing rate (IBR) per currency/jurisdiction for cases where external IBR service is not available.<br><strong>Signature:</strong> <code>-&gt; Double</code><br><strong>Behavior:</strong> Generates correlation id, picks base 0.05; returns 0.05 for USD, 0.03 for EUR, base+0.01 for others; logs via <code>SafeLogEx</code> and returns. On error returns 0.05 in ErrHandler.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Logging.<br><strong>Invariants:</strong> Deterministic mapping; used as conservative fallback, not authoritative. <br><strong>Failure modes:</strong> Should never throw; ErrHandler returns default 0.05.<br><strong>Tests:</strong> Currency strings (case-insensitive) map to expected outputs. Consider replacing with external IBR provider shim when available. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16_ValidateLeaseInput(payments, commencementDate, discountRate)</strong> — <em>input validation helper with structured issues reporting</em><br><strong>Purpose:</strong> Validate key input items and return dictionary of issues; also logs aggregated message via <code>SafeHandleError</code> when issues exist.<br><strong>Signature:</strong> <code>-&gt; Variant (Scripting.Dictionary of issues)</code><br><strong>Behavior:</strong> Validates commencementDate and discountRate, normalizes payments and checks count; builds issues dictionary with error codes and messages; if issues exist, concatenate messages and call <code>SafeHandleError</code> with code 5102 and correlation from payments; returns issues object.<br><strong>Complexity:</strong> O(n) for NormalizePayments if needed.<br><strong>Side-effects:</strong> Calls <code>SafeHandleError</code> for issues (structured logging) but still returns issues dict so caller can act.<br><strong>Invariants:</strong> Always returns a dictionary (possibly empty) when no fatal exception occurs. <br><strong>Failure modes:</strong> Exceptions -> ErrHandler that logs and returns Nothing. <br><strong>Tests:</strong> Missing discountRate/date; empty payments; ensure summarized message contains all issue keys. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16_BatchComputeLeases(leases)</strong> — <em>batch wrapper calling InitialMeasurement across items with cap</em><br><strong>Purpose:</strong> Iterate a collection/array of lease items and run <code>IFRS16_InitialMeasurement</code> for each, returning a Dictionary of results keyed <code>Lease_i</code>. Protects against excessive batch sizes and preserves correlation propagation.<br><strong>Signature:</strong> <code>-&gt; Variant (Scripting.Dictionary of results) or Nothing on fatal error</code><br><strong>Behavior:</strong> Generates correlation, computes safe LBound/UBound, enforces <code>MAX_BATCH_SIZE</code> guard (logs and returns empty results if exceeded), loops leases using <code>On Error Resume Next</code> per item to isolate item errors, extracts fields (Payments, DiscountRate, CommencementDate, InitialDirectCosts, AsOfDate) via <code>GetDictOrField</code> and <code>NzDateFromVariant</code>, calls <code>IFRS16_InitialMeasurement</code> and stores results under "Lease_i". Logs summary via <code>SafeLogEx</code>.<br><strong>Complexity:</strong> O(m * n) where m = number of leases and n = payments per lease (since InitialMeasurement calls PV).<br><strong>Side-effects:</strong> Logging; calls to other public methods and shims.<br><strong>Invariants:</strong> Batch size always checked; results dictionary returned even if some items failed; each item isolation prevents entire batch failure.<br><strong>Failure modes:</strong> Extremely large arrays handled by guard; item-level exceptions do not break entire batch. ErrHandler logs and returns Nothing on top-level error.<br><strong>Tests:</strong> Batch of mixed valid/invalid items; exactly MAX_BATCH_SIZE; empty batch; ensure result keys match expected pattern. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>IFRS16SelfTest()</strong> — <em>self-test harness and reporter</em><br><strong>Purpose:</strong> Execute a suite of deterministic fixtures to validate key behaviours (input shapes, zero discount, leap year, negative-principal protection, schedule generation, collection/dictionary inputs). Persist results to <code>_IFRS_TestResults</code> sheet and attempt to call <code>modTests</code> shims for recording and running all tests.<br><strong>Signature:</strong> <code>-&gt; Boolean (overallOk)</code><br><strong>Behavior:</strong> Creates correlation; prepares multiple fixtures (2D arrays, 1D arrays of arrays, collection, dictionary, leap year, negative principal) and calls <code>IFRS16_InitialMeasurement</code>, <code>IFRS16_GenerateSchedule</code> as appropriate; collects boolean pass/fail per fixture into a Dictionary <code>results</code>; writes results to sheet via <code>WriteSelfTestResultsToSheet</code>; calls <code>TryApplicationRun(&quot;modTests.RecordSelfTestResult&quot;,...)</code> and attempts <code>Application.Run &quot;modTests.RunAllSelfTests&quot;</code>; logs and returns overallOk boolean; on error logs and returns False.<br><strong>Complexity:</strong> O(total fixture operations) — small and deterministic.<br><strong>Side-effects:</strong> Writes to hidden sheet <code>_IFRS_TestResults</code>, calls external <code>modTests</code> if present, logs events, and may create worksheets if missing.<br><strong>Invariants:</strong> Test sheet format stable (Timestamp, CorrelationId, TestKey, Result); function idempotent (multiple calls append rows).<br><strong>Failure modes:</strong> Missing worksheet creation can fail under workbook protection — code attempts to add sheet and set VeryHidden; if workbook prevents sheet creation, tests still return overallOk=False and SafeHandleError records error.<br><strong>Tests:</strong> The function is itself a test; additional unit tests should call it and assert True in a healthy environment. Keep fixtures updated when algorithm changes. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>TryApplicationRun(procName, ByRef outVal, ParamArray args())</strong> — <em>shim-first Application.Run invoker with defensive arg dispatch</em><br><strong>Purpose:</strong> Centralize safe invocation of <code>Application.Run</code> to call external module procs (modUtilities, modAudit, modError, etc.) with up to 10 args, and indicate success/failure without raising errors to caller.<br><strong>Signature:</strong> <code>-&gt; Boolean (True on external success, False otherwise)</code>, side-effect sets <code>outVal</code> when success.<br><strong>Behavior:</strong> Counts args defensively, selects <code>Application.Run</code> overload case for 0..9 args (limits to first 10), catches <code>Err</code>, clears and returns False; untrusted/missing procs handled gracefully without exceptions bubbling up.<br><strong>Complexity:</strong> O(1) per call.<br><strong>Side-effects:</strong> May call external module code which can have arbitrary side-effects; TryApplicationRun itself swallows errors and returns False.<br><strong>Invariants:</strong> Never raises an uncaught error to callers; <code>outVal</code> only set on success.<br><strong>Failure modes:</strong> If external proc raises error, this function returns False; callers must implement fallbacks. <br><strong>Tests:</strong> Stub <code>modUtilities.*</code> functions and verify TryApplicationRun returns True and outVal matches; ensure too many args still calls first 10 args safely. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>ComputePVofPayments(payments, discountRate, asOfDate)</strong> — <em>present value calculator over normalized schedule</em><br><strong>Purpose:</strong> Deterministically compute PV of a set of payments using <code>YearFraction</code> and pow discounting; zero/negative discountRate treated as zero discount (sum of payments). Accepts both normalized and raw payment shapes (calls NormalizePaymentsForRead if needed).<br><strong>Signature:</strong> <code>-&gt; Double</code><br><strong>Behavior:</strong> Normalizes payments (if not already), loops payments 1..n, gets payment date/amount via helper accessors, computes year fraction <code>yf = YearFraction(asOfDate, pd)</code>, if discountRate <= 0 then pv += amt else pv += amt / ((1 + discountRate)^yf). Returns pv. On exception returns 0 and calls <code>SafeHandleError</code>.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> May call <code>SafeHandleError</code> on exception; may call external Normalize helper via TryApplicationRun; deterministic numeric math and exponentiation uses <code>Double</code> precision.<br><strong>Invariants:</strong> If discountRate==0 PV == sum(amounts) within floating error. YearFraction used for fractional exponent power; negative year fractions are normalized to zero by YearFraction.<br><strong>Failure modes:</strong> If payment dates are invalid YearFraction returns 0 causing interest formula to use opening*rate fallback; enormous yf values may create underflow/overflow but unlikely for realistic dates. <br><strong>Tests:</strong> Compare against hand-calculated PV for given dates & rates, zero discount case, irregular date inputs. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>NormalizePaymentsForRead(payments)</strong> — <em>robust normalization shim-first</em><br><strong>Purpose:</strong> Convert many supported input shapes into canonical 1-based 2-column array <code>(date, amount)</code> used internally. Prefer external <code>modUtilities.NormalizePaymentsForRead</code> shim; fallback to internal robust normalizer supporting 2D arrays, 1D arrays, Collections, Dictionaries, and objects with <code>.items</code> or count.<br><strong>Signature:</strong> <code>-&gt; Variant (2D array 1..n,1..2) or Empty</code><br><strong>Behavior:</strong> Attempts <code>TryApplicationRun(&quot;modUtilities.NormalizePaymentsForRead&quot;,...)</code>; on failure, inspects <code>payments</code> shape: returns Empty for missing/empty; for arrays checks <code>ArrayDimensions</code> and converts 2D or 1D-of-arrays into canonical <code>(date, amount)</code> using <code>SafeArrayIndex</code>, <code>NZDoubleOrZero</code> for amounts, converts non-date first values to Empty; for objects: recognizes Collection (iterates), Dictionary (uses <code>.items</code>), or indexable objects with <code>.count</code>. Falls back to Empty at end. Errors logged through SafeHandleError on exception.<br><strong>Complexity:</strong> O(n * cost of SafeArrayIndex).<br><strong>Side-effects:</strong> <code>SafeLogEx</code> when external shim used; <code>SafeHandleError</code> on internal exception.<br><strong>Invariants:</strong> Output always has numeric amounts (0 when not provided) and either valid date or Empty for date column; 1-based consecutive rows. <br><strong>Failure modes:</strong> Unrecognized object types result in Empty; callers must handle Empty. <br><strong>Tests:</strong> Input shapes: 2D variant array (rxc), 1D array of 1D arrays, Collection, Dictionary with "Items" array, simple numeric array; ensure amounts are cast to Double and dates preserved. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>GetPaymentCountFromNormalized(normPayments)</strong> — <em>safe accessor for row count</em><br><strong>Purpose:</strong> Return number of payments in normalized array, preferring external shim if available.<br><strong>Signature:</strong> <code>-&gt; Long</code><br><strong>Behavior:</strong> Try <code>modUtilities.GetPaymentCountFromNormalized</code> via TryApplicationRun; else if array uses <code>UBound-LBound+1</code>; else 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Non-negative integer. <br><strong>Tests:</strong> Arrays of various LBound indices, Empty input. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>GetPaymentAmountFromNormalized(normPayments, idx)</strong> — <em>safe amount accessor</em><br><strong>Purpose:</strong> Return numeric amount at 1-based idx; prefer external shim; fallback uses <code>NZDoubleOrZero</code> and safe indexing. Returns 0 if index out of bounds or malformed.<br><strong>Signature:</strong> <code>-&gt; Double</code><br><strong>Behavior:</strong> Try external shim; else compute base = LBound(normPayments,1) and map idx to base+idx-1; read second column or return 0; swallow errors.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Out-of-range idx, negative idx, non-array input. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>GetPaymentDateFromNormalized(normPayments, idx)</strong> — <em>safe date accessor</em><br><strong>Purpose:</strong> Return date value (Variant) for payment index or Empty when not present. Prefers external shim.<br><strong>Signature:</strong> <code>-&gt; Variant</code><br><strong>Behavior:</strong> As above but returns Empty when not found; does not convert invalid date to default. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Non-date stored values should be returned as stored (caller uses IsDate). </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>YearFraction(d0, d1)</strong> — <em>deterministic daycount calculator (ACT/365 default, ACT/360, 30/360)</em><br><strong>Purpose:</strong> Provide deterministic fractional year between two dates using configured daycount convention, used for deterministic discounting and interest accrual.<br><strong>Signature:</strong> <code>-&gt; Double</code><br><strong>Behavior:</strong> Returns 0 when d1 not a date. Reads <code>GetDayCountConvention()</code> (shim to modConfig or default). When <code>ACT/360</code> returns daysDiff / 360; <code>30/360</code> uses convention mapping day31→30 for both endpoints and returns DIF/360; default <code>ACT/365</code> returns daysDiff / 365 (deterministic across leap years). Negative fractions normalized to 0. Errors yield 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Non-negative output, deterministic. <br><strong>Failure modes:</strong> If dates invalid returns 0, which changes interest calculation path in schedule (fall back interest = opening * rate). <br><strong>Tests:</strong> Known date intervals for each convention including leap-year spans and month-end 31->30 handling. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>ApplySafeRound(v, prec)</strong> — <em>round with modUtilities shim-first fallback to VBA.Round</em><br><strong>Purpose:</strong> Centralize rounding to <code>GetRoundingPrecision()</code> but allow external override (modUtilities.Round) for enterprise rounding rules (banker's rounding vs away-from-zero).<br><strong>Signature:</strong> <code>-&gt; Double</code><br><strong>Behavior:</strong> Calls <code>modUtilities.Round(v,prec)</code> via TryApplicationRun if present and returns numeric; else uses <code>VBA.Round(v,prec)</code> if prec>=0; otherwise returns v unmodified. Exceptions swallowed and return v.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call external code. <br><strong>Invariants:</strong> Consistent rounding used across module; changing default rounding strategy requires careful review. <br><strong>Tests:</strong> Compare results vs expected rounding mode; verify fallback occurs when shim missing. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>NZDoubleOrZero(v) / NZDouble(v, Optional def) / NzVariant(v, Optional def)</strong> — <em>defensive numeric/variant normalizers</em><br><strong>Purpose:</strong> Small utility functions to convert various Variant states (Error, Null, Empty, non-numeric) to numeric defaults or return default variant.<br><strong>Signature:</strong> <code>-&gt; Double</code> or <code>-&gt; Variant</code><br><strong>Behavior:</strong> <code>NZDoubleOrZero</code> converts to 0 for error/null/empty/non-numeric; <code>NZDouble</code> returns def when not numeric; <code>NzVariant</code> returns def when Missing/Null/Empty. All swallow errors.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Safe numeric conversion across inputs. <br><strong>Tests:</strong> Inputs Error(), Null, Empty, numeric strings, objects. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>BuildMaturityAnalysis(schedule)</strong> — <em>extract closing liability maturity table</em><br><strong>Purpose:</strong> Build minimal 2-column (period/date/closing liability) array suitable for disclosures and downstream consumption.<br><strong>Signature:</strong> <code>-&gt; Variant (2D array 0..n,1..3)</code><br><strong>Behavior:</strong> Validates schedule, preallocates out with header row at 0, copies period, date, closing liability (col 7) from schedule rows 1..n. Returns Empty on error.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Ensure header row present and counts match UBound(schedule,1). </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>LBoundArraySafe(arr) / UBoundArraySafe(arr)</strong> — <em>safe array bounds helpers</em><br><strong>Purpose:</strong> Avoid runtime errors when calling LBound/UBound on non-arrays; provide consistent base indexes for normalized arrays.<br><strong>Signature:</strong> <code>-&gt; Long</code><br><strong>Behavior:</strong> Return LBound(arr,1) or 1 for non-arrays; UBound returns 0 for non-arrays. Swallow errors. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Scalars vs arrays with different lower bounds. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>NzDateFromVariant(v, key, def)</strong> — <em>safe date extractor from dict/object</em><br><strong>Purpose:</strong> If v is object and has key, return date coerced; else def.<br><strong>Signature:</strong> <code>-&gt; Variant (Date or def)</code><br><strong>Behavior:</strong> Uses <code>IsObject</code> and <code>Exists</code> then <code>IsDate</code> check. Swallows errors. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Object with string date, non-date value, missing key. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>GetDictOrField(item, key)</strong> — <em>safe field extraction helper</em><br><strong>Purpose:</strong> Return <code>item(key)</code> if object and Exists(key), else Empty.<br><strong>Signature:</strong> <code>-&gt; Variant</code><br><strong>Behavior:</strong> Non-throwing. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Dictionary with/without key, non-object item. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>ArrayDimensions(arr)</strong> — <em>determine number of array dimensions robustly</em><br><strong>Purpose:</strong> Return 0 for non-arrays or count dims by increasing LBound checks up to 60; used by NormalizePaymentsForRead for shape detection.<br><strong>Signature:</strong> <code>-&gt; Long</code><br><strong>Behavior:</strong> Loops i=1..60 calling <code>LBound(arr,i)</code> until Err occurs; counts successful dims; returns 0 on non-array or ErrHandler. <br><strong>Complexity:</strong> O(D) where D = number of dimensions (<=60). <br><strong>Side-effects:</strong> None.<br><strong>Tests:</strong> 0D (non-array), 1D, 2D arrays, jagged arrays where supported. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>SafeArrayIndex(arr, idx1, Optional idx2=0)</strong> — <em>safe indexed accessor with shim-first</em><br><strong>Purpose:</strong> Wrap <code>modUtilities.SafeArrayIndex</code> if present; otherwise safely attempt arr(idx1) or arr(idx1,idx2) while swallowing errors and returning Empty on failure.<br><strong>Signature:</strong> <code>-&gt; Variant</code><br><strong>Behavior:</strong> If TryApplicationRun returns value, use it; otherwise attempt to index inside <code>On Error Resume Next</code> blocks and return Empty on error.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Non-contiguous LB/UB arrays, invalid indices. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>GenerateCorrelationID()</strong> — <em>lightweight correlation id generator</em><br><strong>Purpose:</strong> Produce short unique string using timestamp + random for logging/tracing when no correlation provided.<br><strong>Signature:</strong> <code>-&gt; String</code><br><strong>Behavior:</strong> Uses <code>Randomize Timer</code> seeded once, returns <code>Format(Now,&quot;yyyymmddHHMMSS&quot;) &amp; &quot;-&quot; &amp; 6-digit pseudo-random</code>. Deterministic enough for trace across logs; not cryptographically secure.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Repeated calls produce different suffixes; seeded only first invocation. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>GetRoundingPrecision() / GetDayCountConvention()</strong> — <em>config getters with modConfig shim-first</em><br><strong>Purpose:</strong> Read configuration from <code>modConfig.GetSetting(&quot;IFRS.RoundingPrecision&quot;)</code> or <code>(&quot;IFRS.DayCount&quot;)</code> with fallbacks to module defaults (<code>DEFAULT_ROUNDING_PRECISION</code>, <code>DEFAULT_DAYCOUNT</code>). Log when values read from config to <code>SafeLogEx</code>.<br><strong>Signature:</strong> <code>-&gt; Long</code> (precision) / <code>-&gt; String</code> (daycount)<br><strong>Behavior:</strong> Use TryApplicationRun to consult external config; validate returned types (numeric/string); fall back to defaults; <code>SafeLogEx</code> when reading external setting. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Present/absent settings, invalid types, ensure fallback to defaults. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>SafeLogEx(moduleName, proc, details, corr)</strong> — <em>audit/log shim-first with local fallback</em><br><strong>Purpose:</strong> Centralized logging to <code>modAudit.LogEvent</code> if present; otherwise append to local hidden audit sheet (<code>AppendLocalAudit</code>). Adds correlation id and module/proc context.<br><strong>Signature:</strong> <code>Sub</code><br><strong>Behavior:</strong> Build <code>payload=moduleName.proc | Corr=... | details</code>; TryApplicationRun("modAudit.LogEvent", ...); on False call <code>AppendLocalAudit(payload)</code>. Swallows errors.<br><strong>Complexity:</strong> O(1) plus sheet write if fallback.<br><strong>Side-effects:</strong> May create <code>_IFRS_Audit</code> worksheet (VeryHidden) and append rows. <br><strong>Invariants:</strong> Audit messages length trimmed to 2000 in append fallback. <br><strong>Tests:</strong> Simulate missing modAudit -> confirm <code>_IFRS_Audit</code> sheet created and message written. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>SafeHandleError(procName, errNumber, errDesc, Optional corr)</strong> — <em>centralized error routing shim-first</em><br><strong>Purpose:</strong> Route errors to <code>modError.HandleError</code> if present; otherwise append minimal audit row containing error metadata. Ensures correlation id included and does not rethrow.<br><strong>Signature:</strong> <code>Sub</code><br><strong>Behavior:</strong> If corr empty generate new; TryApplicationRun("modError.HandleError", ...); else <code>AppendLocalAudit(&quot;HandleError unavailable: &quot; &amp; ...)</code>. Swallows errors.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Local audit writes if modError missing. <br><strong>Tests:</strong> Simulated modError missing/available. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>AppendLocalAudit(message)</strong> — <em>local fallback audit writer</em><br><strong>Purpose:</strong> Append audit lines to workbook hidden sheet <code>_IFRS_Audit</code> with Timestamp, User, Message. Creates sheet if missing (VeryHidden) and header row. Trims message to safe length.<br><strong>Signature:</strong> <code>Sub</code><br><strong>Behavior:</strong> Attempts to find sheet, adds if needed (may fail under workbook protection), writes timestamp, Application.UserName and message truncated to 2000 chars. Uses last used row calculation with <code>.End(xlUp)</code>. Swallows errors.<br><strong>Complexity:</strong> O(1) IO to workbook. <br><strong>Failure modes:</strong> If workbook protection prevents adding or writing to sheet the AppendLocalAudit will silently fail — but SafeHandleError guarantees attempt is made. <br><strong>Tests:</strong> Ensure sheet creation, row append, VeryHidden property set. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>ExtractCorrelationFromVariant(v)</strong> — <em>extract corr id when embedded in object/collection</em><br><strong>Purpose:</strong> Read <code>CorrelationId</code> property from objects/dictionaries or from first item of arrays/collections; return empty string if not found. Used widely to propagate correlation through calls.<br><strong>Signature:</strong> <code>-&gt; String</code><br><strong>Behavior:</strong> If IsObject and <code>Exists(&quot;CorrelationId&quot;)</code> returns its string; else attempts to access v(1) and check for <code>CorrelationId</code>. Swallows errors and returns "". <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Dict/object with CorrelationId, collection of items where first item has CorrelationId, plain arrays without. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>GetFirstNonEmptyDateOrDefault(v, def)</strong> — <em>helper returning first valid date else default</em><br><strong>Purpose:</strong> Utility to return a Date for use as reference date in YearFraction and schedule computations.<br><strong>Signature:</strong> <code>-&gt; Date</code><br><strong>Behavior:</strong> If IsDate(v) return CDate(v) else return def. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Non-date inputs. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>WriteSelfTestResultsToSheet(results, corr)</strong> — <em>persist self-test dictionary to <code>_IFRS_TestResults</code> sheet</em><br><strong>Purpose:</strong> Append rows for each test result into a hidden test results sheet with timestamp and correlation id. Creates sheet if missing and sets VeryHidden.<br><strong>Signature:</strong> <code>Sub</code><br><strong>Behavior:</strong> Finds/creates <code>_IFRS_TestResults</code>, ensures header row, then iterates results.keys and writes Timestamp, CorrelationId, TestKey, Result per row (skipping keys "CorrelationId"/"Timestamp"). Uses <code>NzVariant</code> for timestamp fallback. Swallows errors.<br><strong>Complexity:</strong> O(#tests).<br><strong>Side-effects:</strong> Adds sheet and writes rows; important for auditability. <br><strong>Failure modes:</strong> Protected workbook may prevent sheet creation/writes; code swallows errors but tests will not be persisted. <br><strong>Tests:</strong> Run IFRS16SelfTest and inspect <code>_IFRS_TestResults</code> sheet rows. </td></tr><tr><td data-label="Technical breakdown (modIFRS16.bas)"> <strong>Notes on design, security, and maintainability (module-level)</strong><br>- <strong>Shim-first pattern:</strong> All external dependencies (<code>modUtilities</code>, <code>modAudit</code>, <code>modError</code>, <code>modConfig</code>, <code>modTests</code>) are invoked via <code>TryApplicationRun</code> with robust internal fallbacks — this ensures the module is resilient in environments where helper modules are missing or different. Maintainers: do not remove fallbacks without a migration plan.<br>- <strong>Determinism:</strong> Deterministic daycount (<code>YearFraction</code>) and explicit rounding via <code>GetRoundingPrecision</code> / <code>ApplySafeRound</code> keep numeric results repeatable across environments. Changing <code>GetDayCountConvention</code> or rounding strategy must be coordinated with governance/testing because it affects amortization flows and disclosures.<br>- <strong>Correlation & logging:</strong> CorrelationId propagation is consistent (ExtractCorrelationFromVariant / GenerateCorrelationID) and used in all logs. Preserve this contract; logging sinks use <code>SafeLogEx</code> which tries <code>modAudit</code> first and falls back to workbook sheet. Avoid changing correlation key name.<br>- <strong>Error handling policy:</strong> Functions return structured dictionaries for validation issues and CVErr or Empty for runtime failures — callers must handle both patterns. Do not convert validation-issue dictionaries to exceptions: that is deliberate for programmatic consumers.<br>- <strong>I/O & side effects:</strong> Module writes only to hidden audit/test sheets and not to user-facing sheets by default; self tests and audit append create very hidden sheets. Be cautious running in locked workbooks—sheet write attempts will silently fail. Consider adding explicit error return when persistence fails if you need stronger guarantees.<br>- <strong>Testing:</strong> Maintain <code>IFRS16SelfTest</code> as CI smoke tests. Add unit fixtures for daycount conversions, rounding migration tests, and <code>NormalizePaymentsForRead</code> parity tests if moving normalizer to <code>modUtilities</code>.<br>- <strong>Performance:</strong> <code>ComputePVofPayments</code> and schedule generation are linear in payment count; <code>IFRS16_BatchComputeLeases</code> has MAX_BATCH_SIZE guard. For extremely large schedules consider streaming / chunked processing or exposing <code>maxParallel</code>/throttling in batch pipelines.<br>- <strong>Backward compatibility:</strong> Public API names and signatures are preserved intentionally. Any change to return types (e.g., returning custom classes instead of dictionaries/arrays) is a major breaking change—document and version accordingly.<br>- <strong>Recommended small improvements:</strong> (1) Expose <code>maxParallelFetches</code> style parameter if adding external I/O; (2) Add a configurable <code>LOGGING_LEVEL</code> setting via <code>modConfig</code> to avoid writing test/audit data in production runs by default; (3) When spawning sheets for audit/tests, consider toggling VeryHidden only when running in trusted automation contexts.<br><strong>Final summary:</strong> <code>modIFRS16</code> is a defensive, shim-first VBA module that implements IFRS 16 measurement, schedule generation, journaling and disclosures with deterministic daycounting and centralized rounding. It emphasizes robustness (fallbacks for missing modules), traceability (correlation IDs and structured logging), and auditability (self tests and persisted results). Maintain API surface stability, preserve round/days rules, and keep the shim-first fallbacks when evolving the code. </td></tr></tbody></table></div><div class="row-count">Rows: 34</div></div><div class="table-caption" id="Table6" data-table="Docu_0159_06" style="margin-top:2mm;margin-left:3mm;"><strong>Table 6</strong></div>
<div class="table-wrapper" data-table-id="table-6"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical breakdown (modRibbonCallbacks)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical breakdown (modRibbonCallbacks)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Overview:</strong> This table provides a world-class, per-function technical breakdown of <code>modRibbonCallbacks</code> (VBA). Each entry documents: purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security considerations, recommended tests, and maintainer notes. Use this as authoritative inline documentation for reviewers, auditors, and QA. This is exhaustive and precise. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnLoad(ribbon As IRibbonUI)</strong> — <em>entrypoint: ribbon initialization & reconciliation</em><br><strong>Purpose:</strong> Initialize module-level state (registries, caches), ensure support sheets exist, reconcile job state from prior runs, and record audit that ribbon loaded.<br><strong>Signature:</strong> <code>Public Sub Ribbon_OnLoad(ribbon As IRibbonUI)</code> — no return.<br><strong>Behavior:</strong> Saves incoming <code>IRibbonUI</code> to <code>g_ribbon</code>, lazily creates <code>g_handlerRegistry</code>, <code>g_imageProviders</code>, <code>g_lastKnownState</code> (Scripting.Dictionary), calls <code>EnsureJobsSheetExists</code>, <code>EnsureAuditSheetExists</code>, <code>EnsureTestSheetExists</code> (create or migrate support sheets), calls <code>Ribbon_ReconcileJobsOnOpen</code>, and writes a startup audit. Uses <code>On Error GoTo ErrHandler</code> to route exceptions to <code>Ribbon_HandleError</code> without raising to UI.<br><strong>Complexity:</strong> O(1) for registry init; O(#support sheets rows) if migration triggers.<br><strong>Side-effects:</strong> Creates/updates hidden support sheets; writes audit entries; may modify job sheet schema.<br><strong>Invariants:</strong> Idempotent: repeated calls preserve or re-create registries safely; support sheets exist after return (unless errors).<br><strong>Failure modes:</strong> Errors during sheet creation or reconciliation; handled by <code>Ribbon_HandleError</code> and local audit fallback.<br><strong>Security/XSS:</strong> None (VBA context).<br><strong>Tests:</strong> Call with mock <code>IRibbonUI</code>; validate registries initialized, sheets exist and are <code>xlSheetVeryHidden</code>, <code>Ribbon_ReconcileJobsOnOpen</code> was invoked (jobs rows updated/re-scheduled).<br><strong>Notes:</strong> Keep signature stable; avoid expensive work on main thread—defer heavy work to bootstrap if needed. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnButtonClick(control As IRibbonControl)</strong> — <em>public wrapper for button clicks</em><br><strong>Purpose:</strong> Preserve callback signature required by Office customUI; dispatch safely to registered handler.<br><strong>Signature:</strong> <code>Public Sub Ribbon_OnButtonClick(control As IRibbonControl)</code>.<br><strong>Behavior:</strong> Calls <code>SafeCallbackWrapperControl(control, &quot;button&quot;)</code> to convert control->id and dispatch. Minimal logic, relies on registry for behavior.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Triggers audit via called functions; may call external handler via <code>Application.Run</code> inside <code>SafeApplicationRun</code>.<br><strong>Invariants:</strong> Control id must be resolvable to a registered handler for action.<br><strong>Failure modes:</strong> Missing registry entry → silent no-op; handler runtime error swallowed and logged by <code>SafeApplicationRun</code>.<br><strong>Tests:</strong> Attach a test handler via <code>Ribbon_RegisterHandler</code>, simulate <code>IRibbonControl</code> with id, and assert <code>SafeApplicationRun</code> invoked (via audit row).<br><strong>Notes:</strong> Keep mapping exact to customUI element ids. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnToggle(control As IRibbonControl, pressed As Boolean)</strong> — <em>toggle control wrapper</em><br><strong>Purpose:</strong> Receive toggle state from Ribbon and dispatch to registered handler with pressed arg.<br><strong>Signature:</strong> <code>Public Sub Ribbon_OnToggle(control As IRibbonControl, pressed As Boolean)</code>.<br><strong>Behavior:</strong> Calls <code>SafeCallbackWrapperControl(control, &quot;toggle&quot;, pressed)</code>. Updates will be handled by registered handler or cached state via <code>Ribbon_UpdateCachedState</code> invoked by handlers.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Audit events through <code>SafeCallbackWrapper</code> and handlers.<br><strong>Failure modes:</strong> Same as button wrapper; errors captured and audited.<br><strong>Tests:</strong> Register toggle handler and assert handler receives <code>pressed</code> flag. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnGalleryChange(control As IRibbonControl, selectedId As Variant)</strong> — <em>gallery change wrapper</em><br><strong>Purpose:</strong> Dispatch gallery selection changes to registered handler preserving signature expected by customUI.<br><strong>Signature:</strong> <code>Public Sub Ribbon_OnGalleryChange(control As IRibbonControl, selectedId As Variant)</code>.<br><strong>Behavior:</strong> Calls <code>SafeCallbackWrapperControl(control, &quot;gallery&quot;, selectedId)</code>.<br><strong>Complexity / Side-effects / Failure modes / Tests / Notes:</strong> same pattern as other wrappers. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetEnabled(control As IRibbonControl) As Boolean</strong> — <em>ribbon <code>getEnabled</code> provider using cache</em><br><strong>Purpose:</strong> Provide synchronous enabled/disabled state for ribbon controls based on <code>g_lastKnownState</code> cache, with default true.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetEnabled(control As IRibbonControl) As Boolean</code>.<br><strong>Behavior:</strong> Calls <code>GetCachedStateFlag(GetControlId(control), &quot;enabled&quot;, True)</code> and returns boolean. Designed to be fast and idempotent.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None (reads only).<br><strong>Invariants:</strong> Returns default <code>True</code> when no cached state exists.<br><strong>Failure modes:</strong> If <code>control</code> is malformed <code>GetControlId</code> returns "unknown" and cache consulted; safe. Test by setting cache and asserting return. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetVisible(control As IRibbonControl) As Boolean</strong> — <em>visibility provider</em><br><strong>Purpose:</strong> Provide <code>visible</code> flag for ribbon controls, default True.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetVisible(control As IRibbonControl) As Boolean</code>.<br><strong>Behavior / Complexity / Side-effects / Tests:</strong> same pattern as <code>GetEnabled</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetLabel(control As IRibbonControl) As String</strong> — <em>label provider from cache with fallback</em><br><strong>Purpose:</strong> Return text label for control, using cached text or falling back to control.id string.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetLabel(control As IRibbonControl) As String</code>.<br><strong>Behavior:</strong> Returns <code>GetCachedStateText(GetControlId(control), &quot;label&quot;, CStr(control.id))</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. Test by populating <code>g_lastKnownState(cid)(&quot;label&quot;)</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetPressed(control As IRibbonControl) As Boolean</strong> — <em>pressed state provider</em><br><strong>Purpose:</strong> Provide pressed state for toggle controls (default False).<br><strong>Signature:</strong> <code>Public Function Ribbon_GetPressed(control As IRibbonControl) As Boolean</code>.<br><strong>Behavior/Complexity/Side-effects/Tests:</strong> same pattern as <code>GetEnabled</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetImage(control As IRibbonControl) As IPictureDisp</strong> — <em>image provider wrapper with safe call</em><br><strong>Purpose:</strong> Return <code>IPictureDisp</code> for control by calling registered image provider procedure via <code>SafeApplicationRunPicture</code> and catch errors.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetImage(control As IRibbonControl) As IPictureDisp</code>.<br><strong>Behavior:</strong> Retrieves control id; if <code>g_imageProviders</code> has entry, calls provider proc by name with <code>SafeApplicationRunPicture(procName, cid)</code> which wraps <code>Application.Run</code>. Any errors are caught and <code>Ribbon_HandleError</code> invoked. Returns <code>Nothing</code> on failure.<br><strong>Complexity:</strong> O(1) plus cost of provider. <br><strong>Side-effects:</strong> May trigger external code, generate audit, and return COM Picture objects.<br><strong>Failure modes:</strong> Provider proc missing or raises error; fallbacks to <code>Nothing</code> and audit. <br><strong>Tests:</strong> Register a provider that returns a small IPictureDisp and confirm <code>Ribbon_GetImage</code> returns it; test provider throwing to ensure <code>Ribbon_HandleError</code> invoked. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_RegisterHandler(controlId As String, handlerProc As String, Optional category As String = "sync")</strong> — <em>register callback handlers</em><br><strong>Purpose:</strong> Register a handler proc by control id with category and correlation id for auditing and safe dispatch.<br><strong>Signature:</strong> <code>Public Sub Ribbon_RegisterHandler(controlId As String, handlerProc As String, Optional category As String = &quot;sync&quot;)</code>.<br><strong>Behavior:</strong> Validates inputs; creates a Dictionary <code>d</code> with keys <code>proc</code>, <code>category</code>, <code>registeredAt</code>, <code>corrId</code> (via <code>GenerateCorrelationID(controlId)</code>), stores in <code>g_handlerRegistry(controlId)</code>, and audits registration. Category lowercased and defaulted to <code>&quot;sync&quot;</code>; <code>Nz</code> helper used. Idempotent overwrite semantics: re-register overwrites previous entry.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes audit row, updates in-memory registry. Does not persist to sheet.<br><strong>Invariants:</strong> Registry entry always has <code>proc</code> and <code>corrId</code>.<br><strong>Failure modes:</strong> Invalid args are ignored; errors audited via <code>Ribbon_HandleError</code>.<br><strong>Tests:</strong> Register handler, then call <code>SafeCallbackWrapper</code> to ensure handler invoked. Validate <code>g_handlerRegistry</code> contents. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_RegisterImageProvider(controlId As String, procName As String)</strong> — <em>register image provider</em><br><strong>Purpose:</strong> Associate control id with a named procedure that returns <code>IPictureDisp</code> for use by <code>Ribbon_GetImage</code>.<br><strong>Signature:</strong> <code>Public Sub Ribbon_RegisterImageProvider(controlId As String, procName As String)</code>.<br><strong>Behavior:</strong> Stores <code>procName</code> in <code>g_imageProviders(controlId)</code> after simple validation. Audits registration. Overwrites existing provider.<br><strong>Complexity, Side-effects, Tests, Notes:</strong> trivial; ensure provider proc signature compatible with <code>Application.Run</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_RegisterLegacyAlias(oldId As String, newId As String)</strong> — <em>compatibility aliasing</em><br><strong>Purpose:</strong> Allow old control ids to map to new handler entries to preserve compatibility when control ids change.<br><strong>Signature:</strong> <code>Public Sub Ribbon_RegisterLegacyAlias(oldId As String, newId As String)</code>.<br><strong>Behavior:</strong> If <code>g_handlerRegistry.Exists(newId)</code> then set <code>g_handlerRegistry(oldId) = g_handlerRegistry(newId)</code> and audit. No deep-copy; assigns same Dictionary object reference.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates registry; alias and original share same handler object (mutating one affects both).<br><strong>Failure modes:</strong> If <code>newId</code> not found, function exits silently. Maintainers must be aware of shared-reference semantics. <br><strong>Tests:</strong> Register newId then alias oldId; change entry via <code>Ribbon_RegisterHandler(newId, ...)</code> and ensure <code>g_handlerRegistry(oldId)</code> references same object. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeCallbackWrapperControl(control As IRibbonControl, actionType As String, Optional arg1 As Variant)</strong> — <em>thin adapter resolving control id</em><br><strong>Purpose:</strong> Resolve <code>control.id</code> to string and forward to the generic <code>SafeCallbackWrapper</code> API, preserving action type and optional arg.<br><strong>Signature:</strong> <code>Private Sub SafeCallbackWrapperControl(control As IRibbonControl, actionType As String, Optional arg1 As Variant)</code>.<br><strong>Behavior:</strong> Calls <code>SafeCallbackWrapper GetControlId(control), actionType, control, arg1</code>. Minimal logic. Uses <code>GetControlId</code> to safely extract <code>id</code> with <code>On Error Resume Next</code> fallback.<br><strong>Complexity / Side-effects / Tests:</strong> trivial adapter; test with broken control object to ensure <code>GetControlId</code> returns <code>&quot;unknown&quot;</code> and wrapper exits gracefully. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeCallbackWrapper(controlId As String, actionType As String, Optional controlObj As Variant, Optional arg1 As Variant)</strong> — <em>safe dispatch to registered handlers</em><br><strong>Purpose:</strong> Locate handler metadata in <code>g_handlerRegistry</code> for <code>controlId</code>, audit start/end, and invoke handler procedure through <code>SafeApplicationRun</code> with safe error handling. Generates correlation id for each invocation.<br><strong>Signature:</strong> <code>Public Sub SafeCallbackWrapper(controlId As String, actionType As String, Optional controlObj As Variant, Optional arg1 As Variant)</code>.<br><strong>Behavior:</strong> Verifies registry; obtains handler info <code>hi</code>, extracts <code>proc</code> and builds new correlation id; audits <code>CallbackStart</code> (corrId<code>|</code>controlId<code>|</code>actionType). If <code>proc</code> empty logs <code>CallbackMissingProc</code>. Calls <code>SafeApplicationRun proc, Array(controlObj, arg1)</code> and audits <code>CallbackEnd</code>. Errors routed to <code>Ribbon_HandleError</code> via ErrHandler. Designed to swallow exceptions and never raise to host UI.<br><strong>Complexity:</strong> O(1) + cost of underlying <code>Application.Run</code> call.<br><strong>Side-effects:</strong> Calls external handlers which may mutate workbook state. Produces audit rows. Does not change registry. <br><strong>Invariants:</strong> <code>g_handlerRegistry(controlId)</code> should be present for call to proceed; <code>proc</code> expected to be a valid callable name. <br><strong>Failure modes:</strong> Missing handler → no-op with audit. Handler runtime errors swallowed and audited. Handlers that rely on return values must explicitly write to sheets or job rows because <code>SafeApplicationRun</code> returns <code>Empty</code> on error. <br><strong>Tests:</strong> Register a handler that records to a hidden sheet, invoke <code>SafeCallbackWrapper</code> and verify the sheet updated; simulate a handler raising error to ensure error logged in local audit. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ScheduleLongTask(jobId As String, delaySeconds As Double)</strong> — <em>public scheduling API (upsert semantics)</em><br><strong>Purpose:</strong> Schedule a long-running job by id (upsert), persist to jobs sheet, store OnTime proc meta, and call <code>Application.OnTime</code> safely.<br><strong>Signature:</strong> <code>Public Sub Ribbon_ScheduleLongTask(jobId As String, delaySeconds As Double)</code>.<br><strong>Behavior:</strong> Computes <code>whenAt = Now + delaySeconds</code>, calls <code>EnqueueOrUpdateJob jobId, &quot;&quot;, whenAt</code> (handler may be set later), constructs stable proc string via <code>BuildOnTimeProcString(&quot;Ribbon_ProcessJob_OnTime&quot;, jobId)</code>, calls <code>UpdateJobMeta</code> to save meta into job row, calls <code>SafeOnTimeSchedule</code> to schedule via <code>Application.OnTime</code>, and writes an audit <code>ScheduleJob</code> with timestamp. Uses error handler to capture issues.<br><strong>Complexity:</strong> O(1) plus sheet I/O. <br><strong>Side-effects:</strong> Creates/updates a row in <code>_IFRS_Jobs</code>, schedules an OnTime event. <br><strong>Invariants:</strong> Job row will exist with Status <code>queued</code> and v2_migrated flag set. Upsert semantics: re-scheduling same jobId overwrites scheduledAt and meta. <br><strong>Failure modes:</strong> <code>Application.OnTime</code> scheduling may fail (handled in <code>SafeOnTimeSchedule</code>); scheduling failure leaves job recorded as queued but unscheduled; reconciliation will attempt to reschedule on open. <br><strong>Tests:</strong> Schedule a jobId, inspect <code>_IFRS_Jobs</code> row for scheduledAt/meta; call AttemptGracefulShutdown to cancel and verify job status changed accordingly. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>BuildOnTimeProcString(procName As String, jobId As String) As String</strong> — <em>stable OnTime procedure builder with escaping</em><br><strong>Purpose:</strong> Construct the exact string <code>&#x27;&lt;WorkbookName&gt;&#x27;!Proc &quot;jobId&quot;</code> used by Application.OnTime so scheduled macro resolves regardless of workbook path. Escapes internal quotes in jobId.<br><strong>Signature:</strong> <code>Private Function BuildOnTimeProcString(procName As String, jobId As String) As String</code>.<br><strong>Behavior:</strong> Returns <code>&quot;&#x27;ThisWorkbook.name&#x27;!procName &quot;&quot;escapedJobId&quot;&quot;&quot;</code> where <code>Replace(jobId, &quot;&quot;&quot;&quot;, &quot;&quot;&quot;&quot;&quot;&quot;)</code> handles embedded quotes. Called any time OnTime scheduling is required.<br><strong>Complexity:</strong> O(len(jobId)).<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> If ThisWorkbook.name retrieval fails (rare) scheduling string may be malformed—errors propagate to scheduler and are audited. <br><strong>Tests:</strong> Validate result when jobId contains quotes and when workbook name contains spaces. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeOnTimeSchedule(whenAt As Date, procStr As String)</strong> — <em>OnTime wrapper with audit fallback</em><br><strong>Purpose:</strong> Schedule <code>Application.OnTime</code> while capturing and auditing scheduling failures; avoid exceptions bubbling into user UI.<br><strong>Signature:</strong> <code>Private Sub SafeOnTimeSchedule(whenAt As Date, procStr As String)</code>.<br><strong>Behavior:</strong> Calls <code>Application.OnTime EarliestTime:=whenAt, Procedure:=procStr, schedule:=True</code> inside <code>On Error GoTo ErrHandler</code>. On error writes <code>OnTimeScheduleFail</code> audit and clears Err. Does not attempt retries here; reconciliation handles missed schedules later.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May schedule Windows timer for callback; on failure writes local audit. <br><strong>Failure modes:</strong> <code>Application.OnTime</code> exceptions (e.g., invalid proc string); logged and ignored. <br><strong>Tests:</strong> Provide purposely invalid <code>procStr</code> and assert <code>AppendLocalAudit</code> recorded <code>OnTimeScheduleFail</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ProcessJob_OnTime(jobId As String)</strong> — <em>OnTime entrypoint</em><br><strong>Purpose:</strong> Thin public shim invoked by <code>Application.OnTime</code> which calls <code>Ribbon_ProcessJob(jobId)</code>; exists so OnTime proc string is stable and points to a public procedure.<br><strong>Signature:</strong> <code>Public Sub Ribbon_ProcessJob_OnTime(jobId As String)</code>.<br><strong>Behavior:</strong> Calls <code>Ribbon_ProcessJob jobId</code> directly. Minimal logic.<br><strong>Complexity/Side-effects/Tests:</strong> trivial; test by scheduling OnTime proc string referencing this function. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ProcessJob(jobId As String)</strong> — <em>process queued job with resilience</em><br><strong>Purpose:</strong> Idempotent execution of scheduled job: mark running, look up handler in jobs sheet, call handler safely using <code>SafeApplicationRun</code>, update job status to done or error, write timestamps, and audit start/end. Designed to be resilient when handler missing or when errors occur.<br><strong>Signature:</strong> <code>Public Sub Ribbon_ProcessJob(jobId As String)</code>.<br><strong>Behavior:</strong> Ensures jobs sheet exists, finds job row by <code>FindJobRow</code>; if no row -> exit. Sets <code>Status</code> cell to "running", <code>UpdatedAt</code> to Now. Reads handler from sheet (col2). If handler absent marks error, sets LastError cell with truncated "Missing handler for job". Else generates corrId, audits <code>ProcessJobStart</code>, invokes handler via <code>SafeApplicationRun(handler, Array(jobId))</code>. After run, marks <code>Status</code> = "done" and updates timestamp. Errors in job processing are caught by ErrHandler: if error occurs, sets <code>Status</code>="error", writes truncated error to LastError, ensures timestamp updated, and calls <code>Ribbon_HandleError &quot;Ribbon_ProcessJob&quot;, ...</code>. <br><strong>Complexity:</strong> O(#rows) for <code>FindJobRow</code> (Find is optimized but worst-case scan). <br><strong>Side-effects:</strong> Modifies <code>_IFRS_Jobs</code> sheet rows (status,lastError,updatedAt). Triggers arbitrary handler side-effects. Writes audit entries. <br><strong>Invariants:</strong> Post-condition: job row exists and status reflects final state (<code>done</code> or <code>error</code>). Handlers are expected to update job row if needed (e.g., reschedule). <br><strong>Failure modes:</strong> Handler runtime errors; SafeApplicationRun returns Empty on error, so this routine uses sheet data to decide success; possible silent failures if handlers succeed but do not update row—hence audit is important. <br><strong>Tests:</strong> Create job with valid test handler that writes to a known cell; schedule and call <code>Ribbon_ProcessJob</code> and assert status updated to <code>done</code> and handler-produced cell changed. Also test missing handler path and error propagation to LastError cell. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>EnsureJobsSheetExists() As Worksheet</strong> — <em>ensure and migrate jobs support sheet</em><br><strong>Purpose:</strong> Return worksheet <code>_IFRS_Jobs</code>, creating and migrating schema to v2 if needed. Sets header and <code>v2_migrated</code> flag in row1 col9. <br><strong>Signature:</strong> <code>Private Function EnsureJobsSheetExists() As Worksheet</code>.<br><strong>Behavior:</strong> Attempts to get <code>ThisWorkbook.Worksheets(JOBS_SHEET_NAME)</code>. If missing, calls <code>CreateSupportSheet</code> and writes header row <code>A1:I1</code> and sets <code>.Cells(1,9)=1</code> and hides sheet. If present, reads header range and if <code>Cells(1,9) &lt;&gt; 1</code> calls <code>MigrateJobsSheetToV2</code> to backfill CreatedAt/UpdatedAt and set migrated flag for existing rows. Returns Worksheet or Nothing on irrecoverable error.<br><strong>Complexity:</strong> O(#rows) if migration occurs. <br><strong>Side-effects:</strong> Creates/mutates hidden sheet and may alter many rows if migrating. <br><strong>Invariants:</strong> Returned sheet always has header row and col9=1 after function completes (unless error). <br><strong>Failure modes:</strong> Sheet creation could fail due to workbook protection or limited worksheet count; errors bubbled to caller to handle. <br><strong>Tests:</strong> Run on workbook missing <code>_IFRS_Jobs</code> and confirm creation; run on pre-v2 sheet lacking col9 flag and assert migration adds CreatedAt/UpdatedAt for rows. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>MigrateJobsSheetToV2(sh As Worksheet)</strong> — <em>schema migration routine</em><br><strong>Purpose:</strong> Backfill CreatedAt and UpdatedAt for existing job rows and set <code>v2_migrated</code> flag. Non-failing best-effort migration. <br><strong>Signature:</strong> <code>Private Sub MigrateJobsSheetToV2(sh As Worksheet)</code>.<br><strong>Behavior:</strong> Ensures header exists, iterates rows 2..lastRow, writes Now to CreatedAt (col7) and UpdatedAt (col8) if empty, sets col9=1, audits migration <code>MigrateJobsV2</code> with row count. Errors sent to <code>Ribbon_HandleError</code>.<br><strong>Complexity:</strong> O(N) where N is number of job rows. <br><strong>Side-effects:</strong> Mutates many sheet cells. <br><strong>Failure modes:</strong> Partial migration if error occurs mid-loop; function logs error via <code>Ribbon_HandleError</code> and exits. <br><strong>Tests:</strong> Create sheet with older schema, run migration, validate col7/col8 populated and col9=1 for rows. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>EnqueueOrUpdateJob(jobId As String, handler As String, whenAt As Date)</strong> — <em>upsert job row</em><br><strong>Purpose:</strong> Insert or update a job row with handler, scheduledAt, status queued, and timestamp fields. Creates new row if jobId not found or updates existing row. <br><strong>Signature:</strong> <code>Private Sub EnqueueOrUpdateJob(jobId As String, handler As String, whenAt As Date)</code>.<br><strong>Behavior:</strong> Ensures jobs sheet exists, uses <code>.Columns(1).Find(jobId, LookAt:=xlWhole)</code> to find row. If not found creates new row at EOF and writes jobId and createdAt; else updates existing row. Writes handler (if non-empty), status=<code>queued</code>, scheduledAt, UpdatedAt=Now, v2_migrated flag. Audits <code>EnqueueOrUpdate</code>. <br><strong>Complexity:</strong> O(#rows) to Find; average is efficient search. <br><strong>Side-effects:</strong> Mutates <code>_IFRS_Jobs</code>. <br><strong>Invariants:</strong> After call, row exists with jobId and status queued. <br><strong>Failure modes:</strong> Write errors under workbook protection; errors handled by <code>Ribbon_HandleError</code>. <br><strong>Tests:</strong> Upsert same job twice and assert only one row exists and fields updated. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>UpdateJobMeta(jobId As String, meta As String)</strong> — <em>update meta column for job</em><br><strong>Purpose:</strong> Store <code>meta</code> string (OnTime proc string or JSON) into job row col6, update UpdatedAt timestamp. <br><strong>Signature:</strong> <code>Private Sub UpdateJobMeta(jobId As String, meta As String)</code>.<br><strong>Behavior:</strong> Find row using <code>FindJobRow</code> and set col6 = meta and col8 = Now. Silent if job absent. <br><strong>Complexity:</strong> O(#rows) for find. <br><strong>Side-effects:</strong> Mutates jobs sheet. <br><strong>Tests:</strong> Set meta and read back; ensure UpdatedAt changed. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>FindJobRow(jobId As String) As Long</strong> — <em>helper to locate job row</em><br><strong>Purpose:</strong> Return row number or 0 if not found. <br><strong>Signature:</strong> <code>Private Function FindJobRow(jobId As String) As Long</code>.<br><strong>Behavior:</strong> Calls <code>EnsureJobsSheetExists</code>, uses <code>Find</code> on column 1. Returns row index or zero. Swallows errors and returns 0 if anything fails. <br><strong>Complexity:</strong> O(#rows). <br><strong>Tests:</strong> Insert job row then call function. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_AttemptGracefulShutdown()</strong> — <em>best-effort cancel OnTime scheduled jobs</em><br><strong>Purpose:</strong> On shutdown attempt to cancel scheduled <code>Application.OnTime</code> entries for jobs with status queued or running. Mark cancelled/orphaned appropriately in sheet and audit each attempt. <br><strong>Signature:</strong> <code>Public Sub Ribbon_AttemptGracefulShutdown()</code>.<br><strong>Behavior:</strong> Iterates jobs rows; for each queued/running job reads <code>meta</code> (proc string) and scheduledAt, attempts <code>Application.OnTime scheduledAt, meta, schedule:=False</code> inside <code>On Error Resume Next</code>. If cancellation succeeded sets status <code>cancelled</code>; on failure sets <code>orphaned</code>. Updates UpdatedAt and audits result. If <code>meta</code> missing marks orphaned. <br><strong>Complexity:</strong> O(N). <br><strong>Side-effects:</strong> Mutates jobs sheet status cells. <br><strong>Invariants:</strong> After call, queued/running jobs are either <code>cancelled</code> or <code>orphaned</code>. <br><strong>Failure modes:</strong> <code>Application.OnTime</code> cancellation can fail (e.g., process not found). Function logs and continues. <br><strong>Tests:</strong> Schedule a job using <code>Ribbon_ScheduleLongTask</code>, call <code>Ribbon_AttemptGracefulShutdown</code> and verify status changed to cancelled or orphaned depending on environment. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ReconcileJobsOnOpen()</strong> — <em>reconcile orphaned or stale jobs at workbook open</em><br><strong>Purpose:</strong> On workbook open attempt to requeue <code>orphaned</code> jobs and reschedule <code>queued</code> jobs whose scheduledAt is stale or missing; ensures OnTime scheduling consistency across restarts and failure modes.<br><strong>Signature:</strong> <code>Public Sub Ribbon_ReconcileJobsOnOpen()</code>.<br><strong>Behavior:</strong> Iterates <code>_IFRS_Jobs</code> rows; for <code>orphaned</code> rows sets <code>queued</code>, updates UpdatedAt, calls <code>EnqueueOrUpdateJob</code> and schedules <code>SafeOnTimeSchedule</code> with short delay. For <code>queued</code> rows, if scheduledAt older than threshold (here <code>DateAdd(&quot;s&quot;, -5, Now)</code>), picks newWhen ~Now+2s, writes new scheduledAt and meta (BuildOnTimeProcString if missing), calls <code>SafeOnTimeSchedule</code> and audits. If scheduledAt missing schedules soon. <br><strong>Complexity:</strong> O(N). <br><strong>Side-effects:</strong> Updates job rows and schedules OnTime callbacks. <br><strong>Invariants:</strong> After call: orphaned jobs requeued and scheduled; queued jobs scheduled close to Now if stale. <br><strong>Failure modes:</strong> Scheduling can still fail; audit records reschedule attempts. <br><strong>Tests:</strong> Create rows with orphaned/queued statuses having stale scheduledAt and verify reschedule metadata present. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_Invalidate()</strong> — <em>debounced ribbon invalidation scheduler</em><br><strong>Purpose:</strong> Debounce calls to <code>g_ribbon.Invalidate</code> by scheduling a single <code>Application.OnTime</code> after <code>DEFAULT_INVALIDATE_DEBOUNCE_SECONDS</code>. Provides safe fallback to immediate invalidation if scheduling fails. <br><strong>Signature:</strong> <code>Public Sub Ribbon_Invalidate()</code>.<br><strong>Behavior:</strong> If <code>g_invalidateScheduled</code> is True returns early. Otherwise sets <code>g_invalidateScheduled=True</code>, computes <code>g_invalidateWhen = Now + DEFAULT_INVALIDATE_DEBOUNCE_SECONDS</code>, builds proc string for <code>Ribbon_ExecuteDebouncedInvalidate</code> on the current workbook, and calls <code>Application.OnTime</code>. On scheduling error it calls <code>g_ribbon.Invalidate</code> immediately (if ribbon object present), resets flag, clears Err. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Schedules OnTime to call <code>Ribbon_ExecuteDebouncedInvalidate</code>. <br><strong>Invariants:</strong> Prevents multiple invalidation OnTime jobs queued concurrently. <br><strong>Failure modes:</strong> OnTime schedule failure triggers immediate invalidation. <br><strong>Tests:</strong> Call <code>Ribbon_Invalidate</code> several times quickly and assert only one OnTime scheduled and <code>g_invalidateScheduled</code> true until <code>Execute</code> runs. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ExecuteDebouncedInvalidate()</strong> — <em>debounce execution</em><br><strong>Purpose:</strong> Execute the cached ribbon <code>Invalidate</code> call and clear debounce state.<br><strong>Signature:</strong> <code>Public Sub Ribbon_ExecuteDebouncedInvalidate()</code>.<br><strong>Behavior:</strong> Calls <code>g_ribbon.Invalidate</code> if <code>g_ribbon</code> not Nothing, and sets <code>g_invalidateScheduled=False</code>. Errors are swallowed (<code>On Error Resume Next</code>). <br><strong>Complexity/Side-effects/Tests:</strong> trivial; ensure flag resets. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>GetCachedStateFlag(cid As String, key As String, def As Boolean) As Boolean</strong> — <em>state cache getter for booleans</em><br><strong>Purpose:</strong> Read boolean flags for controls from <code>g_lastKnownState</code> dictionary with safe creation of nested dictionaries and defaulting.<br><strong>Signature:</strong> <code>Private Function GetCachedStateFlag(cid As String, key As String, def As Boolean) As Boolean</code>.<br><strong>Behavior:</strong> Lazily creates <code>g_lastKnownState</code> and <code>g_lastKnownState(cid)</code> dictionary; returns default <code>def</code> when key absent; casts to Boolean when present. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> May create in-memory dictionaries. <br><strong>Invariants:</strong> <code>g_lastKnownState(cid)</code> always exists after call. <br><strong>Tests:</strong> Validate default behavior and value retrieval after <code>Ribbon_UpdateCachedState</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>GetCachedStateText(cid As String, key As String, def As String) As String</strong> — <em>state cache getter for strings</em><br><strong>Purpose:</strong> Same as <code>GetCachedStateFlag</code> but returns string typed value with default fallback. <br><strong>Signature:</strong> <code>Private Function GetCachedStateText(cid As String, key As String, def As String) As String</code>.<br><strong>Behavior / Complexity / Tests:</strong> analogous to flag getter. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_UpdateCachedState(cid As String, key As String, value As Variant)</strong> — <em>update state cache and job row UpdatedAt</em><br><strong>Purpose:</strong> Set a value in <code>g_lastKnownState</code> nested dictionary for a control id and update <code>UpdatedAt</code> in any matching job row for telemetry (best-effort).<br><strong>Signature:</strong> <code>Public Sub Ribbon_UpdateCachedState(cid As String, key As String, value As Variant)</code>.<br><strong>Behavior:</strong> Lazily creates dictionaries, assigns <code>g_lastKnownState(cid)(key) = value</code>. Then attempts non-failing update to <code>_IFRS_Jobs</code> row: finds job with same id (col1) and sets UpdatedAt (col8)=Now. Errors swallowed (<code>On Error Resume Next</code>).<br><strong>Complexity:</strong> O(1) for cache update; find is O(#rows).<br><strong>Side-effects:</strong> Mutates in-memory cache and may write sheet UpdatedAt. <br><strong>Invariants:</strong> Cache now contains key/value; job row UpdatedAt updated if matching job exists. <br><strong>Tests:</strong> Update a value and read back via <code>GetCachedState*</code>; create a job row named like the cid and assert UpdatedAt modified. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_Audit(action As String, message As String)</strong> — <em>audit façade with external proc and fallback</em><br><strong>Purpose:</strong> Send audit event to central <code>LogAudit</code> proc (external), and if that fails append to local <code>_IFRS_Audit</code> sheet as fallback.<br><strong>Signature:</strong> <code>Private Sub Ribbon_Audit(action As String, message As String)</code>.<br><strong>Behavior:</strong> <code>Application.Run AUDIT_PROC_NAME, action, message</code>. If <code>Err.Number &lt;&gt; 0</code> clears error and calls <code>AppendLocalAudit action, message</code>. <code>On Error GoTo ErrHandler</code> ensures local fallback tested. Uses <code>AppendLocalAudit</code> which writes to hidden audit sheet. <br><strong>Complexity:</strong> O(1) unless fallback writes to sheet. <br><strong>Side-effects:</strong> Network/external side-effect if <code>LogAudit</code> is remote automation; otherwise writes to hidden sheet. <br><strong>Failure modes:</strong> Both external run and local append could fail (sheet locked) — AppendLocalAudit handles last-resort Debug.Print. <br><strong>Tests:</strong> Temporarily remove external <code>LogAudit</code> proc and assert <code>_IFRS_Audit</code> receives row. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_HandleError(procName As String, errNum As Long, errDesc As String)</strong> — <em>centralized error routing with fallback</em><br><strong>Purpose:</strong> Try to call external <code>HandleError</code> proc with error details; if it fails, append local audit and Debug.Print. Ensures errors never bubble to the user UI.<br><strong>Signature:</strong> <code>Private Sub Ribbon_HandleError(procName As String, errNum As Long, errDesc As String)</code>.<br><strong>Behavior:</strong> <code>Application.Run ERROR_PROC_NAME, procName, errNum, errDesc</code> and on failure calls <code>AppendLocalAudit &quot;HandleErrorFallback&quot;, ...</code> and <code>Debug.Print</code>. Final <code>ErrHandler</code> covers any exceptions and does another local append. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes to audit sheet or calls external handler. <br><strong>Failure modes:</strong> External <code>HandleError</code> missing → fallback works; fallback could also fail leading to Debug.Print. <br><strong>Tests:</strong> Remove external <code>HandleError</code> and ensure local audit populated. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>AppendLocalAudit(action As String, message As String)</strong> — <em>write fallback audit to sheet</em><br><strong>Purpose:</strong> Append a timestamped audit row to <code>_IFRS_Audit</code> with correlation id; used as fallback for audit and error flows.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAudit(action As String, message As String)</code>.<br><strong>Behavior:</strong> Ensures <code>EnsureAuditSheetExists</code>, finds next row, writes <code>Now</code>, truncated action and message, generates <code>GenerateCorrelationID(action)</code> for corrId, sets sheet very hidden. <code>On Error GoTo ErrHandler</code> prints to Debug.Print if even this fails. <br><strong>Complexity:</strong> O(1) aside from sheet I/O. <br><strong>Side-effects:</strong> Mutates <code>_IFRS_Audit</code>. <br><strong>Invariants:</strong> Appended row contains timestamp and corrId; sheet remains hidden. <br><strong>Tests:</strong> Force external audit to fail and assert local audit row appended. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeApplicationRun(procName As String, args As Variant) As Variant</strong> — <em>robust wrapper for Application.Run</em><br><strong>Purpose:</strong> Invoke external VBA macro by name with up to three args while swallowing exceptions and auditing failures. Prevents exceptions from bubbling to calling code and the host UI.<br><strong>Signature:</strong> <code>Private Function SafeApplicationRun(procName As String, args As Variant) As Variant</code> — returns <code>Variant</code> result or <code>Empty</code> on failure. <br><strong>Behavior:</strong> Validates <code>procName</code> non-empty. Inspects <code>args</code> safely (handles <code>IsMissing</code>/UBound guard). Calls <code>Application.Run</code> with 0..3 args, caps args to first three. <code>On Error GoTo ErrHandler</code> ensures errors are appended to local audit <code>SafeApplicationRunError</code> and returns <code>Empty</code>. Errors cleared before return. Designed to be resilient and to avoid Type Mismatch for malformed args. <br><strong>Complexity:</strong> O(1) plus callee cost. <br><strong>Side-effects:</strong> Calls external code which may perform arbitrary side-effects. <br><strong>Invariants:</strong> Never raises exception to caller. Caller must treat <code>Empty</code> as failure. <br><strong>Failure modes:</strong> External proc may raise; wrapper logs and returns <code>Empty</code>. <br><strong>Tests:</strong> Call with: non-existent proc (ensure no exception), proc with varying arg counts, proc that raises error (ensure audit). </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeApplicationRunPicture(procName As String, arg1 As Variant) As IPictureDisp</strong> — <em>picture-returning wrapper</em><br><strong>Purpose:</strong> Call external provider expecting <code>IPictureDisp</code> without raising; returns <code>Nothing</code> on failure.<br><strong>Signature:</strong> <code>Private Function SafeApplicationRunPicture(procName As String, arg1 As Variant) As IPictureDisp</code>.<br><strong>Behavior:</strong> Calls <code>SafeApplicationRun(procName, Array(arg1))</code>, verifies <code>IsObject(v)</code> then <code>Set SafeApplicationRunPicture = v</code>. Errors cleared and swallowed. <br><strong>Tests:</strong> Provider returns IPictureDisp and error cases. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>GetControlId(control As IRibbonControl) As String</strong> — <em>safe control id extractor</em><br><strong>Purpose:</strong> Return <code>control.id</code> or <code>&quot;unknown&quot;</code> on error. Used everywhere to normalize control id extraction.<br><strong>Signature:</strong> <code>Private Function GetControlId(control As IRibbonControl) As String</code>.<br><strong>Behavior:</strong> <code>On Error Resume Next</code> then <code>GetControlId = control.id</code>; if Err then returns <code>&quot;unknown&quot;</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Supply bad object to ensure fallback. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Nz(v As Variant, Optional d As Variant = "") As Variant</strong> — <em>VBA-style null coalescing helper</em><br><strong>Purpose:</strong> Return default <code>d</code> when input is Error/Null/Empty, else <code>v</code>. <br><strong>Signature:</strong> <code>Private Function Nz(v As Variant, Optional d As Variant = &quot;&quot;) As Variant</code>.<br><strong>Behavior:</strong> Checks <code>IsError</code>, <code>IsNull</code>, <code>IsEmpty</code> and returns default. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Pass Empty/Null/Error vs normal values. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>TruncateForCell(s As String) As String</strong> — <em>truncate text to MAX_ERROR_LEN</em><br><strong>Purpose:</strong> Truncate long error messages before writing into cell to avoid overly long content. <br><strong>Signature:</strong> <code>Private Function TruncateForCell(s As String) As String</code>.<br><strong>Behavior:</strong> If <code>Len(s) &lt;= MAX_ERROR_LEN</code> returns s else returns <code>Left$(s, MAX_ERROR_LEN-3) &amp; &quot;...&quot;</code>. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Tests:</strong> Boundary length cases. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>CreateSupportSheet(name As String) As Worksheet</strong> — <em>create hidden support sheet safely</em><br><strong>Purpose:</strong> Add a new support worksheet (very hidden) with a robust naming strategy that avoids name conflicts by appending numeric suffixes until success. Returns created Worksheet or Nothing on failure. <br><strong>Signature:</strong> <code>Private Function CreateSupportSheet(name As String) As Worksheet</code>.<br><strong>Behavior:</strong> Adds new sheet after last sheet, attempts <code>sh.name = name</code> and if fails loops with suffix <code>_1</code>, <code>_2</code>, ... until success. Sets <code>.Visible = xlSheetVeryHidden</code>. On irrecoverable error prints Debug.Print and returns Nothing. <br><strong>Complexity:</strong> O(k) attempts for k name collisions. <br><strong>Side-effects:</strong> Adds worksheet. <br><strong>Failure modes:</strong> Workbook protected or max sheet count reached; handled via Debug.Print and return Nothing. <br><strong>Tests:</strong> Force a name collision by creating sheets with same name; ensure unique suffix created. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>EnsureAuditSheetExists() As Worksheet</strong> — <em>ensure <code>_IFRS_Audit</code> sheet exists</em><br><strong>Purpose:</strong> Lazily create <code>_IFRS_Audit</code> with header <code>&quot;Timestamp&quot;,&quot;Action&quot;,&quot;Message&quot;,&quot;CorrId&quot;</code>. Returns sheet. <br><strong>Signature:</strong> <code>Private Function EnsureAuditSheetExists() As Worksheet</code>.<br><strong>Behavior:</strong> Mirrors <code>EnsureJobsSheetExists</code> but simple; uses <code>CreateSupportSheet</code> when missing and sets header and hidden. <br><strong>Tests:</strong> Validate header created and sheet hidden. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>EnsureTestSheetExists() As Worksheet</strong> — <em>ensure <code>_IFRS_TestResults</code> exists</em><br><strong>Purpose:</strong> Create test-results sheet used by <code>Ribbon_SelfTest</code> with header. <br><strong>Signature:</strong> <code>Private Function EnsureTestSheetExists() As Worksheet</code>.<br><strong>Behavior / Tests:</strong> same pattern as audit. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>GenerateCorrelationID(seed As String) As String</strong> — <em>create corr id from CRC32</em><br><strong>Purpose:</strong> Produce short, stable-ish correlation id for metrics by combining <code>METRIC_PREFIX</code> with CRC32 of timestamp+seed+timer and hex-encoding. <br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID(seed As String) As String</code>.<br><strong>Behavior:</strong> Calls <code>InitializeCRC32Table</code> (lazy), builds string <code>Now|seed|Timer</code>, calculates <code>CRC32_String</code> (returns Long), uses <code>HexFromLong</code> to format 8-hex char and prefixes <code>METRIC_PREFIX</code>. <br><strong>Complexity:</strong> O(len(seed)). <br><strong>Side-effects:</strong> Uses/initializes <code>g_crc32Table</code>. <br><strong>Failure modes:</strong> CRC table init should be robust; if StrToBytes or CRC function errors fallback unhandled? Current code assumes success. <br><strong>Tests:</strong> Call repeatedly with same seed at different times produce different corrIds; verify hex length is 8. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>InitializeCRC32Table() / CRC32_String / StrToBytes / HexFromLong</strong> — <em>CRC32 helpers</em><br><strong>Purpose:</strong> Provide CRC32 calculation for correlation id generation. <code>InitializeCRC32Table</code> builds <code>g_crc32Table</code> once. <code>CRC32_String</code> converts string to bytes and computes CRC32. <code>StrToBytes</code> returns byte array via VBA coercion (UTF-16LE). <code>HexFromLong</code> formats long to 8-hex-digit string.<br><strong>Behavior & Notes:</strong> Uses integer arithmetic with careful logical-right-shift simulation. <code>StrToBytes</code> uses VBA string->byte behavior (UTF-16 LE) — that's a deliberate design choice for stability but should be documented because it differs from UTF-8 CRC expectations.<br><strong>Complexity:</strong> O(len(bytes)).<br><strong>Tests:</strong> Known inputs produce expected CRC values (unit test required); verify table initialized only once. <br><strong>Maintenance note:</strong> If CRC domain needs to match other systems expecting UTF-8, change <code>StrToBytes</code> to explicit UTF-8 conversion and update any external consumers. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_SelfTest()</strong> — <em>deterministic ×10 self-tests writing to TEST sheet</em><br><strong>Purpose:</strong> Run a small set of deterministic checks verifying registry init, SafeApplicationRun behavior, scheduling/cancel path, migration flag presence, and audit fallback; append results to <code>_IFRS_TestResults</code>. Designed non-fatal and idempotent.<br><strong>Signature:</strong> <code>Public Sub Ribbon_SelfTest()</code>.<br><strong>Behavior:</strong> Iterates 1..10; registers dummy handlers, invokes <code>SafeApplicationRun</code> on a non-existent proc (ensuring no unhandled exceptions), enqueues a tiny job then attempts immediate cancel using <code>Application.OnTime</code>, checks migration flag on jobs sheet, calls <code>Ribbon_Audit</code>, and writes test row for each iteration. Any exception inside runs recorded to TEST sheet and local audit. Uses defensive <code>On Error Resume Next</code> in test body to avoid breaking loop. Audits <code>SelfTestCompleted</code> at end.<br><strong>Complexity:</strong> O(10) plus costs of sheet writes and OnTime operations. <br><strong>Side-effects:</strong> Writes multiple rows into <code>_IFRS_TestResults</code> and <code>_IFRS_Jobs</code> as needed; may leave ephemeral job rows behind—test harness should clean up after use. <br><strong>Failure modes:</strong> If sheet creation fails, test logs to local audit and Debug.Print. <br><strong>Tests:</strong> Test harness itself is the test; ensure running it twice produces consistent results and no resource leakage. <br><strong>Notes:</strong> For CI, consider adding cleanup code to remove test job rows after run or mark them as <code>test</code> so they don't affect production flows. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>FindJobScheduledAt(jobId As String) As Variant</strong> — <em>helper read scheduledAt safely</em><br><strong>Purpose:</strong> Non-failing helper to read scheduledAt for a job row (used by tests). <br><strong>Signature:</strong> <code>Private Function FindJobScheduledAt(jobId As String) As Variant</code>.<br><strong>Behavior:</strong> Uses <code>FindJobRow</code> to find row and returns cell value or Empty. Errors swallowed. <br><strong>Tests:</strong> Create job and assert returned date equals scheduledAt cell. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Developer & operational notes (summary)</strong><br>- <strong>Error handling model:</strong> All public callbacks and scheduling code swallow runtime errors and route them to <code>Ribbon_HandleError</code>/<code>AppendLocalAudit</code>. This preserves host stability but means callers must rely on audit/logs for failures.<br>- <strong>Jobs sheet invariants:</strong> <code>_IFRS_Jobs</code> header columns A:I required; col9 <code>v2_migrated=1</code> signals migration. <code>EnqueueOrUpdateJob</code> ensures rows are present and <code>FindJobRow</code> used for lookups—avoid external edits that break header order. <br>- <strong>OnTime scheduling:</strong> Use <code>BuildOnTimeProcString</code> to ensure stable proc strings. <code>SafeOnTimeSchedule</code> only logs scheduling failures; reconciliation attempts recovery on open. Test OnTime behavior thoroughly on the target Excel version (OnTime semantics vary by host process and when workbook is closed).<br>- <strong>Concurrency & race:</strong> Excel/VBA is single-threaded; OnTime may fire while workbook is closing—<code>AttemptGracefulShutdown</code> attempts cancellations but cannot guarantee cancellation in all hosts. Treat job state as eventually consistent and rely on reconciliation on open.<br>- <strong>Audit & error fallbacks:</strong> <code>Application.Run</code> to external <code>LogAudit</code> and <code>HandleError</code> are best-effort; local <code>_IFRS_Audit</code> is primary fallback. Ensure those sheets are monitored/archived by support processes. <br>- <strong>Correlation ID:</strong> <code>GenerateCorrelationID</code> uses VBA string-to-byte coercion (UTF-16LE) for CRC input; if cross-system correlation is required normalize encoding. <br>- <strong>State cache:</strong> <code>g_lastKnownState</code> is in-memory only; consider persistence if required across sessions. Updating job row <code>UpdatedAt</code> on <code>Ribbon_UpdateCachedState</code> is best-effort; do not rely on it for strict telemetry. <br>- <strong>Testing checklist:</strong> Include unit tests for scheduling/cancel, migration paths, SafeApplicationRun behavior (including procs that throw), audit fallback (missing <code>LogAudit</code>), and self-test idempotence. <br>- <strong>Hardening suggestions:</strong> (1) Add per-row unique job GUIDs (separate from jobId) for stronger idempotency. (2) Add a <code>workerPid</code>/host-instance id column to detect jobs scheduled by other Excel instances. (3) Consider serializing job metadata as JSON in <code>Meta</code> but ensure Excel formula/length constraints. (4) OnTime proc strings should be revokable—record and attempt <code>Application.OnTime</code> cancellation on <code>Workbook_BeforeClose</code> too. </td></tr></tbody></table></div><div class="row-count">Rows: 48</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>