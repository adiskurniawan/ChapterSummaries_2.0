<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771304654">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0175_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>HEADER — ONE-PAGE MAP (concise navigation of the guide)</strong>:<br>1) Executive Summary → 2) Quick-Run → 3) Purpose & Workflow → 4) Audience & Assumptions → 5) Prerequisites → 6) File Layout & Naming → 7) Inputs & Validation → 8) Power Query Design & Health → 9) Calculation Layer (Normalization, TTM, Forecast, DCF, Multiples) → 10) Aggregation, MOS & Recommendation → 11) VBA Orchestration & UI → 12) Logging, Reporting & Exports → 13) Testing, QA, CI/CD → 14) Packaging & Distribution → 15) Operations, Runbook & Incident Playbooks → 16) Appendices (Glossary, Examples, Troubleshooting).<br><br><strong>NAVIGATION TIP:</strong> Use the <code>Meta</code> sheet to link to section anchors (named range hyperlinks) so maintainers can jump to any block quickly. Each major block has a <code>Start:</code> row with <code>mod_&lt;block&gt;_Start</code> named range for traceability.<br><br><strong>Extended narrative — Purpose of the map:</strong> The map is the canonical entry point for users and maintainers; it must be kept minimal but current. Treat the map as a living index — each release must update it. The map drives two automations: (a) a "quick jump" UI that reads <code>Meta</code> links and adds them to the UserForm; (b) a CI rule that verifies all referenced named ranges exist. Implement an automated check during the pre-release stage that verifies each <code>mod_&lt;block&gt;_Start</code> exists and points to a valid sheet row. <br><br><strong>Extended example — Automation snippet (pseudo):</strong> <code>For each entry in Meta[&#x27;SectionAnchor&#x27;] validate Application.Range(anchor) exists; if not, fail CI with &quot;Anchor missing: &lt;label&gt;&quot;</code>. Record results to <code>Meta.AnchorCheckTimestamp</code> so the release manager can see failing anchors over time. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>EXECUTIVE SUMMARY: purpose, scope and delivery expectations (expanded)</strong>:<br>This document is a deterministic, auditable, production-oriented Technical User Guide for an Advanced Stock Valuation Tool implemented in Excel with Power Query (PQ) as the typed ingestion pipeline and VBA as the orchestration, UI, logging and deterministic export engine. The tool must be production-ready: signed macros, CI-gated releases, deterministic outputs, append-only logs and explicit fallback policies. <br><br><strong>Scope:</strong> single-ticker valuation flow (extendable to batch), PQ connectors to API/CSV, canonical financial + market schemas, modular calculation blocks (Normalization, TTM, Forecast, DCF, Multiples), deterministic snapshot + PDF export, observability (PQ_Status, Metrics), and operational runbook for scheduled and on-call execution. <br><br><strong>Delivery expectations:</strong> implementers deliver a signed <code>.xlsm</code> with tests and release artifacts (README, Samples, Tests, checksums). The workbook must be auditable (RunID trace across PQ_Status, Logs, artifacts), and implementers must treat the guide as prescriptive: follow naming conventions, logging schema, and migration protocols.<br><br><strong>Deeper narrative — why deterministic outputs matter:</strong> Deterministic outputs mean that given identical inputs (named ranges, Samples, environment) the output must be bitwise comparable across runs where feasible (e.g., same snapshot PDF checksum). Determinism is critical for audit, regression testing, and CI signing. Achieve determinism by: pinning locale and number formats during snapshot, fixing print area and chart placements in code, and avoiding random seeds in any auxiliary process unless recorded and replayable. <br><br><strong>Example — deterministic export checklist:</strong> 1) Ensure <code>Application.International</code> values are set/pinned. 2) Freeze <code>rng_</code> outputs into the <code>Report</code> sheet with <code>Value = Value</code> copies. 3) Generate the PDF with explicit print settings. 4) Compute SHA256 and record to <code>Logs</code> along with RunID and <code>nr_Version</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>QUICK-RUN (exact actions: open → refresh → run → export)</strong>:<br>1) Open <code>YourTool_v{nr_Version}.xlsm</code> and confirm <code>Meta</code> shows expected <code>nr_Version</code> and <code>BuildID</code>. Verify code-signing certificate thumbprint in <code>Meta</code>. <br>2) On <code>Inputs</code>, set required parameters: <code>nr_Ticker</code>, <code>nr_ProjectionYears</code>, <code>nr_WACC</code>, <code>nr_TermGrowth</code>, <code>nr_MOS</code>, <code>nr_LookbackYears</code>, <code>nr_ExportPath</code>. Confirm validations are green (cells use Data Validation and <code>ValidateInputs</code> shows PASS). <br>3) Click <strong>Refresh Data</strong>. UI writes parameters to named ranges and triggers PQ via <code>ThisWorkbook.RefreshAll</code>. <br>4) Monitor <code>Logs</code> and <code>PQ_Status</code> for <code>PQ_OK</code> entries: RowsLoaded > 0, StalenessDays within tolerance, HasRequiredColumns = TRUE. If PQ returns warnings, confirm <code>Samples</code> for raw response. <br>5) Click <strong>Run Valuation</strong>; wait for orchestrator to complete; check <code>rng_ConfidenceScore</code>, <code>rng_AvgFairPrice</code>, and <code>rng_Recommendation</code>. <br>6) Click <strong>Export Report</strong>; confirm file created at <code>nr_ExportPath</code> with filename format <code>TICKER_Report_YYYYMMDD_HHMM_v{nr_Version}.pdf</code> and checksum logged to <code>Logs</code>.<br><br><strong>Deeper narrative — operator flow:</strong> Quick-Run is intentionally minimal and must survive being read aloud during a support call. Include a "one-click repeat" function in UI that reuses <code>nr_Ticker</code> and prior inputs to reproduce last run. The Quick-Run should be a training checklist for junior analysts and include two extra validation hooks: <code>CheckLastRunDiff</code> (showing percent change from previous run) and <code>HealthSnapshot</code> (latest PQ_Status summary). <br><br><strong>Extended example — repeat run UI behavior:</strong> Provide a dropdown of last 10 RunIDs and <code>Repeat</code> action: on selection the UI sets inputs to the saved <code>Inputs</code> JSON from <code>Logs</code> entry for that RunID and triggers the orchestrator in sandbox or live mode per user choice. Logs record <code>RepeatTriggeredBy</code> and <code>OriginalRunID</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PURPOSE & HIGH-LEVEL WORKFLOW: inputs → PQ → calculations → export (detailed)</strong>:<br><strong>Purpose:</strong> automate typed ingestion, normalization, auditable valuation calculations and deterministic reporting while enabling maintainability and CI/CD. <br><br><strong>High-level workflow:</strong> User → <code>Inputs</code> (nr_*) → Orchestrator (VBA writes params + triggers PQ) → PQ uses <code>nr_*</code> to fetch data → PQ outputs canonical <code>tblFinancials</code> and <code>tblMarket</code> + <code>PQ_Status</code> → <code>Calculations</code> sheet executes modular blocks and populates <code>rng_</code> outputs → <code>SelfCheck</code> computes <code>rng_ConfidenceScore</code> → Snapshot to <code>Report</code> sheet (value-only) → Export artifacts (PDF/CSV) + append structured <code>Logs</code>. Every step emits machine-readable health metadata (RunID, timestamps, durations, error codes).<br><br><strong>Deeper narrative — pipeline observability:</strong> Treat each stage as emitting an immutable event record. Implement a small "event bus" in <code>Logs</code> where each stage writes an event row that includes <code>RunID</code>, <code>Stage</code>, <code>Status</code>, <code>Timestamp</code>, <code>ContextJSON</code>. This enables external monitoring to reconstruct the pipeline state and for incident handlers to drill into the stage that failed. <br><br><strong>Example — event schema row:</strong> <code>Timestamp | RunID | Stage | Status | Code | Message | ContextJSON</code>. Example row: <code>2026-01-13T09:30:20Z | 20260113_093012_ABC123 | PQ_GetMarket | INFO | PQ_OK | &quot;RowsLoaded=120&quot; | {&quot;MaxDate&quot;:&quot;2026-01-13&quot;,&quot;DurationMs&quot;:1200}</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>AUDIENCE & ASSUMPTIONS: intended readers and environment (clarified)</strong>:<br><strong>Audience:</strong> financial analysts requiring reproducible valuations, VBA maintainers, data engineers responsible for scheduled Excel automation, DevOps personnel who will host scheduled runs, and auditors. <br><strong>Assumptions:</strong> Windows Excel (Office 365 or Excel 2016+), Power Query available, macros allowed and signable, network access to providers (or local fixtures), secrets stored in a secure vault (e.g., Windows Credential Manager/Azure Key Vault). The workbook is intended to run on corporate Windows hosts; cross-platform behavior (macOS) is out-of-scope unless explicitly tested.<br><br><strong>Deeper narrative — stakeholder expectations:</strong> For each audience, provide a one-page "What I care about" addon: Analysts care about quick-run and assumptions; Maintainers care about <code>Modules</code>, <code>RunTests</code>, and mapping tables; DevOps cares about scheduling and secrets handling; Auditors care about <code>Logs</code>, <code>RunID</code> correlation, and retention. Keep these one-pagers in the release ZIP to reduce support friction. <br><br><strong>Example — Auditors one-pager:</strong> Includes <code>RunID</code> lookup instructions, sample Log rows to search for, how to verify file checksums, and where retention policies are stored in <code>Meta</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PREREQUISITES: Excel versions, PQ, macro policy, credentials (checklist)</strong>:<br>• Windows Excel: Office 365 or Excel 2016+ with Power Query.<br>• Ability to save and distribute <code>.xlsm</code> files.<br>• Admin or support-level access to Trust Center to approve/verify the EV code-signing certificate.<br>• Secure credential management: Windows Credential Manager, Azure Key Vault or equivalent (no secrets in sheets).<br>• Optional: a Windows host for scheduled runs (Task Scheduler, PowerShell) with service account that can read vault secrets. <br><br><strong>Pre-deploy checklist:</strong> confirm EV certificate, create <code>nr_ExportPath</code>, verify <code>nr_ArchivePath</code> exists, populate <code>Samples</code> for offline testing, run <code>RunTests</code>.<br><br><strong>Deeper narrative — binary compatibility and perf:</strong> Document required Excel build numbers and COM/automation behavior. For scheduled runs where headless Excel is used, confirm that the host can run interactive Excel (some environments require a visible desktop session). Capture memory and CPU baselines during performance testing. <br><br><strong>Example — preflight output:</strong> <code>preflight.ps1</code> returns JSON: <code>{&quot;ExcelVersion&quot;:&quot;16.0.XXXX&quot;,&quot;PowerQueryPresent&quot;:true,&quot;ExportPathWritable&quot;:true,&quot;VaultAccessible&quot;:true}</code> and returns non-zero exit on any failure. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>FILE LAYOUT PRINCIPLE: single-sheet-per-purpose (reasons & examples)</strong>:<br>Single responsibility per sheet reduces coupling, simplifies sheet-level protection, and clarifies audit boundaries. Recommended sheets: <code>Meta</code>, <code>Inputs</code>, <code>PQ_Data_Financials</code>, <code>PQ_Data_Market</code>, <code>Calculations</code>, <code>Dashboard</code>, <code>Report</code>, <code>Logs</code>, <code>Tests</code>, <code>Samples</code>, <code>Modules</code>, <code>Metrics</code>. Use <code>Meta</code> for project-level settings and migration notes. Example: <code>PQ_Data_Financials</code> contains only <code>tblFinancials</code> typed table and PQ load settings; <code>Calculations</code> contains only the modular calculation blocks with clear header rows.<br><br><strong>Deeper narrative — enforcement:</strong> Implement a CI check that scans sheet contents for W-strings like <code>Web.Contents</code> or <code>Power Query</code> references that are not in PQ query definitions, and flag places where the separation of concerns is violated. Keep the <code>Calculations</code> sheet free of connections and queries. <br><br><strong>Example — CI rule:</strong> <code>sheet_role_check</code> reads the workbook and reports if any <code>Module</code> logic is present in sheets beyond <code>Modules</code> or if any connection objects exist on <code>Calculations</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>MANDATORY SHEETS LIST: Meta, Inputs, PQ_Data_<em>, Calculations, etc. (details)</strong>:<br><strong>Mandatory:</strong> <code>Meta</code> (version, changelog, buildID, support), <code>Inputs</code> (nr_</em>), <code>PQ_Data_Financials</code> (tblFinancials), <code>PQ_Data_Market</code> (tblMarket), <code>Calculations</code> (modular blocks), <code>Report</code> (snapshot area), <code>Logs</code> (append-only diagnostics), <code>Tests</code> (test vectors). <br><strong>Recommended optional:</strong> <code>Dashboard</code> (KPI tiles), <code>Samples</code> (cached fixtures), <code>Modules</code> (public API index), <code>Metrics</code> (performance counters), <code>Archive</code> (local metadata for archived logs).<br><br><strong>Deeper narrative — minimal audit surface:</strong> The mandatory set must exist in every release. Optional sheets help operations but must be secured as well. Keep <code>Samples</code> write-protected for non-admins. Add a <code>SheetManifest</code> export that CI stores alongside artifacts for auditors. <br><br><strong>Example — SheetManifest format (CSV):</strong> <code>SheetName,Role,Protected,LastModifiedBy,RowCount</code> e.g. <code>Calculations,Computation,True,alice@company,432</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>NAMING CONVENTIONS: nr_, tbl, rng_, mod_ prefixes and rationale (complete list)</strong>:<br>• <code>nr_</code> — single-value named ranges for inputs and exposures, e.g., <code>nr_Ticker</code>, <code>nr_WACC</code>.<br>• <code>tbl</code> — Excel Tables that PQ loads, e.g., <code>tblFinancials</code>, <code>tblMarket</code>.<br>• <code>rng_</code> — calculation outputs exposed to UI/report, e.g., <code>rng_DCF_PerShare</code>.<br>• <code>mod</code> — VBA modules, e.g., <code>modOrchestrator</code>.<br>• <code>chk_</code> — boolean checks, e.g., <code>chk_SelfCheckPass</code>.<br>• <code>lst_</code> — helper named ranges that store arrays/lists.<br><br><strong>Rationale:</strong> deterministic names simplify programmatic access, reduce accidental breaks, and make audit queries straightforward. Document all names and their owner in <code>Meta</code>.<br><br><strong>Deeper narrative — enforcement and discovery:</strong> Export the named range catalog as <code>name_catalog.csv</code> during CI and include owners. Build a dashboard that allows maintainers to search names and see where they are referenced in code and PQ queries. This aids refactoring and safe renames. <br><br><strong>Example — name_catalog row:</strong> <code>nr_WACC,Calculations!B4,% percent WACC used in DCF,Owner=FinanceTeam,LastChanged=2026-01-10</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>META SHEET: version, changelog, buildID, support contact (fields & usage)</strong>:<br>Required fields: <code>ProjectName</code>, <code>nr_Version</code> (semantic MAJOR.MINOR.PATCH+build), <code>BuildID</code> (GUID), <code>Author</code>, <code>LastUpdate</code> (ISO date), <code>SupportContact</code>, <code>RequiredExcel</code> (e.g., "Office365/Excel2019+"), <code>SignedMacroFlag</code> (Y/N), <code>ChangeLog</code> table, <code>MigrationNeeded</code> flag, <code>CertificateThumbprint</code>. <code>Meta</code> is write-protected for normal users; only admins can update. Record migration notes and breaking-change notices here.<br><br><strong>Deeper narrative — machine-readability:</strong> Ensure <code>Meta</code> fields are machine-readable (avoid freeform text where possible). Use JSON blobs for fields that contain complex structures (e.g., <code>ReleaseArtifacts</code> listing files and checksums). The orchestrator reads <code>Meta</code> in preflight and will abort runs if <code>SignedMacroFlag</code> doesn't match expected values. <br><br><strong>Example — Meta JSON field:</strong> <code>Meta.ReleaseArtifacts = [{&quot;file&quot;:&quot;YourTool_v2.0.0_signed.xlsm&quot;,&quot;sha256&quot;:&quot;abcdef...&quot;},{&quot;file&quot;:&quot;README_USER.pdf&quot;,&quot;sha256&quot;:&quot;12345...&quot;}]</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>INPUTS SHEET DESIGN: one parameter per cell, named ranges (examples & metadata)</strong>:<br>Design each input row with columns: <code>Parameter</code>, <code>NamedRange</code>, <code>Value</code>, <code>Type</code>, <code>Unit</code>, <code>Validation</code>, <code>Default</code>, <code>Owner</code>, <code>Notes</code>. Example input rows: <code>nr_Ticker</code> (string, non-empty), <code>nr_ProjectionYears</code> (int 1–20), <code>nr_WACC</code> (pct 0–100), <code>nr_TermGrowth</code> (pct < WACC), <code>nr_MOS</code> (pct 0–100), <code>nr_PQTimeoutSeconds</code> (int). Use the <code>Value</code> column as the actual named range cell; do not duplicate values.<br><br><strong>Deeper narrative — UI generation & validation:</strong> Build a small UI generator that reads the <code>Inputs</code> metadata table and automatically builds the UserForm controls, validation messages and tooltips. Store input-level help text so analyst-facing UI shows concise guidance and a "why this matters" tooltip that links to the Report appendix. <br><br><strong>Example — Input metadata row:</strong> <code>nr_WACC | nr_WACC | 0.10 | Percent | % | 0.01–0.30 | 0.10 | FinanceTeam | &quot;WACC must be &gt; Term Growth + epsilon (0.2%)&quot;</code>. The UI generator uses <code>Validation</code> to set DataValidation on the input cell and shows a red border if invalid. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>INPUT VALIDATION RULES: numeric bounds, formats, non-empty checks (rules & codes)</strong>:<br>Validation rules implemented via Excel Data Validation and runtime <code>ValidateInputs</code> routine. Rules include: integer years 1–20, percentages 0–100, non-empty tickers (regex: <code>^[A-Z0-9\.\-]{1,10}$</code>), shares > 0. On validation failure, <code>ValidateInputs</code> writes a structured log row with <code>Code</code> prefix <code>VAL_</code> and human-readable message. Prevent runs when critical validations fail (fail-fast policy).<br><br><strong>Deeper narrative — validation levels:</strong> Distinguish between critical (block run) and advisory validations (allow run but lower confidence). Implement <code>ValidationSeverity</code> column in <code>Inputs</code> metadata; <code>ValidateInputs</code> returns a list of errors grouped by severity. Allow scheduled runs to hard-fail on critical levels but interactive runs to return a modal with "Fix / Override" options; any override is logged with <code>OVERRIDE_BY</code> and <code>OVERRIDE_REASON</code>. <br><br><strong>Example — ValidateInputs JSON return:</strong> <code>{&quot;status&quot;:&quot;FAIL&quot;,&quot;critical&quot;:[{&quot;code&quot;:&quot;VAL_TICKER_EMPTY&quot;,&quot;msg&quot;:&quot;Ticker empty&quot;}],&quot;advisory&quot;:[{&quot;code&quot;:&quot;VAL_WACC_LOW&quot;,&quot;msg&quot;:&quot;WACC below typical bound, proceed with caution&quot;}]}</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>REFRESH KEY: control cell to force PQ parameter propagation (pattern)</strong>:<br>Implement <code>nr_RefreshKey</code> as a timestamp/epoch integer that UI toggles before <code>ThisWorkbook.RefreshAll</code>. Include <code>nr_RefreshKey</code> in PQ provider URLs or query parameters to bypass provider caching when necessary. Example: <code>&amp;refreshKey=</code> & <code>nr_RefreshKey</code>. Keep a short TTL between toggles to avoid excessive calls.<br><br><strong>Deeper narrative — operational discipline:</strong> Use <code>nr_RefreshKey</code> as a controlled mechanism; never set it automatically on scheduled loop without logic to avoid provider rate limits. Track <code>nr_RefreshKey</code> deltas in <code>Metrics</code> and throttle requests through orchestrator. For debugging, allow a "force-refresh" admin toggle that increments <code>nr_RefreshKey</code> and records reason in <code>Logs</code>. <br><br><strong>Example — PQ usage:</strong> PQ query builds URL <code>&quot;https://api.provider.com/v1/data?t=&quot; &amp; Excel.CurrentWorkbook(){[Name=&quot;nr_Ticker&quot;]}[Content]{0}[Column1] &amp; &quot;&amp;rk=&quot; &amp; Text.From(Excel.CurrentWorkbook(){[Name=&quot;nr_RefreshKey&quot;]}[Content]{0}[Column1])</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>POWER QUERY RESPONSIBILITIES: ingestion, normalization, health (expanded)</strong>:<br>PQ responsibilities are strictly: read parameters from workbook, fetch provider data (API/CSV), parse response, normalize provider schema to canonical shape, apply type conversion, perform validation checks, emit a <code>PQ_Status</code> row summarizing health, and finally load typed tables <code>tblFinancials</code>/<code>tblMarket</code>. PQ must not store credentials in workbook cells. Each PQ query must implement a <code>HealthSummary</code> step containing RowsLoaded, MinDate, MaxDate, ColumnCheck, Errors, DurationMs, LatestClose. <code>PQ_Status</code> rows are appended to <code>Logs</code>.<br><br><strong>Deeper narrative — provider-schema drift handling:</strong> PQ should surface schema drift as a first-class citizen. Provide a <code>SchemaDrift</code> check that compares provider fields with the mapping table; if drift detected, PQ produces <code>MissingColumns</code> and <code>ExtraColumns</code> lists in <code>HealthSummary</code>. The orchestrator then decides whether to apply an automated best-effort rename mapping (if an exact alias is found) or to fail and require manual mapping update. <br><br><strong>Example — HealthSummary entry:</strong> <code>{&quot;RunID&quot;:&quot;20260113_093012_ABC123&quot;,&quot;QueryName&quot;:&quot;GetFinancials&quot;,&quot;RowsLoaded&quot;:12,&quot;MissingColumns&quot;:[&quot;FCF&quot;],&quot;ExtraColumns&quot;:[&quot;free_cash_flow_v2&quot;],&quot;DurationMs&quot;:1420,&quot;LatestValue&quot;:null}</code>. Orchestrator can use <code>MissingColumns</code> to automatically attempt <code>Mapping</code> updates if a single unambiguous alias exists. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ PARAMETERIZATION: manage parameters via workbook names (best-practice)</strong>:<br>Map PQ parameters to Excel named ranges using the <code>Excel.CurrentWorkbook(){[Name=&quot;nr_Ticker&quot;]}[Content]{0}[Column1]</code> pattern (or <code>Name</code> value table pattern) so queries reference <code>nr_</code> values centrally. Avoid hard-coded tickers or API endpoints in queries; centralize provider endpoints in <code>Meta</code> and map them via provider keys.<br><br><strong>Deeper narrative — sandboxing and test-mode:</strong> Add <code>nr_UseSamples</code> and <code>nr_SampleKey</code> named ranges to support sandbox runs. When <code>nr_UseSamples=TRUE</code>, PQ switches to <code>File.Contents</code> paths under <code>Samples/</code> using <code>nr_SampleKey</code>. This permits CI to execute PQ deterministically without network. Ensure <code>nr_UseSamples</code> defaults to <code>FALSE</code> in production artifacts. <br><br><strong>Example — PQ param pattern:</strong> <code>let ticker = Excel.CurrentWorkbook(){[Name=&quot;nr_Ticker&quot;]}[Content]{0}[Column1] in ...</code> or <code>let useSamples = Excel.CurrentWorkbook(){[Name=&quot;nr_UseSamples&quot;]}[Content]{0}[Column1] in if useSamples then File.Contents(&quot;Samples/&quot; &amp; ticker &amp; &quot;_market.csv&quot;) else Web.Contents(endpoint)</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ STRUCTURE: separate ingestion, normalization, validation steps (detailed step names)</strong>:<br>Recommended step names sequence in Advanced Editor: <code>Source</code> → <code>ParseResponse</code> → <code>ToTable</code> → <code>ExpandRecords</code> → <code>SchemaMapping</code> → <code>ApplyMappingTable</code> → <code>RenameColumnsCanon</code> → <code>TransformTypes</code> → <code>NullHandling</code> → <code>ValidateRequiredColumns</code> → <code>ComputeDerivedFields</code> → <code>HealthSummary</code> → <code>FinalLoad</code>. Keep each step minimal and testable; include <code>#shared</code> helper functions where appropriate.<br><br><strong>Deeper narrative — step-level testing:</strong> Break PQ into modular steps and write PQ unit tests in the repo that call individual M expressions using a test harness where possible (or via a thin wrapper that writes intermediate step outputs to <code>Samples</code> during debug runs). This allows faster diagnosis when a provider changes schema. <br><br><strong>Example — debug output pattern:</strong> During dev runs, have PQ write a <code>StepDebug</code> CSV for <code>ExpandRecords</code> and <code>RenameColumnsCanon</code> steps so maintainers can inspect intermediate shapes. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ OUTPUTS: tblFinancials and tblMarket canonical schemas (field definitions)</strong>:<br><code>tblFinancials</code> canonical fields: <code>Date</code> (date), <code>PeriodType</code> (Annual/Quarter), <code>Revenue</code> (number), <code>EBIT</code> (number), <code>NetIncome</code> (number), <code>EPS</code> (number), <code>FCF</code> (number), <code>SharesOutstanding</code> (number), <code>BVPS</code> (number), <code>Currency</code> (text). <br><code>tblMarket</code> canonical fields: <code>Date</code>, <code>Open</code>, <code>High</code>, <code>Low</code>, <code>Close</code>, <code>AdjClose</code>, <code>Volume</code>, <code>Dividend</code>, <code>Currency</code>. Enforce strong types using <code>Table.TransformColumnTypes</code> at the final PQ step and ensure null-handling rules are explicit.<br><br><strong>Deeper narrative — canonical policies:</strong> Document canonical units (e.g., numeric units are always base currency units, FCF in USD unless FX converted), date handling (end-of-period dates), and period types. Any deviation must be captured in <code>PQ_Status.MissingColumns</code>/<code>Errors</code>. Maintain a per-run <code>Provenance</code> JSON object listing the provider, sample file, and transform hash to enable exact replay. <br><br><strong>Example — provenance JSON:</strong> <code>{&quot;provider&quot;:&quot;AlphaVantage&quot;,&quot;provider_version&quot;:&quot;v2&quot;,&quot;transform_hash&quot;:&quot;sha256:abc...&quot;,&quot;loaded_table&quot;:&quot;tblFinancials&quot;}</code> stored in <code>PQ_Status.ContextJSON</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ_STATUS / HEALTH: required diagnostic fields and placement (schema & usage)</strong>:<br><code>PQ_Status</code> fields: <code>RunID</code>, <code>Timestamp</code>(ISO), <code>QueryName</code>, <code>RowsLoaded</code>, <code>MinDate</code>, <code>MaxDate</code>, <code>HasRequiredColumns</code>(bool), <code>MissingColumns</code>(text list), <code>Errors</code>(text), <code>DurationSeconds</code>, <code>LatestValue</code>(LatestClose), <code>StalenessDays</code>. Load <code>PQ_Status</code> to <code>Logs</code> as a single-row per query per run for orchestration consumption. Orchestrator reads these to decide fallback paths or abort flows.<br><br><strong>Deeper narrative — automated remediation triggers:</strong> Use <code>PQ_Status</code> to drive remediation rules: if <code>MissingColumns</code> contains critical fields, <code>modOrchestrator</code> either triggers a mapping-update workflow or fails the run and notifies the owner. Provide a triage queue that collects <code>PQ_Status</code> entries requiring human action and surfaces them to maintainers. <br><br><strong>Example — triage action:</strong> <code>PQ_Status</code> with <code>MissingColumns=[&quot;FCF&quot;]</code> creates a JIRA ticket via automation: <code>CreateTicket(&quot;Mapping update required for AlphaVantage: missing FCF&quot;, Attach samples/raw_response_RunID.json)</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ MAPPING TABLE: provider field alias → canonical name mapping (example)</strong>:<br><code>Mapping</code> table columns: <code>Provider</code>, <code>ProviderField</code>, <code>CanonicalField</code>, <code>LastSeen</code>, <code>Notes</code>. Example row: <code>AlphaVantage</code>,<code>freeCashFlow</code>,<code>FCF</code>,<code>2025-01-05</code>,<code>mapped via denom</code>. PQ applies this mapping to rename fields dynamically, enabling quick fixes when providers change schema. Document mapping edits in <code>Meta</code>.<br><br><strong>Deeper narrative — mapping governance:</strong> All mapping changes must be PR-driven in the repo-backed mapping CSV and applied through CI that updates the workbook's <code>Mapping</code> table. For urgent fixes, allow hotfix updates but record them and require subsequent PR reconciliation. Each mapping change must include <code>VerifiedBy</code> and <code>TestSample</code> references. <br><br><strong>Example — mapping change entry:</strong> <code>Provider=AlphaVantage, ProviderField=free_cash_flow_v2, CanonicalField=FCF, LastSeen=2026-01-12, Notes=&quot;provider renaming&quot;, VerifiedBy=bob@company, TestSample=Samples/alpha_v2_financials_20260112.json</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ SKELETON (implementation steps, non-code) (recipe)</strong>:<br>1) Read <code>nr_Ticker</code> and parameters. <br>2) Build provider URL or select <code>Samples</code> CSV for offline runs. <br>3) Fetch data via <code>Web.Contents</code> or <code>File.Contents</code>. <br>4) Parse JSON/CSV into records and tables. <br>5) Apply <code>Mapping</code> table renames. <br>6) Transform column types. <br>7) Apply data quality checks and record failures/warnings. <br>8) Emit <code>PQ_Status</code> row. <br>9) Load final table as <code>tblFinancials</code> / <code>tblMarket</code> and refresh workbook.<br><br><strong>Deeper narrative — standard operating procedure:</strong> Enforce timeouts at fetch stage and capture raw provider headers for rate limit and quota diagnostics. For each fetch, log HTTP status, latency, and content length in <code>PQ_Status.ContextJSON</code>. For large responses, stage them into <code>Samples</code> and load from local temp files to avoid repeated downloads during dev. <br><br><strong>Example — fetch metadata:</strong> <code>ContextJSON={&quot;http_status&quot;:200,&quot;latency_ms&quot;:340,&quot;content_length_bytes&quot;:120345}</code> and store <code>Samples/raw_&lt;RunID&gt;_market.json</code> for debugging. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ BEST PRACTICES: short steps, named steps, explicit types (do / don't)</strong>:<br>Do: keep steps small and test them, name steps semantically, apply explicit <code>Table.TransformColumnTypes</code>, use mapping tables for schema drift, and log health. Don't: rely on implicit type inference, use global <code>Table.Buffer</code> without measuring, or leave credentials as plain text in the workbook.<br><br><strong>Deeper narrative — reproducibility:</strong> Keep transforms deterministic: avoid functions that depend on session-specific state. Add unit tests around transforms by exporting step outputs to <code>Samples</code> and asserting shapes/checks in CI. Document failures in <code>ChangeLog</code> when transforms must be adjusted due to provider changes. <br><br><strong>Example — CI transform test:</strong> For <code>GetFinancials</code>, assert that final <code>tblFinancials</code> contains <code>PeriodType</code> in {"Annual","Quarter"} and <code>Date</code> column is non-null for last 3 entries. Fail CI if not met. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ RETRY & RATE-LIMITS: pattern for backoff and graceful failures (policy)</strong>:<br>Implement retries when provider connectivity is transient. Use a limited retry strategy (e.g., <code>nr_PQMaxRetries</code> default 3) with exponential backoff starting at <code>nr_PQBackoffSeconds</code> (default 5s). Record each attempt with status and latency in <code>PQ_Status</code>. On rate-limit or 429: set <code>PQ_Status.Errors</code> to <code>RATE_LIMIT</code> with provider-supplied reset time if present. Avoid infinite retry loops; fail safely and emit remediation hints.<br><br><strong>Deeper narrative — polite behavior:</strong> Implement rate-limit awareness in orchestrator to avoid amplifying provider issues: on 429, include a <code>RetryAfter</code> sleep and re-queue the run with exponential backoff or escalate if run is scheduled and critical. Keep telemetry to monitor frequency of rate-limited runs and adjust scheduling windows to spread load. <br><br><strong>Example — PQ_Status attempts array:</strong> <code>Attempts=[{&quot;attempt&quot;:1,&quot;status&quot;:200,&quot;duration_ms&quot;:240},{&quot;attempt&quot;:2,&quot;status&quot;:429,&quot;duration_ms&quot;:1200,&quot;retryAfter&quot;:60}]</code>. Orchestrator uses <code>retryAfter</code> to schedule a re-run job. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>PQ CREDENTIALS: never store secrets in cells; use secure store (implementation notes)</strong>:<br>Use PQ's credential prompts or configured enterprise connectors to store credentials externally. For scheduled runs, use an automation host that retrieves secrets from a vault and injects them into the execution context (PowerShell + COM or an enterprise connector). Mask credentials in logs and ensure <code>ContextJSON</code> never contains plaintext secrets. Record required credentials in <code>Meta</code> as <code>CredentialType</code> and <code>Owner</code>.<br><br><strong>Deeper narrative — secrets lifecycle:</strong> Rotate keys periodically and record rotation events in <code>Meta</code>. For scheduled runs, ensure the host uses a service principal with least privilege. For manual runs, provide a secure "inject secrets" helper that writes credentials into an in-memory COM session and never writes them to disk. Log only secret IDs and rotation timestamps. <br><br><strong>Example — Meta credential entry:</strong> <code>Credential={&quot;Name&quot;:&quot;AlphaVantageAPIKey&quot;,&quot;Type&quot;:&quot;APIKey&quot;,&quot;Storage&quot;:&quot;AzureKeyVault&quot;,&quot;Owner&quot;:&quot;IT-SRE&quot;,&quot;RotationDays&quot;:90}</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>DATA QUALITY RULES: column presence, lookback, freshness checks (rules & thresholds)</strong>:<br>Quality rules include: minimum lookback years (<code>nr_MinLookbackYears</code> default 3), required columns presence, null-rate thresholds (e.g., FCF null-rate < 20%), market freshness (default 7 days for equilibrium, configurable by <code>nr_MarketFreshnessDays</code>), and continuity checks for periodic data. Failures produce <code>DQ_</code> reason codes and change weighting in <code>rng_ConfidenceScore</code>.<br><br><strong>Deeper narrative — data-quality metadata:</strong> Produce a <code>DataQuality</code> table per run listing per-column null rates, continuity gaps, and flags. Use this to compute sub-scores for the <code>SelfCheck</code> rubric. Where automatic repair is feasible (e.g., forward-fill a missing trailing quarter when flagged as advisory), record the repair action in <code>Provenance</code> so auditors see the modification. <br><br><strong>Example — DataQuality row:</strong> <code>{&quot;column&quot;:&quot;FCF&quot;,&quot;null_rate&quot;:0.25,&quot;gaps&quot;:[{&quot;start&quot;:&quot;2019-03-31&quot;,&quot;end&quot;:&quot;2019-06-30&quot;}],&quot;action&quot;:&quot;none&quot;,&quot;score&quot;:40}</code> leading to <code>DQ_LOOKBACK_FAIL</code> and confidence reduction. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>FALLBACK POLICIES: DCF unavailable → multiples-only with flags (procedures)</strong>:<br>Define fallback hierarchy: 1) Full DCF if FCF history meets minimum lookback and quality. 2) If insufficient FCF history, compute multiples valuations (PE, PBV, Graham). 3) If market data missing, block recommendation and set <code>rng_ConfidenceScore</code> low. When DCF is unavailable, flag <code>rng_DCF_PerShare</code> as <code>N/A</code>, compute weighted aggregate using available methods, and write <code>FALLBACK_REASON</code> to <code>Logs</code>.<br><br><strong>Deeper narrative — deterministic fallback handling:</strong> The fallback decision logic must be deterministic and encoded in a rules table within <code>Meta</code>, e.g., <code>If DCF_invalid_and_PE_valid_then_use_PE_weighting=1.0</code> so different environments produce the same fallback. On fallback, add explicit instructions in the exported <code>Report</code> appendix telling users why DCF was skipped and what data would restore it. <br><br><strong>Example — Logs fallback entry:</strong> <code>{&quot;RunID&quot;:&quot;...&quot;,&quot;FallbackReason&quot;:&quot;Insufficient_FCF_History&quot;,&quot;UsedMethods&quot;:[&quot;PE&quot;,&quot;PBV&quot;],&quot;AppliedWeights&quot;:{&quot;PE&quot;:0.625,&quot;PBV&quot;:0.375}}</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>CONNECTING PQ → CALCULATIONS: structured references and examples (formulas)</strong>:<br>Load PQ outputs as Excel Tables and reference via structured formulas: e.g., latest close: <code>=INDEX(tblMarket[Close], MATCH(MAX(tblMarket[Date]), tblMarket[Date], 0))</code>. Sum FCF last 3 years: <code>=SUM(INDEX(tblFinancials[FCF], MATCH(LARGEST_DATE, tblFinancials[Date],0) - {0,1,2}))</code> — use helper named ranges for readability. Avoid volatile functions like <code>OFFSET</code> for performance.<br><br><strong>Deeper narrative — auditability of formulas:</strong> For every complex formula create an adjacent comment cell that explains the logic and original named ranges used. Provide an "audit map" sheet that maps each critical named range to the PQ table and the PQ query that produced it. This reduces the time auditors spend tracing the provenance of numbers. <br><br><strong>Example — audit map row:</strong> <code>rng_LatestClose -&gt; Calculations!B8 -&gt; derived from tblMarket[AdjClose] loaded by PQ Query GetMarket_v1</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>CALCULATION LAYER DESIGN: modular blocks and auditability (layout & style)</strong>:<br>Arrange <code>Calculations</code> into clearly separated blocks with header rows and border styles: <code>Normalization</code>, <code>TTM Engine</code>, <code>Forecast Engine</code>, <code>DCF Table</code>, <code>Multiples</code>, <code>Aggregation &amp; MOS</code>, <code>Sanity Checks &amp; SelfCheck</code>. Each block must include comment cells documenting the assumptions and expose key outputs as named ranges (<code>rng_DCF_PerShare</code>, <code>rng_AvgFairPrice</code>, <code>rng_MOS_Price</code>, <code>rng_ConfidenceScore</code>). Keep formulas explicit and avoid hidden transformations.<br><br><strong>Deeper narrative — unit testability:</strong> Each block must be unit-testable: provide a small harness macro <code>modSelfCheck.TestBlock(blockName)</code> that runs the block in isolation using <code>Samples</code> and outputs results into <code>Tests</code> with diffs. This helps when a single block changes logic or formula and allows targeted testing rather than full end-to-end runs. <br><br><strong>Example — block header metadata:</strong> <code>Normalization Block</code> includes <code>Inputs: tblFinancials, SharesOutstanding</code> <code>Outputs: rng_FCF_per_share</code> <code>Tests: Test_Normalization_1</code> recorded in <code>Modules</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>NORMALIZATION BLOCK: per-share conversions and unit checks (examples)</strong>:<br>Convert aggregates to per-share: <code>FCF_per_share = Total_FCF / SharesOutstanding</code>. Validate currencies and conduct FX conversions if <code>nr_ReportCurrency</code> differs: use maintained FX rates in <code>tblFX</code> with PQ or in <code>Calculations</code> with last-close FX mapping. Clearly document any per-share denominators and rounding policies adjacent to the normalization block.<br><br><strong>Deeper narrative — rounding & precision:</strong> Decide and document rounding policy: store raw intermediate values with high precision and round only for reporting. For per-share conversion define denominator source (provider vs Inputs override). Maintain a small "units" table that maps each field to its unit and whether it is per-share or aggregate for clarity. <br><br><strong>Example — normalization provenance:</strong> <code>rng_FCF_per_share</code> derived as <code>=IF(nr_FCF_is_per_share, nr_FCF_value, tblFinancials.TotalFCF / nr_SharesOutstanding)</code> and set <code>rng_FCF_Provenance=&quot;derived_from_aggregate&quot;</code> in a comment cell. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>TTM ENGINE: explicit handling of partial periods and edge cases (algorithm)</strong>:<br>TTM must handle fiscal overlaps and missing quarters: when quarterly data is missing, prorate using last available quarter or fall back to annualized LTM. Use weighted averaging where only partial quarter data exists. Document formulas and provide an explicit <code>TTM_FallbackUsed</code> boolean named range so the SelfCheck can account for reduced confidence.<br><br><strong>Deeper narrative — fiscal calendar handling:</strong> Support both calendar fiscal years and custom fiscal-year starts. Allow per-company fiscal configuration in <code>Inputs</code> so TTM computations can align with company reporting. Maintain a <code>FiscalCalendar</code> helper table if needed. If quarter alignment mismatches arise, expose a <code>TTM_Notes</code> field explaining the treatment used for auditors. <br><br><strong>Example — TTM fallback log:</strong> <code>TTM_FallbackUsed=TRUE; TTM_Notes=&quot;Q4 missing: used annualized LTM using prior annual and Q1-Q3 partials; see Samples/Provider_raw_response.json&quot;</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>FORECAST ENGINE: support constant and segmented growth vectors (config)</strong>:<br>Support both simple constant growth and segmented growth vectors (fast-transition-steady). Allow per-year growth inputs via an <code>Inputs</code> growth table (years 1..n). Provide scenario presets (Conservative/Base/Optimistic) with named vectors (e.g., <code>lst_Growth_Base</code>) and allow UI to select presets. Expose per-year growth table in <code>Report</code> appendix for transparency.<br><br><strong>Deeper narrative — governance of scenarios:</strong> Store scenario presets in <code>Meta</code> with author and date; changes to scenario presets require PR and CI tests. Ensure the UI clearly indicates which scenario preset is selected and the provenance of its parameterization (manual vs preset vs last-run). Include an "explain" column in scenario table that lists rationale or source (e.g., historical mean, analyst input). <br><br><strong>Example — scenario preset row:</strong> <code>Name=Base, GrowthVector=[0.08,0.06,0.05,0.04,0.03], Author=AnalystTeam, Rationale=&quot;Historical mean 5Y&quot;</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>DCF BLOCK — Inputs required and high-level flow (detailed)</strong>:<br><strong>Inputs required:</strong> <code>LastFCF</code> (per-share or aggregate + shares), <code>Growth_t</code> vector t=1..n, <code>nr_WACC</code>, <code>nr_TermGrowth</code>, <code>nr_ProjectionYears</code>, <code>SharesOutstanding</code> (nr_SharesOutstanding). <br><strong>Flow:</strong> compute FCF series, compute discount factors DF_t = 1/(1+WACC)^t, compute Terminal Value at n, discount TV to present, sum to PV_total, then compute <code>DCF_per_share = PV_total / SharesOutstanding</code>. Validate guard <code>WACC &gt; TermGrowth + ε</code>.<br><br><strong>Deeper narrative — alternative TV methods:</strong> In addition to Gordon growth model, include an exit multiple TV option and compute both. When both are computed, report both and compute <code>TV_Divergence = abs(TV_gordon - TV_exit) / avg(TV_gordon,TV_exit)</code> and flag if divergence > threshold. This gives a sanity check on TV sensitivity and provides auditors with alternate viewpoints. <br><br><strong>Example — TV divergence:</strong> <code>TV_gordon=1,200,000, TV_exit=2,100,000, divergence=0.5 -&gt; flag in Report &quot;Large TV divergence — re-evaluate growth assumptions or exit multiples.&quot;</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>DCF MATH: FCF_t, DF_t, TV, PV and per-share conversion formulas (explicit)</strong>:<br>• <code>FCF_t = FCF_{t-1} × (1 + growth_t)</code>.<br>• <code>DF_t = 1 / (1 + WACC)^t</code>.<br>• <code>TV = FCF_n × (1 + g_term) / (WACC − g_term)</code> with guard to avoid division by near-zero.<br>• <code>PV = Σ_{t=1..n} (FCF_t × DF_t) + TV × DF_n</code>.<br>• <code>DCF_per_share = PV / SharesOutstanding</code>. <br>Implement numeric stability: limit <code>g_term &lt; WACC − ε</code> and guard PV against overflow/inf when <code>WACC</code> close to <code>g_term</code>.<br><br><strong>Deeper narrative — numeric stability & auditing:</strong> Implement numeric guards in formulas and also in <code>modSelfCheck</code> so that both Excel and VBA detect instability. Document the epsilon used and provide auto-suggestions in <code>Report</code> (e.g., "increase WACC by 0.25% or reduce terminal growth to 2.5% to enable TV calculation"). Expose signed justification requirement for any manual override. <br><br><strong>Example — guard triggered:</strong> <code>WACC=0.03, g_term=0.029</code> -> <code>WACC - g_term = 0.001 &lt; 0.002 (ε)</code> -> TV invalid -> <code>rng_DCF_PerShare=N/A</code> and <code>Logs</code> entry <code>TV_GUARD_FAIL</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>DCF GUARDS: WACC > terminal growth and TV safety epsilon (policy)</strong>:<br>Require <code>WACC &gt; g_term + ε</code> where ε recommended = 0.002 (0.2%). If guard fails: mark TV invalid, set DCF result to N/A, append <code>TV_GUARD_FAIL</code> log with guidance and require manual override <code>nr_ManualTVOverride</code> with documented reason. Include an automated suggestion area in <code>Report</code> showing required WACC for a valid TV.<br><br><strong>Deeper narrative — operational response:</strong> When TV guard fails in scheduled runs, escalate via alerts and place the run into "requires manual review" state — do not produce exports. Include an admin override button in UI that requires reasons and approval recording (who, why, timestamp). This produces audit trails for any risk acceptance. <br><br><strong>Example — override record:</strong> <code>OverrideRunID=..., OverrideBy=jane@company, OverrideReason=&quot;Temporary market dislocation&quot;, Approver=HeadOfResearch, Timestamp=...</code>. All recorded in <code>Logs</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>MULTIPLES BLOCK: PE, PBV, Graham number and negative-value rules (handling)</strong>:<br>Calculate multiples with careful handling of sign and extremes: <br>- PE valuation = <code>EPS * Target_PE</code> only if <code>EPS &gt; 0</code>. If <code>EPS &lt;=0</code> set PE=N/A and log <code>PE_NEGATIVE</code>. <br>- PBV valuation = <code>BVPS * Target_PBV</code> only if <code>BVPS &gt; 0</code>. <br>- Graham number computed as <code>sqrt(22.5 * EPS * BVPS)</code> with units check; if inputs invalid, set N/A and write <code>GRAHAM_INVALID</code>. Exclude invalid valuations from aggregation and re-normalize weights.<br><br><strong>Deeper narrative — consistency of EPS inputs:</strong> Explicitly document whether EPS is TTM, forward consensus, or analyst estimate. For transparency include a small table showing which EPS was used and why. Where forward EPS is used, record the source and the date. Adjust PE calculations accordingly. <br><br><strong>Example — multiples provenance:</strong> <code>PE: Source=TTM (provider), EPS=5.2; PBV: BVPS=20; Graham: computed sqrt(22.5*5.2*20)=...; notes: PE valid=true, PBV valid=true, Graham valid=true</code>. </td></tr><tr><td data-label="Technical User Guide — Advanced Stock Valuation Tool (VBA + Power Query)"> <strong>AGGREGATION RULES: weighting scheme and configurable weights (algorithm)</strong>:<br>Default weights: DCF 50%, PE 25%, PBV 15%, Graham 10% (configurable via <code>nr_Weight_*</code>). If a method is invalid, exclude it and normalize remaining weights proportionally. For reproducibility, record applied weights per run in <code>Logs</code> and expose <code>rng_WeightBreakdown</code> for reporting. Provide an audit trace showing which methods were included/excluded and why.<br><br><strong>Deeper narrative — governance for weight overrides:</strong> Any permanent change to default weights must go through PR and release governance. Allow interactive runs to temporarily change weights but record overrides with <code>OVERRIDE_BY</code> and require a reason. Keep defaults in <code>Meta</code> and ensure runtime applied weights are recorded for each artifact. <br><br><strong>Example — applied weights log:</strong> <code>AppliedWeights={&quot;DCF&quot;:0.00,&quot;PE&quot;:0.60,&quot;PBV&quot;:0.30,&quot;Graham&quot;:0.10,&quot;note&quot;:&quot;DCF invalid due to TV_GUARD_FAIL&quot;}</code>. </td></tr></tbody></table></div><div class="row-count">Rows: 35</div></div><div class="table-caption" id="Table2" data-table="Docu_0175_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Quick Reference — Comprehensive**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Quick Reference — Comprehensive</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Quick Reference — Comprehensive"> <strong>Named Ranges (most-used) — full details, validation, examples, and operational notes</strong> <br> <strong>Purpose & governance:</strong> Named ranges are the single-source-of-truth configuration inputs for orchestrator, PQ, exports, guards, and UI conditional logic. All named ranges must be documented in the <code>Meta.NamedRanges</code> sheet with fields <code>Name</code>, <code>Type</code>, <code>AllowedRange</code>, <code>Default</code>, <code>Description</code>, <code>LastChangedBy</code>, <code>LastChangedOn</code>. Changes to any <code>nr_*</code> should increment <code>nr_Version</code> and write a <code>Meta.ChangeLog</code> entry. <br><br> <strong>List & canonical rules:</strong> <br> • <code>nr_Ticker</code> (string) — expected format <code>^[A-Z0-9\-]{1,10}$</code>; canonicalize by trimming, uppercasing, collapsing whitespace, replacing invalid characters with <code>-</code>. Example mapping: input <code>brk b</code> → stored <code>BRK-B</code>. Validate existence against <code>Samples</code> or <code>tblMarket</code> when possible; log <code>VAL_TICKER_NOT_FOUND</code> if absent. <br> • <code>nr_Version</code> (integer) — semantic increment rules: major when model/signature changes, minor for non-breaking performance/fix; used in artifact file names and manifests. <br> • <code>nr_RefreshKey</code> (integer) — store last writer and timestamp in <code>Meta.RefreshHistory</code>. Use atomic increments for scheduled runs to avoid race conditions (e.g., use VBA <code>InterlockedIncrement</code> pattern). <br> • <code>nr_ProjectionYears</code> (integer) — allowed 1–30; default 10; enforce integer type and write <code>VAL_RANGE</code> if out of bounds. <br> • <code>nr_WACC</code> (decimal) — stored as decimal (e.g., 0.085); input UI shows percent; allowed 0–1.0 (0–100%); validate non-negative, numeric. <br> • <code>nr_TermGrowth</code> (decimal) — allowed -0.10–0.10; store decimal; require <code>nr_WACC &gt; nr_TermGrowth + TV_EPSILON</code>. <br> • <code>nr_MOS</code> (decimal) — 0.0–1.0 stored as decimal; default 0.30; UI displays percent. <br> • <code>nr_ExportPath</code> (string) — absolute path only; validate by attempt to create and delete temp file; fallback to <code>Meta.DefaultExportPath</code> if invalid and log <code>EXPORT_PATH_FALLBACK</code>. <br> • <code>nr_PQTimeoutSeconds</code> (integer) — default 120; bounds 10–3600; used for each external PQ call. <br> • <code>nr_PQMaxRetries</code> (integer) — default 3; combined with <code>nr_PQBackoffSeconds</code> to compute retry schedule. <br> • <code>nr_PQBackoffSeconds</code> (integer) — default 5; exponential backoff implemented: sleep = backoff * (2^(attempt-1)). <br> • <code>nr_MinLookbackYears</code> (integer) — default 5; enforce ≤ <code>nr_ProjectionYears</code> and used to compute trailing averages. <br> • <code>nr_RunLockTimeout</code> (integer seconds) — default 1800 (30m); used by orphan detection. <br><br> <strong>Validation contract:</strong> The <code>ValidateInputs</code> function returns a structured JSON payload: <code>{&quot;ok&quot;:bool,&quot;errors&quot;:[{&quot;field&quot;:string,&quot;code&quot;:string,&quot;message&quot;:string,&quot;severity&quot;:&quot;Warning|Error&quot;}],&quot;fixes&quot;:[{&quot;field&quot;,&quot;suggestedValue&quot;,&quot;rationale&quot;}]}</code>. Any <code>Error</code> severity prevents run; <code>Warning</code> allows run but writes <code>WARN_*</code> logs. Validation must be idempotent and runnable from CI. <br><br> <strong>Operational notes & governance:</strong> Changes to any <code>nr_*</code> used in production must be approved via <code>Meta.ChangeControl</code> workflow and recorded in <code>Meta.ChangeLog</code> with <code>Author</code>, <code>Reviewer</code>, <code>Reason</code>, <code>RolloutWindow</code>. Automated alerts notify <code>Meta.Oncall</code> if <code>nr_ExportPath</code> becomes unwritable or if <code>nr_WACC</code> violates safety guards. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Core Tables (canonical fields, types, constraints, sample transforms, and monitoring)</strong> <br> <strong>Overview:</strong> Core tables are normalized canonical tables used across modules; all reads/writes should use a small set of helper functions (<code>GetTable</code>, <code>WriteTableSnapshot</code>, <code>ValidateTableSchema</code>) to ensure schema stability and auditability. Keep a <code>Mapping</code> table to translate provider fields to canonical fields. <br><br> <strong><code>tblFinancials</code> (canonical)</strong> <br> • Columns: <code>Date</code> (date, PK), <code>PeriodType</code> (enum: Q/Y), <code>Revenue</code> (decimal,currency), <code>EBIT</code> (decimal,currency), <code>NetIncome</code> (decimal,currency), <code>FCF</code> (decimal,currency), <code>SharesOutstanding</code> (decimal), <code>Currency</code> (ISO4217), <code>AdjustedForSplits</code>(bool), <code>Source</code> (string), <code>IngestedOn</code> (UTC timestamp). <br> • Constraints: unique <code>Date+PeriodType</code>; <code>SharesOutstanding</code> > 0; currency required. <br> • Null handling / DQ: nulls are flagged as <code>DQ_MISSING</code> entries in <code>tblDQ</code> with fields <code>Table</code>, <code>Column</code>, <code>RowIdentifier</code>, <code>Issue</code>, <code>SuggestedFix</code>. <br> • Typical transforms: currency conversion using <code>tblFX</code>, share split adjustment (apply cumulative split factor), smoothing negative FCF outliers with winsorization policy. <br> • Monitoring: <code>DataCompletenessPct</code> is computed per key column and written to <code>Meta.DataQuality</code> daily. If completeness < threshold (configurable), <code>rng_ConfidenceScore</code> is penalized. <br><br> <strong><code>tblMarket</code> (canonical)</strong> <br> • Columns: <code>Date</code> (date, PK), <code>Open</code>/<code>High</code>/<code>Low</code>/<code>Close</code>/<code>AdjClose</code> (decimal), <code>Volume</code> (int), <code>Dividend</code> (decimal), <code>Currency</code>, <code>Source</code>, <code>IngestedOn</code>. <br> • Fill-forward rules: when market is closed or missing a row, the system may forward-fill <code>Close</code> from prior trading day only for non-sensitivity processes; for valuation, missing recent days cause <code>StalePrice</code> flags. <br> • Exchange holidays and timezone normalization handled by <code>MarketCalendar</code> helper. <br><br> <strong><code>tblFX</code></strong> <br> • Columns: <code>Date</code>, <code>Pair</code> (e.g., <code>USD/IDR</code>), <code>Rate</code> (decimal), <code>Source</code>, <code>IngestedOn</code>. <br> • Use-case: normalize financials and market prices to a single base currency; store <code>fx_method</code> (spot/average) and period used. <br><br> <strong><code>Mapping</code></strong> <br> • Columns: <code>Provider</code>, <code>ProviderField</code>, <code>CanonicalField</code>, <code>Transform</code> (M/VBA/PQ M snippet reference), <code>LastSeen</code>, <code>IsActive</code>. <br> • Auto-drift detection: if <code>ProviderField</code> not seen for 7 days, create <code>PQ_SCHEMA_CHANGE</code> alert and set <code>IsActive=false</code> pending human review. <br><br> <strong><code>Samples</code></strong> <br> • Columns: <code>SampleID</code>, <code>Source</code>, <code>FixtureType</code>, <code>RawPayload</code> (blob/text), <code>Hash</code> (SHA256), <code>IngestTimestamp</code>, <code>UsedInTest</code> (bool). <br> • Usage: sandbox runs, CI, reproducible troubleshooting. <code>RunTests</code> must only use <code>Samples</code> where network is disabled. <br><br> <strong>Data contracts & schema evolution:</strong> Any schema change must be recorded in <code>Meta.SchemaVersion</code> and require migration script that updates <code>Mapping</code>, <code>Samples</code>, and <code>RunTests</code>. Use semantic versioning for canonical schemas; automated backward compatibility tests must run in CI. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Key Named Outputs (rng_) — precise definitions, calculation details, failure modes, and provenance</strong> <br> <strong>Design principles:</strong> <code>rng_</code> values are single-cell canonical outputs exposed to UI and exports. Each <code>rng_</code> must have immediate provenance (RunID, Source, Timestamp) and a small metadata object stored in <code>Meta.RngProvenance</code> with <code>Method</code>, <code>InputsHash</code>, <code>ModelVersion</code>, <code>Warnings</code>. <br><br> <strong><code>rng_DCF_PerShare</code></strong> <br> • Formula: <code>DCF_PerShare = (Σ PV(FCF_t) for t=1..N + PV(TerminalValue)) / SharesOutstanding</code> where PV uses <code>nr_WACC</code> as discount rate. <br> • Terminal value options: Gordon Growth (default), Exit multiple (optional). Choice recorded in <code>Meta.ValuationSettings</code>. <br> • Guard: if <code>nr_WACC &lt;= nr_TermGrowth + TV_EPSILON</code>, set <code>rng_DCF_PerShare = N/A</code>, write <code>TV_GUARD_FAIL</code>, and add <code>SelfCheck_ReasonCodes = [&quot;TV_GUARD_FAIL&quot;]</code>. <br> • Rounding & format: currency with two decimal places; store internal high-precision result in <code>Meta.IntermediateValues</code> for audit. <br> • Failure modes: division by zero if <code>SharesOutstanding</code> = 0 → log <code>VAL_ZERO_SHARES</code> and set <code>N/A</code>. Missing FCF series → <code>DQ_MISSING_FCF</code> and fallback to proxy cashflow method only if <code>SelfCheck.AllowProxy=true</code>. <br><br> <strong><code>rng_AvgFairPrice</code> & composition</strong> <br> • Composition: mean of valuation methods enabled and not excluded by <code>SelfCheck</code> (e.g., DCF, RelativeValuation, LiquidationValue). Methods excluded are recorded with reason. <br> • Weighting: default equal-weight; configurable via <code>Meta.ValuationWeights</code> to support weighted average. <br> • Exclusions: methods failing guards are excluded automatically and logged. <br><br> <strong><code>rng_MOS_Price</code></strong> <br> • Formula: <code>rng_MOS_Price = rng_AvgFairPrice * (1 - nr_MOS)</code>. <br> • If <code>rng_AvgFairPrice</code> = N/A, propagate <code>N/A</code> and require manual override via <code>Meta.Override_MOS_Price</code> with reason. <br><br> <strong><code>rng_ConfidenceScore</code></strong> <br> • Range: integer 0–100. <br> • Components & weights (configurable in <code>Meta.ConfidenceWeights</code>): DataCompleteness (40%), ModelStability (30%), SourceReliability (30%). <br> • DataCompleteness measured as weighted completeness across <code>tblFinancials</code> key columns. <br> • ModelStability measured by sensitivity analysis (change in fair price for ±50bp WACC, ±1yr projection) and variance across accepted methods in previous 30 days. <br> • SourceReliability measured by provider SLAs, recent PQ errors, and sample freshness. <br> • Effects: if <code>rng_ConfidenceScore &lt; rng_ConfidenceThreshold</code> exports may be blocked (configurable). <br><br> <strong><code>rng_LatestClose</code></strong> <br> • Sourced from <code>tblMarket</code> <code>AdjClose</code> preferentially; provenance includes <code>MarketDate</code>, <code>Source</code>, <code>IngestedOn</code>. <br> • Stale price handling: if <code>MarketDate</code> older than <code>nr_StalePriceDays</code> (default 2), set <code>StalePrice=true</code>, decrement <code>rng_ConfidenceScore</code> by configurable penalty, and add <code>WARN_STALE_PRICE</code>. <br><br> <strong>Provenance & audit:</strong> For each <code>rng_</code> write adjacent provenance cells: <code>rng_&lt;name&gt;_RunID</code>, <code>rng_&lt;name&gt;_Source</code>, <code>rng_&lt;name&gt;_Timestamp</code>, and write a compact JSON <code>Meta.RngProvenance</code> row with <code>InputsSnapshot</code>, <code>ModelVersion</code>, <code>ComputationHash</code>. All computations append a <code>ComputationRow</code> to <code>Meta.Computations</code> containing input hashes and intermediate values for reproducibility. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Essential VBA Modules & Public Signatures (expanded with examples, error codes, and recommended implementation patterns)</strong> <br> <strong>Design principles:</strong> Modules must be modular, testable, and return deterministic outputs for given inputs. Use JSON strings for structured returns and avoid MsgBox in core logic; UI should call wrapper functions that handle modals. Handle errors with explicit error codes and stack traces logged via <code>modLogger.LogEvent</code>. All modules should expose synchronous functions and asynchronous triggers only via orchestrator. <br><br> <strong>Core signatures & behavior:</strong> <br> • <code>modOrchestrator.RunOrchestrator(mode As String, Optional ticker As String) As String</code> <br> — Modes: <code>&quot;Interactive&quot;</code>, <code>&quot;Scheduled&quot;</code>, <code>&quot;Sandbox&quot;</code>. <br> — Behavior: check <code>RunLock</code> and <code>ValidateInputs</code>; if OK set <code>RunLock=RunID</code>, write <code>RunStart</code> to <code>Meta.Runs</code>, execute orchestrator pipeline steps (InputValidation → DataRefresh → Mapping → Transform → Valuation → SelfCheck → ExportPreparation). <br> — Return: JSON <code>{&quot;RunID&quot;:&quot;&lt;GUID&gt;&quot;,&quot;Status&quot;:&quot;Success|Failed|Partial&quot;,&quot;Errors&quot;:[{&quot;code&quot;,&quot;message&quot;}],&quot;Warnings&quot;:[...],&quot;Artifacts&quot;:[{&quot;path&quot;,&quot;sha256&quot;}]}</code>. <br> — Error handling: On any critical error write <code>modLogger.LogEvent</code> with <code>Level=ERROR</code>, set <code>Status=Failed</code> and clear <code>RunLock</code>. For partial success (e.g., PQ partial), return <code>Status=Partial</code> with <code>Warnings</code>. <br><br> • <code>modPQ.RefreshPQ(timeoutSeconds As Long) As Boolean</code> <br> — Implements retry with exponential backoff using <code>nr_PQMaxRetries</code> and logs each attempt in <code>PQ_Attempts</code> table with <code>AttemptNo</code>, <code>Status</code>, <code>ElapsedSeconds</code>, <code>Error</code>. Return <code>True</code> if at least primary datasets retrieved. <br><br> • <code>modLogger.LogEvent(RunID As String, Level As String, Component As String, Code As String, Message As String, ContextJSON As String)</code> <br> — Append-only log table <code>tblLogs</code> with <code>TimestampUTC</code>, <code>RunID</code>, <code>Level</code>, <code>Component</code>, <code>Code</code>, <code>Message</code>, <code>ContextJSON</code>. Ensure log write is robust (e.g., buffered and flushed on error). <br><br> • <code>modSelfCheck.ComputeConfidenceScore(RunID As String) As Double</code> <br> — Returns numeric score; writes <code>SelfCheck_ReasonCodes</code> and explanation text. Use deterministic calculations and store intermediate component scores for auditing. <br><br> • <code>modExport.ExportReport(RunID As String, targetPath As String) As String</code> <br> — Validates <code>targetPath</code>, checks <code>rng_ConfidenceScore</code> threshold, builds <code>manifest.json</code> (see manifest schema below), renders PDF/XLSX artifacts, computes SHA256, writes <code>Meta.Artifacts</code> row, optionally signs via HSM call. Return artifact path or raise <code>EXPORT_BLOCKED</code> with context. <br><br> <strong>Recommended implementation patterns:</strong> <br> — Use small pure functions for transforms and a single orchestrator that composes them. <br> — Avoid global mutable state; use <code>RunContext</code> object (dictionary) passed between functions. <br> — For long-running operations, implement heartbeat by updating <code>RunLockTimestamp</code> every N seconds to support orphan detection. <br> — Provide a <code>DryRun</code> flag to run all validations and compute outcomes without side-effects; used by CI and preflight checks. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Important Macros (buttons → action mapping, UI states, accessibility, and telemetry)</strong> <br> <strong>UI behavior & accessibility:</strong> Buttons should be discoverable, have keyboard shortcuts, and ARIA-equivalent tooltip metadata in <code>Meta.UI</code>. Provide visual disablement and progress state (indeterminate/progress bar) during operations. Log every UI action to <code>tblUIActions</code> with <code>User</code>, <code>Action</code>, <code>Timestamp</code>, and <code>RunID</code> when applicable. <br><br> <strong>Button behaviors:</strong> <br> • <code>btnRefresh</code> — on click: disable UI action buttons, increment <code>nr_RefreshKey</code>, set temporary <code>RunLock</code>, call <code>modOrchestrator.TriggerRefresh</code>, stream progress lines to a <code>UI_Progress</code> pane (last N=50), re-enable buttons on completion. <code>btnRefresh</code> should be debounce-protected (e.g., 3s). <br> • <code>btnRun</code> — triggers <code>RunOrchestrator(&quot;Interactive&quot;)</code>; before run show <code>PreRunSummary</code> modal (inputs snapshot and key derived indicators). If <code>ValidateInputs</code> fails, show error and abort. <br> • <code>btnExport</code> — visible and enabled only if <code>rng_ConfidenceScore &gt;= Meta.MinConfidenceToExport</code> and <code>rng_*</code> outputs not <code>N/A</code>. On click runs <code>modExport.ExportReport</code>; show progress and final artifact link. If export blocked, show <code>CollectDiagnostics</code> modal prepopulated with suggested attachments. <br> • <code>btnCollectDiagnostics</code> — packages <code>Logs</code>, <code>Samples</code>, <code>PQ_Status</code>, <code>Mapping</code> into <code>{TICKER}_Diag_{RunID}.zip</code> and uploads to <code>Meta.DiagnosticStoragePath</code> or returns file path for manual attachment; recommended to include an automated ticket creation helper that uses <code>Meta.SupportContact</code>. <br><br> <strong>Telemetry & metrics:</strong> Track <code>button_clicks</code>, <code>run_durations</code>, <code>export_success_rate</code>, <code>pq_failure_rate</code>. Surface these metrics in <code>Meta.HealthDashboard</code>. Use them for SLO reporting. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Log Codes (top-level), mapping to playbook actions, and automation rules</strong> <br> <strong>Structure & classification:</strong> Log codes use hierarchical naming <code>CATEGORY_SUBCATEGORY_DETAIL</code> with severity implied by suffix mapping. Always include <code>ContextJSON</code> with <code>RunID</code>, <code>QueryID</code>, <code>SampleRef</code>, and minimal stack trace if applicable. <br><br> <strong>Common codes & remediation playbooks:</strong> <br> • <code>VAL_MISSING</code> — missing required input. <em>Remediation:</em> Run <code>ValidateInputs</code> UI, prompt user to fill required fields, re-run. <br> • <code>VAL_RANGE</code> — input out of allowable range. <em>Remediation:</em> Suggest nearest allowed value in <code>ValidateInputs</code> fixes. <br> • <code>PQ_TIMEOUT</code> — PQ call timed out after retries. <em>Remediation:</em> capture raw payload to <code>Samples</code>, increase timeout if transient, escalate to provider if persistent. <br> • <code>PQ_SCHEMA_CHANGE</code> — provider removed/renamed fields. <em>Remediation:</em> snapshot <code>RawPayload</code> to <code>Samples</code>, create <code>Mapping</code> entry for new fields, mark failing queries as <code>Blocked</code> until mapping updated. <br> • <code>DQ_MISSING</code> — data quality missing values. <em>Remediation:</em> run repair transforms or flag as <code>AcceptMissing</code> with reason; reduce <code>rng_ConfidenceScore</code>. <br> • <code>DQ_OUTLIER</code> — statistical outlier detected. <em>Remediation:</em> run <code>Winsorize</code> or manual review and document corrective transform. <br> • <code>TV_GUARD_FAIL</code> — terminal value guard. <em>Remediation:</em> review WACC and TermGrowth inputs; document justification if overriding. <br> • <code>EXPORT_BLOCKED</code> — export prevented by guards or path issues. <em>Remediation:</em> check <code>rng_ConfidenceScore</code>, <code>nr_ExportPath</code> writable, and <code>rng_*</code> statuses. <br><br> <strong>Automation rules & routing:</strong> Use a rules engine to automatically route high-severity errors (e.g., <code>FATAL</code>, <code>TV_GUARD_FAIL</code>) to <code>Meta.Oncall</code> via email/pager and attach <code>CollectDiagnostics</code> bundle. Lower severity logs can create tickets in a backlog queue. Logs are retention-controlled and archived to <code>Meta.ArchivePath</code> after <code>Meta.LogRetentionDays</code>. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Run Modes & Locking — full behavior, heartbeat, orphan detection, takeover, and resume semantics</strong> <br> <strong>Run modes:</strong> <br> • <code>Interactive</code> — user-initiated, UI-visible; runs with current credentials and interactive error handling. <br> • <code>Scheduled</code> — runs under a service account with restricted permissions; uses <code>nr_RefreshKey</code> for change detection. <br> • <code>Sandbox</code> — offline, uses <code>Samples</code> only; network calls disabled; intended for CI and reproducible tests. <br><br> <strong>Locking & concurrency model:</strong> <br> • <code>RunLock</code> named range stores <code>RunID</code> when a run is active. Also store <code>RunLockOwner</code> (user or service account), <code>RunLockTimestamp</code>, and <code>RunLockHeartbeat</code> which is updated periodically (default every 30s). <br> • <code>RunLockTimeout</code> (configurable) controls when a lock is considered orphaned. If <code>RunLockTimestamp</code> older than <code>nr_RunLockTimeout</code>, orchestrator marks <code>RunLockOrphan=true</code> and notifies <code>Meta.Oncall</code>. <br><br> <strong>Orphan handling & takeover:</strong> <br> • Automated takeover allowed only if <code>AutoTakeover=true</code> and <code>RunLockTimestamp</code> older than <code>nr_AutoTakeoverDelay</code> (default 2×RunLockTimeout). <br> • Before takeover, require <code>AuditCheck</code> that compares <code>Meta.Runs[RunID].LastStep</code> to <code>ResumableCheckpoints</code> to determine safe resume point. If safe resume possible, new run resumes from last checkpoint; otherwise abort and require manual intervention. <br><br> <strong>Checkpointing & resume:</strong> <br> • Orchestrator writes periodic checkpoints to <code>ResumableRuns</code> with <code>RunID</code>, <code>LastCompletedStep</code>, <code>StateHash</code>, and <code>CheckpointData</code> (serialized minimal state). On resume, orchestrator validates <code>StateHash</code> against current environment and attempts resume if validated. <br><br> <strong>Observability:</strong> <br> • Monitor <code>RunLock</code> events: acquisitions, releases, heartbeats missed, or orphan detections. Surface metrics to <code>Meta.HealthDashboard</code> and alert when heartbeat missed > 3 intervals. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Defaults & Safety Guards — comprehensive list, rationale, and override patterns</strong> <br> <strong>Default values & rationale:</strong> <br> • <code>nr_MOS</code> = 30%: conservative default to account for model and data risk. <br> • <code>nr_PQMaxRetries</code> = 3 & <code>nr_PQBackoffSeconds</code> = 5: balance retry aggressiveness with not overloading providers. <br> • <code>TV_EPSILON</code> = 0.002 (0.2%): minimal buffer to prevent near-equal WACC/TermGrowth scenarios. <br> • <code>nr_RunLockTimeout</code> = 1800s: typical tolerance for UI-run interruptions. <br> • <code>rng_ConfidenceThreshold</code> = 50/100: default threshold to gate exports. <br><br> <strong>Guard rules & enforcement:</strong> <br> • Terminal value guard: require <code>nr_WACC &gt; nr_TermGrowth + TV_EPSILON</code>, else block DCF and flag <code>TV_GUARD_FAIL</code>. <br> • Stale market data guard: require <code>MarketDate &gt;= UTCNow - nr_StalePriceDays</code>; otherwise set <code>StalePrice</code> and penalize confidence score. <br> • Shares outstanding guard: if <code>SharesOutstanding &lt;= 0</code> block per-share computations and log <code>VAL_ZERO_SHARES</code>. <br> • Missing history guard: if <code>tblFinancials</code> coverage < <code>nr_MinLookbackYears</code> block projections and recommend <code>Proxy</code> methods; log <code>VAL_INSUFFICIENT_HISTORY</code>. <br><br> <strong>Override patterns:</strong> <br> • Manual overrides must be recorded in <code>Meta.Overrides</code> table with <code>OverrideID</code>, <code>Field</code>, <code>OldValue</code>, <code>NewValue</code>, <code>Reason</code>, <code>Author</code>, <code>ApprovedBy</code>, <code>Timestamp</code>. <br> • Overrides may be temporary or permanent; temporary overrides auto-expire after <code>OverrideTTL</code> (default 30 days). <br> • Any override affecting valuation must require a reviewer and write <code>Override_Rationale</code> into exported <code>manifest.json</code>. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Export Filename, Folder Layout, Manifest schema, signing, retention, and verification</strong> <br> <strong>Filename & folder pattern:</strong> <br> • Filename: <code>{TICKER}_Report_{YYYYMMDD}_{HHMM}_v{nr_Version}.pdf</code> sanitized to alnum+hyphen. <br> • Folder layout: <code>{nr_ExportPath}/{TICKER}/{YYYY}/{MM}/{RunID}/</code> containing artifacts, <code>manifest.json</code>, <code>logs.zip</code>, and <code>signature.sig</code> if signed. <br><br> <strong>manifest.json schema (recommended):</strong> <br> ``<code>json { &quot;run_id&quot;:&quot;&lt;GUID&gt;&quot;, &quot;ticker&quot;:&quot;&lt;TICKER&gt;&quot;, &quot;generated_on&quot;:&quot;2026-01-16T14:22:00Z&quot;, &quot;inputs_snapshot&quot;:{&quot;nr_WACC&quot;:0.085,&quot;nr_TermGrowth&quot;:0.02,&quot;...&quot;:&quot;...&quot;}, &quot;artifacts&quot;:[{&quot;path&quot;:&quot;report.pdf&quot;,&quot;sha256&quot;:&quot;&lt;hex&gt;&quot;,&quot;size_bytes&quot;:12345,&quot;type&quot;:&quot;pdf&quot;}], &quot;rng_outputs&quot;:{&quot;rng_DCF_PerShare&quot;:123.45,&quot;rng_AvgFairPrice&quot;:120.00}, &quot;provenance&quot;:{&quot;model_version&quot;:&quot;v1.2.3&quot;,&quot;computation_hash&quot;:&quot;&lt;hex&gt;&quot;}, &quot;signing&quot;:{&quot;signed&quot;:true,&quot;signer&quot;:&quot;HSM-Ref-1234&quot;,&quot;signature_path&quot;:&quot;signature.sig&quot;}, &quot;notes&quot;:&quot;Auto-exported via orchestrator&quot; } </code>`<code> &lt;br&gt;&lt;br&gt; **Signing &amp; verification:** &lt;br&gt; • Recommended: sign the artifact or manifest using an enterprise HSM/EVCert. Store signature reference in </code>Meta.Artifacts<code>. &lt;br&gt; • Verification: </code>VerifyArtifact(path, signature)<code> verifies SHA256 and signature chain; status recorded in </code>Meta.ArtifactVerifications<code>. &lt;br&gt;&lt;br&gt; **Retention &amp; housekeeping:** &lt;br&gt; • </code>Meta.RetentionDays<code> default 365. &lt;br&gt; • Daily housekeeping deletes artifacts older than retention unless </code>Signed=true<code> or </code>Permanent=true<code>; soft-delete to </code>ArchivePath<code> for 90 days then purge. &lt;br&gt;&lt;br&gt; **Export failure modes &amp; remediation:** &lt;br&gt; • </code>EXPORT_BLOCKED<code> due to </code>rng_ConfidenceScore<code> below threshold → fix inputs/data or explicitly approve override stored in </code>Meta.Overrides<code>. &lt;br&gt; • Filesystem errors → attempt fallback to </code>Meta.FallbackExportPath<code> and notify </code>Meta.Oncall`. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Signing & verification:</strong> <br> • Recommended: sign the artifact or manifest using an enterprise HSM/EVCert. Store signature reference in <code>Meta.Artifacts</code>. <br> • Verification: <code>VerifyArtifact(path, signature)</code> should verify SHA256 and signature chain; verification status recorded in <code>Meta.ArtifactVerifications</code>. <br><br> <strong>Retention & housekeeping:</strong> <br> • <code>Meta.RetentionDays</code> default 365. <br> • Housekeeping job runs daily to delete artifacts older than retention unless <code>Signed=true</code> or <code>Permanent=true</code>. Deleted artifacts are soft-deleted to <code>ArchivePath</code> for 90 days then purged. <br><br> <strong>Export failure modes & remediation:</strong> <br> • <code>EXPORT_BLOCKED</code> due to <code>rng_ConfidenceScore</code> below threshold → either fix inputs/data or explicitly approve override stored in <code>Meta.Overrides</code>. <br> • Filesystem errors → attempt fallback to <code>Meta.FallbackExportPath</code> and notify <code>Meta.Oncall</code>. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>RunTests / CI Commands, expected artifacts, gating rules, and reproducibility</strong> <br> <strong>Purpose:</strong> <code>RunTests</code> executes orchestrator in <code>Sandbox</code> using <code>Samples</code> only and validates deterministic behavior, schema integrity, regressions, and quality gates before releasing artifacts. <br><br> <strong>Local/CI sequence (detailed):</strong> <br> 1. <code>rubberduck lint</code> — static code checks for VBA. <br> 2. <code>vba_unit_tests</code> — unit tests for helper functions; fail fast on errors. <br> 3. <code>modOrchestrator.RunOrchestrator &quot;Sandbox&quot;</code> — run with network disabled and <code>Samples</code> preloaded. <br> 4. <code>generate_tests_report</code> — aggregates unit, integration, and DQ results into <code>tests_report.html</code>. <br> 5. <code>compare_baseline</code> — compute diffs against baseline snapshots stored in <code>Samples/Baselines</code>. <br> 6. <code>sign_and_publish</code> — sign artifacts if gates pass. <br><br> <strong>Artifacts produced:</strong> <code>tests_report.html</code>, <code>diffs/*.json</code> (input->output diffs), <code>report_snapshots/*.pdf</code>, <code>artifacts_manifest.json</code>, <code>ci_metadata.json</code> (CI run details). <br><br> <strong>Gating rules:</strong> <br> • Fail CI if any <code>High</code> severity <code>DQ_*</code> or <code>TV_GUARD_FAIL</code>. <br> • Fail CI if <code>rng_ConfidenceScore</code> drops below <code>Meta.MinConfidenceForRelease</code>. <br> • Warn on minor regressions and require manual sign-off. <br><br> <strong>Reproducibility:</strong> <br> • All runs must include <code>InputsSnapshot</code> and <code>ComputationHash</code> to allow byte-for-byte reproduction. <br> • <code>Samples</code> must be immutable for CI runs; any change to <code>Samples</code> requires a <code>Meta.SampleChangeLog</code> entry and a new baseline. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Top Troubleshooting Steps (expanded triage, commands, and examples)</strong> <br> <strong>Fast triage flow:</strong> <br> 1) Reproduce failure locally in <code>Sandbox</code> using the failing <code>RunID</code>'s <code>InputsSnapshot</code>. <br> 2) Re-run raw PQ query in PQ Editor; save the raw payload to <code>Samples</code> and compute SHA256. <br> 3) Inspect <code>tblLogs</code> for earliest <code>ERROR</code>/<code>WARN</code> correlated by <code>QueryID</code> and <code>RunID</code>. <br> 4) Validate <code>Mapping</code> for schema drift; attempt minimal transform and re-run mapping step. <br> 5) Run <code>modSelfCheck</code> to compute reasons for low confidence; apply fixes (data ingestion, mapping, override) and re-run. <br><br> <strong>Diagnostic commands & artifacts to collect:</strong> <br> • <code>CollectDiagnostics(RunID)</code> → produces <code>{TICKER}_Diag_{RunID}.zip</code> containing <code>logs.csv</code>, <code>samples/</code>, <code>pq_payloads/</code>, <code>mapping_snapshot.csv</code>, <code>rng_outputs.json</code>, <code>manifest.json</code>. <br> • Attach diagnostics to ticketing system with <code>TicketCreate(Title, Description, AttachmentPath, Priority)</code>. <br><br> <strong>Common scenarios & fixes:</strong> <br> • PQ timeout: increase <code>nr_PQTimeoutSeconds</code> for provider slow responses, or optimize query to select fewer fields. <br> • Schema change: update <code>Mapping</code>, create transform in PQ or VBA, re-run. <br> • Bad FX rates: fallback to alternate provider, mark <code>FX_FALLBACK</code> and log impact on <code>rng_DCF_PerShare</code>. <br> • Zero shares outstanding: check corporate actions; if split/merge occurred, apply share adjustment transform and re-compute. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Maintenance & Release Checklist (practical, prescriptive steps)</strong> <br> <strong>Pre-release:</strong> <br> 1) Ensure all unit tests pass and <code>RunTests</code> in <code>Sandbox</code> completed successfully. <br> 2) Bump <code>nr_Version</code> and update <code>Meta.ChangeLog</code> with PR link and release notes. <br> 3) Export PQ M scripts and VBA modules to <code>repo/src/</code> and create a commit. <br> 4) Build unsigned <code>.xlsm</code> artifact. <br> 5) Run <code>integration_smoke_tests</code> and validate that <code>rng_ConfidenceScore</code> >= threshold. <br><br> <strong>Signing & publish:</strong> <br> 1) Invoke <code>sign_artifact</code> with HSM; record <code>SignerRef</code> and <code>Signature</code>. <br> 2) Upload artifacts to <code>Meta.ArtifactStore</code> and write manifest with <code>sha256</code>. <br> 3) Update <code>Meta.ReleaseNotes</code> and notify <code>Meta.SupportContact</code> and stakeholders. <br><br> <strong>Post-release:</strong> <br> 1) Monitor <code>export_success_rate</code> and <code>pq_failure_rate</code> for 48–72 hours. <br> 2) If anomalies found, open a postmortem and document in <code>Meta.Postmortems</code>. <br> 3) Backfill any missing <code>Samples</code> or provenance if discovered later. </td></tr><tr><td data-label="Quick Reference — Comprehensive"> <strong>Contact & Escalation (fields, templates, automated flows)</strong> <br> <strong>Fields to populate in <code>Meta</code>:</strong> <code>Meta.SupportContact</code>, <code>Meta.Owner</code>, <code>Meta.SLA</code>, <code>Meta.Oncall</code> (list), <code>Meta.EscalationMatrix</code> (P1→P2→P3 contacts), <code>Meta.IncidentRunbookPath</code>. <br><br> <strong>Automated paging rules:</strong> <br> • P1: <code>EXPORT_BLOCKED</code> for >1 critical client in 1h or <code>TV_GUARD_FAIL</code> for top-tier tickers → immediate page to primary oncall and create P1 ticket with <code>CollectDiagnostics</code>. <br> • P2: sustained PQ failures (>10% requests failing in 1h) → page secondary oncall, create ticket. <br><br> <strong>Email/ticket templates (example):</strong> <br> Subject: <code>[P1] Orchestrator Failure - {TICKER} - {RunID}</code> <br> Body (auto-populated): includes <code>RunID</code>, <code>Timestamp</code>, <code>TopErrors</code>, <code>AttachedDiagnostics</code> (link), <code>ImmediateImpact</code>, <code>SuggestedNextSteps</code>. <br><br> <strong>Oncall rotation & handoff:</strong> <br> • Store <code>Meta.Oncall</code> entries as objects with <code>start</code>, <code>end</code>, <code>pager</code>, and <code>backup</code>. Handoffs are recorded in <code>Meta.OncallHistory</code>. <br> • After action, update ticket with <code>Resolution</code>, <code>RootCause</code>, and <code>PostmortemLink</code> if applicable. </td></tr></tbody></table></div><div class="row-count">Rows: 14</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>