<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1764452135">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li>
<li class="toc-item"><a class="toc-link" href="#Table6">Table 6</a></li>
<li class="toc-item"><a class="toc-link" href="#Table7">Table 7</a></li>
<li class="toc-item"><a class="toc-link" href="#Table8">Table 8</a></li>
<li class="toc-item"><a class="toc-link" href="#Table9">Table 9</a></li>
<li class="toc-item"><a class="toc-link" href="#Table10">Table 10</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0118_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Area**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Area</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by TV Behavior" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">TV Behavior</div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by PTT Behavior" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">PTT Behavior</div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Logger namespace</strong></div></div></td><td data-label="TV Behavior"> <code>render.convert</code> </td><td data-label="PTT Behavior"> <code>convert</code> </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Markdown renderer import</strong></div></div></td><td data-label="TV Behavior"> <code>from .markdown import get_markdown_renderer</code> </td><td data-label="PTT Behavior"> <code>from markdown import get_markdown_renderer</code> </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Heading id location</strong></div></div></td><td data-label="TV Behavior"> <code>&lt;h3 id="table-{idx}" class="table-heading"&gt;</code> </td><td data-label="PTT Behavior"> Caption <code>id="Table{idx}"</code>; wrapper <code>data-table-id="table-{idx}"</code> </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Wrapper metadata</strong></div></div></td><td data-label="TV Behavior"> Minimal: <code>data-table-id</code> </td><td data-label="PTT Behavior"> Extra: <code>data-table-id</code>, <code>data-table-index</code>, <code>data-table-alignments</code>, <code>table-caption</code> </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Title generation</strong></div></div></td><td data-label="TV Behavior"> Normalizes via TV pipeline                        </td><td data-label="PTT Behavior"> Normalizes differently; slight mismatches on newline/markup                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Heading-text normalization</strong></div></div></td><td data-label="TV Behavior"> Matches JS rules                                  </td><td data-label="PTT Behavior"> Different sanitizer; no explicit match to JS tokenizer                               </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>_escape_unmatched_markers</strong></div></div></td><td data-label="TV Behavior"> Conservative; often returns raw                   </td><td data-label="PTT Behavior"> Escapes `<code> </code> `<code> → </code>|` outside code/pre                                               </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>single_newline_to_br</strong></div></div></td><td data-label="TV Behavior"> Supported flag                                    </td><td data-label="PTT Behavior"> No equivalent flag; fixed behavior                                                   </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>_split_row_keep_code</strong></div></div></td><td data-label="TV Behavior"> Canonical version; outer-empty-cell logic cleaner </td><td data-label="PTT Behavior"> Same logic but minor differences in trimming / ordering                              </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>CSV autodetect (<code>_looks_like_csv</code>)</strong></div></div></td><td data-label="TV Behavior"> Rejects CSV if any <code>,</code> present                </td><td data-label="PTT Behavior"> Earlier ratio check; slightly different heuristics                               </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>sanitize_bold_html</strong></div></div></td><td data-label="TV Behavior"> TV variant (cleaner, tighter regex)               </td><td data-label="PTT Behavior"> Slightly different fallback rules                                                    </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Error/log granularity</strong></div></div></td><td data-label="TV Behavior"> More debug samples logged                         </td><td data-label="PTT Behavior"> Some errors swallowed silently                                                       </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Pandas integration</strong></div></div></td><td data-label="TV Behavior"> Sets <code>_table_alignments</code> consistently             </td><td data-label="PTT Behavior"> Sets attributes differently; sometimes missing                                       </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Alignment metadata</strong></div></div></td><td data-label="TV Behavior"> Canonical DataFrame attribute                     </td><td data-label="PTT Behavior"> <code>data-table-alignments</code> CSV string on wrapper                                        </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Left-column heading hook</strong></div></div></td><td data-label="TV Behavior"> TV canonical variant                              </td><td data-label="PTT Behavior"> Slightly different fallbacks, same intent                                            </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Unicode cleanup</strong></div></div></td><td data-label="TV Behavior"> Removes BOM, NBSP, ZW chars via TV flow           </td><td data-label="PTT Behavior"> Similar but not identical code path                                                  </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>High-level API</strong></div></div></td><td data-label="TV Behavior"> <code>extract_tables_debug</code> + helpers                  </td><td data-label="PTT Behavior"> Adds <code>convert_structure</code>, <code>convert_text_to_html</code> </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>TOC friendliness</strong></div></div></td><td data-label="TV Behavior"> Fully JS-compatible (<code>.table-heading</code>)            </td><td data-label="PTT Behavior"> Heading id missing; caption id incompatible for TOC                                  </td></tr></tbody></table></div><div class="row-count">Rows: 18</div></div><div class="table-caption" id="Table2" data-table="Docu_0118_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Area**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Area</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **TV Behavior (reference)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>TV Behavior (reference)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **PTT Behavior (post-patch)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>PTT Behavior (post-patch)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Logger namespace</strong></div></div></td><td data-label="TV Behavior (reference)"> <code>render.convert</code> (namespaced for TV) </td><td data-label="PTT Behavior (post-patch)"> <code>convert</code> (left as PTT; unchanged) </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Markdown renderer import</strong></div></div></td><td data-label="TV Behavior (reference)"> <code>from .markdown import get_markdown_renderer</code> (project-local) </td><td data-label="PTT Behavior (post-patch)"> <code>from markdown import get_markdown_renderer</code> fallback; <code>_get_default_markdown_renderer</code> preserved </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Heading / caption placement</strong></div></div></td><td data-label="TV Behavior (reference)"> Visible heading emitted inside <code>.table-heading-bar</code> as <code>&lt;h3 id="table-{idx}" class="table-heading"&gt;</code> </td><td data-label="PTT Behavior (post-patch)"> Caption external as <code>&lt;div class="table-caption" id="Table{idx}"&gt;</code>; wrapper keeps <code>data-table-id="table-{idx}"</code> </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Wrapper metadata attributes</strong></div></div></td><td data-label="TV Behavior (reference)"> Minimal: <code>data-table-id</code> </td><td data-label="PTT Behavior (post-patch)"> Extended: <code>data-table-id</code>, <code>data-table-index</code>, <code>data-table-alignments</code>, caption element </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Title generation</strong></div></div></td><td data-label="TV Behavior (reference)"> <code>Topic</code> for single table; <code>Table {idx}</code> otherwise </td><td data-label="PTT Behavior (post-patch)"> Same rules; external caption preferred when no explicit title </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Heading-text normalization</strong></div></div></td><td data-label="TV Behavior (reference)"> TV tokenizer rules </td><td data-label="PTT Behavior (post-patch)"> Improved normalization (typo map, NBSP removal) but not identical to TV tokenizer </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Inline-code stash/restore</strong></div></div></td><td data-label="TV Behavior (reference)"> Placeholder stash/restore (<code>\x00CODE{n}\x00</code>) </td><td data-label="PTT Behavior (post-patch)"> Same mechanism in PTT </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Pipe-splitting logic</strong></div></div></td><td data-label="TV Behavior (reference)"> <code>_split_row_keep_code</code>: splits on unescaped <code>|</code>, restores code </td><td data-label="PTT Behavior (post-patch)"> Same algorithm; PTT whitespace trimming preserved </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Divider grammar</strong></div></div></td><td data-label="TV Behavior (reference)"> <code>_DIVIDER_PART_RE</code> strict <code>:?-{1,}\:?</code> </td><td data-label="PTT Behavior (post-patch)"> Same regex </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Markdown table parser</strong></div></div></td><td data-label="TV Behavior (reference)"> Detects header+divider, pads ragged rows, ignores escaped pipes in code </td><td data-label="PTT Behavior (post-patch)"> TV-style logic ported; PTT return shape preserved </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>CSV autodetect heuristic</strong></div></div></td><td data-label="TV Behavior (reference)"> Conservative: rejects CSV if pipe-dominated </td><td data-label="PTT Behavior (post-patch)"> PTT keeps earlier heuristic; integrated with TV fallback </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>CSV parsing (<code>parse_csv_tables</code>)</strong></div></div></td><td data-label="TV Behavior (reference)"> <code>csv.Sniffer</code>, fallback to delimiter candidates </td><td data-label="PTT Behavior (post-patch)"> Same parser; same return shape </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong><code>extract_tables_debug</code> behavior</strong></div></div></td><td data-label="TV Behavior (reference)"> Pipe tables first, CSV fallback second </td><td data-label="PTT Behavior (post-patch)"> Same control flow; adds PTT metadata for alignments </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Pandas integration</strong></div></div></td><td data-label="TV Behavior (reference)"> Creates <code>DataFrame</code>, sets alignment attribute </td><td data-label="PTT Behavior (post-patch)"> Same behavior; <code>_SimpleDF</code> fallback </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Alignment metadata in DOM</strong></div></div></td><td data-label="TV Behavior (reference)"> Minimal DOM attrs </td><td data-label="PTT Behavior (post-patch)"> Writes <code>data-table-alignments</code> for robustness </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Left-column heading hook</strong></div></div></td><td data-label="TV Behavior (reference)"> TV applies <code>_apply_left_col_heading</code> </td><td data-label="PTT Behavior (post-patch)"> PTT keeps hook (noop when absent) </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Bold/italic sanitizer</strong></div></div></td><td data-label="TV Behavior (reference)"> <code>sanitize_bold_html</code> </td><td data-label="PTT Behavior (post-patch)"> Same fallback; differences possible </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Escape unmatched markers</strong></div></div></td><td data-label="TV Behavior (reference)"> Conservative <code>_escape_unmatched_markers</code> </td><td data-label="PTT Behavior (post-patch)"> Ported TV-like behavior </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Single-newline handling</strong></div></div></td><td data-label="TV Behavior (reference)"> Optional flag <code>single_newline_to_br</code> </td><td data-label="PTT Behavior (post-patch)"> PTT converts single newlines during preprocessing </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Numbered list handling</strong></div></div></td><td data-label="TV Behavior (reference)"> Full support (<code>1.</code>, <code>1)</code>, <code>1:</code>), nested lists </td><td data-label="PTT Behavior (post-patch)"> PTT canonicalizes markers; nested lists → real <code>&lt;ol&gt;</code> </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Bullet list normalization</strong></div></div></td><td data-label="TV Behavior (reference)"> Normalizes many bullet chars to <code>- </code> </td><td data-label="PTT Behavior (post-patch)"> Same normalization set </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Nested lists and continuations</strong></div></div></td><td data-label="TV Behavior (reference)"> Respects indentation; skips fenced code </td><td data-label="PTT Behavior (post-patch)"> Same logic in PTT </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Fenced code &amp; inline code inside lists</strong></div></div></td><td data-label="TV Behavior (reference)"> Preserved by stash/restore </td><td data-label="PTT Behavior (post-patch)"> Same behavior </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Escaped pipe behavior (<code>\|</code>)</strong></div></div></td><td data-label="TV Behavior (reference)"> Preserved as literal <code>|</code> </td><td data-label="PTT Behavior (post-patch)"> Same in PTT </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>BOM / typographic cleanup</strong></div></div></td><td data-label="TV Behavior (reference)"> Removes BOM, NBSP, ZW; maps quotes </td><td data-label="PTT Behavior (post-patch)"> Same typomap applied </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Error/log verbosity</strong></div></div></td><td data-label="TV Behavior (reference)"> More granular debug logs (<code>render.convert</code>) </td><td data-label="PTT Behavior (post-patch)"> PTT keeps existing logging; some exceptions swallowed </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>API surface / function names</strong></div></div></td><td data-label="TV Behavior (reference)"> <code>parse_markdown_tables</code>, <code>parse_csv_tables</code>, <code>render_table</code>, <code>extract_tables_debug</code> </td><td data-label="PTT Behavior (post-patch)"> Same; plus PTT helpers <code>convert_structure</code>, <code>convert_text_to_html</code> </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Return shapes</strong></div></div></td><td data-label="TV Behavior (reference)"> Lists for parse, string for render, tuple for debug </td><td data-label="PTT Behavior (post-patch)"> Same shapes </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Backward compatibility / consumers</strong></div></div></td><td data-label="TV Behavior (reference)"> Minimal DOM changes </td><td data-label="PTT Behavior (post-patch)"> Metadata-rich DOM preserved for PTT consumers </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Performance considerations</strong></div></div></td><td data-label="TV Behavior (reference)"> Fewer DOM attrs </td><td data-label="PTT Behavior (post-patch)"> Slightly heavier DOM; parsing paths optimized </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Tests &amp; determinism</strong></div></div></td><td data-label="TV Behavior (reference)"> Stable under edge cases </td><td data-label="PTT Behavior (post-patch)"> Now aligned with TV; deterministic CSV fallback </td></tr></tbody></table></div><div class="row-count">Rows: 31</div></div><div class="table-caption" id="Table3" data-table="Docu_0118_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Area**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Area</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **core_renderer.py (before revision)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>core_renderer.py (before revision)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **core_renderer.py (after revision)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>core_renderer.py (after revision)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Caption-injection gate</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Injection runs under multiple call paths; no strict check tied to <code>request_ctx.action=="load_group"</code>.              </td><td data-label="core_renderer.py (after revision)"> Injection <strong>only</strong> executes when <code>request_ctx.action=="load_group"</code> and <code>meta.source=="group_load"</code>. All other request types skip injection entirely. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Fragment meta handling</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Caption fragments not consistently marked; downstream renderer cannot reliably know if injection already occurred. </td><td data-label="core_renderer.py (after revision)"> Every injected caption fragment is stamped <code>meta.injected=true</code>, enabling <code>html_renderer</code> gating for payload emission.                                </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-meta augmentation</strong></div></div></td><td data-label="core_renderer.py (before revision)"> <code>table_meta</code> often missing caption IDs; client script must infer or recompute.                                     </td><td data-label="core_renderer.py (after revision)"> Explicit stable caption IDs attached (<code>caption_ids</code>, <code>caption_seq</code>, <code>stable_block_id</code>) so client <code>script.core.js</code> can inject deterministically.       </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Stable-ID propagation</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Relies on upstream modules; renderer does not verify integrity.                                                    </td><td data-label="core_renderer.py (after revision)"> Validates presence of stable IDs created by <code>core_fragments.CaptionFragment.create()</code>; repairs missing IDs defensively.                               </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Multi-fragment grouping</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Sequential text blocks sometimes merged incorrectly; renderer may flatten separate caption groups.                 </td><td data-label="core_renderer.py (after revision)"> Groups CaptionBlocks by <code>group_id</code> and preserves ordering; multi-caption groups stay stable across full round-trip.                                   </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Order of operations</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Sanitization assumed; no guarantee caption HTML is safe before injection.                                          </td><td data-label="core_renderer.py (after revision)"> Injection performed <strong>after</strong> <code>sanitize_caption_html()</code> and after table ID assignment, ensuring safe, correct placement.                              </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Duplicate-injection defense</strong></div></div></td><td data-label="core_renderer.py (before revision)"> No guard; a repeated render pass can produce duplicated <code>&lt;script data-caption-payload&gt;</code>.                           </td><td data-label="core_renderer.py (after revision)"> Hard guard: if any fragment has <code>meta.injected==true</code>, renderer suppresses a second injection.                                                        </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Output hook for html_renderer</strong></div></div></td><td data-label="core_renderer.py (before revision)"> html_renderer cannot reliably detect caption payload and may omit needed <code>&lt;script&gt;</code> block.                         </td><td data-label="core_renderer.py (after revision)"> Clear contract: html_renderer checks <code>meta.injected==true</code> → emits payload; otherwise emits none.                                                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Payload emission shape</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Payload shape inconsistent; client sometimes receives flat lists without context.                                  </td><td data-label="core_renderer.py (after revision)"> Unified payload: <code>{table_id, caption_html, caption_ids, group_id, source, order}</code> ensuring 1-to-1 mapping with client injector logic.                 </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-ID consistency</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Some tables missing <code>data-table-id</code>; client resolver fails.                                                        </td><td data-label="core_renderer.py (after revision)"> Uses <code>core_table.ensure_table_id()</code> output, required before injection; guaranteed presence of unique DOM IDs.                                         </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Cross-file coordination</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Renderer unaware of upstream <code>source="group_load"</code>; behavior inconsistent when called from <code>/convert</code>.             </td><td data-label="core_renderer.py (after revision)"> Honors full server→convert→sanitize→fragments→renderer pipeline; <code>/convert</code> path never gets caption injection.                                        </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Logging clarity</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Logging scattered; cannot trace caption lifecycle across modules.                                                  </td><td data-label="core_renderer.py (after revision)"> Namespaced logs for injection begin/end, caption grouping, gating decisions, duplicate suppression.                                                   </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Failure mode behavior</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Missing meta fields (source, stable_id, caption_seq) cause silent mis-renders.                                     </td><td data-label="core_renderer.py (after revision)"> Defensive defaults and explicit warnings; table rendered cleanly even if caption payload must be skipped.                                             </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Return surface</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Rendered HTML only; caption payload emitted indirectly.                                                            </td><td data-label="core_renderer.py (after revision)"> Rendered HTML + explicit <code>caption_payloads</code> block injected into DOM via <code>&lt;script data-caption-payload&gt;…&lt;/script&gt;</code>.                                    </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Client compatibility (script.core.js)</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Client responsible for guessing caption order; unstable results.                                                   </td><td data-label="core_renderer.py (after revision)"> Guarantees deterministic order; <code>window.PTT.injectCaptions()</code> receives stable payload matching server computation.                                    </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Backward compatibility</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Existing behavior leads to duplicated captions in multi-render paths.                                              </td><td data-label="core_renderer.py (after revision)"> Fully backward compatible with older consumers; new gating prevents regression in <code>/convert</code> or non-group page loads.                                 </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Project-safety guarantee</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Renderer sometimes mutates input structures, breaking downstream table renderers.                                  </td><td data-label="core_renderer.py (after revision)"> Pure-function style: no mutation of upstream raw blocks; only enriched metadata surfaces.                                                             </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><div class="table-caption" id="Table4" data-table="Docu_0118_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Area**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Area</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **core_renderer.py (before revision)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>core_renderer.py (before revision)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **core_renderer.py (after revision)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>core_renderer.py (after revision)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Caption-injection gate</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Injection may run under multiple call paths; no strict check tied to <code>request_ctx.action=="load_group"</code>.      </td><td data-label="core_renderer.py (after revision)"> Injection <strong>only</strong> executes when <code>request_ctx.action=="load_group"</code> <strong>and</strong> <code>meta.source=="group_load"</code>. All other request types skip injection. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Fragment meta handling</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Caption fragments not consistently marked; downstream renderer cannot know if injection has already occurred. </td><td data-label="core_renderer.py (after revision)"> Each injected caption fragment is stamped <code>meta.injected=true</code>, enabling reliable html_renderer gating.                                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-meta augmentation</strong></div></div></td><td data-label="core_renderer.py (before revision)"> <code>table_meta</code> sometimes missing caption IDs; client must infer or recompute.                                   </td><td data-label="core_renderer.py (after revision)"> Attaches explicit stable IDs (<code>caption_ids</code>, <code>caption_seq</code>, <code>stable_block_id</code>) for deterministic client-side injection.                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Stable-ID propagation</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Assumes upstream modules provide IDs; renderer does not verify or repair missing data.                        </td><td data-label="core_renderer.py (after revision)"> Verifies stable IDs from <code>core_fragments.CaptionFragment.create()</code> and patches missing IDs defensively.                                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Multi-fragment grouping</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Sequential CaptionBlocks may collapse or merge incorrectly during render.                                     </td><td data-label="core_renderer.py (after revision)"> Groups CaptionBlocks by <code>group_id</code> and preserves order; multi-caption groups remain stable across round-trips.                                   </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Order of operations</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Assumes sanitization and table-ID setup are done; injection may occur too early.                              </td><td data-label="core_renderer.py (after revision)"> Injection happens strictly <strong>after</strong> sanitization and after table-ID assignment, ensuring correct, safe placement.                               </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Duplicate-injection defense</strong></div></div></td><td data-label="core_renderer.py (before revision)"> No guard against double processing; repeat renders can output duplicated <code>&lt;script&gt;</code> payloads.                 </td><td data-label="core_renderer.py (after revision)"> Hard guard: if any fragment has <code>meta.injected==true</code>, injection is skipped on subsequent passes.                                                </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Output hook for html_renderer</strong></div></div></td><td data-label="core_renderer.py (before revision)"> html_renderer cannot reliably detect injection state; may omit or mis-emit caption payload.                   </td><td data-label="core_renderer.py (after revision)"> Clear contract: html_renderer checks <code>meta.injected==true</code> to emit payload; otherwise emits none.                                                </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Payload emission shape</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Payload format inconsistent; client sometimes receives partial or flat lists.                                 </td><td data-label="core_renderer.py (after revision)"> Unified structure: <code>{table_id, caption_html, caption_ids, group_id, source, order}</code> ensuring consistent mapping to client injector.              </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-ID consistency</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Some tables rendered without proper <code>data-table-id</code>, causing lookup failures on the client.                   </td><td data-label="core_renderer.py (after revision)"> Enforces presence of table IDs via <code>core_table.ensure_table_id()</code> before injection.                                                              </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Cross-file coordination</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Renderer unaware of upstream <code>source="group_load"</code>; behaves inconsistently on <code>/convert</code> path.                </td><td data-label="core_renderer.py (after revision)"> Honors full server→convert→sanitize→fragment→renderer pipeline; <code>/convert</code> never performs caption injection.                                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Logging clarity</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Logging is scattered; caption lifecycle cannot be traced across modules.                                      </td><td data-label="core_renderer.py (after revision)"> Namespaced logging for gating decisions, injection start/end, grouping, and duplicate suppression.                                               </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Failure-mode behavior</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Missing metadata fields cause silent failures in caption alignment or table attachment.                       </td><td data-label="core_renderer.py (after revision)"> Defensive defaults and warnings; table still renders cleanly even if caption injection must be skipped.                                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Return surface</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Renderer only outputs HTML; payload is derived indirectly by html_renderer.                                   </td><td data-label="core_renderer.py (after revision)"> Renderer enables explicit <code>caption_payloads</code> block that html_renderer emits via <code>&lt;script data-caption-payload&gt;…&lt;/script&gt;</code>.                       </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Client compatibility (script.core.js)</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Client must guess caption order; ordering may differ between renders.                                         </td><td data-label="core_renderer.py (after revision)"> Deterministic payload order guaranteed; <code>window.PTT.injectCaptions()</code> receives stable, ordered caption sets.                                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Backward compatibility</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Behavior on repeat renders or non-group loads can produce duplicates or missing captions.                     </td><td data-label="core_renderer.py (after revision)"> Backward compatible for old consumers; strict gating prevents double-injection and prevents caption leakage into <code>/convert</code>.                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Project-safety guarantee</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Renderer mutates upstream input structures in some paths, causing mismatches in later stages.                 </td><td data-label="core_renderer.py (after revision)"> Avoids mutation of raw input; only enriches explicit metadata structures, preserving downstream module behavior.                                 </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><div class="table-caption" id="Table5" data-table="Docu_0118_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Area**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Area</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **core_renderer.py (before revision)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>core_renderer.py (before revision)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **core_renderer.py (after revision)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>core_renderer.py (after revision)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Caption-injection gate</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Injection may run under multiple call paths; no strict check tied to <code>request_ctx.action=="load_group"</code>.      </td><td data-label="core_renderer.py (after revision)"> Injection only executes when <code>request_ctx.action=="load_group"</code> and <code>meta.source=="group_load"</code>. All other request types skip injection cleanly. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Fragment meta handling</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Caption fragments not consistently marked; downstream renderer cannot know if injection has already occurred. </td><td data-label="core_renderer.py (after revision)"> Each injected caption fragment is stamped <code>meta.injected=true</code>, enabling reliable and deterministic html_renderer gating.                        </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-meta augmentation</strong></div></div></td><td data-label="core_renderer.py (before revision)"> <code>table_meta</code> sometimes missing caption IDs; client must infer or recompute.                                   </td><td data-label="core_renderer.py (after revision)"> Attaches explicit stable IDs (<code>caption_ids</code>, <code>caption_seq</code>, <code>stable_block_id</code>) for deterministic client-side injection.                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Stable-ID propagation</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Assumes upstream provides IDs; renderer does not verify or repair missing values.                             </td><td data-label="core_renderer.py (after revision)"> Validates stable IDs created upstream and repairs missing ones defensively to maintain consistency.                                              </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Multi-fragment grouping</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Sequential CaptionBlocks may collapse or merge incorrectly during render.                                     </td><td data-label="core_renderer.py (after revision)"> Groups CaptionBlocks by <code>group_id</code> and preserves strict ordering; multi-caption groups remain stable across all rendering passes.                </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Order of operations</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Injection may occur before sanitization or before table-ID assignment.                                        </td><td data-label="core_renderer.py (after revision)"> Injection always occurs after sanitization and after <code>ensure_table_id()</code>, guaranteeing correct placement and safe HTML.                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Duplicate-injection defense</strong></div></div></td><td data-label="core_renderer.py (before revision)"> No protection; repeated render flows can emit duplicated <code>&lt;script&gt;</code> payloads.                                 </td><td data-label="core_renderer.py (after revision)"> Hard guard: if any fragment already has <code>meta.injected==true</code>, injection is skipped, preventing duplicates.                                      </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Output hook for html_renderer</strong></div></div></td><td data-label="core_renderer.py (before revision)"> html_renderer cannot reliably detect injected state; may omit or mis-emit caption payload.                    </td><td data-label="core_renderer.py (after revision)"> Clean contract: html_renderer checks <code>meta.injected==true</code>; only then emits the <code>&lt;script data-caption-payload&gt;</code> block.                           </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Payload emission shape</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Payload format inconsistent; sometimes flat lists or partial structures.                                      </td><td data-label="core_renderer.py (after revision)"> Standardized structure <code>{table_id, caption_html, caption_ids, group_id, source, order}</code> for consistent client consumption.                       </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-ID consistency</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Some tables rendered without complete <code>data-table-id</code>, breaking client resolvers.                             </td><td data-label="core_renderer.py (after revision)"> Enforces presence of <code>table_id</code> from <code>ensure_table_id()</code> for every captioned table before injection.                                             </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Cross-file coordination</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Renderer not aware of upstream <code>source="group_load"</code> flags; inconsistent behavior under <code>/convert</code>.           </td><td data-label="core_renderer.py (after revision)"> Fully honors the pipeline: <code>/convert</code> path never triggers injection; only <code>group_load</code> flows do.                                                 </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Logging clarity</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Logs fragmented; cannot trace caption lifecycle or gating behavior.                                           </td><td data-label="core_renderer.py (after revision)"> Clear, namespaced logs for gating, grouping, injection start/end, and duplicate suppression.                                                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Failure-mode behavior</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Missing fields (<code>source</code>, <code>stable_id</code>, <code>caption_seq</code>) lead to silent failure or bad ordering.                 </td><td data-label="core_renderer.py (after revision)"> Defensive checks and warnings; HTML always renders even if caption injection must be skipped safely.                                             </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Return surface</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Only HTML is returned; caption payload indirectly assembled elsewhere.                                        </td><td data-label="core_renderer.py (after revision)"> Renderer provides explicit caption-payload structure for html_renderer to embed via <code>&lt;script data-caption-payload&gt;…&lt;/script&gt;</code>.                   </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Client compatibility (script.core.js)</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Client must guess caption order, resulting in unstable injection.                                             </td><td data-label="core_renderer.py (after revision)"> Deterministic ordering guaranteed; payload sent to <code>window.PTT.injectCaptions()</code> always matches server-computed caption structure.               </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Backward compatibility</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Old behavior produces duplication or leakage into non-group flows.                                            </td><td data-label="core_renderer.py (after revision)"> Backward compatible; strict gating eliminates duplicates and prevents caption spillover into <code>/convert</code>.                                         </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Project-safety guarantee</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Some paths mutate upstream objects, causing mismatches in later modules.                                      </td><td data-label="core_renderer.py (after revision)"> Input structures remain immutable; only explicit metadata containers are enriched, ensuring downstream stability.                                </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><div class="table-caption" id="Table6" data-table="Docu_0118_06" style="margin-top:2mm;margin-left:3mm;"><strong>Table 6</strong></div>
<div class="table-wrapper" data-table-id="table-6"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Area**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Area</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **Implementation / Patch (concise)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Implementation / Patch (concise)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Caption-injection gate</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Add top-level guard in <code>inject_captions(...)</code>: <code>if not request_ctx or request_ctx.get("action") != "load_group": return</code>. Ensure every call site passes <code>request_ctx</code>. Add unit test verifying no injection when <code>action!="load_group"</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Fragment meta handling</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Before mutating, ensure <code>meta["meta"] = meta.get("meta", {})</code>; set <code>mmeta["injected"]=True</code> only after successful attach. Use <code>if mmeta.get("injected"): continue</code>. Add <code>logger.debug("inject: skipping already-injected idx=%r", idx)</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-meta augmentation</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Create/normalize <code>table_meta</code> object and set keys: <code>caption_ids</code> (list), <code>caption_seq</code> (int sequence if provided), <code>stable_block_id</code> (generated fallback via <code>_stable_hash</code>). Example: <code>tmeta.setdefault("caption_ids", [])</code>, <code>tmeta.setdefault("stable_block_id", _stable_hash({...}))</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Stable-ID propagation</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Validate candidate IDs: <code>v = str(v).strip(); if not re.match(r'^[A-Za-z0-9_.:-]{1,200}$', v): continue</code>. If none present, assign <code>stable_block_id = f"auto-{hash[:8]}"</code> and place into <code>tmeta["stable_block_id"]</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Multi-fragment grouping</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Group by <code>group_id = tmeta.get("group_id") or mmeta.get("group_id")</code>. Build grouped lists preserving <code>order</code> from fragments_map keys. When emitting payload, sort by <code>(group_id, seq_in_group)</code> where <code>seq_in_group</code> uses <code>caption_seq</code> or fragments_map key order. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Order of operations</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Ensure callers call <code>sanitize_html(...)</code> and <code>ensure_table_id(fragment)</code> before <code>inject_captions</code>. Add assertion at start of <code>inject_captions</code>: <code>assert mmeta.get("sanitized") is True, "inject_captions requires pre-sanitized meta"</code>. (Use defensive <code>if not ...: continue</code> in production.) </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Duplicate-injection defense</strong></div></div></td><td data-label="Implementation / Patch (concise)"> In <code>inject_captions</code>, if any fragment in group has <code>mmeta.get("injected")</code>, skip injection for that fragment. When building payload in <code>render_html</code>, skip fragments without <code>meta.injected==True</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Output hook for html_renderer</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Change <code>render_html</code> to accept optional <code>caption_payload_out</code> key in return. When emitting <code>&lt;script data-caption-payload&gt;</code>, also attach <code>result["caption_payload"] = caption_payloads</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Payload emission shape</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Standardize payload entries: <code>{"table_id": "TableX", "caption_html": "...", "caption_ids": [...], "group_id": "...", "source": "...", "order": N}</code>. Ensure <code>caption_html</code> is sanitized text-only (or limited sanitized HTML) and size-limited. Use <code>json.dumps(payload, ensure_ascii=False)</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-ID consistency</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Add <code>ensure_table_id(fragment, idx, book_prefix)</code> helper that sets <code>tmeta["table_id"] = f"Table{idx}"</code> and <code>tmeta["data_table_id"] = f"{book_prefix}_{idx:02d}"</code>. Call this before injection and before writing fragment to disk. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Cross-file coordination</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Require <code>mmeta.get("source") == "group_load"</code> to permit injection. Add explicit check in <code>inject_captions</code>. Document that <code>/convert</code> must not set <code>source</code> to <code>group_load</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Logging clarity</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Add namespaced debug/info logs: <code>logger.info("caption: gate=%s group=%s idx=%s", request_ctx.get('action'), group_id, idx)</code> and <code>logger.debug("caption: payload entries=%d", len(payload))</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Failure-mode behavior</strong></div></div></td><td data-label="Implementation / Patch (concise)"> When mandatory keys missing, emit warning <code>warnings.append({"level":"warn","msg":"caption injection skipped: missing stable id for fragment %s" % idx})</code> and continue; never raise. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Return surface</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Return <code>result["caption_payload"] = caption_payloads</code> (list) alongside HTML. Keep backward compatibility if caller ignores it. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Client compatibility (script.core.js)</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Ensure payload order is deterministic server-side. Add <code>window.PTT = window.PTT {}; window.PTT._serverCaptionPayload = &lt;payload&gt;</code> in <code>&lt;script&gt;</code> and call <code>window.PTT.injectCaptions?.(window.PTT._serverCaptionPayload)</code>. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Backward compatibility</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Default behavior unchanged for non-group flows. Add <code>config</code> flag <code>force_caption_inject=False</code> to allow testing/backcompat. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Project-safety guarantee</strong></div></div></td><td data-label="Implementation / Patch (concise)"> Avoid mutating upstream objects passed into <code>render_html</code>. Work on shallow copy: <code>fragments_map = {k: dict(v) for k,v in fragments_map.items()}</code> then mutate <code>fragments_map[k]["meta"]</code> etc. Document immutability guarantee. </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><div class="table-caption" id="Table7" data-table="Docu_0118_07" style="margin-top:2mm;margin-left:3mm;"><strong>Table 7</strong></div>
<div class="table-wrapper" data-table-id="table-7"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Area**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Area</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **core_renderer.py (before revision)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>core_renderer.py (before revision)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **core_renderer.py (after revision — final unified design)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>core_renderer.py (after revision — final unified design)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Caption-injection gate</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Injection could run under multiple paths; conditions inconsistent.                        </td><td data-label="core_renderer.py (after revision — final unified design)"> Injection <strong>only</strong> runs when <code>request_ctx.action=="load_group"</code> <strong>and</strong> <code>meta.source=="group_load"</code>; all other flows skip cleanly.                  </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Fragment meta handling</strong></div></div></td><td data-label="core_renderer.py (before revision)"> No stable marker showing that fragments already received caption injection.               </td><td data-label="core_renderer.py (after revision — final unified design)"> Every injected fragment carries <code>meta.injected=true</code>; renderer and html_renderer use it as the authoritative gating signal.                         </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Sanitization ordering</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Injection sometimes ran before sanitization, producing unsafe HTML.                       </td><td data-label="core_renderer.py (after revision — final unified design)"> Injection occurs <strong>strictly after</strong> sanitization (<code>meta.sanitized=true</code>) and after table-ID assignment.                                             </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-meta augmentation</strong></div></div></td><td data-label="core_renderer.py (before revision)"> <code>table_meta</code> lacked explicit caption IDs and sequence, forcing the client to infer order. </td><td data-label="core_renderer.py (after revision — final unified design)"> <code>table_meta</code> receives: <code>caption_ids</code>, <code>caption_seq</code>, <code>stable_block_id</code>, and validated <code>table_id</code> from ensure_table_id(). No inference required.     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Stable-ID propagation</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Relied entirely on upstream; missing or malformed IDs were not fixed.                     </td><td data-label="core_renderer.py (after revision — final unified design)"> Stable IDs are validated and repaired deterministically; fallback ID generation is safe, consistent, and logged.                                    </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Multi-fragment grouping</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Caption groups could merge or collapse; ordering varied across runs.                      </td><td data-label="core_renderer.py (after revision — final unified design)"> Grouped by <code>group_id</code>, ordered deterministically by <code>caption_seq</code> (or fragment index fallback). Groups remain stable across all render passes.      </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Duplicate-injection defense</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Repeated calls could re-inject <code>&lt;script&gt;</code> blocks.                                         </td><td data-label="core_renderer.py (after revision — final unified design)"> Hard guard: if any fragment in group has <code>meta.injected==true</code>, injection is skipped. End-to-end idempotent.                                        </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Payload emission shape</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Inconsistent: sometimes lists, sometimes incomplete structures.                           </td><td data-label="core_renderer.py (after revision — final unified design)"> Strict schema: <code>{table_id, caption_html, caption_ids, group_id, source, order}</code>. Sanitized, size-limited, stable ordering.                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Output hook for html_renderer</strong></div></div></td><td data-label="core_renderer.py (before revision)"> html_renderer guessed state; often mis-detected injected fragments.                       </td><td data-label="core_renderer.py (after revision — final unified design)"> html_renderer checks only <code>meta.injected</code>; if true, embeds <code>&lt;script data-caption-payload&gt;</code> with standardized JSON payload emitted by core_renderer. </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Table-ID consistency</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Some captioned tables had no reachable <code>table_id</code>, producing client-side lookup errors.   </td><td data-label="core_renderer.py (after revision — final unified design)"> <code>ensure_table_id()</code> always runs before injection; every captioned table receives canonical <code>table_id</code> and <code>data_table_id</code>.                          </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Cross-file coordination</strong></div></div></td><td data-label="core_renderer.py (before revision)"> <code>/convert</code> pipeline accidentally allowed injection in some cases.                         </td><td data-label="core_renderer.py (after revision — final unified design)"> <code>/convert</code> never triggers injection; injection requires both <code>action=="load_group"</code> and <code>source=="group_load"</code>.                                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Logging clarity</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Hard to trace lifecycle; inconsistent log format.                                         </td><td data-label="core_renderer.py (after revision — final unified design)"> Namespaced logs for: gating, grouping, ID repair, injection start/end, duplicate blocking, and payload emission counts.                             </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Failure-mode behavior</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Missing fields caused silent breakage or incorrect ordering.                              </td><td data-label="core_renderer.py (after revision — final unified design)"> Defensive checks with warnings; if required fields missing, injection is skipped but HTML still renders safely.                                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Return surface</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Returned only HTML; caption payload lived elsewhere and was recomputed.                   </td><td data-label="core_renderer.py (after revision — final unified design)"> Returns explicit <code>caption_payload</code> list (parallel to emitted script), ensuring deterministic one-source-of-truth.                                   </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Client compatibility</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Client guessed order; unstable injection in script.core.js.                               </td><td data-label="core_renderer.py (after revision — final unified design)"> Server guarantees deterministic payload order; <code>window.PTT.injectCaptions()</code> always receives complete, authoritative structure.                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Backward compatibility</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Legacy behavior leaked captions into unrelated flows.                                     </td><td data-label="core_renderer.py (after revision — final unified design)"> Backward compatible: non-group flows untouched; strict gating prevents leakage.                                                                     </td></tr><tr><td data-label="Area"><div class="tv-left-col"><div class="left-col-heading"><strong>Project-safety guarantee</strong></div></div></td><td data-label="core_renderer.py (before revision)"> Renderer mutated upstream structures, causing subtle cross-module inconsistencies.        </td><td data-label="core_renderer.py (after revision — final unified design)"> Input structures remain immutable; renderer works on safe copies and mutates only internal metadata containers.                                     </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><div class="table-caption" id="Table8" data-table="Docu_0118_08" style="margin-top:2mm;margin-left:3mm;"><strong>Table 8</strong></div>
<div class="table-wrapper" data-table-id="table-8"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Module Region**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Module Region</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **Before Revision**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Before Revision</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **After Revision — Final Corrected Structure (Expanded Technical Description)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>After Revision — Final Corrected Structure (Expanded Technical Description)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>1. Imports &amp; Logger Setup</strong></div></div></td><td data-label="Before Revision"> The original file used broad imports with several unused modules left over from older versions of the renderer. Logging relied on a generic top-level logger without a dedicated namespace, producing interleaved logs from unrelated subsystems, complicating debugging and log correlation during group loads. </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> All imports are now explicitly curated and relevant to the renderer’s final responsibilities. The logger is namespaced under <code>"core_renderer"</code> to isolate caption-injection events from other components. Logging structure is standardized across all methods with clear INFO/DEBUG layers: INFO tracks pipeline milestones (gating, injection start/end, payload completion), while DEBUG captures internal states (meta normalization, ID repairs, group formation, ordering resolution). The module avoids importing anything not used by final logic, ensuring tight dependency hygiene and predictable runtime behavior. </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>2. Public Entry Points</strong></div></div></td><td data-label="Before Revision"> The earlier version allowed <code>render_html</code> to implicitly handle caption injection in some situations, causing inconsistent behavior depending on which internal helper invoked first. Public surface area was not clearly defined, and callers needed to know implicit details of various internal flags.         </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> The corrected version defines a <strong>clean three-function interface</strong>: <code>inject_captions()</code> (pure mutation of enriched metadata on sanitized fragments), <code>build_caption_payload()</code> (canonical, deterministic JSON-ready payload builder), and <code>render_html()</code> (final HTML builder with deterministic payload embedding). No implicit invocation occurs—callers must explicitly call inject → payload → render. The file behaves as a predictable pipeline stage with explicit responsibilities.                                                                                                                                    </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>3. Request Context Handling</strong></div></div></td><td data-label="Before Revision"> Request context checks were inconsistent, with some paths neglecting to verify <code>action</code>, others ignoring <code>source</code>, and many silently assuming captions should be injected by default. Missing fields often resulted in accidental injection.                                                                     </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> The new design defines a strict contract: <code>request_ctx</code> must contain <code>action</code>, <code>source</code>, and <code>client_req_id</code>. Injection is <strong>allowed only</strong> when <code>(action=="load_group") AND (source=="group_load")</code>. Any missing or mismatched field disables injection deterministically. This eliminates misfires and guarantees <code>/convert</code> or unrelated flows never trigger caption metadata injection.                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>4. Fragment Copying / Mutability Rules</strong></div></div></td><td data-label="Before Revision"> Renderer mutated upstream objects directly, leading to subtle breakages in later modules like html_renderer and diff stabilizers. Some fragments were modified in place while others were copied, resulting in inconsistent metadata graphs.                                                                     </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Final design clones the fragment map shallowly, producing safe, isolated metadata containers. Only <code>meta</code> and <code>table_meta</code> are enriched, never the original caption payloads or external structures. The immutability guarantee ensures other modules receive stable, untouched input objects, preventing extremely hard-to-debug state contamination.                                                                                                                                                                                                                                                                         </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>5. Sanitization Enforcement</strong></div></div></td><td data-label="Before Revision"> In multiple code paths, caption injection ran before sanitization completed or before sanitized flags were propagated. This allowed raw HTML to leak into payloads or caused injection to skip erroneously.                                                                                                      </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> The renderer now <strong>requires</strong> <code>meta.sanitized == True</code>. Sanitization must occur upstream. If a fragment is not explicitly sanitized, injection is skipped with a visible warning but HTML still renders. This ensures no unsafe HTML enters caption payloads and that caption flow always follows the documented pipeline order.                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>6. Table-ID Assignment Phase</strong></div></div></td><td data-label="Before Revision"> Many captioned tables lacked a guaranteed <code>table_id</code>, and data-table-id was often missing entirely. Some flows required the client-side script to attempt recovery, frequently failing.                                                                                                                          </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Every captioned table receives a guaranteed <code>table_id</code> and <code>data_table_id</code> via <code>ensure_table_id()</code>. IDs are stable across runs, derived from deterministic sequences or fallback stable hashes. The renderer never proceeds with injection unless table IDs are confirmed valid, preserving downstream lookup reliability in script.core.js.                                                                                                                                                                                                                                                                                   </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>7. Caption Injection Gate</strong></div></div></td><td data-label="Before Revision"> Injection logic was distributed across several branches and helper functions, making it easy for injection to run unintentionally. Some flows ignored <code>action</code> entirely.                                                                                                                                         </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Now, there is one absolute gate: injection runs in exactly one place and only if all gating conditions match. The guard ensures perfect separation between group-load behavior and all other system behaviors. This is the fundamental correctness guarantee of the new file.                                                                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>8. Fragment Metadata Normalization</strong></div></div></td><td data-label="Before Revision"> Metadata structures varied widely, depending on which upstream converter produced the fragments. Missing keys forced many fallback heuristics, often incorrect.                                                                                                                                                  </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> The corrected file standardizes every metadata container: <code>meta</code>, <code>meta.injected</code>, <code>meta.source</code>, <code>meta.sanitized</code>, and <code>table_meta</code> all become normalized structures. Caption sequencing (<code>caption_seq</code>), stable IDs (<code>stable_block_id</code>), and explicit <code>caption_ids</code> are guaranteed for any fragment eligible for injection. Downstream phases never need to guess.                                                                                                                                                                                                                                                           </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>9. Grouping &amp; Ordering Logic</strong></div></div></td><td data-label="Before Revision"> Multi-caption groups (common in complex scientific documents) collapsed unpredictably. Ordering differed between runs depending on dictionary iteration or nondeterministic upstream behavior.                                                                                                                   </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Final grouping logic: group by <code>group_id</code>, then sort by <code>caption_seq</code> if present, else fall back to the stable integer order that originates from fragment indices. Grouping is strict and repeatable. Two consecutive renders of the exact same fragments map will always produce the same caption payload ordering.                                                                                                                                                                                                                                                                                                          </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>10. Duplicate-Injection Protection</strong></div></div></td><td data-label="Before Revision"> No support for detecting already-injected fragments. Double renders (client retries, pipeline re-entry) led to repeated script payloads that corrupted the client caption registry.                                                                                                                              </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> A strict idempotency rule: any fragment with <code>meta.injected==true</code> is skipped by injection logic. This eliminates all accidental double-emission scenarios and ensures pipeline re-entry never amplifies payloads or corrupts client state.                                                                                                                                                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>11. Caption HTML Management</strong></div></div></td><td data-label="Before Revision"> Caption HTML sometimes came directly from raw conversion without full sanitization. Some flows stripped HTML entirely, while others preserved too much. Payloads had no size limits.                                                                                                                             </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Caption HTML is always sanitized upstream; the renderer enforces this requirement. Payload HTML is reduced to a safe, text-only or lightly sanitized form, trimmed to a size budget to maintain payload stability and avoid producing massive inline JSON. Renderer HTML and caption HTML are now cleanly separated concerns.                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>12. Payload Builder</strong></div></div></td><td data-label="Before Revision"> Payload structures changed across releases, sometimes missing keys, sometimes using inconsistent object shapes, sometimes using arrays without descriptors.                                                                                                                                                      </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> The final builder produces absolutely deterministic objects containing: <code>{table_id, caption_html, caption_ids, group_id, source, order}</code>. All keys always exist; types are predictable; order is deterministic. This schema becomes a stable contract for script.core.js.                                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>13. Payload Serialization</strong></div></div></td><td data-label="Before Revision"> html_renderer partially built payloads and merged them with fragments, causing double serialization bugs and mismatched states.                                                                                                                                                                                  </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Payload generation is now centralized inside core_renderer. html_renderer only emits what core_renderer provides. There is <strong>one</strong> source of payload truth, eliminating desync conditions.                                                                                                                                                                                                                                                                                                                                                                                                                                     </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>14. Emission Hook</strong></div></div></td><td data-label="Before Revision"> html_renderer incorrectly guessed which fragments were injected based on scattered conditions.                                                                                                                                                                                                                   </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> html_renderer now uses the one authoritative signal: <code>meta.injected == True</code>. If true, embed <code>&lt;script data-caption-payload&gt;…&lt;/script&gt;</code> exactly once. Simple, reliable, and deterministic.                                                                                                                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>15. Logging</strong></div></div></td><td data-label="Before Revision"> Log output was incomplete, inconsistent, and frequently unhelpful for diagnosing caption injection failures.                                                                                                                                                                                                     </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Full lifecycle logging: gating decision logs, grouping formation logs, stable-ID-validation logs, injection start/end logs, duplicate-skip logs, and payload-emission logs. Troubleshooting becomes straightforward.                                                                                                                                                                                                                                                                                                                                                                                                           </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>16. Error Handling</strong></div></div></td><td data-label="Before Revision"> Missing fields or malformed metadata frequently caused silent failures or incorrect payloads, sometimes crashing the renderer.                                                                                                                                                                                   </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> New file uses defensive guards: if critical metadata missing, skip injection for that fragment with warnings while still producing valid HTML. Renderer never crashes the pipeline.                                                                                                                                                                                                                                                                                                                                                                                                                                            </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>17. Return Surface</strong></div></div></td><td data-label="Before Revision"> Returned only HTML, forcing client systems to reconstruct caption metadata by scanning DOM or partial payloads.                                                                                                                                                                                                  </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Returns <code>{"html": ..., "caption_payload": ...}</code> with an exact, server-defined payload matching the embedded script tag. Client receives canonical authoritative data.                                                                                                                                                                                                                                                                                                                                                                                                                                                          </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>18. Backward Compatibility</strong></div></div></td><td data-label="Before Revision"> Older behavior polluted unrelated conversion workflows with caption metadata.                                                                                                                                                                                                                                    </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> New gating fully isolates group-load logic. <code>/convert</code> paths remain untouched and old functionality remains stable without caption interference.                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>19. End-to-End Contract</strong></div></div></td><td data-label="Before Revision"> Client did heavy inference and often got ordering wrong.                                                                                                                                                                                                                                                         </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Server guarantees order, grouping, IDs, and all caption structure. Client logic simplifies to: receive payload → inject deterministically → done. End-to-end consistency is guaranteed.                                                                                                                                                                                                                                                                                                                                                                                                                                        </td></tr></tbody></table></div><div class="row-count">Rows: 19</div></div><div class="table-caption" id="Table9" data-table="Docu_0118_09" style="margin-top:2mm;margin-left:3mm;"><strong>Table 9</strong></div>
<div class="table-wrapper" data-table-id="table-9"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Module Region**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Module Region</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **Before Revision**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Before Revision</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th><th aria-label="Sort by **After Revision — Final Corrected Structure (Expanded Technical Description)**" class="tv-col" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>After Revision — Final Corrected Structure (Expanded Technical Description)</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>1. Imports &amp; Logger Setup</strong></div></div></td><td data-label="Before Revision"> Used broad, legacy imports with unused modules. Logger was global and un-namespaced, mixing caption logs with unrelated subsystems.                                                                                                                                                                             </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Imports strictly limited to the corrected renderer’s responsibilities (fragments, tables, logging, utils). Logger is namespaced <code>"core_renderer"</code> with consistent INFO/DEBUG levels. All stages (gate checks, grouping, ID validation, injection, payload build, emission) have uniform lifecycle logging. No unused imports remain.                                                                                                                                                                                                                                                                                           </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>2. Public Entry Points</strong></div></div></td><td data-label="Before Revision"> <code>render_html()</code> implicitly triggered caption injection depending on call order. Public API unclear; some helpers invoked hidden steps.                                                                                                                                                                          </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Clear three-stage API: <strong>inject_captions()</strong> → <strong>build_caption_payload()</strong> → <strong>render_html()</strong>. No implicit injection. Each step is deterministic and idempotent. Upstream modules must call stages explicitly.                                                                                                                                                                                                                                                                                                                                                                         </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>3. Request Context Handling</strong></div></div></td><td data-label="Before Revision"> <code>request_ctx</code> validation inconsistent; some paths ignored <code>source</code>, some ignored <code>action</code>. Non-group flows accidentally triggered injection.                                                                                                                                                                    </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Strict contract: injection allowed only when <code>action=="load_group"</code> AND <code>source=="group_load"</code> AND <code>client_req_id</code> exists. Any mismatch disables injection deterministically. <code>/convert</code> and all unrelated flows are permanently isolated.                                                                                                                                                                                                                                                                                                                                              </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>4. Fragment Copying / Mutability Rules</strong></div></div></td><td data-label="Before Revision"> Upstream fragment objects mutated in place, causing downstream instability and cross-module divergence. Mixed mutation and copying rules.                                                                                                                                                                       </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> New version clones fragment structures shallowly and enriches only <code>meta</code> + <code>table_meta</code>. Original upstream objects remain untouched. Prevents inter-module contamination and ensures stable idempotent behavior.                                                                                                                                                                                                                                                                                                                                                                       </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>5. Sanitization Enforcement</strong></div></div></td><td data-label="Before Revision"> Sometimes injected before sanitization; <code>meta.sanitized</code> not consistently checked. Raw HTML could leak into payload.                                                                                                                                                                                            </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Injection requires <code>meta.sanitized==True</code>. Unsanitized fragments are skipped with warnings. Ensures pipeline order and prevents unsafe HTML in payloads.                                                                                                                                                                                                                                                                                                                                                                                                                                </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>6. Table-ID Assignment Phase</strong></div></div></td><td data-label="Before Revision"> Many captioned tables lacked <code>table_id</code>. Some flows emitted HTML without <code>data-table-id</code>, breaking client lookups.                                                                                                                                                                                               </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> <code>ensure_table_id()</code> required for every captioned table. Stable IDs validated and repaired if missing. Injection never proceeds unless IDs are confirmed valid and stable.                                                                                                                                                                                                                                                                                                                                                                                                              </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>7. Caption Injection Gate</strong></div></div></td><td data-label="Before Revision"> Injection code scattered across multiple helpers; some paths triggered injection based solely on fragment type or HTML.                                                                                                                                                                                         </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Single absolute gate inside <code>inject_captions()</code> performs all gating. Only executes if request context matches strict conditions. Guarantees isolation of group-load behavior from all other code paths.                                                                                                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>8. Fragment Metadata Normalization</strong></div></div></td><td data-label="Before Revision"> Metadata structures inconsistent; many upstream converters omitted keys (caption_seq, stable_block_id, source). Renderer used fallback heuristics.                                                                                                                                                               </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Complete normalization of all metadata containers. Every eligible fragment receives standardized: <code>meta.injected</code>, <code>meta.source</code>, <code>meta.sanitized</code>, <code>caption_ids</code>, <code>caption_seq</code>, <code>stable_block_id</code>, enriched <code>table_meta</code>. Downstream code never performs inference.                                                                                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>9. Grouping &amp; Ordering Logic</strong></div></div></td><td data-label="Before Revision"> Caption groups collapsed unpredictably; ordering dependent on Python dict iteration or converter quirks.                                                                                                                                                                   </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Grouping is deterministic: group by <code>group_id</code>, then sort within each group by <code>caption_seq</code>; if absent, fallback to stable index-based ordering. Guarantees reproducible ordering across all runs.                                                                                                                                                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>10. Duplicate-Injection Protection</strong></div></div></td><td data-label="Before Revision"> No detection of prior injected fragments. Multiple passes produced duplicate <code>&lt;script&gt;</code> tags, corrupting client registry state.                                                                                                                                                                                  </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Hard idempotency guarantee: if <code>meta.injected==True</code>, injection is skipped for that fragment. Prevents re-injection in retries, parallel passes, repeated render calls, or when html_renderer re-enters.                                                                                                                                                                                                                                                                                                                                                                                </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>11. Caption HTML Management</strong></div></div></td><td data-label="Before Revision"> Caption HTML sometimes un-sanitized or inconsistently stripped. Payload sizes varied widely; large captions produced unstable payloads.                                                                                                                                                                          </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Renderer relies on upstream sanitized HTML. Caption HTML is always safe, trimmed, and normalized. No raw or oversized HTML enters payloads. Clean contract: upstream sanitizes → renderer only packages.                                                                                                                                                                                                                                                                                                                                                                                </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>12. Payload Builder</strong></div></div></td><td data-label="Before Revision"> Payload format inconsistent across releases; keys missing; ordering unstable; sometimes arrays, sometimes dicts.                                                                                                                                                                                                  </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Canonical stable schema: <code>{table_id, caption_html, caption_ids, group_id, source, order}</code>. All keys always exist. Types never vary. Ordering deterministic across all fragments and runs. This becomes the stable API consumed by script.core.js.                                                                                                                                                                                                                                                                                                                                        </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>13. Payload Serialization</strong></div></div></td><td data-label="Before Revision"> html_renderer partially built payloads and merged with renderer output, causing double-encoding and mismatched object trees.                                                                                                                                                                                      </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Payload generation fully centralized inside core_renderer. html_renderer only embeds final payload as provided. Eliminates desync and double-serialization bugs.                                                                                                                                                                                                                                                                                                                                                                                                                       </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>14. Emission Hook</strong></div></div></td><td data-label="Before Revision"> html_renderer guessed injection state using scattered heuristics; often emitted payload incorrectly or multiple times.                                                                                                                                                                                           </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> New contract: html_renderer checks <strong>only</strong> <code>meta.injected==True</code>. If true, embed exactly one <code>&lt;script data-caption-payload&gt;</code> tag containing the canonical payload. Zero ambiguity.                                                                                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>15. Logging</strong></div></div></td><td data-label="Before Revision"> Logs inconsistent, sparse, and without lifecycle structure. Hard to trace failures or verify correct gating.                                                                                                                                                                                                     </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Full structured lifecycle logging: gating decisions, sanitization validation, stable-ID repairs, grouping resolution, injection start/end, duplicate suppression, and final payload assembly. Troubleshooting becomes direct and traceable.                                                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>16. Error Handling</strong></div></div></td><td data-label="Before Revision"> Missing metadata caused silent failures, broken ordering, or crashes. Renderer assumptions often unsafe.                                                                                                                                                                                                         </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Defensive guards around all critical metadata. If a fragment lacks required metadata, injection skips safely with warnings; HTML always continues rendering. Renderer never breaks pipeline even under malformed upstream input.                                                                                                                                                                                                                                                                                                                                                         </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>17. Return Surface</strong></div></div></td><td data-label="Before Revision"> Only HTML returned. Client forced to infer caption metadata by scanning DOM or partial scripts.                                                                                                                                                                                                                  </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Returns <code>{html, caption_payload}</code>. Server becomes the authoritative provider of caption structure. Client simply injects what server defines.                                                                                                                                                                                                                                                                                                                                                                                                                                            </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>18. Backward Compatibility</strong></div></div></td><td data-label="Before Revision"> Old caption logic leaked into <code>/convert</code> or simple HTML-only flows. Some older behavior persisted in legacy paths.                                                                                                                                                                                               </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Fully isolated: strict gating means <code>/convert</code> and non-group flows never receive caption injection. All legacy behaviors preserved exactly where expected. No regressions introduced.                                                                                                                                                                                                                                                                                                                                                                                                     </td></tr><tr><td data-label="Module Region"><div class="tv-left-col"><div class="left-col-heading"><strong>19. End-to-End Contract</strong></div></div></td><td data-label="Before Revision"> Client performed heavy inference to deduce grouping, ordering, IDs, and relationships. Errors common.                                                                                                                                                                                                            </td><td data-label="After Revision — Final Corrected Structure (Expanded Technical Description)"> Server now guarantees deterministic grouping, stable IDs, correct ordering, and complete payload structure. Client reduces to: receive payload → inject → done. Entire system becomes stable, predictable, and debuggable.                                                                                                                                                                                                                                                                                                                                                               </td></tr></tbody></table></div><div class="row-count">Rows: 19</div></div><div class="table-caption" id="Table10" data-table="Docu_0118_10" style="margin-top:2mm;margin-left:3mm;"><strong>Table 10</strong></div>
<div class="table-wrapper" data-table-id="table-10"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th aria-label="Sort by **Expert_Plan_20251115_01**" class="tv-col-left" role="button"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Expert_Plan_20251115_01</strong></div><button aria-label="Toggle sort" class="sort-btn sort-state-0" title="Toggle sort"><span aria-hidden="true" class="sort-icon"></span></button></div></th></tr></thead><tbody><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-content">Conduct a <strong>complete repository enumeration</strong> using multilayer search across filenames, inline strings, regex patterns, dynamic loaders, asset globbing, HTML templates, Python asset registries, JS import graphs, and runtime bootstrap code. Search for both exact filename (<code>script.toc.js</code>) and semantic markers (<code>toc</code>, <code>table-of-contents</code>, <code>toc_init</code>, injected TOC anchor patterns). Enumerate results in a scratchpad and classify each hit as: <em>critical reference</em>, <em>runtime loader</em>, <em>build-time reference</em>, <em>dead path</em>, <em>comment-only</em>, or <em>false positive</em>.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-content">Examine the <strong>asset loading pathway</strong> starting from templates (<code>templates/index.html</code>) moving through <code>html_renderer.py</code>, then <code>render/core_assets.py</code>, checking for inclusion primitives such as static <code>&lt;script&gt;</code> tags, autoload manifests, dictionary mappings, list-based enumerations, hashing pipelines, SRI injection, version stamping, and conditional inclusion structures. Map dependency direction: <em>template → renderer → asset manager → assets folder</em>. If any part of this chain assumes or resolves <code>script.toc.js</code>, mark as blocking dependency.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-content">Trace the <strong>client bootstrap pipeline</strong> beginning with <code>script.core.js</code> → <code>script.table.js</code> → <code>script.list.js</code> → <code>utils.js</code>. Identify any implicit runtime injection wrappers, global namespace pollution via <code>window.PTT</code>, feature toggles, queue processors (<code>_PTT_Q</code>), DOMContentLoaded hooks, and late-binding logic such as <code>document.querySelectorAll("script[data-ptt-*]")</code>. Check for any call sites like <code>PTT.loadTOC</code>, <code>PTT.initTOC</code>, <code>PTT.tocWorker</code>, or DOM queries that assume TOC scripts exist or attach event listeners to TOC container elements.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Dissect <code>script.toc.js</code> internally. Extract its <strong>functional surface area</strong></div><div class="left-col-content">event binding, DOM mutation, TOC generation algorithms, anchor mapping, scroll spies, highlight logic, hash synchronization, collapsible nodes, state caching, or worker delegation. Tag each function with one of: <em>critical</em>, <em>UI-only</em>, <em>decorative</em>, <em>deprecated</em>, <em>duplicate</em>, <em>migratable</em>, or <em>removable</em>. Build a dependency DAG (directed acyclic graph) mapping every exported or implicitly leaked function to call sites elsewhere. If the DAG shows zero inbound edges, file qualifies for immediate deprecation.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Build an <strong>asset dependency graph</strong> using filename</div><div class="left-col-content">level relationships: which JS scripts require which other scripts, in what order, using what loaders (static tags, dynamic <code>import()</code>, inline loader, custom bundler). Confirm whether removing a file breaks order guarantees. Example failure mode: <code>script.toc.js</code> attaches itself to <code>window.PTT</code> early, and another script expects that property to exist. Perform negative tests: temporarily rename file to <code>script.toc.js.off</code> and observe if runtime crashes.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Perform <strong>server</strong></div><div class="left-col-content">side inspection in Python: <code>server.py</code>, <code>core_renderer.py</code>, <code>core_utils.py</code>, <code>core_fragments.py</code>, <code>core_table.py</code>, <code>core_assets.py</code>, and any <code>asset_registry</code> logic. Look for hardcoded asset sequences, such as <code>{“scripts”: [“script.core.js”, “script.table.js”, “script.toc.js”]}</code>, or loops reading folder contents in alphabetical order. Verify whether removal shifts file ordering and breaks deterministic hashing or output reproducibility.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Execute <strong>end</strong></div><div class="left-col-content">to-end smoke tests for all rendering paths: <em>manual paste</em>, <em>load group</em>, <em>load large table</em>, <em>caption injection enabled</em>, <em>caption injection disabled</em>, <em>groups.json-driven workflows</em>, <em>labels.json lookups</em>, and <em>worker.js future features</em>. Specifically evaluate the two main request flows documented in your diagram: (a) <code>load_group</code>, (b) <code>manual_paste</code>. Confirm TOC logic is never referenced in either metadata flow: <code>fromList</code>, <code>injected</code>, <code>client_req_id</code>, or caption payload emission.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Validate <strong>front</strong></div><div class="left-col-content">end rendering integrity by running the application with DevTools → Network tab, ensuring no 404s from script loaders. Use console monitoring to confirm absence of ReferenceErrors, undefined property access (e.g., <code>PTT.toc</code> undefined), missing initialization phases, event listener errors, or failed DOM queries. Use MutationObserver logs to confirm no abandoned callback tries to bind to removed DOM nodes.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Apply the <strong>incremental deprecation path</strong></div><div class="left-col-content">create folder <code>assets/_deprecated/</code>, move <code>script.toc.js</code> there. Update asset enumerators to exclude deprecated folders. Run entire application again; ensure no runtime request attempts to fetch that file. This step simulates final deletion but allows rollback. Keep file present but out of pipeline.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Perform <strong>differential behavioral analysis</strong></div><div class="left-col-content">capture DOM snapshots before and after deprecation using consistent inputs. Compare (a) injected HTML, (b) rendered table fragments, (c) caption blocks, (d) asset tags in HTML head/footer, (e) scroll behavior. Confirm removing TOC code does not alter table rendering, metadata payloads, or caption injection.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Audit for <strong>latent dynamic loaders</strong></div><div class="left-col-content">search for code constructing filenames using template strings or concatenation. Example: <code>const script = "script." + mode + ".js";</code>. Confirm no mode ever resolves to <code>"toc"</code>. Review worker communication endpoints: <code>worker.js</code> may attempt to load additional scripts depending on feature flags. Also inspect <code>extra.js</code> and <code>utils.js</code> for fallback loading code.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Validate <strong>backward</strong></div><div class="left-col-content">compatibility for consumers outside this repo. If any third-party integration loads <code>script.toc.js</code> directly from this asset folder, you must mark the file as removed in release notes or maintain a stub that logs a deprecation warning without functionality. If repo is private and not distributed, skip this.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Execute <strong>controlled deletion</strong></div><div class="left-col-content">once all searches and tests are clean, remove file using <code>git rm</code>, update manifests or templates accordingly, update the commit message with structured metadata: <code>chore(asset): remove unused script.toc.js after dependency audit</code>. Ensure CI pipeline passes.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Perform <strong>staging rollout verification</strong></div><div class="left-col-content">deploy to staging, run full regression across browsers (Chrome, Firefox, Edge). Inspect caching behavior; force cache invalidation. Ensure no service workers or CDN layers still expect the file. Examine logs for 404 patterns in staging. If any client hits that path, track referrer and identify outdated pages.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Conduct <strong>production cautious rollout</strong></div><div class="left-col-content">deploy with monitoring enabled for JavaScript errors, 404 asset requests, and server-side exceptions. Watch logs for patterns involving missing TOC functions during table render requests. Perform synthetic checks by running automated browsers that load typical pages. Continue this for 24–48 hours.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Prepare <strong>automated rollback path</strong></div><div class="left-col-content">maintain a lightweight stub at same filename if necessary. Rollback can be done via <code>git revert</code> or cherry-pick restoration. Document restoration in internal notes.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">After stability confirmed, update internal docs</div><div class="left-col-content">remove TOC feature references, clean asset lists, update architecture diagrams, and update any contributor onboarding documentation that previously listed TOC scripts. This prevents future regressions or accidental reintroduction.</div></div></td></tr><tr><td data-label="Expert_Plan_20251115_01"><div class="tv-left-col"><div class="left-col-heading">Finalize with a <strong>post</strong></div><div class="left-col-content">mortem cleanup sweep: re-scan the repo to ensure no new references appeared, ensure packaging scripts do not assume a fixed asset count, confirm SRI generator no longer includes entry for the removed file, and re-run table rendering pipeline with extreme inputs (very large tables, deeply nested captions) to confirm no side effects.</div></div></td></tr></tbody></table></div><div class="row-count">Rows: 18</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>