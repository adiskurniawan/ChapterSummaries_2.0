<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771304646">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0161_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modRibbonCallbacks)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modRibbonCallbacks)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Overview:</strong> This table is a per-function, authoritative technical breakdown of the <code>modRibbonCallbacks</code> VBA module you supplied. Each entry documents: purpose, signature (inputs/outputs), high-level behavior, important implementation details, algorithmic complexity, side-effects, invariants, failure modes, security/robustness considerations, recommended tests, and concise notes for maintainers. Use it as exhaustive inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>(module state & constants)</strong> — <em>module-level configuration and caches</em><br><strong>Purpose:</strong> Hold shared runtime state (ribbon reference, handler/image/state registries), scheduling constants, sheet names and column indices, job caps, CRC cache and debounce state used by many functions.<br><strong>Signature:</strong> N/A — module-level variables: <code>g_ribbon As IRibbonUI</code>, <code>g_handlerRegistry</code>, <code>g_imageProviders</code>, <code>g_lastKnownState</code>, <code>g_crc32Table()</code>, <code>g_crc32TableInitialized</code>, <code>g_invalidateScheduled</code>, <code>g_invalidateWhen</code> and many <code>Const</code>s (sheet names, column indices, caps).<br><strong>Behavior:</strong> Initialized on <code>Ribbon_OnLoad</code> or lazily by helpers. Column indices are explicit to avoid magic numbers. Constants centralize tuning. CRC table lazily constructed.<br><strong>Complexity:</strong> O(1) to read constants; CRC table initialization O(256 * 8) operations once.<br><strong>Side-effects:</strong> Global mutable state; must be robust to workbook reloads and multiple Add-in loads.<br><strong>Invariants:</strong> Column index constants must match jobs sheet schema; <code>g_crc32TableInitialized</code> must reflect table presence.<br><strong>Failure modes:</strong> Corruption if multiple copies of add-in load simultaneously; global caps may block job creation.<br><strong>Security:</strong> None directly, but state drives scheduling and audit actions that interact with sheets.<br><strong>Tests:</strong> Validate all expected constants; simulate double <code>Ribbon_OnLoad</code> and ensure idempotency.<br><strong>Notes:</strong> Keep this block minimal; add new columns only at the end and update <code>COL_HandlerMeta</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnLoad</strong> — <em>ribbon initialization / entry point</em><br><strong>Purpose:</strong> Primary entry called by Excel Ribbon when custom UI initializes. Sets up module-level registries, ensures support sheets exist, primes CRC and debounce defaults, reconciles outstanding jobs, and audits load event.<br><strong>Signature:</strong> <code>Public Sub Ribbon_OnLoad(ribbon As IRibbonUI)</code> (no return).<br><strong>Behavior:</strong> Stores ribbon reference; lazy-creates <code>g_handlerRegistry</code>, <code>g_imageProviders</code>, <code>g_lastKnownState</code>; calls <code>EnsureJobsSheetExists</code>, <code>EnsureAuditSheetExists</code>, <code>EnsureTestSheetExists</code>; attempts <code>EnsureDebounceConfigDefault</code> and <code>modUtilities.InitializeCRC32Table</code> (both tolerant of errors); calls <code>Ribbon_ReconcileJobsOnOpen</code>; emits <code>Ribbon_AuditStructured &quot;Ribbon_OnLoad&quot;</code>; errors routed to <code>Ribbon_HandleError</code>.<br><strong>Complexity:</strong> O(n) where n = number of jobs processed during reconciliation (calls <code>Ribbon_ReconcileJobsOnOpen</code>).<br><strong>Side-effects:</strong> Creates hidden support sheets if missing, modifies global registries, may call external modules (<code>modUtilities</code>, <code>modConfig</code>).<br><strong>Invariants:</strong> Runs once per ribbon load; safe to call repeatedly (idempotent protections).<br><strong>Failure modes:</strong> Missing privileges to create sheets; Application.Run failures; must not let error bubble to Excel UI. <br><strong>Security:</strong> Uses <code>Application.Run</code> to call other modules — input validated elsewhere. <br><strong>Recommended tests:</strong> Simulate workbook with no support sheets; call <code>Ribbon_OnLoad</code> and assert sheets created, CRC table initialized, audit entry appended; simulate <code>modUtilities</code> missing and confirm fallback behavior. <br><strong>Notes:</strong> Keep fast; avoid blocking operations here. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetEnabled</strong> — <em>ribbon callback for enabled state</em><br><strong>Purpose:</strong> Provide cached-enabled state to Ribbon controls to avoid repeated heavy computation in UI thread.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetEnabled(control As IRibbonControl) As Boolean</code>.<br><strong>Behavior:</strong> Calls <code>GetCachedStateFlag(GetControlId(control), &quot;enabled&quot;, True)</code>. Returns default <code>True</code> when state absent.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None (reads <code>g_lastKnownState</code> and may initialize dictionary).<br><strong>Invariants:</strong> Always returns Boolean. Cached state keys are per-controlId. <br><strong>Failure modes:</strong> If <code>control.ID</code> throws, <code>GetControlId</code> returns <code>&quot;unknown&quot;</code>; safe default <code>True</code>.<br><strong>Tests:</strong> Validate for control with and without cached state; assert fallback <code>True</code>.<br><strong>Notes:</strong> Keep very small to minimize ribbon callback latency. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetVisible</strong> — <em>ribbon callback for visibility</em><br><strong>Purpose:</strong> Provide cached visible flag for Ribbon controls.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetVisible(control As IRibbonControl) As Boolean</code>.<br><strong>Behavior:</strong> Delegates to <code>GetCachedStateFlag</code> with default <code>True</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Same as <code>Ribbon_GetEnabled</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetLabel</strong> — <em>ribbon callback for label text</em><br><strong>Purpose:</strong> Return label text cached for control, fallback to safe default (control id) if missing.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetLabel(control As IRibbonControl) As String</code>.<br><strong>Behavior:</strong> Calls <code>GetCachedStateText(GetControlId(control), &quot;label&quot;, GetControlId(control))</code> to avoid direct control id access risks. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> If <code>control.ID</code> inaccessible uses <code>&quot;unknown&quot;</code>. <br><strong>Tests:</strong> Cached label present vs absent. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetPressed</strong> — <em>ribbon callback for toggle pressed state</em><br><strong>Purpose:</strong> Provide cached pressed state for toggle controls.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetPressed(control As IRibbonControl) As Boolean</code>.<br><strong>Behavior:</strong> Delegates to <code>GetCachedStateFlag</code> with default <code>False</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Toggle state transitions reflected in cache. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_RegisterHandler</strong> — <em>register control handler (registry upsert)</em><br><strong>Purpose:</strong> Allow domain code to register a handler proc for a control ID; stores metadata including category, registration time and correlation id.<br><strong>Signature:</strong> <code>Public Sub Ribbon_RegisterHandler(controlId As String, handlerProc As String, Optional category As String = &quot;sync&quot;)</code>.<br><strong>Behavior:</strong> Validates inputs, enforces minimal handler name validation via <code>IsValidProcName</code>, constructs dictionary <code>d</code> with keys <code>proc</code>, <code>category</code>, <code>registeredAt</code>, <code>corrId</code>, and stores it into <code>g_handlerRegistry(controlId)</code>. Emits audit <code>RegisterHandler</code>. Silent no-op for invalid inputs. Errors handled by <code>Ribbon_HandleError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>g_handlerRegistry</code> and persists correlation id logic. May call <code>Ribbon_AuditStructured</code> (which may call modAudit).<br><strong>Invariants:</strong> <code>g_handlerRegistry(controlId)</code> is a Dictionary with <code>proc</code> & <code>category</code>. <code>category</code> normalized to lower-case. <br><strong>Failure modes:</strong> Invalid proc names rejected; registry absent — created lazily. <br><strong>Security:</strong> Prevents dangerous proc strings via <code>IsValidProcName</code> to avoid injection through <code>Application.Run</code>. <br><strong>Tests:</strong> Register valid and invalid handlers; assert dictionary contents and audit trace. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_RegisterImageProvider</strong> — <em>register image provider proc for control</em><br><strong>Purpose:</strong> Allow code to supply IPicture providers for ribbon image callbacks.<br><strong>Signature:</strong> <code>Public Sub Ribbon_RegisterImageProvider(controlId As String, procName As String)</code>.<br><strong>Behavior:</strong> Stores <code>procName</code> in <code>g_imageProviders(controlId)</code> and audits. No validation beyond non-empty strings. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>g_imageProviders</code>.<br><strong>Failure modes:</strong> Invalid proc will later be rejected by <code>SafeApplicationRunPicture</code>. <br><strong>Tests:</strong> Register and call <code>Ribbon_GetImage</code> to validate provider executed. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_RegisterLegacyAlias</strong> — <em>map legacy control id to a registered handler</em><br><strong>Purpose:</strong> Backwards-compatible aliasing: map older control ids to new handler entries by copying dictionary reference when <code>newId</code> exists.<br><strong>Signature:</strong> <code>Public Sub Ribbon_RegisterLegacyAlias(oldId As String, newId As String)</code>.<br><strong>Behavior:</strong> If <code>g_handlerRegistry(newId)</code> exists then <code>g_handlerRegistry(oldId)</code> is set equal to it; audits alias creation. Silent no-op otherwise.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates <code>g_handlerRegistry</code>. <br><strong>Failure modes:</strong> Does nothing if <code>newId</code> not registered. <br><strong>Tests:</strong> Register newId handler then alias oldId and verify both resolve to same handler. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnButtonClick</strong> — <em>handler dispatch for button control clicks</em><br><strong>Purpose:</strong> Central dispatch for button clicks: looks up registered handler and either executes synchronously via <code>SafeApplicationRun</code> or schedules an async job via job sheet/OnTime when <code>category=&quot;async&quot;</code>.<br><strong>Signature:</strong> <code>Public Sub Ribbon_OnButtonClick(control As IRibbonControl)</code>.<br><strong>Behavior:</strong> Gets <code>cid</code> from <code>GetControlId</code>; finds <code>h</code> in <code>g_handlerRegistry</code>; extracts <code>proc</code> and <code>category</code>; if <code>async</code> constructs <code>jobId = cid &amp; &quot;-&quot; &amp; GenerateCorrelationID(cid)</code>, calls <code>EnqueueOrUpdateJob</code> with when = Now+1s, builds <code>meta</code> via <code>BuildOnTimeProcString(&quot;Ribbon_ProcessJob_OnTime&quot;, jobId)</code>, <code>UpdateJobMeta</code>, then <code>SafeOnTimeScheduleWithRetry</code> and audits <code>ButtonClickScheduled</code>; else calls <code>SafeApplicationRun(proc)</code> and audits result. Errors routed to <code>Ribbon_HandleError</code>.<br><strong>Complexity:</strong> O(1) for sync path; O(log n) to O(n) depending on job sheet operations for async path (FindInColumn search).<br><strong>Side-effects:</strong> May write job row, schedule OnTime, append audit logs. <br><strong>Failure modes:</strong> Missing handler -> audit and noop; invalid proc rejected by <code>SafeApplicationRun</code> or schedule validation; OnTime schedule failures handled by retry function. <br><strong>Security:</strong> Uses validated proc strings; job metadata persisted to sheet; correlation id generated for tracing. <br><strong>Tests:</strong> Register both sync and async handlers; click; assert sync runs and returns result; async enqueues job row, scheduled OnTime entry persisted; audit entries created. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnToggle</strong> — <em>toggle control dispatch</em><br><strong>Purpose:</strong> Dispatches toggle state changes to handler with <code>pressed</code> boolean; supports scheduling same as button click for <code>async</code> handlers.<br><strong>Signature:</strong> <code>Public Sub Ribbon_OnToggle(control As IRibbonControl, pressed As Boolean)</code>.<br><strong>Behavior:</strong> Mirrors <code>Ribbon_OnButtonClick</code> but passes <code>pressed</code> as an argument to <code>SafeApplicationRun</code> or schedules an async job (currently async scheduled job does not persist <code>pressed</code> value — handler expected to read UI state or job row meta). Audits <code>ToggleScheduled</code>/<code>ToggleInvoked</code>.<br><strong>Complexity:</strong> Same as button click.<br><strong>Side-effects:</strong> See <code>Ribbon_OnButtonClick</code> (job sheet writes). <br><strong>Failure modes:</strong> If async and handler requires <code>pressed</code> value, mismatch because scheduled job executes later; document expectation that async handlers should query UI or handler meta. <br><strong>Tests:</strong> Toggle sync handler receives pressed arg; async schedules job row and audit. <br><strong>Notes:</strong> Consider persisting pressed state into <code>HandlerMeta</code> column for async runs. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnGalleryChange</strong> — <em>gallery/combobox selection change handler</em><br><strong>Purpose:</strong> Dispatch gallery selection changes to a handler; supports async scheduling. Selected id passed to <code>SafeApplicationRun</code> when sync.<br><strong>Signature:</strong> <code>Public Sub Ribbon_OnGalleryChange(control As IRibbonControl, selectedId As Variant)</code>.<br><strong>Behavior:</strong> Same pattern as toggle/button: sync runs with <code>selectedId</code> argument; async schedules job. Audits accordingly.<br><strong>Complexity & Side-effects:</strong> As above. <br><strong>Tests:</strong> Ensure selectedId arrives intact on sync path; scheduled jobs recorded with correlation id. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_GetImage</strong> — <em>ribbon image callback wrapper with safe execution</em><br><strong>Purpose:</strong> Provide IPictureDisp for ribbon image via registered provider, executed safely with <code>SafeApplicationRunPicture</code> to avoid errors leaking into Excel UI.<br><strong>Signature:</strong> <code>Public Function Ribbon_GetImage(control As IRibbonControl) As IPictureDisp</code>.<br><strong>Behavior:</strong> Retrieves <code>cid</code>; looks up provider proc in <code>g_imageProviders</code>; calls <code>SafeApplicationRunPicture(proc, control)</code> and returns picture if object otherwise <code>Nothing</code>. Errors handled via <code>Ribbon_HandleError</code>.<br><strong>Complexity:</strong> O(1) plus provider execution. <br><strong>Side-effects:</strong> None in module (provider may have side-effects). <br><strong>Tests:</strong> Register provider that returns IPictureDisp and confirm returned object; provider errors should not raise to UI. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ScheduleLongTask</strong> — <em>public API to schedule arbitrary job</em><br><strong>Purpose:</strong> High-level API to schedule a long-running background job by creating/updating a job row and scheduling an OnTime callback for job processing.<br><strong>Signature:</strong> <code>Public Sub Ribbon_ScheduleLongTask(jobId As String, delaySeconds As Double)</code>.<br><strong>Behavior:</strong> Validates <code>jobId</code>, computes <code>whenAt = Now + delaySeconds</code>, calls <code>EnqueueOrUpdateJob jobId, &quot;&quot;, whenAt</code>, builds <code>procStr = BuildOnTimeProcString(&quot;Ribbon_ProcessJob_OnTime&quot;, jobId)</code>, <code>UpdateJobMeta</code>, <code>SafeOnTimeScheduleWithRetry</code>, then audits <code>ScheduleJob</code>.<br><strong>Complexity:</strong> O(1) plus job sheet operations (FindInColumn).<br><strong>Side-effects:</strong> Writes job sheet row, schedules OnTime, records metadata. <br><strong>Failure modes:</strong> Global job cap prevents enqueue; schedule failures recorded and audited. <br><strong>Tests:</strong> Call with valid jobId and verify job row created and OnTime scheduled entry persisted. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>EnsureJobsSheetExists</strong> — <em>ensure support jobs sheet existed and migrated</em><br><strong>Purpose:</strong> Find or create the jobs support worksheet (<code>_IFRS_Jobs</code>), ensure header columns and migration marker, and trigger migration if necessary.<br><strong>Signature:</strong> <code>Private Function EnsureJobsSheetExists() As Worksheet</code> (returns Worksheet or Nothing).<br><strong>Behavior:</strong> Attempts to locate worksheet by name; if missing creates it with <code>CreateSupportSheet</code>, writes header array <code>A1:N1</code>, sets row 2 marker <code>v2_migrated=1</code> else checks <code>Cells(2,COL_v2_migrated)</code> for migration; if missing calls <code>MigrateJobsSheetToV2</code>. Also ensures header column count >= <code>COL_HandlerMeta</code>, patching header row if shorter.<br><strong>Complexity:</strong> O(r) where r = number of used columns/rows for header checks; migration cost is O(#rows) when invoked. <br><strong>Side-effects:</strong> May create hidden worksheet, write headers, call migration routine. <br><strong>Invariants:</strong> After success, header present with at least <code>COL_HandlerMeta</code> columns and migration marker set. <br><strong>Failure modes:</strong> Permission denied creating sheets; <code>CreateSupportSheet</code> may fail returning Nothing. <br><strong>Tests:</strong> Remove worksheet and call function; verify header created; simulate legacy sheet requiring migration. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>MigrateJobsSheetToV2</strong> — <em>deterministic migration with backup</em><br><strong>Purpose:</strong> Upgrade older jobs sheet schema to v2 safely: back up sheet, fill missing fields, set migration marker, and audit migration.<br><strong>Signature:</strong> <code>Private Sub MigrateJobsSheetToV2(sh As Worksheet)</code>.<br><strong>Behavior:</strong> Creates deterministic backup sheet <code>JOBS_backup_TIMESTAMP</code>, copies used range to backup, iterates rows 2..lastRow to set <code>CreatedAt</code>,<code>UpdatedAt</code>,<code>Attempts</code>,<code>RunDurationMs</code> defaults where empty and marks <code>v2_migrated=1</code>. Writes new header if sheet empty. Audits <code>MigrateJobsV2</code>. Errors go to <code>Ribbon_HandleError</code>.<br><strong>Complexity:</strong> O(rows) to touch each job row. <br><strong>Side-effects:</strong> New backup sheet created; original sheet modified in-place. <br><strong>Failure modes:</strong> Running out of sheet names or failure to create backup; ensure backup copy encrypted? (not implemented). <br><strong>Tests:</strong> Create sample legacy sheet missing columns and assert migration results and backup created. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>EnqueueOrUpdateJob</strong> — <em>upsert job row into jobs sheet with cap enforcement</em><br><strong>Purpose:</strong> Insert or update a job row in jobs sheet with status <code>queued</code>, scheduled time, created/updated timestamps and attempt counters. Enforce global job cap to avoid uncontrolled growth.<br><strong>Signature:</strong> <code>Private Sub EnqueueOrUpdateJob(jobId As String, Handler As String, whenAt As Date)</code>.<br><strong>Behavior:</strong> Ensures jobs sheet exists; counts <code>totalRows</code> via <code>End(xlUp)</code>; if exceeds <code>GLOBAL_JOB_CAP</code> logs audit <code>EnqueueRejected_GlobalCap</code> and exits; finds existing row via <code>FindInColumn</code> on <code>COL_JobId</code>; if none inserts new row and sets <code>CreatedAt</code>, <code>Attempts=0</code>, <code>RunDurationMs=0</code>, <code>CorrId</code>; else updates existing row. Sets <code>Handler</code>, <code>Status=&quot;queued&quot;</code>, <code>ScheduledAt</code>, <code>UpdatedAt</code>, <code>v2_migrated=1</code>. Audits <code>EnqueueOrUpdate</code>.<br><strong>Complexity:</strong> O(rows) average for Find operation (Excel FIND optimized but worst-case O(n)).<br><strong>Side-effects:</strong> Mutates workbook jobs sheet writes; may create new rows. <br><strong>Invariants:</strong> Newly inserted rows have <code>CorrId</code>. <br><strong>Failure modes:</strong> Job cap prevents insert; corrupted sheet may misreport <code>UsedRange</code>. <br><strong>Tests:</strong> Upsert new job, update existing job, simulate cap reached. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>UpdateJobMeta</strong> — <em>write meta/handler meta and timestamps to job row</em><br><strong>Purpose:</strong> Persist job meta strings (OnTime proc string or handler metadata) into job row for OnTime routing and debugging.<br><strong>Signature:</strong> <code>Private Sub UpdateJobMeta(jobId As String, meta As String)</code>.<br><strong>Behavior:</strong> Finds job row and writes <code>COL_Meta</code>, <code>COL_HandlerMeta</code>, <code>COL_UpdatedAt</code>, ensures <code>CorrId</code> present. Silent no-op if job row missing. <br><strong>Complexity:</strong> O(rows) for find. <br><strong>Side-effects:</strong> Mutates job row. <br><strong>Tests:</strong> Verify meta stored and CorrId persisted. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>FindJobRow</strong> — <em>lookup job row index</em><br><strong>Purpose:</strong> Return numeric worksheet row index for <code>jobId</code> or 0 when not found.<br><strong>Signature:</strong> <code>Private Function FindJobRow(jobId As String) As Long</code>.<br><strong>Behavior:</strong> Uses <code>EnsureJobsSheetExists</code> then <code>FindInColumn</code> on <code>COL_JobId</code>. Returns 0 when sheet or row missing. <br><strong>Complexity:</strong> O(rows) for search. <br><strong>Tests:</strong> Find existing row and non-existing job returns 0. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeOnTimeSchedule</strong> — <em>thin wrapper for Application.OnTime with validation</em><br><strong>Purpose:</strong> Schedule a valid OnTime call after validating proc string safety to avoid injection attempts and to handle errors gracefully.<br><strong>Signature:</strong> <code>Private Sub SafeOnTimeSchedule(whenAt As Date, procStr As String)</code>.<br><strong>Behavior:</strong> Validates procStr via <code>IsValidProcName</code>; calls <code>Application.OnTime EarliestTime:=whenAt, Procedure:=procStr, schedule:=True</code> inside error handler; on immediate error logs audit <code>OnTimeScheduleFailImmediate</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Schedules OnTime event. <br><strong>Failure modes:</strong> Invalid procString rejected; Application.OnTime may throw for invalid times — captured and audited. <br><strong>Tests:</strong> Try scheduling invalid and valid proc strings to observe differing audit outcomes. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeOnTimeScheduleWithRetry</strong> — <em>OnTime with retry/backoff and job attempt recording</em><br><strong>Purpose:</strong> Robust OnTime scheduling loop with up to <code>ONTIME_MAX_RETRIES</code> attempts, exponential backoff, and recording of schedule attempts into job row metadata.<br><strong>Signature:</strong> <code>Private Sub SafeOnTimeScheduleWithRetry(whenAt As Date, procStr As String, Optional jobId As String = &quot;&quot;)</code>.<br><strong>Behavior:</strong> Loops attempts 1..<code>ONTIME_MAX_RETRIES</code>: validates procStr, calls <code>Application.OnTime</code> inside <code>On Error Resume Next</code>; on success records <code>RecordScheduleAttempt jobId, attempt, True, &quot;&quot;</code> and updates job row <code>COL_ScheduledAt</code> & <code>COL_UpdatedAt</code>; on failure records attempt with error message, audits <code>OnTimeScheduleRetry</code>, computes backoffSec = <code>2^(attempt-1)</code> seconds, resets <code>whenAt = Now + backoffSec</code>, calls <code>DoEvents</code> and retries. After exceeding retries marks job as <code>orphaned</code>/<code>orphaned_permanent</code> in jobs sheet and audits <code>OnTimeScheduleFailPermanent</code>.<br><strong>Complexity:</strong> O(retries) (small fixed loop).<br><strong>Side-effects:</strong> Writes job row attempt counters and last errors; may reschedule OnTime several times; audits each retry. <br><strong>Failure modes:</strong> Repeated scheduler failures lead to orphaned jobs. <br><strong>Tests:</strong> Force Application.OnTime to fail (simulate environment or invalid proc) to exercise retry logic and orphan handling. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>RecordScheduleAttempt</strong> — <em>persist attempts and last error to job row</em><br><strong>Purpose:</strong> Increment attempt counter and record last error and timestamps for a job row, used by scheduling retry logic.<br><strong>Signature:</strong> <code>Private Sub RecordScheduleAttempt(jobId As String, attempt As Long, success As Boolean, errMsg As String)</code>.<br><strong>Behavior:</strong> Finds job row; increments <code>COL_Attempts</code>; if not success sets <code>COL_LastError</code> truncated; updates <code>COL_LastAttemptAt</code> & <code>COL_UpdatedAt</code> with Now.<br><strong>Complexity:</strong> O(rows) find + O(1) writes. <br><strong>Tests:</strong> Ensure counters increment and last error set on failures. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_AttemptGracefulShutdown</strong> — <em>cancel scheduled OnTime events and mark job statuses</em><br><strong>Purpose:</strong> Attempt to cancel scheduled jobs safely on shutdown: iterate open job rows and call <code>Application.OnTime ... schedule:=False</code> for their stored meta; mark job status to <code>cancelled</code> or <code>orphaned</code> as appropriate.<br><strong>Signature:</strong> <code>Public Sub Ribbon_AttemptGracefulShutdown()</code>.<br><strong>Behavior:</strong> Iterates rows; for status <code>queued</code> or <code>running</code> attempts to cancel scheduled OnTime using <code>meta</code> if present in job row; on cancellation failure marks <code>orphaned</code>. Updates <code>UpdatedAt</code> and audits action per job. Uses <code>On Error Resume Next</code> around cancel calls to avoid crash. <br><strong>Complexity:</strong> O(rows).<br><strong>Side-effects:</strong> Mutates jobs sheet statuses and may call <code>Application.OnTime</code> cancellation. <br><strong>Failure modes:</strong> <code>Application.OnTime</code> cancellation may fail; code robustly marks <code>orphaned</code>. <br><strong>Tests:</strong> Create queued job with meta scheduled in future and call this method; verify OnTime cancelled and status updated. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ReconcileJobsOnOpen</strong> — <em>reconcile orphaned/stale jobs at Add-in load</em><br><strong>Purpose:</strong> Ensure job rows with <code>orphaned</code> or stale <code>queued</code> statuses are rescheduled (with cap limits) or marked permanently orphaned to keep system consistent on Add-in open.\br><strong>Signature:</strong> <code>Public Sub Ribbon_ReconcileJobsOnOpen()</code>.<br><strong>Behavior:</strong> Iterates jobs; for <code>orphaned</code> if <code>Attempts &gt;= RECONCILE_RESCHEDULE_CAP</code> mark <code>orphaned_permanent</code> else set <code>queued</code>, compute <code>newWhen = Now+2s</code>, update <code>ScheduledAt</code> and <code>Meta</code> (via <code>BuildOnTimeProcString</code>), call <code>SafeOnTimeScheduleWithRetry</code>; for <code>queued</code> if <code>ScheduledAt</code> older than 5s in past treat as stale and reschedule unless attempts exceed cap; if scheduledAt missing set new schedule. Audits each decision path. <br><strong>Complexity:</strong> O(rows).<br><strong>Side-effects:</strong> Updates job rows and schedules OnTime. <br><strong>Failure modes:</strong> Persistent schedule failures lead to <code>orphaned_permanent</code>. <br><strong>Tests:</strong> Mixed job states to validate reschedule, stale detection, and orphaning. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_Invalidate</strong> — <em>debounced ribbon invalidate entry</em><br><strong>Purpose:</strong> Debounce repeated invalidation requests for the Ribbon UI; schedule a single <code>Ribbon_ExecuteDebouncedInvalidate</code> via <code>Application.OnTime</code> after configured seconds.<br><strong>Signature:</strong> <code>Public Sub Ribbon_Invalidate()</code>.<br><strong>Behavior:</strong> If <code>g_invalidateScheduled</code> true returns; sets <code>g_invalidateScheduled=True</code>, <code>debounceSec = GetConfiguredDebounceSeconds()</code>, sets <code>g_invalidateWhen = Now+debounceSec</code>, builds <code>procStr</code> referencing this workbook <code>&#x27;WorkbookName&#x27;!Ribbon_ExecuteDebouncedInvalidate</code> (validated by <code>IsValidProcName</code>), then <code>Application.OnTime g_invalidateWhen, procStr, schedule:=True</code>; if schedule fails call <code>g_ribbon.Invalidate</code> (immediate fallback) and reset scheduled flag. Uses <code>On Error Resume Next</code> to be forgiving.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Schedules OnTime call; interacts with ribbon object. <br><strong>Failure modes:</strong> Invalid proc string or schedule errors will fall back to immediate <code>g_ribbon.Invalidate</code>. <br><strong>Tests:</strong> Rapidly call <code>Ribbon_Invalidate</code> many times and assert only one scheduled OnTime exists and eventual call to <code>Ribbon_ExecuteDebouncedInvalidate</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ExecuteDebouncedInvalidate</strong> — <em>execute debounced invalidate</em><br><strong>Purpose:</strong> Called by OnTime to perform the actual <code>g_ribbon.Invalidate</code> action and clear scheduled flag.<br><strong>Signature:</strong> <code>Public Sub Ribbon_ExecuteDebouncedInvalidate()</code>.<br><strong>Behavior:</strong> Calls <code>g_ribbon.Invalidate</code> if not <code>Nothing</code> and then sets <code>g_invalidateScheduled = False</code>. Suppresses errors. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Ensure triggers ribbon update and clears flag. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>GetConfiguredDebounceSeconds</strong> — <em>read debounce setting (names / modConfig fallback)</em><br><strong>Purpose:</strong> Determine debounce seconds from workbook named range <code>IFRS_RibbonInvalidateDebounceSeconds</code> or via <code>modConfig.GetSetting</code>, with fallback to <code>DEFAULT_INVALIDATE_DEBOUNCE_SECONDS</code>.<br><strong>Signature:</strong> <code>Private Function GetConfiguredDebounceSeconds() As Double</code>.<br><strong>Behavior:</strong> If named exists reads its value (safe), else calls <code>Application.Run(&quot;modConfig.GetSetting&quot;, &quot;RibbonInvalidateDebounceSeconds&quot;)</code> tolerant of errors; if numeric returns that; else returns const fallback. Uses <code>On Error Resume Next</code> liberally.<br><strong>Complexity:</strong> O(1) but depends on <code>Application.Run</code> call. <br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> <code>modConfig</code> absent returns fallback. <br><strong>Tests:</strong> Provide named range, nil, and modConfig to assert result. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>EnsureDebounceConfigDefault</strong> — <em>seed default into modConfig if missing</em><br><strong>Purpose:</strong> Best-effort ensure <code>modConfig.SetSetting</code> contains default debounce seconds to surface configurable setting later.<br><strong>Signature:</strong> <code>Private Sub EnsureDebounceConfigDefault()</code>.<br><strong>Behavior:</strong> Calls <code>Application.Run(&quot;modConfig.GetSetting&quot;, &quot;RibbonInvalidateDebounceSeconds&quot;)</code>; if empty/invalid calls <code>Application.Run &quot;modConfig.SetSetting&quot;, &quot;RibbonInvalidateDebounceSeconds&quot;, DEFAULT_INVALIDATE_DEBOUNCE_SECONDS</code>. Tolerant of errors. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May write config if <code>modConfig</code> present. <br><strong>Tests:</strong> With a mock <code>modConfig</code> ensure setting created. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_UpdateCachedState</strong> — <em>update in-memory cached state and persist updatedAt to job row if id matches</em><br><strong>Purpose:</strong> Update <code>g_lastKnownState(cid)(key)=value</code> so ribbon callbacks can reflect the latest state. Also update the corresponding job row's <code>UpdatedAt</code> timestamp if <code>cid</code> exists as job id.<br><strong>Signature:</strong> <code>Public Sub Ribbon_UpdateCachedState(cid As String, key As String, value As Variant)</code>.<br><strong>Behavior:</strong> Ensures dictionary exists and assigns the value; then (best-effort) opens jobs sheet, finds job row by <code>cid</code> and sets <code>COL_UpdatedAt=Now</code>. <br><strong>Complexity:</strong> O(1) for dict writes; O(rows) for optional job row lookup. <br><strong>Side-effects:</strong> Mutates in-memory cache and jobs sheet <code>UpdatedAt</code> cell. <br><strong>Tests:</strong> Update cache and confirm value and job <code>UpdatedAt</code> timestamp updated. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_AuditStructured</strong> — <em>structured audit dispatcher with module fallbacks</em><br><strong>Purpose:</strong> Centralized structured audit emitter that prefers <code>modAudit.LogAudit</code> then <code>modUtilities.AppendLocalAuditStructured</code> then local fallback <code>AppendLocalAuditFallback</code> to persist audit messages safely.<br><strong>Signature:</strong> <code>Private Sub Ribbon_AuditStructured(action As String, message As String, Optional jobId As String = vbNullString, Optional procName As String = vbNullString, Optional corrId As String = vbNullString)</code>.<br><strong>Behavior:</strong> If <code>corrId</code> empty generate one; attempts <code>Application.Run &quot;modAudit.LogAudit&quot;, ...</code> first, if error falls back to <code>modUtilities.AppendLocalAuditStructured</code>, else calls local <code>AppendLocalAuditFallback</code>. Catches errors at each step and logs minimal debug on ultimate failure. <br><strong>Complexity:</strong> O(1) but may call external modules which perform I/O. <br><strong>Side-effects:</strong> Appends audit to whichever sink is available. <br><strong>Failure modes:</strong> All external sinks absent — writes to local audit sheet in fallback. <br><strong>Security:</strong> Minimal; ensure message trimming to avoid huge cell writes. <br><strong>Tests:</strong> Temporarily remove modAudit/modUtilities and verify fallback to local sheet. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_HandleError</strong> — <em>centralized error handling with delegation</em><br><strong>Purpose:</strong> Attempt structured error handling through <code>modError.HandleError</code> or <code>modUtilities.HandleError</code> and if unavailable write a local audit fallback; always attach correlation id and truncate messages for cell safety.<br><strong>Signature:</strong> <code>Private Sub Ribbon_HandleError(procName As String, errNum As Long, errDesc As String)</code>.<br><strong>Behavior:</strong> Tries <code>modError.HandleError</code> then <code>modUtilities.HandleError</code>. If both fail calls <code>AppendLocalAuditFallback &quot;HandleErrorFallback&quot;, ...</code> and <code>Debug.Print</code> for diagnostics. Wraps with <code>On Error</code> to avoid exceptions. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes audit fallback when external handlers missing. <br><strong>Tests:</strong> Force an error and verify fallback audit recorded. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>AppendLocalAuditFallback</strong> — <em>local audit sink when centralized modules missing</em><br><strong>Purpose:</strong> Write audit to <code>_IFRS_Audit</code> sheet if <code>modUtilities.AppendLocalAuditStructured</code> unavailable. Ensures minimal always-available audit path and avoids recursion into <code>Ribbon_AuditStructured</code>.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAuditFallback(action As String, message As String, jobId As String, procName As String, corrId As String)</code>.<br><strong>Behavior:</strong> Attempts <code>Application.Run &quot;modUtilities.AppendLocalAuditStructured&quot;</code> first; if that fails opens <code>EnsureAuditSheetExists</code>, appends row with <code>Now</code>, truncated action, message, corrId, jobId, procName. Swallows errors. <br><strong>Complexity:</strong> O(1) writes. <br><strong>Side-effects:</strong> Mutates audit sheet. <br><strong>Tests:</strong> Ensure fallback writes to sheet with expected columns. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>AppendLocalAudit</strong> — <em>backwards-compatible thin wrapper</em><br><strong>Purpose:</strong> Keep compatibility for other modules calling the old <code>AppendLocalAudit(action,message)</code> by routing through <code>Ribbon_AuditStructured</code>.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAudit(action As String, message As String)</code>.<br><strong>Behavior:</strong> Calls <code>Ribbon_AuditStructured</code> with generated correlation id. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Keep until dependents migrated. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>GetControlId</strong> — <em>safe retrieval of IRibbonControl.ID</em><br><strong>Purpose:</strong> Return <code>control.ID</code> or <code>&quot;unknown&quot;</code> on error to avoid raising errors in ribbon callbacks where COM objects may misbehave.<br><strong>Signature:</strong> <code>Private Function GetControlId(control As IRibbonControl) As String</code>.<br><strong>Behavior:</strong> <code>On Error Resume Next</code> to read <code>control.ID</code>; on error returns <code>&quot;unknown&quot;</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Pass a mock control that throws on <code>.ID</code> to ensure safe fallback. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Nz</strong> — <em>VB-style null/empty guard</em><br><strong>Purpose:</strong> Return default <code>d</code> when value is Error/Null/Empty otherwise original variant.<br><strong>Signature:</strong> <code>Private Function Nz(v As Variant, Optional d As Variant = &quot;&quot;) As Variant</code>.<br><strong>Behavior:</strong> If <code>IsError(v) Or IsNull(v) Or IsEmpty(v)</code> return <code>d</code> else <code>v</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Null/Empty/Error cases. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>TruncateForCell</strong> — <em>truncate long strings for safe cell writes</em><br><strong>Purpose:</strong> Truncate text to <code>MAX_ERROR_LEN</code> characters with <code>...</code> suffix to avoid excessive cell content that may break audit readability or exceed cell limits.<br><strong>Signature:</strong> <code>Private Function TruncateForCell(s As String) As String</code>.<br><strong>Behavior:</strong> If <code>Len(s) &lt;= MAX_ERROR_LEN</code> return original else return <code>Left$(s, MAX_ERROR_LEN - 3) &amp; &quot;...&quot;</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Strings shorter/longer than threshold. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>CreateSupportSheet</strong> — <em>create hidden support worksheet with unique name</em><br><strong>Purpose:</strong> Create a very-hidden support worksheet reliably, handling name collisions by suffixing <code>_n</code> if needed, return sheet object or Nothing when creation fails.\br><strong>Signature:</strong> <code>Private Function CreateSupportSheet(name As String) As Worksheet</code>.<br><strong>Behavior:</strong> Adds a new worksheet after last worksheet, attempts to set <code>.Name = name</code>; if error loops with appended suffix <code>_1..n</code> until a unique name assigned; sets <code>Visible = xlSheetVeryHidden</code>; returns new sheet. On failure audits <code>CreateSupportSheetFail</code> and returns <code>Nothing</code>.\br><strong>Complexity:</strong> O(k) where k is number of name collisions.\br><strong>Side-effects:</strong> Creates hidden sheets; may leave partially created sheet in failure — code attempts to handle but test for orphan sheets recommended.\br><strong>Tests:</strong> Repeatedly call with same name and assert unique names created. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>EnsureAuditSheetExists / EnsureTestSheetExists</strong> — <em>ensure audit/test support sheets</em><br><strong>Purpose:</strong> Find or create <code>_IFRS_Audit</code> and <code>_IFRS_TestResults</code> with proper header columns and very-hidden visibility.\br><strong>Signature:</strong> <code>Private Function EnsureAuditSheetExists() As Worksheet</code>, <code>Private Function EnsureTestSheetExists() As Worksheet</code>.\br><strong>Behavior:</strong> If sheet missing create via <code>CreateSupportSheet</code> and write headers. Return created worksheet object or Nothing if creation failed. \br><strong>Complexity:</strong> O(1). \br><strong>Side-effects:</strong> May create hidden sheets. \br><strong>Tests:</strong> Call in blank workbook and ensure both created with correct header rows. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>GenerateCorrelationID</strong> — <em>create short trace id using CRC32 fallback</em><br><strong>Purpose:</strong> Provide deterministic-ish correlation ids for auditing and OnTime routing; prefer <code>modUtilities.CRC32_String</code> delegate otherwise compute local CRC32 of a seed string and hex-encode with <code>METRIC_PREFIX</code> prefix.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID(seed As String) As String</code>.\br><strong>Behavior:</strong> Builds seed <code>t = CStr(Now) &amp; &quot;|&quot; &amp; seed &amp; &quot;|&quot; &amp; CStr(Timer)</code>; attempts <code>Application.Run(&quot;modUtilities.CRC32_String&quot;, t)</code> and on success uses that; otherwise calls <code>InitializeCRC32Table</code> and <code>CRC32_String(t)</code> and returns <code>METRIC_PREFIX &amp; HexFromLong(c)</code>. Tolerant of errors. \br><strong>Complexity:</strong> CRC call O(len(bytes)). Local CRC uses precomputed table; cost O(n). \br><strong>Side-effects:</strong> None. \br><strong>Tests:</strong> Generate multiple ids ensure uniqueness and stable format. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>InitializeCRC32Table / CRC32_String / StrToBytes / HexFromLong</strong> — <em>local CRC32 implementation</em><br><strong>Purpose:</strong> Local deterministic CRC32 functions used when <code>modUtilities</code> unavailable: initialize lookup table, compute CRC32 on UTF-16LE bytes (<code>StrToBytes</code>), and format hex string.\br><strong>Signatures:</strong> <code>Private Sub InitializeCRC32Table()</code>, <code>Private Function CRC32_String(s As String) As Long</code>, <code>Private Function StrToBytes(s As String) As Byte()</code>, <code>Private Function HexFromLong(v As Long) As String</code>.\br><strong>Behavior:</strong> <code>InitializeCRC32Table</code> populates <code>g_crc32Table(0..255)</code> with polynomial &HEDB88320; <code>CRC32_String</code> builds bytes via <code>StrToBytes</code>, iterates bytes updating <code>crc</code> via table and returns <code>crc Xor &amp;HFFFFFFFF</code>; <code>StrToBytes</code> obtains UTF-16LE bytes by simple assignment <code>b = s</code> (VBA behaviour); <code>HexFromLong</code> returns zero-padded 8-hex-digit string. \br><strong>Complexity:</strong> Table init O(256*8) once; CRC compute O(len(bytes)). \br><strong>Side-effects:</strong> Allocates <code>g_crc32Table</code> and sets flag. \br><strong>Tests:</strong> Cross-verify with known CRC32 test vectors; compare delegated <code>modUtilities</code> output if available. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>FindJobScheduledAt</strong> — <em>read scheduled time for a job id</em><br><strong>Purpose:</strong> Convenience access to scheduled time stored in job row or Empty if not found.\br><strong>Signature:</strong> <code>Private Function FindJobScheduledAt(jobId As String) As Variant</code>.\br><strong>Behavior:</strong> Find job row and return cell <code>COL_ScheduledAt</code> value or Empty. \br><strong>Complexity:</strong> O(rows). \br><strong>Tests:</strong> Row exists and missing row case. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>IncrementJobAttemptsRow</strong> — <em>increment attempts counter on a specific row</em><br><strong>Purpose:</strong> Small helper to increment <code>COL_Attempts</code> on a given worksheet row index (used by process/job code paths).\br><strong>Signature:</strong> <code>Private Sub IncrementJobAttemptsRow(sh As Worksheet, rowIdx As Long)</code>.\br><strong>Behavior:</strong> <code>On Error Resume Next</code> increment cell value <code>COL_Attempts</code> by 1 using <code>Nz</code> fallback. \br><strong>Complexity:</strong> O(1). \br><strong>Tests:</strong> Row with numeric/empty attempts. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>BuildOnTimeProcString</strong> — <em>construct OnTime procedure string with fallback routing</em><br><strong>Purpose:</strong> Build either a long OnTime proc string that directly invokes <code>procBase</code> with a corrId argument (if string length and validation permit) or fallback to short route <code>Ribbon_OnTimeRoute corrId</code> that resolves via corrId at runtime. Persist corrId to job row for route resolution.\br><strong>Signature:</strong> <code>Public Function BuildOnTimeProcString(procBase As String, jobId As String) As String</code>.<br><strong>Behavior:</strong> Escapes workbook name by doubling single quotes, generates <code>corrId = GenerateCorrelationID(jobId)</code>, constructs <code>longProc = &quot;&#x27;wbName&#x27;!procBase &quot;&quot;corrId&quot;&quot;&quot;</code>. If <code>Len(longProc) &lt;= PROC_STR_MAX_LEN</code> and <code>IsValidProcName(longProc)</code> returns true then returns <code>longProc</code>; else returns <code>&quot;&#x27;wb&#x27;!Ribbon_OnTimeRoute &quot;&quot;corrId&quot;&quot;&quot;</code>. Persists <code>corrId</code> into job row <code>COL_CorrId</code> if <code>jobId</code> provided. On error falls back to short route without raising. <br><strong>Complexity:</strong> O(1) plus job row write O(rows) for persistence. <br><strong>Side-effects:</strong> May write <code>COL_CorrId</code> into jobs sheet. <br><strong>Failure modes:</strong> Very long workbook names may require fallback; persistence could fail. <br><strong>Security:</strong> Uses <code>IsValidProcName</code> to avoid unsafe proc strings. <br><strong>Tests:</strong> Test long and short route outputs; verify corrId persisted. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>NameExists / FindInColumn</strong> — <em>support helpers for Names and Find</em><br><strong>Purpose:</strong> <code>NameExists</code> checks if workbook-level name exists robustly; <code>FindInColumn</code> searches a given column for a lookup value using <code>Range.Find</code> with stable parameters.<br><strong>Signatures:</strong> <code>Private Function NameExists(nm As String) As Boolean</code>, <code>Private Function FindInColumn(sh As Worksheet, colIndex As Long, lookup As Variant) As Range</code>.<br><strong>Behavior:</strong> <code>NameExists</code> attempts <code>ThisWorkbook.Names(nm)</code> and returns not Nothing; <code>FindInColumn</code> defends <code>On Error</code> and uses <code>sh.Columns(colIndex).Find(... LookAt:=xlWhole, MatchCase:=False)</code>. <br><strong>Complexity:</strong> <code>FindInColumn</code> O(n) internal Excel optimized find. <br><strong>Tests:</strong> Named range present/absent and search matches/miss. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>IsValidProcName</strong> — <em>whitelist-ish validation for Application.Run/OnTime proc strings</em><br><strong>Purpose:</strong> Strong defensive validator for proc strings used with <code>Application.Run</code> and <code>Application.OnTime</code> to prevent injection of arbitrary commands (e.g., multiple chained statements) and disallow control characters beyond printable ASCII; also validates quoting patterns for OnTime-style workbook-qualified strings.<br><strong>Signature:</strong> <code>Private Function IsValidProcName(procName As String) As Boolean</code>.<br><strong>Behavior:</strong> Returns False for empty or overly long strings (>PROC_STR_MAX_LEN), disallows control chars (ASCII <32 or >126), disallows <code>;</code> and <code>,</code> to prevent command chaining, rejects unpaired quotes, rejects multiple <code>!</code> separators; allows parentheses; validates both OnTime-style (<code>!</code> present) strings by splitting into workbook/rhs and conducting basic checks on rhs including paired quotes count of 0 or 2. For non-<code>!</code> strings disallows quotes altogether. <br><strong>Complexity:</strong> O(len(procName)). <br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Conservative; may reject some valid but complex proc strings — callers must update whitelist if legitimate cases encountered. <br><strong>Tests:</strong> Good/bad proc strings including OnTime longProc, and injections like <code>Proc;Other</code> should be rejected. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>MakeArgSafe / CStrSafe</strong> — <em>sanitize and normalize args for SafeApplicationRun</em><br><strong>Purpose:</strong> Convert arguments to safe scalar representations to limit <code>Application.Run</code> argument surface; object/complex types converted to <code>typeName:value</code> string fallback.<br><strong>Signatures:</strong> <code>Private Function MakeArgSafe(a As Variant) As Variant</code>, <code>Private Function CStrSafe(v As Variant) As String</code>.<br><strong>Behavior:</strong> <code>MakeArgSafe</code> permits scalar types (String, Boolean, Integer, Long, Single, Double, Date, Empty, Null), converts vbError to string; for other types returns <code>TypeName(a) &amp; &quot;:&quot; &amp; CStrSafe(a)</code> to avoid passing object references across <code>Application.Run</code>. <code>CStrSafe</code> attempts <code>CStr(v)</code> and falls back to <code>TypeName(v)</code> on error. <br><strong>Complexity:</strong> O(1). <br><strong>Security:</strong> Prevents passing complex objects into handlers that are executed later, lowering risk and facilitating auditability. <br><strong>Tests:</strong> Pass scalar, object, error types. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeApplicationRun</strong> — <em>bounded, sanitized Application.Run wrapper with centralized delegate preference</em><br><strong>Purpose:</strong> Execute a proc safely with capped and sanitized arguments, prefer <code>modUtilities.TryRunReturn(proc, args...)</code> if available, fall back to direct <code>Application.Run</code> with up to <code>SAFE_ARG_LIMIT</code> args. Records audits on invalid proc names or failures. Returns the result or Empty on error/invalid input.<br><strong>Signature:</strong> <code>Public Function SafeApplicationRun(proc As String, ParamArray args() As Variant) As Variant</code>.<br><strong>Behavior:</strong> Validates <code>proc</code> with <code>IsValidProcName</code>, caps <code>argCount</code> to <code>SAFE_ARG_LIMIT</code>; sanitizes up to first three args via <code>MakeArgSafe</code>; attempts <code>Application.Run(&quot;modUtilities.TryRunReturn&quot;, proc, a0,a1,a2)</code> first (non-throwing path if present) and on error falls back to <code>Application.Run(proc, ...)</code> with capped args. Any error generates <code>Ribbon_AuditStructured &quot;SafeApplicationRunFail&quot;</code> and returns Empty. On success returns result of run. <br><strong>Complexity:</strong> O(1) plus cost of invoked proc. <br><strong>Side-effects:</strong> May call external module functions; audits on failure. <br><strong>Failure modes:</strong> Invalid proc rejected; delegate call may be absent causing fallback. <br><strong>Security:</strong> Strong validation of proc name and argument sanitization prevents unexpected COM/automation behaviour or injection. <br><strong>Tests:</strong> Call safe run with valid/invalid proc, with >3 args, and ensure auditing. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>SafeApplicationRunPicture</strong> — <em>picture-specialized safe run wrapper</em><br><strong>Purpose:</strong> Same as <code>SafeApplicationRun</code> but explicitly expects and returns <code>IPictureDisp</code> object; returns <code>Nothing</code> on failure or if returned value is not object.<br><strong>Signature:</strong> <code>Public Function SafeApplicationRunPicture(proc As String, ParamArray args() As Variant) As IPictureDisp</code>.<br><strong>Behavior:</strong> Delegates to <code>SafeApplicationRun</code> and if returned value is object sets result; otherwise returns <code>Nothing</code>. Errors handled by <code>Ribbon_HandleError</code>. <br><strong>Tests:</strong> Register image provider returning IPictureDisp and validate; provider returning other types yields <code>Nothing</code>. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_OnTimeRoute</strong> — <em>short routing proc called by short OnTime route</em><br><strong>Purpose:</strong> When <code>BuildOnTimeProcString</code> returned the short route, OnTime will call <code>Ribbon_OnTimeRoute(corrId)</code> which resolves the job row by <code>COL_CorrId</code> and calls <code>Ribbon_ProcessJob</code> for the found <code>jobId</code>.\br><strong>Signature:</strong> <code>Public Sub Ribbon_OnTimeRoute(routeId As String)</code>.\br><strong>Behavior:</strong> Validates <code>routeId</code>, finds job row via <code>FindInColumn</code> on <code>COL_CorrId</code>, audits <code>OnTimeRouteNotFound</code> if missing, reads <code>jobId</code> from that row and calls <code>Ribbon_ProcessJob jobId</code>. <br><strong>Complexity:</strong> O(rows) for find. <br><strong>Side-effects:</strong> None except subsequent <code>Ribbon_ProcessJob</code>. <br><strong>Failure modes:</strong> Missing corrId or job row logs audit and exits. <br><strong>Tests:</strong> Simulate OnTime short route invocation and verify job executed. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ProcessJob_OnTime</strong> — <em>OnTime entry using longProc route</em><br><strong>Purpose:</strong> When longProc route is used, OnTime will call <code>Ribbon_ProcessJob_OnTime(argCorrId)</code>; function resolves the job row by corrId and calls <code>Ribbon_ProcessJob jobId</code>.\br><strong>Signature:</strong> <code>Public Sub Ribbon_ProcessJob_OnTime(argCorrId As String)</code>.\br><strong>Behavior:</strong> Validates <code>argCorrId</code>; <code>FindInColumn</code> on <code>COL_CorrId</code> to locate job row; audit and return if none found; reads jobId and calls <code>Ribbon_ProcessJob jobId</code>. <br><strong>Complexity:</strong> O(rows). <br><strong>Tests:</strong> longProc with corrId present triggers job run. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_ProcessJob</strong> — <em>core job execution & lifecycle updates</em><br><strong>Purpose:</strong> Validate and run a job's handler (from job sheet Handler cell), update job status and attempts counters, measure run duration, persist last error on failure, and decide on final job state (<code>completed</code> or <code>orphaned</code>/<code>orphaned_permanent</code>). This is the authoritative job runtime pathway invoked either directly or via OnTime routing.\br><strong>Signature:</strong> <code>Public Sub Ribbon_ProcessJob(jobId As String)</code>.\br><strong>Behavior (stepwise):</strong> 1) Validate jobId; find job row; if missing audit and exit. 2) Read <code>handlerName</code> from job row; if empty set <code>Status=&quot;failed&quot;</code>, set <code>LastError=&quot;No handler&quot;</code>, update <code>UpdatedAt</code> and audit. 3) Set <code>Status=&quot;running&quot;</code>, set <code>LastAttemptAt</code> and <code>UpdatedAt</code> and increment attempts via <code>IncrementJobAttemptsRow</code>. 4) Record <code>startDT = Now</code>, <code>ok=False</code>; <code>On Error GoTo HandlerRunErr</code> and call <code>res = SafeApplicationRun(handlerName, jobId)</code>; on success set <code>ok=True</code>. 5) On handler error (HandlerRunErr) capture <code>Err.Description</code> truncated to <code>herr</code>, set <code>ok=False</code>, write <code>LastError=herr</code>, audit <code>ProcessJobHandlerError</code>. 6) In finally block compute <code>durMs = CLng((Now - startDT) * 24*3600*1000)</code> write to <code>COL_RunDurationMs</code>, update <code>UpdatedAt</code>. If <code>ok=True</code> set <code>Status=&quot;completed&quot;</code> and clear <code>LastError</code>, audit <code>ProcessJobComplete</code>; else if attempts >= <code>RECONCILE_RESCHEDULE_CAP</code> set <code>Status=&quot;orphaned_permanent&quot;</code> else <code>Status=&quot;orphaned&quot;</code>. <br><strong>Complexity:</strong> O(rows) to locate job + handler execution cost. <br><strong>Side-effects:</strong> Mutates job row heavily: status, last error, attempts, run duration; may call arbitrary handler code via <code>SafeApplicationRun</code>. <br><strong>Invariants:</strong> Update timestamp always set; attempts incremented. <br><strong>Failure modes:</strong> Handler may crash — caught and recorded; long-running handlers may block Excel UI if not async. <br><strong>Security:</strong> Handler names validated earlier; however <code>SafeApplicationRun</code> must prevent dangerous arg types. <br><strong>Tests:</strong> Execute with: non-existent handler, handler that throws, a successful handler (mock via small procedure), ensure status transitions and audit entries. <br><strong>Notes for maintainers:</strong> Consider adding timeouts for long-running handlers or running handlers in a worker/external process to avoid blocking UI. Persist handler arguments or metadata if needed for async semantics. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Ribbon_RunSelfTestOnce / Ribbon_VerifyPlan / Ribbon_SelfTest</strong> — <em>CI / verification hooks & self-test harness</em><br><strong>Purpose:</strong> Provide deterministic self-test routines for CI and manual verification that create rows in <code>TEST_SHEET_NAME</code> documenting the pass/fail of various checks: existence of support sheets, debounce config, proc-name validation, OnTime proc generation, enqueue/find/update meta, safe-run rejects, cleanup etc. <code>Ribbon_RunSelfTestOnce</code> is a thin wrapper to run the self-test. <code>Ribbon_VerifyPlan</code> runs lightweight checks 10× writing results. <code>Ribbon_SelfTest</code> runs a sequence of tests including enqueue and cleanup and audits <code>SelfTestComplete</code>.<br><strong>Signatures:</strong> <code>Public Sub Ribbon_RunSelfTestOnce()</code>, <code>Public Sub Ribbon_VerifyPlan()</code>, <code>Public Sub Ribbon_SelfTest()</code>.<br><strong>Behavior:</strong> Each test writes timestamp, test name, iteration and pass/fail with notes into <code>_IFRS_TestResults</code>. Tests are defensive and wrapped in <code>On Error</code> to always write a fail row on unexpected exceptions. <code>Ribbon_SelfTest</code> enqueues a <code>selftest-job</code> with a generated correlation id, runs multiple small assertions and marks test job cancelled at the end. Audits <code>SelfTestComplete</code> on success. <br><strong>Complexity:</strong> O(test_count) where test_count ~ 10; each may call O(rows) operations (job sheet lookups) but small. <br><strong>Side-effects:</strong> Mutates test sheet rows and jobs sheet for test job but cleans it up. <br><strong>Failure modes:</strong> Tests depend on sheet creation — if sheet creation fails tests will log failure; tests should be safe and idempotent. <br><strong>Tests:</strong> Running harness itself is the test. Use CI to call <code>Ribbon_RunSelfTestOnce</code> after deployment. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Public callback list (doc) & helper public subs</strong> — <em>one-page list of public subs for API stability</em><br><strong>Purpose:</strong> Human-readable list included in module comments enumerating the public API surface to keep implementation and exports in sync. Includes <code>Ribbon_OnLoad</code>, <code>Ribbon_OnButtonClick</code>, <code>Ribbon_OnToggle</code>, <code>Ribbon_OnGalleryChange</code>, <code>Ribbon_Get*</code> callbacks, <code>Ribbon_Register*</code>, scheduling and job processing APIs, and self-test functions. <br><strong>Notes:</strong> Keep this list up-to-date when adding/removing public subs to avoid ribbon XML/Excel runtime mismatch. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Misc small helpers (FindJobScheduledAt already documented)</strong> — <em>any tiny helpers not explicitly listed</em><br><strong>Purpose:</strong> Utility functions such as <code>IncrementJobAttemptsRow</code> are intentionally small single-responsibility units enabling readability and testability. <br><strong>Notes:</strong> Maintain unit tests for these to avoid regression in larger flows. </td></tr><tr><td data-label="Technical breakdown (modRibbonCallbacks)"> <strong>Global design notes & recommendations</strong> — <em>operational & security guidance</em><br><strong>Behavioral summary:</strong> <code>modRibbonCallbacks</code> implements a defensive Ribbon dispatch + job scheduler architecture using a job sheet as durable queue, OnTime for deferred execution, audit fallback chain, and robust validation and retry logic. It prefers centralized helpers in <code>modUtilities</code>, <code>modAudit</code> and <code>modError</code> but provides local fallbacks to remain operational when those modules are absent. The module is deliberately conservative about <code>Application.Run</code> and <code>Application.OnTime</code> inputs via <code>IsValidProcName</code> and <code>SafeApplicationRun</code> to reduce injection/execution risk. <br><strong>Performance:</strong> Job sheet <code>FindInColumn</code> searches are the main possible O(n) hotspots; limit global job cap; consider indexing strategies (sorted JobId column) if necessary. <br><strong>Robustness:</strong> <code>SafeOnTimeScheduleWithRetry</code> and <code>Ribbon_ReconcileJobsOnOpen</code> provide recovery from transient OnTime scheduling failures and orphaned jobs on Excel restarts. <br><strong>Security & safety:</strong> Never pass complex object references into scheduled jobs; <code>MakeArgSafe</code> converts to strings. <code>IsValidProcName</code> is conservative — update only with careful review. Audit/tracing uses correlation ids (CRC32 or modUtilities). <br><strong>Recommended tests:</strong> Unit tests for <code>IsValidProcName</code>, <code>BuildOnTimeProcString</code> permutations, job enqueue/upsert paths, OnTime scheduling with simulated failures, <code>Ribbon_ProcessJob</code> success/fail paths, CRC32 parity tests, and <code>Ribbon_SelfTest</code> integration. <br><strong>Maintenance notes:</strong> - When adding new job row columns append to schema and update <code>EnsureJobsSheetExists</code> header initializer. - When changing <code>IsValidProcName</code> rules coordinate with CI and increase <code>PROC_STR_MAX_LEN</code> only with audit. - Consider persisting job metadata JSON into <code>HandlerMeta</code> rather than opaque meta strings to support complex argument passing. - Add unit-test harness (VB-based test runner or external automation) that calls <code>Ribbon_RunSelfTestOnce</code> in CI after workbook build. </td></tr></tbody></table></div><div class="row-count">Rows: 56</div></div><div class="table-caption" id="Table2" data-table="Docu_0161_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modSecurity)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modSecurity)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Overview:</strong> This table gives a world-class, per-function technical breakdown of the <code>modSecurity</code> VBA module you supplied. Each entry documents: purpose, signature (inputs/outputs), internal behavior, complexity, side-effects, invariants, failure modes, security considerations, recommended tests, and notes for maintainers. Use as authoritative inline documentation for reviewers/auditors/QA. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_CheckWorkbookSignature(minSignatures As Long = -1, Optional callerCid As String = "")</strong> — <em>workbook digital-signature probe & audit</em><br><strong>Purpose:</strong> Verify that the open workbook has at least a minimum number of signatures; resolve default <code>minSignatures</code> at runtime from configuration candidates if a sentinel is passed.<br><strong>Signature:</strong> <code>Function Security_CheckWorkbookSignature(Optional minSignatures As Long = -1, Optional callerCid As String = &quot;&quot;) As Boolean</code> — returns <code>True</code> if signature count >= resolved threshold, else <code>False</code>.<br><strong>Behavior:</strong> Resolves <code>minSignatures</code> when passed <code>-1</code> by calling <code>RunConfigGet(&quot;DEFAULT_MIN_SIGNATURES&quot;, MS_DEFAULT_MIN_SIGNATURES)</code>. Checks workbook availability via <code>WorkbookAvailable(ThisWorkbook)</code>. Reads <code>ThisWorkbook.Signatures.count</code> defensively under <code>On Error Resume Next</code> to tolerate objects absence or runtime trust settings. Audits result via <code>Security_Audit</code>. Returns <code>False</code> on any error via <code>ErrHandler</code> with <code>Security_HandleError</code> call.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes an audit entry. May call RunConfigGet which in turn might call external config candidate procedures.<br><strong>Invariants:</strong> If workbook unavailable returns <code>False</code>. If config value non-numeric falls back to module default. Does not change workbook state.<br><strong>Failure modes:</strong> Missing <code>Signatures</code> collection, protected environment where signature APIs unavailable, malformed config value. All are handled with safe fallback to <code>False</code> and audit.<br><strong>Security:</strong> Non-sensitive; ensures signature-based integrity checks are applied conservatively. Avoids throwing sensitive data into logs; uses audit redaction.<br><strong>Tests:</strong> (1) Workbook with 0, 1, N signatures and various <code>DEFAULT_MIN_SIGNATURES</code> settings. (2) No workbook context (call from unexpected host) should return False. (3) Malformed config value (non-numeric) falls back correctly.<br><strong>Notes:</strong> Keeps public signature API stable while avoiding compile-time default constant dependency. Good candidate to add unit test that simulates signature exception paths. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_IsVBAProjectProtected(Optional callerCid As String = "") As Variant</strong> — <em>probe VBProject protection state</em><br><strong>Purpose:</strong> Return protection state of <code>ThisWorkbook.VBProject.Protection</code> where permitted; return <code>CVErr(xlErrNA)</code> when probe not possible or unavailable.<br><strong>Signature:</strong> <code>Function Security_IsVBAProjectProtected(Optional callerCid As String = &quot;&quot;) As Variant</code> — <code>Variant</code> to allow <code>CVErr</code> sentinel.<br><strong>Behavior:</strong> Validates workbook availability. Attempts to read <code>ThisWorkbook.VBProject.Protection</code> under <code>On Error Resume Next</code>. Returns <code>CVErr(xlErrNA)</code> on errors or missing object; otherwise returns the protection value. Audits outcome.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Audit only.<br><strong>Invariants:</strong> Returns <code>CVErr(xlErrNA)</code> when VBE access denied or on Mac. Consumers must test <code>IsError()</code> before using numeric result.<br><strong>Failure modes:</strong> VBE trust settings blocking access (common), cross-platform differences. Clean error handling present.<br><strong>Security:</strong> Reading VBProject may be sensitive; returned value is non-secret. Keep audit redacted.<br><strong>Tests:</strong> Call when VBE access allowed/denied; assert CVErr returned in denied case. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_VerifyMacroSettings(Optional callerCid As String = "") As Boolean</strong> — <em>automation macro-security validation</em><br><strong>Purpose:</strong> Check <code>Application.AutomationSecurity</code> is not set to <code>msoAutomationSecurityForceDisable</code> (value 2).<br><strong>Signature:</strong> <code>Function Security_VerifyMacroSettings(Optional callerCid As String = &quot;&quot;) As Boolean</code> — returns <code>True</code> when macros permitted at runtime level.<br><strong>Behavior:</strong> Reads <code>Application.AutomationSecurity</code>, compares to 2, returns boolean; audits value and result. Handles errors via <code>Security_HandleError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Audit. Does not alter <code>AutomationSecurity</code>.<br><strong>Invariants:</strong> If error occurs returns False.<br><strong>Failure modes:</strong> Non-standard hosts, unexpected security enumeration values. Handled. <br><strong>Security:</strong> Conservative: treat absence or error as unacceptable. <br><strong>Tests:</strong> Simulate <code>AutomationSecurity = 2</code> and other values; assert result and audit. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_IsUserAdmin(Optional callerCid As String = "") As Boolean</strong> — <em>best-effort OS-level admin check (Windows-only)</em><br><strong>Purpose:</strong> Determine whether current user is in administrators group using <code>whoami /groups</code> heuristic guarded by feature flags and creation of <code>WScript.Shell</code> only when permitted.<br><strong>Signature:</strong> <code>Function Security_IsUserAdmin(Optional callerCid As String = &quot;&quot;) As Boolean</code> — returns <code>True/False</code>.<br><strong>Behavior:</strong> Short-circuits on Mac (returns and audits unsupported). Uses <code>CreateObjectSafe(&quot;WScript.Shell&quot;)</code> feature-flag gated by <code>FLAG_USE_WHOAMI_FOR_ADMIN_PROBE</code>. When enabled, runs <code>Security_RunCmdAndGetOutput(&quot;whoami /groups&quot;, cid)</code>, truncates output to 4096 chars, searches for <code>s-1-5-32-544</code> SID or string <code>administrators</code>. Audits outcomes. Returns False for missing features or parsing failure.<br><strong>Complexity:</strong> O(output length) for parsing; typically small.<br><strong>Side-effects:</strong> Potentially spawns <code>cmd</code> via <code>WScript.Shell.Exec</code> (guarded by IsCmdSafe and feature flag). Writes audit.<br><strong>Invariants:</strong> Never escalates privileges. On Mac or when disabled, returns False and logs.<br><strong>Failure modes:</strong> <code>whoami</code> absent, output localized or different format, command execution blocked — handled with logs and False.<br><strong>Security:</strong> Dangerous to run arbitrary shell; mitigations: feature flag gate, <code>IsCmdSafe</code> check, output length truncation, audit only. Recommended to keep disabled unless vetted. <br><strong>Tests:</strong> Feature-flag enabled/disabled flows, simulate <code>whoami</code> output containing admin SID and not, host without WScript. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_AllowExportToPath(targetPath As String, Optional callerCid As String = "") As Boolean</strong> — <em>policy check for permitted export locations</em><br><strong>Purpose:</strong> Determine whether an arbitrary <code>targetPath</code> is permitted for export, using an allow-list CSV from config or default workbook path fallback and a writeability check.<br><strong>Signature:</strong> <code>Function Security_AllowExportToPath(ByVal targetPath As String, Optional callerCid As String = &quot;&quot;) As Boolean</code>.<br><strong>Behavior:</strong> Normalizes <code>targetPath</code> via <code>NormalizePathShared</code>. Retrieves <code>DEFAULT_EXPORT_ALLOW_KEY</code> via <code>RunConfigGet</code> and resolves allowed CSV via <code>RunConfigGet(CFGRES, &quot;&quot;)</code> if <code>DEFAULT_EXPORT_ALLOW_KEY</code> is a key. If <code>allowedCsv</code> empty then compute workbook path fallback and permit if <code>Security_PathIsUnder(tNorm, rNorm)</code> and <code>Security_VerifyExportPathWritable</code> returns true. If CSV present, check each entry normalized and permit + writable. Audit the decision. Uses <code>Security_PathIsUnder</code> and <code>Security_VerifyExportPathWritable</code> for safety.<br><strong>Complexity:</strong> O(N) where N = number of CSV entries; string ops dominated.<br><strong>Side-effects:</strong> Audit and potential atomic write attempt inside <code>VerifyExportPathWritable</code> which performs a temp-file roundtrip.<br><strong>Invariants:</strong> Returns False on invalid or empty <code>targetPath</code>. Normalizes to trailing-slash style paths. <br><strong>Failure modes:</strong> Misconfigured CSV/keys, inability to access FileSystemObject, race conditions between writable probe and actual export; atomic write probe might fail due to antivirus or network share latency — function returns False on probe failure. <br><strong>Security:</strong> Prevents exporting outside allow-lists; prefers safe defaults (workbook path). Warning: probing via atomic write can create artifacts; ensure cleanup. <br><strong>Tests:</strong> Allowed CSV matching exact and subfolder cases; workbook fallback allowed path; unwritable path returns False. Simulate FSO unavailable. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_GetCredential(credKey As String, Optional callerCid As String = "") As String</strong> — <em>credential retrieval with secure-store-first strategy</em><br><strong>Purpose:</strong> Retrieve a secret by key, preferring secure store procedures, falling back to delegated prompts, and rejecting CustomXMLParts at runtime (deprecated). Controlled fallback to unmasked InputBox behind feature flag.<br><strong>Signature:</strong> <code>Function Security_GetCredential(ByVal credKey As String, Optional callerCid As String = &quot;&quot;) As String</code> — returns credential string or <code>&quot;&quot;</code> when unavailable/refused.<br><strong>Behavior:</strong> Validates <code>credKey</code>. Calls <code>RunCandidatesReturn</code> with candidate secret-getter names (prefers <code>modConfig.Config_GetSecret</code>). If populated returns result and audits with <code>method=store</code>. If empty, logs deprecation about CustomXML and tries delegated prompt candidate names (<code>SecretPrompt,modConfig.SecretPrompt,...</code>) via <code>RunCandidatesReturn</code>. If present and string, return it. If still empty and <code>FLAG_ENABLE_PROMPT_FALLBACK</code> enabled, prompt via <code>Security_PromptForSecret</code> (unmasked InputBox potentially) and return if non-empty. Otherwise audit <code>prompt_disabled</code> and return empty. All calls happen under error handling and redacted audits.<br><strong>Complexity:</strong> O(1) for calls; depends on external candidate implementations.<br><strong>Side-effects:</strong> May show prompt UI (masked delegated prompt or InputBox), audits, calls to external config procedures.<br><strong>Invariants:</strong> Never reads CustomXMLParts; does not persist values. <br><strong>Failure modes:</strong> Secret store absent or candidate procs unavailable; delegated prompt may return non-string types; InputBox may be canceled (returns False boolean). Handled gracefully. <br><strong>Security:</strong> Designed to avoid plaintext secret persistence. Avoids reading CustomXML in runtime. Redacts <code>credKey</code> in audits via <code>RedactKey</code>. Developers must ensure delegated prompt implementations are secure (masking, OS-level keychain). <br><strong>Tests:</strong> (1) Secret store returns value path. (2) Delegated prompt candidate invoked. (3) Feature-flag prompt fallback exercised and prevented when flag disabled. (4) Ensure audit does not contain raw secret. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_SetCredential(credKey As String, credValue As String, Optional callerCid As String = "") As Boolean</strong> — <em>credential persistence via secure store, conservative fallback</em><br><strong>Purpose:</strong> Store a credential using secure store candidate procedures; refuse insecure persistence unless explicit feature flags enable deprecated CustomXML write path with migration flag confirmation.<br><strong>Signature:</strong> <code>Function Security_SetCredential(ByVal credKey As String, ByVal credValue As String, Optional callerCid As String = &quot;&quot;) As Boolean</code> — returns <code>True</code> on success.<br><strong>Behavior:</strong> Validates inputs. Attempts <code>RunCandidatesReturn</code> for config-set candidates (e.g., <code>modConfig.Config_SetSecret</code>) and if success marks ok and audits as <code>method=store</code>. If absent and both <code>FLAG_ALLOW_PLAINTEXT_SECRET_PERSIST</code> and <code>FLAG_CUSTOMXML_MIGRATION_CONFIRM</code> true, attempts to write a CustomXML fragment to <code>ThisWorkbook.CustomXMLParts.Add</code> with encoded XML; audits method <code>customxml_deprecated_write</code> on success. Otherwise refuses and audits <code>refused_no_store</code> returning False. Error handling via <code>Security_HandleError</code>.<br><strong>Complexity:</strong> O(1) plus XML creation cost.<br><strong>Side-effects:</strong> May write CustomXMLParts (deprecated behavior) — this is destructive and flagged. Audits operations. <br><strong>Invariants:</strong> Will not write plaintext unless both flags enabled. Secure-store writes preferred. <br><strong>Failure modes:</strong> Candidate store absent, inability to write CustomXML due to protected workbook; function returns False. <br><strong>Security:</strong> Very sensitive function: writing secrets to CustomXML is explicitly discouraged. Must ensure audits do not contain credential values. Recommend unit tests to verify flags prevent insecure persistence. <br><strong>Tests:</strong> Secure store success path; flags-off refusal; flags-on CustomXML write success/failure. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_RunCmdAndGetOutput(cmd As String, Optional callerCid As String = "") As String</strong> — <em>safe, time-limited command runner (Windows-only)</em><br><strong>Purpose:</strong> Run safe OS command (Windows <code>cmd /c &lt;cmd&gt;</code>) using <code>WScript.Shell.Exec</code>, read stdout with an enforced timeout, return textual output; heavily policy-gated and sanitized.<br><strong>Signature:</strong> <code>Function Security_RunCmdAndGetOutput(ByVal cmd As String, Optional callerCid As String = &quot;&quot;) As String</code> — returns collected stdout or <code>&quot;&quot;</code> on failure/skip.<br><strong>Behavior:</strong> Rejects on Mac. Checks <code>IsCmdSafe(cmd)</code> to detect dangerous tokens/patterns (pipes, redirects, blacklisted tools, URL patterns). Attempts to create <code>WScript.Shell</code> via <code>CreateObjectSafe</code>. Executes <code>cmd /c &lt;cmd&gt;</code> via <code>wsh.Exec</code>. Loops reading <code>execObj.StdOut.ReadLine</code> while respecting <code>MS_CMD_TIMEOUT_SEC</code> seconds; if timeout, calls <code>execObj.Terminate</code> and audits <code>timeout_terminated</code>. Truncates long output to <code>MS_MAX_RUNCMD_OUTPUT</code>. Audits only summary <code>output_len=</code>. Returns output string. Cleanups COM objects, handles errors. <br><strong>Complexity:</strong> O(output size) to read output up to MS_MAX_RUNCMD_OUTPUT. <br><strong>Side-effects:</strong> May spawn a process. Audits summary only. Could create transient processes; kills on timeout. <br><strong>Invariants:</strong> Only allowed commands pass <code>IsCmdSafe</code> and feature flags gate higher-level callers. Designed never to echo raw command to logs. <br><strong>Failure modes:</strong> <code>WScript.Shell</code> unavailable, <code>Exec</code> fails, stdout not available, long-running commands — all handled via safe returns and audits. <br><strong>Security:</strong> High-risk function; mitigations: <code>IsCmdSafe</code> blacklist and syntax checks, no URL/HTTP in commands, length limit, output truncation, audit redaction. Recommend strict code review, restrict feature-flag usage, and CI gating when used. <br><strong>Tests:</strong> Run safe command <code>echo hello</code> (on Windows) returns "hello". Reject commands with <code>|</code> or <code>curl</code>. Timeout behavior test by running a sleep-like command (if available) and ensure termination path executed. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_VerifyExportPathWritable(targetPath As String, Optional callerCid As String = "") As Boolean</strong> — <em>writeability probe via atomic temp file</em><br><strong>Purpose:</strong> Test whether a target folder (or parent of <code>targetPath</code>) accepts writes by doing an atomic write: create temp file then move/rename to target, with cleanup on success/failure.<br><strong>Signature:</strong> <code>Function Security_VerifyExportPathWritable(ByVal targetPath As String, Optional callerCid As String = &quot;&quot;) As Boolean</code> — returns <code>True</code> when a temporary file can be created and deleted/moved successfully.<br><strong>Behavior:</strong> Uses <code>Scripting.FileSystemObject</code> from <code>CreateObjectSafe</code>. Resolves folder parent via <code>GetParentFolderName</code>. Generates temp name via <code>Scriptlet.TypeLib.guid</code> when available; otherwise fallback timestamp/random. Creates a temporary file with <code>CreateTextFile</code>, writes <code>&quot;ok&quot;</code>, then deletes and/or moves to final path using <code>MoveFile</code>. If move fails, attempts to create final file directly as fallback. Deletes temp on error. Audits normalized folder path and writable flag. <br><strong>Complexity:</strong> O(1) file operations; IO-bound. <br><strong>Side-effects:</strong> Creates temporary file(s) in target folder; may leave artifacts if failure occurs. Deletes file on success when possible. <br><strong>Invariants:</strong> Does not rely on admin privileges; returns False if folder does not exist or FSO missing. <br><strong>Failure modes:</strong> Network share latency, antivirus locking file, insufficient permissions, FSO not present. Function ensures cleanup attempts and returns False otherwise. <br><strong>Security:</strong> Avoid writing sensitive contents; writes only <code>&quot;ok&quot;</code>. Audit message uses normalized path. <br><strong>Tests:</strong> Writable local folder returns True; read-only folder returns False; FSO unavailable path handled. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_SelfTest(Optional callerCid As String = "") As Boolean</strong> — <em>composite health & environment self-check</em><br><strong>Purpose:</strong> Run a suite of conservative checks (macro settings, signature presence, VBProject protection, export path writable, admin check optionally) to determine a boolean pass/fail for environment security posture. Supports deterministic single-iteration mode via feature flag.<br><strong>Signature:</strong> <code>Function Security_SelfTest(Optional callerCid As String = &quot;&quot;) As Boolean</code>.<br><strong>Behavior:</strong> If <code>FLAG_SELFTEST_DETERMINISTIC</code> set, runs a reduced deterministic set once; otherwise runs <code>MS_SELFTEST_ITER</code> iterations doing <code>Security_VerifyMacroSettings</code>, <code>Security_CheckWorkbookSignature</code>, <code>Security_IsVBAProjectProtected</code>, and optionally logs user admin via <code>Security_IsUserAdmin</code>. Resolves <code>ThisWorkbookPathFallback</code> and verifies writeability of root. Audits <code>SelfTestResult</code> and calls <code>WriteSelfTestResult</code> to persist run. Returns aggregated boolean <code>ok</code> indicating all checks passed. Errors route to <code>Security_HandleError</code>. <br><strong>Complexity:</strong> O(iterations) where each iteration is O(1) checks and potential IO. <br><strong>Side-effects:</strong> Writes self-test results to <code>MS_TEST_RESULTS_SHEET_NAME</code> via <code>WriteSelfTestResult</code>. Audits per-iteration. <br><strong>Invariants:</strong> Returns False on any failing probe. <br><strong>Failure modes:</strong> If sheet creation fails, <code>WriteSelfTestResult</code> may log to debug but not break main return. <br><strong>Security:</strong> Useful for CI gating; avoid running indiscriminately in user sessions (noise). <br><strong>Tests:</strong> Deterministic flag path; failing macro settings; non-writable root scenario. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_RunUnitTests(Optional callerCid As String = "") As Boolean</strong> — <em>module-level unit-test harness & smoke tests</em><br><strong>Purpose:</strong> Execute small suite of internal unit tests for RedactSecrets, SafeApplicationRun, SelfTest, ADODB availability, duplicate-symbol scans and audit-contents assertions, persisting test result. Designed for CI/diagnostics, not exhaustive unit tests.<br><strong>Signature:</strong> <code>Function Security_RunUnitTests(Optional callerCid As String = &quot;&quot;) As Boolean</code>.<br><strong>Behavior:</strong> Constructs sample inputs, validates <code>RedactSecrets</code> behavior on typical and edge-case inputs, asserts <code>SafeApplicationRun</code> returns <code>Empty</code> for non-existent proc, executes <code>Security_SelfTest</code>, appends <code>WriteSelfTestResult</code>, probes ADODB Stream availability, runs symbol scans, cross-module collisions, and <code>AssertNoSecretsInAudit</code>. Optionally runs fallback-path simulations when <code>FLAG_RUN_FALLBACK_TESTS</code> is enabled. Writes audit lines for each test and persists the boolean <code>ok</code>. Returns False on any unexpected failures or route to <code>Security_HandleError</code>. <br><strong>Complexity:</strong> Aggregate of included checks; scanning code modules may be O(total code length). <br><strong>Side-effects:</strong> Writes to test-results sheet and audit. May trigger prompts depending on called functions. <br><strong>Invariants:</strong> Should be idempotent; safe to run repeatedly though may append audit/test rows. <br><strong>Failure modes:</strong> Tape-dependent functions like <code>SelfTest</code> may fail due to environment. Tests rely on VBE access for some probes, which may be denied. <br><strong>Security:</strong> Tests assert not to leak secrets to audit and use <code>AssertNoSecretsInAudit</code> to check. <br><strong>Tests:</strong> The function itself is a test entry; verify it returns True in a healthy environment and logs failures appropriately. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_MigrateCustomXMLToStore(Optional requireAdmin As Boolean = True, Optional callerCid As String = "") As Long</strong> — <em>migrate deprecated CustomXML secrets into secure store candidates</em><br><strong>Purpose:</strong> Best-effort migration of credentials stored in CustomXMLParts into secure store (<code>Config_SetSecret</code> candidates), counting migrated entries and auditing results. Controlled by <code>FLAG_ALLOW_CUSTOMXML_FALLBACK</code> and <code>FLAG_CUSTOMXML_MIGRATION_CONFIRM</code> flags and optional admin requirement.<br><strong>Signature:</strong> <code>Function Security_MigrateCustomXMLToStore(Optional requireAdmin As Boolean = True, Optional callerCid As String = &quot;&quot;) As Long</code> — returns number migrated.<br><strong>Behavior:</strong> Checks required feature flags; if <code>requireAdmin</code> true ensures <code>Security_IsUserAdmin</code> returns True. Iterates <code>ThisWorkbook.CustomXMLParts</code>, searches for <code>&lt;CredentialKey&gt;</code> and <code>&lt;Value&gt;</code> tags via string search, extracts key/value, calls candidate setters <code>Config_SetSecret</code> via <code>RunCandidatesReturn</code>, increments counter on success. Does not delete CustomXMLParts (non-destructive). Audits migrated_count. <br><strong>Complexity:</strong> O(number of CustomXMLParts * xml length). <br><strong>Side-effects:</strong> Calls secure-store candidate setter; writes audits; does not delete original CustomXMLParts. <br><strong>Invariants:</strong> Will not attempt migration unless both flags enabled. Admin gating avoids unauthorized migration. <br><strong>Failure modes:</strong> CustomXML malformed, missing setter candidates, write failures to store. Handled per-entry. <br><strong>Security:</strong> Migration sensitive; auditors must ensure store write succeeded before deleting original artifacts (this module intentionally avoids automatic deletion). <br><strong>Tests:</strong> CustomXML with valid credential fragments migrated to mock <code>Config_SetSecret</code> and counter increments; admin-block prevents migration. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_GenerateCorrelationId() As String</strong> — <em>correlation id factory wrapper</em><br><strong>Purpose:</strong> Generate correlation id for logging via <code>NewCorrelationId()</code> wrapper to preserve public API naming.<br><strong>Signature:</strong> <code>Function Security_GenerateCorrelationId() As String</code> — returns string id.<br><strong>Behavior:</strong> Delegates to <code>NewCorrelationId</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Always returns a string (GUID-derived or fallback timestamp).<br><strong>Tests:</strong> Returns GUID-like lowercase string when possible. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_FindCrossModuleCollisions(Optional callerCid As String = "") As String</strong> — <em>scan across open workbooks for duplicated symbol definitions</em><br><strong>Purpose:</strong> Scan all open workbooks VM/VB projects source code for duplicate public/private module-level <code>Const/Function/Sub</code> identifiers and report collisions with their locations; best-effort and skips on Mac or when VBE access blocked.<br><strong>Signature:</strong> <code>Function Security_FindCrossModuleCollisions(Optional callerCid As String = &quot;&quot;) As String</code> — returns multi-line string report or "No cross-module duplicates detected..." message.<br><strong>Behavior:</strong> Uses <code>VBScript.RegExp</code> to match declarations, collects <code>keyRead = typeName: symbol</code> into <code>Scripting.Dictionary</code> mapping to workbook:component labels. Loops Application.Workbooks → VBProject → VBComponents. Aggregates entries with multiple occurrences and returns textual report. Audits summary length. Handles COM errors with safe fallbacks. <br><strong>Complexity:</strong> O(total source length) across open workbooks. <br><strong>Side-effects:</strong> Audit. <br><strong>Invariants:</strong> Skips on Mac; returns best-effort results. <br><strong>Failure modes:</strong> VBE access blocked, unusual code module formats. <br><strong>Security:</strong> Non-sensitive. Must be used in controlled diagnostic context because it inspects code. <br><strong>Tests:</strong> Create two modules with same public name and assert report includes both locations. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>ValidateConfigConstants(Optional callerCid As String = "") Sub</strong> — <em>runtime probe for expected config constants and handler presence</em><br><strong>Purpose:</strong> At initialization run-time probe for presence of many <code>modConfig</code> constants and centralized handlers; log missing items and advise migration.\br><strong>Signature:</strong> <code>Sub ValidateConfigConstants(Optional callerCid As String = &quot;&quot;)</code> — no return; side-effecting validator.<br><strong>Behavior:</strong> Iterates a large pre-defined array of names calling <code>RunConfigGet(name, Empty)</code> to detect empties; collects missing items into a <code>Collection</code> and audits them. Also calls <code>AssertCentralizedHandlersPresent</code> and logs missing centralized handlers. Designed as a non-fatal probe to help administrators detect migration gaps. <br><strong>Complexity:</strong> O(M) where M is number of probe keys. <br><strong>Side-effects:</strong> Audits messages, no configuration changes. <br><strong>Invariants:</strong> Non-destructive; safe to run at startup. <br><strong>Failure modes:</strong> Candidate <code>RunConfigGet</code> implementations that have side-effects—<code>RunConfigGet</code> documented as read-only but caution recommended. <br><strong>Tests:</strong> When config keys absent ensure missing list logged. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>ValidateConfigConstantsReport(Optional callerCid As String = "") As String</strong> — <em>reporting wrapper returns CSV of missing config names</em><br><strong>Purpose:</strong> Same probe as <code>ValidateConfigConstants</code> but returns comma-separated string of missing names for programmatic consumption.<br><strong>Signature:</strong> <code>Function ValidateConfigConstantsReport(Optional callerCid As String = &quot;&quot;) As String</code> — returns missing names or <code>&quot;probe_error&quot;</code> on unexpected failure.<br><strong>Behavior:</strong> Calls <code>RunConfigGet</code> for the same set and returns CSV of those empty. <br><strong>Complexity/Side-effects:</strong> O(M) and only audit via caller if used.<br><strong>Tests:</strong> Produces empty string when all present. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_Audit(action As String, message As String, Optional cid As String = "") Sub</strong> — <em>central audit façade with redaction and fallbacks</em><br><strong>Purpose:</strong> Single place to log structured audit messages: try delegated centralized audit APIs first, then optionally write to local fallback audit sheet. Always redact secrets and limit message size unless verbose flag enabled. <br><strong>Signature:</strong> <code>Private Sub Security_Audit(ByVal action As String, ByVal message As String, Optional ByVal cid As String = &quot;&quot;)</code> — no return.<br><strong>Behavior:</strong> Redacts <code>message</code> via <code>RedactSecrets</code>, truncates unless <code>FLAG_AUDIT_VERBOSE</code>, enforces <code>MS_AUDIT_MESSAGE_MAX_LEN</code>. Ensures a <code>cid</code> exists by calling <code>NewCorrelationId</code> if blank. Calls <code>RunCandidatesReturn</code> with candidate names like <code>modAudit.LogAudit</code> and returns if successful. If no centralized audit candidate found and <code>FLAG_ENABLE_LOCAL_AUDIT</code> is True, calls <code>AppendLocalAuditStructured_Fallback</code>. On error uses minimal fallback to append to local audit (calls <code>AppendLocalAuditStructured_Fallback</code> with safe data). Wrapped with robust error handling. <br><strong>Complexity:</strong> O(len(message)) for redaction. <br><strong>Side-effects:</strong> Writes to centralized audit or local hidden sheet. <br><strong>Invariants:</strong> Never logs raw secret values; always use <code>RedactSecrets</code>. <br><strong>Failure modes:</strong> Candidate central audit function absent — fallback only when flagged. <br><strong>Security:</strong> Crucial to avoid PII/secret leakage. Developers must ensure <code>RedactSecrets</code> covers patterns used in project. <br><strong>Tests:</strong> Ensure <code>modAudit.LogAudit</code> candidate intercepts calls when mocked; ensure <code>RedactSecrets</code> strips token values before audit sheet append. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_AppendAuditStructured(action,cid,userName,message,meta) Private Sub</strong> — <em>preferred internal wrapper for structured audit append</em><br><strong>Purpose:</strong> Attempt to use centralized structured audit API candidates; fall back to local minimal writer when feature-flagged.<br><strong>Signature:</strong> <code>Private Sub Security_AppendAuditStructured(ByVal action As String, ByVal correlationId As String, ByVal userName As String, ByVal message As String, ByVal meta As String)</code>.<br><strong>Behavior:</strong> <code>message</code> redacted then <code>RunCandidatesReturn</code> to <code>modAudit.LogAudit</code> etc. If none found and <code>FLAG_ENABLE_LOCAL_AUDIT</code> true, call <code>AppendLocalAuditStructured_Fallback</code>. Errors are caught and minimal fallback used. <br><strong>Complexity/Side-effects:</strong> O(len(message)). Writes audit via fallback if needed. <br><strong>Tests:</strong> Ensure call route behaves when candidate present vs not. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>AppendLocalAuditStructured_Fallback(action,cid,userName,message,meta) Private Sub</strong> — <em>in-module best-effort local audit delegator</em><br><strong>Purpose:</strong> Try to delegate to <code>modAudit.AppendLocalAuditStructured</code> if present, else run minimal in-module writer when <code>FLAG_ENABLE_LOCAL_AUDIT</code> is enabled.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAuditStructured_Fallback(ByVal action As String, ByVal correlationId As String, ByVal userName As String, ByVal message As String, ByVal meta As String)</code>.<br><strong>Behavior:</strong> Calls <code>RunCandidatesReturn(&quot;modAudit.AppendLocalAuditStructured,modAudit.AppendLocalAudit,AppendLocalAuditStructured&quot;, ...)</code>. If not present and local audit flag enabled, call <code>AppendLocalAuditStructured_Minimal</code>. Errors handled. <br><strong>Complexity/Side-effects:</strong> Writes to centralized modAudit if present; else writes to local sheet if feature-flagged. <br><strong>Tests:</strong> Validate fallback path when modAudit absent and flag enabled. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>AppendLocalAuditStructured_Minimal(action,cid,userName,message,meta) Private Sub</strong> — <em>minimal local audit writer (hidden sheet)</em><br><strong>Purpose:</strong> Minimal, auditable local logging mechanism that writes structured rows to a hidden worksheet <code>MS_AUDIT_SHEET_NAME</code> when centralized audit is not present and local-audit flag allows it.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAuditStructured_Minimal(ByVal action As String, ByVal correlationId As String, ByVal userName As String, ByVal message As String, ByVal meta As String)</code>.<br><strong>Behavior:</strong> Ensures hidden audit sheet exists (creates after last sheet), sets header row once, appends timestamped row with CorrelationId, User, Action, Message (truncated), Meta (truncated), and a computed RowHash via <code>ComputeRowHash</code>. Hides the sheet as <code>xlSheetVeryHidden</code>. <br><strong>Complexity:</strong> O(1) per append plus sheet creation cost first time. <br><strong>Side-effects:</strong> Creates/updates workbook worksheet. May increase workbook size over time. <br><strong>Invariants:</strong> Sheet is <code>VeryHidden</code> to reduce accidental exposure. <br><strong>Failure modes:</strong> Workbook protection or workbook without write access; errors swallowed in handler. <br><strong>Security:</strong> RowHash provides tamper-evidence but is a weak FNV-based hash; do not assume cryptographic integrity. <br><strong>Tests:</strong> Append few rows and verify headers and RowHash computed. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>ComputeRowHash(s As String) As String Private Function</strong> — <em>FNV-derived 32-bit hash for audit row integrity</em><br><strong>Purpose:</strong> Produce short hex digest of combined row fields for basic tamper detection in fallback audit sheet.<br><strong>Signature:</strong> <code>Private Function ComputeRowHash(ByVal s As String) As String</code>.<br><strong>Behavior:</strong> Implements a 32-bit FNV-1a like mixing (offset 2166136261, multiply 16777619) over bytes produced by <code>Asc</code> of each char and returns hex string. Uses <code>On Error Resume Next</code>. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Hash collisions possible; not cryptographic; only for lightweight tamper evidence. <br><strong>Notes:</strong> Replace with HMAC/SHA in high-security contexts if available. <br><strong>Tests:</strong> Deterministic outputs for known inputs. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>WriteSelfTestResult(correlationId As String, ok As Boolean, iterations As Long) Private Sub</strong> — <em>persist self-test results to hidden sheet</em><br><strong>Purpose:</strong> Append self-test metadata (timestamp, correlation id, bool ok, iterations, username) to a hidden <code>MS_TEST_RESULTS_SHEET_NAME</code> worksheet; used by <code>SelfTest</code> and <code>RunUnitTests</code>.<br><strong>Signature:</strong> <code>Private Sub WriteSelfTestResult(ByVal correlationId As String, ByVal ok As Boolean, ByVal iterations As Long)</code>.<br><strong>Behavior:</strong> Creates test-results sheet if missing (very hidden) and appends row. If creation fails prints debug and returns. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Adds worksheet rows. <br><strong>Notes:</strong> Non-privileged storage for test outcomes; consider rotating/cleaning in long-running projects. <br><strong>Tests:</strong> Verify sheet creation and appended content. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_PathIsUnder(path As String, root As String) As Boolean Private Function</strong> — <em>path containment test (normalized)</em><br><strong>Purpose:</strong> Determine whether <code>path</code> resides under <code>root</code> after normalization and canonicalization; case-insensitive and robust to trailing slashes.<br><strong>Signature:</strong> <code>Private Function Security_PathIsUnder(ByVal path As String, ByVal root As String) As Boolean</code>.<br><strong>Behavior:</strong> Normalizes both via <code>NormalizePathShared</code>, lowercases and replaces <code>\</code> with <code>/</code>. Ensures both trailing slashes present and uses <code>Left$(pNorm, Len(rNorm)) = rNorm</code> containment check. <br><strong>Complexity:</strong> O(len(path)+len(root)). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Returns False for empty inputs. <br><strong>Failure modes:</strong> Path canonicalization edge-cases around unicode or network-share canonicalization differences; handled conservatively. <br><strong>Tests:</strong> Various path/root combinations, including drive-letter differences, case differences, and <code>../</code> sequences. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>NormalizePathShared(p As String) As String Private Function</strong> — <em>pluggable normalize delegator</em><br><strong>Purpose:</strong> Normalize a filesystem path using <code>modUtilities.NormalizePath</code> if present via <code>RunCandidatesReturn</code> else fall back to local <code>NormalizePath</code> implementation.<br><strong>Signature:</strong> <code>Private Function NormalizePathShared(ByVal p As String) As String</code>.<br><strong>Behavior:</strong> Short-circuits for empty input; calls <code>RunCandidatesReturn(&quot;modUtilities.NormalizePath,NormalizePathShared,NormalizePath&quot;, p)</code> and returns candidate result if present; otherwise uses local <code>NormalizePath</code>. Errors suppressed. <br><strong>Complexity:</strong> O(len(p)). <br><strong>Side-effects:</strong> None. <br><strong>Notes:</strong> Encourages centralizing path logic in modUtilities while retaining safe fallback. <br><strong>Tests:</strong> With and without <code>modUtilities</code> present, outputs consistent trailing slash form. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>NormalizePath(p As String) As String Private Function</strong> — <em>local path normalization fallback</em><br><strong>Purpose:</strong> Convert path separators to <code>/</code>, expand <code>~/</code> on Mac to home path, canonicalize segments (remove <code>.</code> and resolve <code>..</code>) and ensure trailing slash. <br><strong>Signature:</strong> <code>Private Function NormalizePath(ByVal p As String) As String</code>.<br><strong>Behavior:</strong> Replaces <code>\</code> with <code>/</code>, expands <code>~</code> for Mac via <code>MacHomePathFallback</code>, canonicalizes segments via <code>CanonicalizePathSegments</code>, appends trailing slash. Returns empty string for empty input. <br><strong>Complexity:</strong> O(len(p)). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Output always ends with <code>/</code> unless empty. <br><strong>Tests:</strong> Paths with mixed slashes, <code>..</code>, <code>.</code> and <code>~/</code> on Mac. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>CanonicalizePathSegments(p As String) As String Private Function</strong> — <em>resolve <code>.</code> and <code>..</code> segments</em><br><strong>Purpose:</strong> Remove <code>.</code> segments and collapse <code>..</code> segments deterministically producing canonical relative segments (without leading/ending slash handling — caller normalizes further).<br><strong>Signature:</strong> <code>Private Function CanonicalizePathSegments(ByVal p As String) As String</code>.<br><strong>Behavior:</strong> Splits on <code>/</code>, uses a collection as a stack: skip empty or <code>.</code>; pop on <code>..</code> if available else ignore. Rejoins with <code>/</code>, preserves trailing behavior. <br><strong>Complexity:</strong> O(#segments). <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> <code>a/b/../c</code> => <code>a/c/</code>, <code>../../x</code> => <code>x</code> behavior depends on caller. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_PromptForSecret(prompt As String, Optional cid As String = "") As String Private Function</strong> — <em>delegated or InputBox fallback secret prompt</em><br><strong>Purpose:</strong> Present a masked (delegated) secret prompt if available, otherwise optionally show <code>Application.InputBox</code> unmasked prompt when <code>FLAG_ENABLE_PROMPT_FALLBACK</code> true. Records audit <code>&quot;prompt_shown&quot;</code>.<br><strong>Signature:</strong> <code>Private Function Security_PromptForSecret(ByVal prompt As String, Optional ByVal cid As String = &quot;&quot;) As String</code>.<br><strong>Behavior:</strong> Attempts <code>RunCandidatesReturn(&quot;SecretPrompt,modConfig.SecretPrompt,SECRET_PROMPT,Secret_Prompt&quot;, prompt, usedCid)</code>. If candidate returns a string, returns it. If not and feature flag enabled uses <code>Application.InputBox(prompt, &quot;Secret required&quot;, Type:=2)</code> (unmasked) and returns value (empty if canceled). <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> May show UI; audit <code>PromptForSecret</code> event. <br><strong>Security:</strong> Unmasked InputBox fallback is insecure; must be enabled only with deliberate flag and admin awareness. Delegated secret prompt must implement masking. <br><strong>Tests:</strong> Delegated candidate returns masked string; InputBox path activated under flag. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_HandleError(procName As String, errNum As Long, errDesc As String) Private Sub</strong> — <em>unified error handler with candidate delegation + audit fallback</em><br><strong>Purpose:</strong> Provide resilient error handling: attempt to call centralized <code>modError</code> handlers with multiple signature candidates; if none present fallback to <code>Security_Audit</code> and <code>Debug.Print</code> with redacted description and new correlation id.<br><strong>Signature:</strong> <code>Private Sub Security_HandleError(ByVal procName As String, ByVal errNum As Long, ByVal errDesc As String)</code>.<br><strong>Behavior:</strong> Generates new <code>cid</code>, truncates and redacts <code>errDesc</code>, attempts <code>RunCandidatesReturn</code> for several <code>modError</code> handler signatures in prioritized order. If none accept, writes audit <code>&quot;Error&quot;</code> with truncated safe description and <code>Debug.Print</code>. Robust <code>On Error Resume Next</code> wrappers used to avoid cascading failures. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Calls centralized error handlers if present, writes audit and debug output otherwise. <br><strong>Invariants:</strong> Never raises further errors; swallows them and logs fallback. <br><strong>Security:</strong> Ensures no secrets leaked by redaction. <br><strong>Tests:</strong> Simulate <code>modError.HandleError</code> present and absent, ensure fallback audit called. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>NewCorrelationId() As String Private Function</strong> — <em>GUID-or-fallback correlation id generator</em><br><strong>Purpose:</strong> Return a unique correlation id using <code>Scriptlet.TypeLib</code> GUID or timestamp+random fallback when GUID creation fails. Lowercases GUID and strips braces.<br><strong>Signature:</strong> <code>Private Function NewCorrelationId() As String</code>.<br><strong>Behavior:</strong> Tries <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code>; on error uses <code>Randomize</code> then builds <code>cid-&lt;yyyymmddHHNNSS&gt;-&lt;random&gt;</code> string. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Always returns a non-empty string. <br><strong>Tests:</strong> Ensure GUID format returned when <code>Scriptlet.TypeLib</code> available, fallback format otherwise. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>WorkbookAvailable(wb As Workbook) As Boolean Private Function</strong> — <em>safe workbook object probe</em><br><strong>Purpose:</strong> Defensive check whether a <code>Workbook</code> reference is valid (non-nil) in host environment. <br><strong>Signature:</strong> <code>Private Function WorkbookAvailable(ByVal wb As Workbook) As Boolean</code>.<br><strong>Behavior:</strong> Returns False on <code>wb</code> Nothing or error; otherwise True. Used throughout to avoid accessing <code>ThisWorkbook</code> in unexpected hosts. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Called with <code>ThisWorkbook</code> present and with <code>Nothing</code>. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>LooksLikeFolder(path As String) As Boolean Private Function</strong> — <em>heuristic folder detection</em><br><strong>Purpose:</strong> Heuristically determine whether a path string represents a folder (trailing slash or lacks filename extension after last slash) to choose parent folder logic.<br><strong>Signature:</strong> <code>Private Function LooksLikeFolder(ByVal path As String) As Boolean</code>.<br><strong>Behavior:</strong> Returns True if last char is slash/backslash or if last dot occurs before last slash (no extension). Uses simple string heuristics. <br><strong>Complexity:</strong> O(len(path)). <br><strong>Notes:</strong> Heuristic, may misclassify files without extension. <br><strong>Tests:</strong> Paths with trailing slash, file names with extension, no-extension filenames. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>ThisWorkbookPathFallback() As String Private Function</strong> — <em>robust workbook path fallback</em><br><strong>Purpose:</strong> Determine a sensible root path fallback: <code>ThisWorkbook.path</code> if available, then <code>Environ$(&quot;USERPROFILE&quot;)</code>, then OS-specific fallback (Mac home) or <code>&quot;C:\&quot;</code> on Windows.<br><strong>Signature:</strong> <code>Private Function ThisWorkbookPathFallback() As String</code>.<br><strong>Behavior:</strong> Attempts <code>ThisWorkbook.path</code> defensively then environment fallbacks; used where export root is needed. <br><strong>Complexity:</strong> O(1). <br><strong>Notes:</strong> Used widely as conservative default. <br><strong>Tests:</strong> When <code>ThisWorkbook.path</code> empty use environment fallback. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>IsMac() As Boolean Private Function</strong> — <em>platform detect</em><br><strong>Purpose:</strong> Detect if host OS is Mac by checking <code>Application.OperatingSystem</code> string contains "Mac".<br><strong>Signature:</strong> <code>Private Function IsMac() As Boolean</code>.<br><strong>Behavior:</strong> Returns boolean; used to avoid VBE operations and Windows-specific commands. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Mock <code>Application.OperatingSystem</code> strings. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>MacHomePathFallback() As String Private Function</strong> — <em>Mac home resolution</em><br><strong>Purpose:</strong> Return <code>Environ$(&quot;HOME&quot;)</code> or default <code>&quot;/Users&quot;</code> if unset. <br><strong>Signature:</strong> <code>Private Function MacHomePathFallback() As String</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Environment present/absent. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>RedactSecrets(txt As String) As String Private Function</strong> — <em>tight regex-based secret redaction</em><br><strong>Purpose:</strong> Remove/redact high-probability secret occurrences from free-form text (audit messages), using a defensive regex matching common keys (<code>password</code>, <code>token</code>, <code>apikey</code>, etc.) with separators <code>=</code> or <code>:</code> and bounded value length. Falls back to a simple substring scrubbing if RegExp fails.<br><strong>Signature:</strong> <code>Private Function RedactSecrets(ByVal txt As String) As String</code>.<br><strong>Behavior:</strong> Constructs VBScript.RegExp pattern capturing key names and short values up to 128 chars and replaces matched value with <code>[REDACTED]</code> unless value appears to be short/uninteresting or short file path. Iterates matches backwards to safely splice replacements. If RegExp unavailable, performs substring-based heuristic replacements. <br><strong>Complexity:</strong> O(len(txt)) but regex engine dependent. <br><strong>Side-effects:</strong> None except return mutated string. <br><strong>Invariants:</strong> Avoid over-redaction of short benign tokens (<=2 chars) and short filesystem fragments. <br><strong>Failure modes:</strong> Misses secrets that don't match patterns (e.g., JSON fields without key names); false negatives possible. False positives minimized by heuristics but still possible. <br><strong>Security:</strong> Central to audit safety — maintain and extend pattern list with care; consider additional patterns used in project. <br><strong>Tests:</strong> Inputs with <code>password=secret</code>, <code>token:abcd123</code>, file path <code>C:\inetpub\secretfile</code>, short tokens <code>ab</code> — verify correct redaction behavior. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>RedactKey(key As String) As String Private Function</strong> — <em>short key redaction helper</em><br><strong>Purpose:</strong> Redact credential key strings for audit (e.g., show first 1-2 chars then <code>*</code>) to avoid revealing full keys in audit messages.<br><strong>Signature:</strong> <code>Private Function RedactKey(ByVal key As String) As String</code>.<br><strong>Behavior:</strong> If length <=6 shows first char + <code>*</code>; else shows first 2 chars + masked middle + last 2 chars. <br><strong>Complexity:</strong> O(len(key)).<br><strong>Tests:</strong> Various lengths. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>SafeApplicationRun(procName As String, ParamArray args() As Variant) As Variant Private Function</strong> — <em>robust Application.Run wrapper</em><br><strong>Purpose:</strong> Safely call <code>Application.Run</code> with variable arguments, capturing runtime errors and returning <code>Empty</code> on failure instead of throwing compile-time or runtime errors. Useful when candidate procedure names may not exist at runtime across deployments.<br><strong>Signature:</strong> <code>Private Function SafeApplicationRun(ByVal procName As String, ParamArray args() As Variant) As Variant</code>.<br><strong>Behavior:</strong> Validates proc name; counts args with defensively guarded <code>LBound/UBound</code>; switches based on arg count and calls corresponding <code>Application.Run</code> with up to first 10 args; catches errors and returns <code>Empty</code>. <br><strong>Complexity:</strong> O(#args) but small. <br><strong>Side-effects:</strong> Executes target proc if present. <br><strong>Invariants:</strong> Never throws; returns <code>Empty</code> if proc missing or errors. <br><strong>Tests:</strong> Run with known existing arg-less proc; run with non-existent proc returns <code>Empty</code>. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>CreateObjectSafe(progId As String) As Object Private Function</strong> — <em>safe COM object factory</em><br><strong>Purpose:</strong> Safely <code>CreateObject</code> wrapped to return <code>Nothing</code> on failure rather than raising. <br><strong>Signature:</strong> <code>Private Function CreateObjectSafe(ByVal progId As String) As Object</code>.<br><strong>Behavior:</strong> <code>On Error</code> wrapper around <code>CreateObject(progId)</code>, returns <code>Nothing</code> on failure. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Known COM progId present returns object; unknown returns Nothing. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>FeatureFlagEnabled(flagKey As String, defaultValue As Boolean) As Boolean Private Function</strong> — <em>pluggable feature-flag reader</em><br><strong>Purpose:</strong> Query runtime feature flags via candidate config procedures (<code>Config_Get</code>, <code>modConfig.Config_Get</code>, etc.) and coerce to Boolean, otherwise return default. <br><strong>Signature:</strong> <code>Private Function FeatureFlagEnabled(ByVal flagKey As String, ByVal defaultValue As Boolean) As Boolean</code>.<br><strong>Behavior:</strong> Uses <code>RunCandidatesReturn</code> to attempt config reader; if <code>IsEmpty</code> returns default; else attempts <code>CBool(v)</code> with error handling. <br><strong>Complexity:</strong> O(1).<br><strong>Security:</strong> Feature flags drive behavior including sensitive fallbacks — ensure flags are stored and managed securely. <br><strong>Tests:</strong> Candidate config returns exact true/false or string <code>&quot;True&quot;</code>, absence returns default. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>XmlEncode(s As String) As String Private Function</strong> — <em>minimal XML entity encoder</em><br><strong>Purpose:</strong> Escape <code>&amp; &lt; &gt; &quot; &#x27;</code> for safe embedding inside XML fragments used for CustomXMLParts read/write. <br><strong>Signature:</strong> <code>Private Function XmlEncode(ByVal s As String) As String</code>.<br><strong>Behavior:</strong> Replaces <code>&amp;</code> -> <code>&amp;amp;</code>, <code>&lt;</code> -> <code>&amp;lt;</code>, <code>&gt;</code> -> <code>&amp;gt;</code>, <code>&quot;</code> -> <code>&amp;quot;</code>, <code>&#x27;</code> -> <code>&amp;apos;</code>. <br><strong>Complexity:</strong> O(len(s)).<br><strong>Tests:</strong> Strings with XML-sensitive chars. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>AtomicWriteFile(fullPath As String, contents As String) As Boolean Private Function</strong> — <em>safe write via temp+move strategy</em><br><strong>Purpose:</strong> Implement atomic write semantics on Windows/FSO-capable hosts: write temp file into target directory, then move/rename to target path; fallback to direct create if move fails. <br><strong>Signature:</strong> <code>Private Function AtomicWriteFile(ByVal fullPath As String, ByVal contents As String) As Boolean</code>.<br><strong>Behavior:</strong> Use <code>Scripting.FileSystemObject</code> to compute parent folder, create temp file name with time/random, <code>CreateTextFile(tmpPath, True)</code>, write <code>contents</code>, close, attempt to delete target and <code>MoveFile tmpPath -&gt; fullPath</code>. If move fails, attempt direct <code>CreateTextFile(fullPath)</code> fallback. Returns True on success. Errors handled returning False. <br><strong>Complexity:</strong> IO-bound; O(#bytes written).<br><strong>Side-effects:</strong> Produces temporary file(s) and may leave artifacts if failures occur. <br><strong>Invariants:</strong> Must run in folder with write permissions. <br><strong>Failure modes:</strong> FSO absent, folder missing, antivirus locking file — returns False. <br><strong>Security:</strong> Do not write sensitive data unless necessary; prefer setting restrictive ACLs externally. <br><strong>Tests:</strong> Successful atomic write in local folder; simulate move failing and ensure fallback writes. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>IsADODBStreamAvailable() As Boolean Private Function</strong> — <em>detect ADODB.Stream COM availability</em><br><strong>Purpose:</strong> Probe for existence of <code>ADODB.Stream</code> COM type for potential binary IO paths.<br><strong>Signature:</strong> <code>Private Function IsADODBStreamAvailable() As Boolean</code>.<br><strong>Behavior:</strong> Tries <code>CreateObjectSafe(&quot;ADODB.Stream&quot;)</code> and returns boolean presence. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Present vs absent environments. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_ScanForDuplicateSymbols(Optional callerCid As String = "") As String</strong> — <em>module-local duplicate symbol scan</em><br><strong>Purpose:</strong> Similar to cross-module collisions but focused on <code>ThisWorkbook.VBProject</code> to find duplicate declarations across components in the same workbook. Returns summary text or error message if access denied.<br><strong>Signature:</strong> <code>Function Security_ScanForDuplicateSymbols(Optional callerCid As String = &quot;&quot;) As String</code>.<br><strong>Behavior:</strong> If VBE access unavailable logs and returns message. Otherwise regex-scan code modules and produce list of symbols with occurrence counts >1. Audits summary. <br><strong>Complexity:</strong> O(total code length). <br><strong>Side-effects:</strong> Audit. <br><strong>Tests:</strong> Duplicate functions in same workbook reported. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_MigrationChecklistReport(Optional callerCid As String = "") As String</strong> — <em>human-friendly migration checklist generator</em><br><strong>Purpose:</strong> Produce a small stepwise checklist including results for feature flags, sample store probe, and centralized audit presence, used by migration engineers to plan progressive rollout.<br><strong>Signature:</strong> <code>Function Security_MigrationChecklistReport(Optional callerCid As String = &quot;&quot;) As String</code> — returns multi-line string checklist.<br><strong>Behavior:</strong> Appends lines about <code>Scan for duplicates</code>, feature flag state for <code>FLAG_ALLOW_CUSTOMXML_FALLBACK</code>, probes secure store via <code>RunCandidatesReturn(&quot;Config_GetSecret,..&quot;, &quot;ifrs_probe_key_exists_dummy&quot;)</code> and reports present/empty. Audits generation. <br><strong>Complexity:</strong> O(1) + candidate probe cost. <br><strong>Tests:</strong> Ensure appropriate reporting when store probe returns Empty or a value. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_RolloutPlan(Optional callerCid As String = "") As String</strong> — <em>opinionated minimal rollout guidance</em><br><strong>Purpose:</strong> Return a short recommended textual rollout plan for migration to centralized handlers and secret handling. Programmatic convenience only. <br><strong>Signature:</strong> <code>Function Security_RolloutPlan(Optional callerCid As String = &quot;&quot;) As String</code>.<br><strong>Behavior:</strong> Returns fixed string <code>&quot;a) apply non-breaking refactors and tests; b) switch callers to centralized audit/error API; c) enable stricter secret handling behind feature flag; d) flip flag after verification.&quot;</code> and audits. <br><strong>Complexity/Side-effects:</strong> None besides audit. <br><strong>Notes:</strong> Keep updated with organizational rollout policy. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>IsCmdSafe(cmd As String) As Boolean Private Function</strong> — <em>command safety policy evaluator</em><br><strong>Purpose:</strong> Heuristically reject dangerous <code>cmd</code> strings (pipes, redirects, blacklisted commands, encoded payloads, URL presence, oversized commands) to avoid arbitrary command execution vulnerabilities.<br><strong>Signature:</strong> <code>Private Function IsCmdSafe(ByVal cmd As String) As Boolean</code>.<br><strong>Behavior:</strong> Lowercases input and rejects if contains <code>|</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>&gt;</code> <code>&lt;</code>, or any blacklisted substrings like <code>powershell -enc</code>, <code>certutil</code>, <code>curl </code>, <code>wget </code>, <code>invoke-webrequest</code>, <code>iex</code>, or <code>http(s)://</code>. Caps length at 1024. Returns boolean. <br><strong>Complexity:</strong> O(len(cmd)). <br><strong>Security:</strong> Primary safelist/blacklist gate for <code>Security_RunCmdAndGetOutput</code>. Maintain and harden this list in CI; blacklist approach is conservative but incomplete—prefer feature flagging and runtime allowlists when possible. <br><strong>Tests:</strong> Strings with blocked tokens rejected; simple dir/list commands accepted. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>AssertNoSecretsInAudit(Optional callerCid As String = "") As Long Private Function</strong> — <em>scan recent audit rows for suspicious secret tokens</em><br><strong>Purpose:</strong> Scan the last ~200 audit rows in local fallback audit sheet for suspicious tokens (password, secret, token, api_key, etc.) and count matches; returns count or -1 on error.<br><strong>Signature:</strong> <code>Private Function AssertNoSecretsInAudit(Optional ByVal callerCid As String = &quot;&quot;) As Long</code>.<br><strong>Behavior:</strong> If local audit sheet exists, builds VBScript.RegExp pattern for credential keywords and counts matches in concatenation of Message and Meta columns for recent rows. Audits suspicious count. Returns count; <code>-1</code> indicates failure to scan. <br><strong>Complexity:</strong> O(rows scanned * cell length). <br><strong>Side-effects:</strong> Audit of suspicious_count. <br><strong>Notes:</strong> Useful CI/health-check to ensure no secrets persisted; false positives possible; combine with manual review. <br><strong>Tests:</strong> Insert audit rows with <code>password=secret</code> and verify detection. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>AssertCentralizedHandlersPresent(Optional callerCid As String = "") As Boolean Public Function</strong> — <em>assert presence of central audit and error handlers</em><br><strong>Purpose:</strong> Programmatically check that <code>modAudit.LogAudit</code> and <code>modError.HandleError</code> (candidate names) respond to a <code>ping</code> to ensure centralized handlers are wired before enabling stricter CI gates.<br><strong>Signature:</strong> <code>Public Function AssertCentralizedHandlersPresent(Optional ByVal callerCid As String = &quot;&quot;) As Boolean</code> — returns True when both present. <br><strong>Behavior:</strong> Calls <code>RunCandidatesReturn(&quot;modAudit.LogAudit,LogAudit,AuditAppend&quot;, &quot;ping&quot;)</code> and <code>RunCandidatesReturn(&quot;modError.HandleError,HandleError&quot;, &quot;ping&quot;)</code>; audit and return False if missing. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Audits. <br><strong>Tests:</strong> Mock candidate functions to respond to <code>&quot;ping&quot;</code>. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_CI_Gate() As String Public Function</strong> — <em>CI gating helper for security checks</em><br><strong>Purpose:</strong> Run <code>Security_RunUnitTests</code>, optionally <code>Security_SelfTest</code>, and assert centralized handlers per flags; return empty string on OK or descriptive failure string for CI consumption.<br><strong>Signature:</strong> <code>Public Function Security_CI_Gate() As String</code> — returns <code>&quot;&quot;</code> on pass, or error string on failure.<br><strong>Behavior:</strong> Audits start event, runs <code>Security_RunUnitTests</code>, respects feature-flag <code>FLAG_CI_FAIL_ON_SELFTEST</code> to optionally run <code>Security_SelfTest</code>, respects <code>FLAG_REQUIRE_CENTRAL_HANDLERS_FOR_CI</code> to require central handlers; returns textual failure messages for CI. Audits <code>CI_Gate</code> result. <br><strong>Complexity:</strong> Sum of underlying checks. <br><strong>Side-effects:</strong> Audit and sheet writes via tests. <br><strong>Notes:</strong> Intended for CI invocation; safe to call but may create audit/test artifacts in workbook. <br><strong>Tests:</strong> CI pass & failure scenarios toggling flags. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Security_ReviewSummary(Optional callerCid As String = "") As String Public Function</strong> — <em>compact programmatic security review summary string</em><br><strong>Purpose:</strong> Produce compact one-line summary including missing config constants, duplicates summary, and audit secrets count to assist automated reviews. <br><strong>Signature:</strong> <code>Public Function Security_ReviewSummary(Optional ByVal callerCid As String = &quot;&quot;) As String</code>.<br><strong>Behavior:</strong> Compiles <code>ValidateConfigConstantsReport</code>, truncated <code>Security_ScanForDuplicateSymbols</code>, and <code>AssertNoSecretsInAudit</code> into a semicolon-separated string. Audits generation. <br><strong>Complexity:</strong> O(1) + cost of underlying scans. <br><strong>Tests:</strong> Confirm format and content for various scenarios. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>RunCandidatesReturn(candidatesCSV As String, ParamArray args() As Variant) As Variant Private Function</strong> — <em>candidate invocation helper (first non-empty)</em><br><strong>Purpose:</strong> Try a comma-separated list of procedure names in order via <code>SafeApplicationRun</code> and return first non-empty result (<code>Empty</code> indicates no candidate returned a value). This centralizes the pattern of pluggable/candidate cross-module integration for configuration, audit, and secret APIs.<br><strong>Signature:</strong> <code>Private Function RunCandidatesReturn(ByVal candidatesCSV As String, ParamArray args() As Variant) As Variant</code>.<br><strong>Behavior:</strong> Splits CSV, trims each candidate name, calls <code>SafeApplicationRun(name, args)</code> and returns first non-empty result. Uses defensive error handling and returns <code>Empty</code> otherwise. <br><strong>Complexity:</strong> Up to O(N) calls where N is number of candidates; each call is O(1) plus their internal costs. <br><strong>Side-effects:</strong> Can execute arbitrary application-run procedures chosen as candidates — thus calls must be controlled and candidate lists curated. <br><strong>Invariants:</strong> Returns <code>Empty</code> when none exist. <br><strong>Security:</strong> Candidate strings must be whitelisted; <code>SafeApplicationRun</code> mitigates missing-proc exceptions. <br><strong>Tests:</strong> Candidate list with mock functions where one returns value ensures correct short-circuit. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>RunConfigGet(key As String, Optional defaultValue As Variant) As Variant Private Function</strong> — <em>convenience config getter using candidates</em><br><strong>Purpose:</strong> Helper wrapper to fetch a single configuration key using candidate config getters; returns <code>defaultValue</code> on <code>Empty</code>. <br><strong>Signature:</strong> <code>Private Function RunConfigGet(ByVal key As String, Optional ByVal defaultValue As Variant) As Variant</code>.<br><strong>Behavior:</strong> Calls <code>RunCandidatesReturn(&quot;Config_Get,modConfig.Config_Get,ConfigGet,Config_Get&quot;, key)</code> and returns <code>defaultValue</code> if result is <code>Empty</code>. <br><strong>Complexity:</strong> O(1) plus candidate call. <br><strong>Notes:</strong> Central for decoupling from compile-time constants. <br><strong>Tests:</strong> Candidate returns value vs <code>Empty</code>. </td></tr><tr><td data-label="Technical breakdown (modSecurity)"> <strong>Final notes (module-level guidance)</strong> — <em>maintenance, security, CI, and integration considerations</em><br><strong>Purpose:</strong> Summarize cross-cutting advice for maintainers integrating <code>modSecurity</code> into the add-in lifecycle described in your diagram.<br><strong>Key Points:</strong><br>- Keep <code>modConfig</code> candidate names and feature-flag keys centralized and versioned; prefer explicit migration steps rather than relying on <code>RunCandidatesReturn</code> heuristics in new code. <br>- Treat <code>Security_RunCmdAndGetOutput</code>, secret prompt fallbacks, and CustomXML write paths as high-risk and gate them behind explicit feature flags plus CI checks. <br>- <code>RedactSecrets</code> regex must be kept current with application secret naming conventions; add unit tests for each new secret token pattern. <br>- Audit pipeline: prefer <code>modAudit.LogAudit</code> and <code>modError.HandleError</code>. Only enable <code>FLAG_ENABLE_LOCAL_AUDIT</code> in controlled recovery scenarios. <br>- For CI: use <code>Security_CI_Gate</code> to fail builds early, but ensure <code>FLAG_REQUIRE_CENTRAL_HANDLERS_FOR_CI</code> and <code>FLAG_CI_FAIL_ON_SELFTEST</code> are tuned per branch. <br>- Operational: periodically run <code>AssertNoSecretsInAudit</code> and <code>Security_MigrationChecklistReport</code> during migration rollouts. <br><strong>Recommended tests (priority):</strong> tokenizer: config getters & candidate resolution; <code>RedactSecrets</code> pattern coverage; audit fallback writes and <code>AssertNoSecretsInAudit</code>; <code>AtomicWriteFile</code> behavior across network share and read-only targets; <code>Security_RunCmdAndGetOutput</code> allowed vs rejected commands (sandboxed); secret store set/get and denial with flags; <code>Security_SelfTest</code> determinism under <code>FLAG_SELFTEST_DETERMINISTIC</code>; <code>RunCandidatesReturn</code> candidate selection semantics. <br><strong>Final maintenance note:</strong> This module emphasizes safety-by-default: prefer centralized handlers and secure stores; abundant feature flags allow progressive rollout. Before enabling any deprecated fallback (CustomXML, InputBox), add explicit migration & admin confirmation steps. </td></tr></tbody></table></div><div class="row-count">Rows: 54</div></div><div class="table-caption" id="Table3" data-table="Docu_0161_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modStatements)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modStatements)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modStatements)"> <strong>Overview:</strong> This document gives a world-class, per-function technical breakdown of the <code>modStatements</code> VBA module you provided. Each entry documents: purpose, signature (inputs/outputs), detailed internal behavior, algorithmic/space complexity, side-effects, invariants, failure modes, security considerations, recommended unit/integration tests, and concise maintainer notes. Use this as authoritative inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>Module-level constants & public API</strong> — <em>module identity & surface</em><br><strong>Constants:</strong> <code>STATEMENT_SNAPSHOT_PREFIX</code>, <code>STATEMENT_PACKAGE_SCHEMA</code>, <code>STATEMENT_BALANCE_TOLERANCE</code>, <code>MAX_LINES_THRESHOLD</code>.<br><strong>Public API (surface):</strong> <code>AssembleStatementPackage</code>, <code>ValidateStatementPackage</code>, <code>RenderStatementToSheet</code>, <code>RestoreStatementSnapshot</code>, <code>CreateStatementSnapshot</code>, <code>GenerateReconciliation</code>, <code>ExportSheetToCsv</code>, <code>ModStatements_SelfTest</code>, <code>ModStatements_ReleaseChecklist</code>, <code>ModStatements_ConsistencyCheck</code>.<br><strong>Purpose:</strong> Single authoritative module to assemble, validate, render, snapshot and reconcile financial statement packages. Exposes deterministic package schema, snapshot lifecycle, reconciliation compared to a trial balance, CSV export, and self-test/release utilities.<br><strong>Notes:</strong> Schema version is explicit (<code>STATEMENT_PACKAGE_SCHEMA = &quot;1.0.0&quot;</code>). Public functions uniformly use structured audit and defensive error handling via host helpers. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>AssembleStatementPackage(packageID As String, sourceLines As Variant, Optional templateName As String = \"\", Optional author As String = \"\") -> Object (Dictionary or Nothing)</strong> — <em>package builder / migration hook</em><br><strong>Purpose:</strong> Build a deterministic <code>Scripting.Dictionary</code> package from arbitrary <code>sourceLines</code>; attach metadata, enforce limits, run optional migration hook and emit audit.<br><strong>Signature:</strong> inputs: <code>packageID</code> (String), <code>sourceLines</code> (Variant allow many shapes), optional <code>templateName</code>, optional <code>author</code>. Output: <code>Scripting.Dictionary</code> on success; <code>Nothing</code> on failure.<br><strong>Behavior:</strong> Validate <code>packageID</code> non-empty; create <code>pkg</code> dictionary with <code>PackageID</code>, <code>CorrelationID</code> (via <code>SafeNewCorrelationID</code>), <code>SchemaVersion</code>, <code>TemplateName</code>, <code>Author</code> (fallback to <code>Application.userName</code>), <code>CreatedUTC</code> (via <code>SafeGetUtcIsoTimestamp</code>). Normalizes <code>sourceLines</code> via <code>NormalizeLines</code>, enforces <code>MAX_LINES_THRESHOLD</code> (truncates with <code>ReDim Preserve</code>), sets <code>Lines</code> and <code>Status=&quot;Assembled&quot;</code>. Calls host migration hook <code>MigrateStatementPackage</code> via <code>TryRunReturn</code> and replaces <code>pkg</code> if migration returns an object. Performs structured audit before return.<br><strong>Complexity:</strong> O(n) to normalize lines and possibly O(n) memory to copy/truncate lines, where n = line count. Constant extra metadata overhead.<br><strong>Side-effects:</strong> Calls <code>SafeAuditStructured</code>; may call host <code>MigrateStatementPackage</code>; may log via <code>SafeLog</code> if truncation happened.<br><strong>Invariants:</strong> Returned <code>pkg</code> has <code>PackageID</code>, <code>CorrelationID</code>, <code>SchemaVersion</code>, <code>Lines</code> (1-based array or Empty), <code>Status</code>. <code>Lines</code> trimmed to ≤ <code>MAX_LINES_THRESHOLD</code> if necessary.<br><strong>Failure modes:</strong> Missing/empty <code>packageID</code> returns <code>Nothing</code>; exceptions funnel to <code>SafeHandleError</code> and <code>Nothing</code> returned. Migration hook that returns non-dictionary is ignored. Truncation is logged but not signaled as an error.<br><strong>Security:</strong> No user content injection into host; relies on host helpers. Correlation IDs generated locally when host helper absent.<br><strong>Recommended tests:</strong> assemble with scalar, 1D array, 2D array, Dictionary, Collection inputs; verify truncation path with > <code>MAX_LINES_THRESHOLD</code>; migration hook present vs absent; author default fallback.<br><strong>Notes for maintainers:</strong> Keep tokenization/normalization in <code>NormalizeLines</code> stable; changing <code>MAX_LINES_THRESHOLD</code> impacts memory and downstream code. Ensure <code>MigrateStatementPackage</code> schema parity. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>ValidateStatementPackage(pkg As Object) -> Object (Dictionary of issues)</strong> — <em>package validator</em><br><strong>Purpose:</strong> Validate package shape and line-level integrity; return dictionary of issues where empty dictionary means valid.<br><strong>Signature:</strong> input: <code>pkg</code> (Object); output: <code>Scripting.Dictionary</code> listing <code>key -&gt; description</code> issues (always returns dictionary even on internal errors).<br><strong>Behavior:</strong> Audit entry, allocate <code>issues</code> dictionary. Defensive checks: <code>pkg</code> presence and object type, <code>Lines</code> member existence. Uses <code>NzVariantDict</code>/<code>GetLineCount</code> to iterate lines. For each line checks <code>IsDictLike</code>, <code>LineID</code> non-empty, <code>Amount</code> numeric (<code>IsNumericDict</code>). Sums <code>Amount</code> across lines and checks that <code>Abs(total) &lt;= STATEMENT_BALANCE_TOLERANCE</code> (else add <code>TotalNotZero</code> with formatted total). Final audit with <code>IssuesCount</code> recorded. On runtime error, appends <code>InternalError</code> to <code>issues</code> and still returns dictionary.<br><strong>Complexity:</strong> O(n) to iterate lines; constant memory beyond input.<br><strong>Side-effects:</strong> Writes structured audit entry; may call <code>SafeHandleError</code> on internal exceptions.<br><strong>Invariants:</strong> Always returns a <code>Scripting.Dictionary</code>. Keys are stable: <code>PackageMissing</code>, <code>PackageInvalidType</code>, <code>LinesMissing</code>, <code>LineType_i</code>, <code>LineID_i</code>, <code>Amount_i</code>, <code>TotalNotZero</code>, <code>InternalError</code>.<br><strong>Failure modes:</strong> Nil or non-object <code>pkg</code> returns issues dict with appropriate key; malformed lines increase issue count; numeric coercion failures handled gracefully. If host helper exists, <code>SafeHandleError</code> used to record internal failure.<br><strong>Security:</strong> Validation avoids executing any code from package content; numeric checks use <code>IsNumeric</code> and <code>CDbl</code> guarded by <code>NzDoubleDict</code>.<br><strong>Recommended tests:</strong> empty pkg, non-object pkg, missing Lines, line not dictionary, missing LineID, non-numeric Amount, balanced vs unbalanced totals within and outside tolerance, large line sets. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>RenderStatementToSheet(pkg As Object, sheetName As String, Optional targetWb As Workbook = Nothing) -> Boolean</strong> — <em>render package to worksheet safely</em><br><strong>Purpose:</strong> Render package lines as tabular rows into a worksheet with header + sanitized cell values, batch write for performance, and set <code>pkg(&quot;Status&quot;) = &quot;Rendered&quot;</code> on success.<br><strong>Signature:</strong> input: <code>pkg</code> (Object), <code>sheetName</code> (String), optional <code>targetWb</code>; output: Boolean success flag.<br><strong>Behavior:</strong> Entry audit. Validate inputs. Resolve workbook via <code>ResolveWorkbook</code> (host helper preferred). Attempt <code>SafeGetWorksheet</code> to see if sheet exists; if not, attempt host <code>SafeCreateSheet</code> via <code>TryRunReturn</code> then fall back to <code>SafeCreateSheetUnique</code>. If sheet exists, clear <code>ws.Cells</code> (safe around errors). Build headers array <code>hdr = Array(&quot;LineID&quot;,&quot;Label&quot;,&quot;Amount&quot;,&quot;Sign&quot;,&quot;AccountRefs&quot;,&quot;Notes&quot;)</code>. Transform to 1xN 2D array <code>hdr2</code> with <code>SanitizeForCell()</code> per header then set headerRange.value and bold row 1. Read <code>pkg(&quot;Lines&quot;)</code> via <code>NzVariantDict</code> and n = <code>GetLineCount(lines)</code>. Build <code>outArr(1..n,1..6)</code> batch; uses <code>refsCache</code> dictionary keyed by <code>LineID|Amount</code> to cache normalized refs; calls <code>NormalizeRefsToArray</code> and <code>JoinAccountRefs</code>. Uses <code>SanitizeForCell</code> for textual columns; numeric assigned as double. Writes <code>destRange.value = outArr</code>. Sets <code>pkg(&quot;Status&quot;) = &quot;Rendered&quot;</code>. Audit and return True.<br><strong>Complexity:</strong> O(n*m) but effectively O(n) for single pass; memory O(n) for <code>outArr</code>. Batch write reduces roundtrips to Excel COM significantly. <code>NormalizeRefsToArray</code> may also be O(k) per refs list.<br><strong>Side-effects:</strong> Creates or deletes sheets; modifies workbook; updates <code>pkg</code> dictionary; writes to audit.<br><strong>Invariants:</strong> Headers always present in row 1; data starts at row 2. AccountRefs serialized as semicolon-separated string. All text cells sanitized via <code>SanitizeForCell</code> (prevents formula injection). <code>pkg(&quot;Status&quot;)</code> updated on success.<br><strong>Failure modes:</strong> Workbook resolution failure, sheet creation failure, COM errors during writes; caught and routed to <code>SafeHandleError</code>, returns False. If host-provided <code>SafeCreateSheet</code> returns non-Worksheet, fallback used. If <code>Lines</code> zero length, writes nothing but still returns True after setting Status.<br><strong>Security:</strong> Uses <code>SanitizeForCell</code> to prefix potential formula-leading characters with <code>&#x27;</code> to avoid formula injection. No <code>Evaluate</code> or <code>Execute</code> on cells. Uses batch <code>Range.value</code> to avoid intermediate cell formulas.<br><strong>Recommended tests:</strong> render with existing sheet, non-existing sheet (create path), sheet creation that collides with name (SafeCreateSheetUnique), lines with formula-leading text (verify <code>&#x27;</code> prefix), AccountRefs cache effectiveness, very large n near threshold, ensure <code>pkg(&quot;Status&quot;)</code> updated. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>RestoreStatementSnapshot(snapshotSheetName As String, targetSheetName As String, Optional targetWb As Workbook = Nothing) -> Boolean</strong> — <em>snapshot restore with collision handling</em><br><strong>Purpose:</strong> Restore a very-hidden snapshot sheet by copying and renaming to a desired visible sheet name, handling name collisions by incremental suffixes, and auditing the operation.<br><strong>Signature:</strong> inputs: <code>snapshotSheetName</code>, <code>targetSheetName</code>, optional <code>targetWb</code>; returns Boolean.<br><strong>Behavior:</strong> Entry audit; validate names and workbook resolution. Locate <code>src</code> via <code>SafeGetWorksheet</code>; if missing error out. If a <code>dstExisting</code> with <code>targetSheetName</code> exists, delete it (using <code>Application.DisplayAlerts = False</code> to avoid prompts). Use <code>src.Copy After:=wb.Worksheets(wb.Worksheets.count)</code> to duplicate the sheet; get <code>dst</code> as last worksheet; attempt rename to sanitized safeName via <code>SafeSheetName</code>, looping with incremental suffix <code>_k</code> up to 1000 attempts; uses <code>On Error Resume Next</code> to detect name collision and retry. If rename fails after attempts, raise error. Finally set <code>dst.Visible = xlSheetVisible</code> and audit <code>Snapshot-&gt;RestoredAs</code>. Return True on success.<br><strong>Complexity:</strong> O(1) extraneous algorithmic work; copy cost depends on Excel internals (sheet size). Name collision loop bounded by 1000 iterations.<br><strong>Side-effects:</strong> Deletes existing target sheet if present; creates a new worksheet copy. May temporarily change <code>Application.DisplayAlerts</code>. Writes audit.<br><strong>Invariants:</strong> Restored sheet becomes visible with a unique name derived from <code>targetSheetName</code> sanitized. Snapshot sheet remains unchanged.<br><strong>Failure modes:</strong> Missing snapshot sheet -> error; inability to rename after many attempts -> error; COM exceptions during copy; errors handled by <code>SafeHandleError</code> and False return.<br><strong>Security:</strong> No content execution; copying preserves sheet content as-is. Caller must ensure snapshots do not contain sensitive data inadvertently exposed when made visible.<br><strong>Recommended tests:</strong> restore when target exists (deletion path), when target does not exist, when rename collisions force suffix, when snapshot name missing. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>CreateStatementSnapshot(pkg As Object, sourceSheetName As String, Optional targetWb As Workbook = Nothing) -> String (snapshotName or \"\")</strong> — <em>atomic snapshot + metadata record</em><br><strong>Purpose:</strong> Create a very-hidden snapshot copy of <code>sourceSheetName</code>, name it deterministically (timestamp + short correlation suffix), create persistent metadata row in <code>_IFRS_Snapshots</code> sheet with stable JSON of <code>pkg</code>, and return snapshot sheet name. Has robust fallback attempt via temporary workbook move if direct rename fails.<br><strong>Signature:</strong> inputs: <code>pkg</code>, <code>sourceSheetName</code>, optional <code>targetWb</code>; returns snapshot sheet name on success or empty string on failure.<br><strong>Behavior:</strong> Entry audit and input validation. Resolve workbook and <code>src</code> sheet. <code>src.Copy</code> to create <code>dst</code>. Build <code>baseName = STATEMENT_SNAPSHOT_PREFIX &amp; SafeTimestampCompact()</code> and append truncated <code>CorrelationID</code> safely to avoid the 31-char Excel sheet name length; loop rename attempts similar to <code>RestoreStatementSnapshot</code> up to 1000 tries. Fallback: try <code>src.Copy</code> to create temporary workbook, move its sheet into target workbook, attempt rename with loop; close temp workbook. If rename fails still, delete <code>dst</code> and return failure. Set <code>dst.Visible = xlSheetVeryHidden</code>. Call <code>GetOrCreateSnapshotMetadataSheet(wb)</code> and append a metadata row with <code>dst.name</code>, <code>PackageID</code>, <code>CorrelationID</code>, <code>SchemaVersion</code>, <code>CreatedUTC</code>, <code>SourceSheet</code>, and <code>GetStableJson(pkg)</code> (uses host helper preferentially). Audit and return <code>dst.name</code>.<br><strong>Complexity:</strong> O(1) additional; cost dominated by sheet copy. JSON serialization <code>GetStableJson</code> may be O(k) where k = nested dictionary size.<br><strong>Side-effects:</strong> Creates hidden worksheet; writes to metadata sheet (<code>_IFRS_Snapshots</code>) adding stable JSON payload; may create and close temporary workbook. Updates audit.<br><strong>Invariants:</strong> Snapshot name conforms to safe sheet naming and length limits; metadata sheet has header row and appended details. Snapshot set to <code>xlSheetVeryHidden</code> to avoid casual user exposure.<br><strong>Failure modes:</strong> copy/rename fails, temp workbook operations fail, metadata sheet creation failure; all guarded and call <code>SafeHandleError</code>, then cleanup where possible. If metadata sheet cannot be created, snapshot still created but metadata recording omitted silently (best-effort).<br><strong>Security & Privacy:</strong> <code>GetStableJson</code> writes full package into a worksheet cell — this may contain PII or sensitive numbers. Maintainers must ensure <code>_IFRS_Snapshots</code> is stored only in secure workbooks and consider encrypting or obfuscating package JSON when required. Telemetry/local audit may record <code>CorrelationID</code> — handle accordingly.<br><strong>Recommended tests:</strong> normal snapshot create; snapshot create with long correlation IDs that push name truncation; failure path forcing temp workbook fallback; confirm metadata row fields and <code>GetStableJson</code> output; ensure <code>xlSheetVeryHidden</code> applied. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>GenerateReconciliation(pkg As Object, tbRange As Range) -> Variant (2D array or Empty)</strong> — <em>reconcile package lines to trial balance</em><br><strong>Purpose:</strong> For each package line, sum trial balance amounts that match <code>AccountRefs</code> and compute the difference between <code>Line.Amount</code> and TB sum; return 2D array rows: <code>(LineID, Amount, TBsum, Difference)</code> to enable downstream reporting or writeback.<br><strong>Signature:</strong> inputs: <code>pkg</code> (Object), <code>tbRange</code> (Range with at least 2 columns <code>Account</code>, <code>Amount</code>); output: 2D Variant array <code>out(1..n,1..4)</code> or <code>Empty</code> on error. If no lines returns empty array <code>Array()</code>.\<br><strong>Behavior:</strong> Entry audit. Validate inputs and <code>tbRange.Columns.count &gt;= 2</code>. Build trial-balance <code>tb</code> dictionary by iterating rows in <code>tbRange</code>: use <code>Trim$(CStr(NzString(acctObj)))</code> as key; numeric aggregation of amounts (use <code>NZDouble</code> to coerce). If no account keys found -> error. Read <code>lines = NzVariantDict(pkg, &quot;Lines&quot;)</code>; if zero lines return <code>Array()</code>. Reuse <code>refsCache</code> dictionary keyed by <code>LineID|Amount</code> to avoid repeated normalization of <code>AccountRefs</code> per line by calling <code>NormalizeRefsToArray</code>. For each refs element, look up in <code>tb</code> (case-sensitive key as coded), sum associated TB amounts into <code>sumTb</code>. Populate <code>out(i,1..4)</code> accordingly and compute difference. Audit and return <code>out</code>.<br><strong>Complexity:</strong> O(R + n * r) where R = number of rows in tbRange, n = number of lines, r = average number of refs per line. Memory O(n) for output array.<br><strong>Side-effects:</strong> Writes audit. No workbook modification. Uses <code>refsCache</code> to improve performance for repeated lines.<br><strong>Invariants:</strong> Result rows correspond one-to-one with input <code>Lines</code> order. Keys used for TB lookup are case-sensitive per code; this is a documented behavior but important for maintainers (switch to <code>UCase$</code> for case-insensitive matching).<br><strong>Failure modes:</strong> Missing pkg or tbRange returns <code>Empty</code> and <code>SafeHandleError</code>. TB without account keys returns an error. Non-existing account refs result in zero <code>sumTb</code> for that ref (no error).<br><strong>Security:</strong> No code injection; reading workbook cells only. Caller must ensure <code>tbRange</code> points to correct area and that numeric parse obeys locale; code uses <code>NZDouble</code> and does not attempt currency normalization.<br><strong>Recommended tests:</strong> tbRange with varying white space and case; refs as scalar, array, 2D arrays; repeated refs to test cache; zero-lines handling; case-sensitivity behavior check; mismatched accounts produce difference. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>ExportSheetToCsv(sh As Worksheet, filepath As String) -> Boolean</strong> — <em>worksheet CSV exporter with security probe</em><br><strong>Purpose:</strong> Export <code>sh.UsedRange</code> to a CSV file path, guarded by security check <code>Security_VerifyExportPathWritable</code> if available, handling quoting and decimal separator normalization to <code>.</code>.<br><strong>Signature:</strong> inputs: <code>sh</code> (Worksheet), <code>filepath</code> (String). Returns Boolean success flag.<br><strong>Behavior:</strong> Validate <code>sh</code> and <code>filepath</code>. If host <code>Security_VerifyExportPathWritable</code> exists, call it and abort if it returns False. Determine <code>ur = sh.UsedRange</code>; if nothing, returns False. Compute startRow/Col and maxRow/Col from <code>ur</code>. Open file handle <code>fnum = FreeFile</code> and <code>Open filepath For Output As #fnum</code>. Iterate rows and columns; for each cell obtain <code>v = sh.Cells(r,c).value</code>. Convert to <code>cellText</code> as: empty if empty/null; numeric -> <code>CStr(v)</code> with <code>Application.DecimalSeparator</code> replaced by <code>&quot;.&quot;</code>; else <code>CStr(v)</code>. Escape double-quotes by doubling <code>&quot;&quot;</code> and wrap field in quotes if contains <code>,</code>, <code>&quot;</code>, or newline. Join per-row with <code>,</code> and <code>Print #fnum, outLine</code>. Close file. Return True. Errors close file and call <code>SafeHandleError</code>.<br><strong>Complexity:</strong> O(R*C) where R and C are used range dims; streaming write to disk. Memory O(1) per row (temporary array).<br><strong>Side-effects:</strong> Writes file to disk; may call host security helper; may reveal workbook data externally — ensure policy compliance.<br><strong>Invariants:</strong> Decimal separator normalized to <code>.</code> in file regardless of user locale. Quotes properly escaped in CSV standard style.\n<strong>Failure modes:</strong> File open/write errors, permission issues, security helper denying export; these path report via <code>SafeHandleError</code> and return False. If <code>ur</code> is Nothing, returns False quietly.\n<strong>Security:</strong> Integrates host security check to avoid unwanted writes. Ensure path normalization and host policy confirm safe output. CSV contains raw values (sensitive data may be exported); user must ensure export destination is trusted.\n<strong>Recommended tests:</strong> numeric cells under different locale settings, text with quotes/commas/newlines, security helper deny/allow, empty sheet, very large used range. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>NormalizeLines(v As Variant) -> Variant (1-based array or Empty)</strong> — <em>robust input normalizer</em><br><strong>Purpose:</strong> Convert heterogeneous <code>sourceLines</code> input (arrays 1D/2D, Dictionary <code>.Items</code>, Collection, iterable object, scalar) into a deterministic 1-based (1..n) 1D array of items. Returns <code>Empty</code> if input empty/uninitialized.\n<strong>Signature:</strong> input: <code>v</code> variant; output: 1-based array of items or <code>Empty</code>.\n<strong>Behavior:</strong> Early return for <code>IsEmpty(v)</code> or <code>IsNull(v)</code>. If <code>IsArray(v)</code>, detect 2D by probing <code>LBound(v,2)</code> with <code>On Error</code> guard. If 1D, copy elements into <code>tmp(1..ub-lb+1)</code> preserving original order. If 2D, convert each row into an inner 1-based array <code>inner(1..cols)</code> and return outer array of rows. If <code>IsObject(v)</code>: if <code>typeName(v) = &quot;Dictionary&quot;</code> use <code>.Items</code> and copy; else if <code>v.count</code> present iterate <code>For Each</code> into tmp; else generic <code>For Each</code> fallback iteration with <code>ReDim Preserve</code> growing tmp. Scalar fallback: wrap single value into <code>tmp(1)</code>.\n<strong>Complexity:</strong> O(n) time and memory copying input; 2D conversion cost O(rows*cols) to allocate inner arrays.\n<strong>Side-effects:</strong> None (pure transform). Uses <code>On Error</code> defensively to detect shapes.\n<strong>Invariants:</strong> Output is either <code>Empty</code> or 1-based array where each element is the original item (or inner 1-based arrays for 2D source). Order preserved.\n<strong>Failure modes:</strong> Unusual COM collection types that throw during enumeration — code handles via <code>On Error</code> patterns and returns fallback single-element array. Large inputs may be truncated later by <code>AssembleStatementPackage</code> limit.\n<strong>Recommended tests:</strong> scalar, 1D variant arrays with non-1 LBound, 2D arrays, Dictionary, Collection, custom iterable object, empty/null inputs. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>GetLineCount(v As Variant) -> Long</strong> — <em>safe array length</em><br><strong>Purpose:</strong> Return number of elements in a 1-based array or 0 for non-arrays safely without raising errors.\n<strong>Behavior:</strong> Detect <code>IsArray</code>, call <code>LBound</code> and <code>UBound</code> with <code>On Error</code> guards; return <code>Max(0, ub-lb+1)</code> or 0 if errors.\n<strong>Complexity:</strong> O(1).\n<strong>Failure modes:</strong> None; returns 0 on any error.\n<strong>Tests:</strong> 1-based arrays, arrays with atypical bounds, non-arrays. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>IsDictLike(v As Variant) -> Boolean</strong> — <em>dictionary-like probe</em><br><strong>Purpose:</strong> Heuristically determine whether <code>v</code> behaves like a dictionary: either <code>typeName = &quot;Dictionary&quot;</code> or exposes <code>.Exists</code> method.\n<strong>Behavior:</strong> If not object => False. If <code>typeName(v) = &quot;Dictionary&quot;</code> => True. Else attempt <code>v.Exists(&quot;__IFRS_PROBE__&quot;)</code> under <code>On Error</code> to see if method exists; if no error treat as dictionary-like.\n<strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Objects that throw on <code>.Exists</code> call are caught and result False. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>DictHasKey(d As Variant, k As String) -> Boolean</strong> — <em>defensive Exists check</em><br><strong>Purpose:</strong> Safely test <code>d.Exists(k)</code> without raising if <code>d</code> not an object or method missing.\n<strong>Behavior:</strong> On Error wrappers; return False on exceptions.\n<strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> dictionary with and without key, non-object input, object that lacks <code>.Exists</code>. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>NzStringDict(d,k,def) / NzDoubleDict(d,k,def) / NzVariantDict(d,k) / IsNumericDict(d,k)</strong> — <em>safe typed getters</em><br><strong>Purpose:</strong> Defensive accessors to read typed members from dictionary-like objects without raising. <code>NzStringDict</code> returns string default, <code>NzDoubleDict</code> returns coerced double or default, <code>NzVariantDict</code> returns variant or Empty, <code>IsNumericDict</code> returns Boolean whether value numeric.\n<strong>Behavior:</strong> <code>On Error</code> guards, <code>DictHasKey</code> usage, <code>IsNumeric</code> checks for doubles. Always return provided default on error.\n<strong>Complexity:</strong> O(1).\n<strong>Recommended tests:</strong> keys missing, keys present with mismatched types, null values. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>JoinAccountRefs(v) -> String</strong> — <em>serialize refs to semicolon-separated string</em><br><strong>Purpose:</strong> Normalize <code>AccountRefs</code> into semicolon-separated flat string for cell storage. Accepts array or raw input.\n<strong>Behavior:</strong> If <code>v</code> is array iterate <code>LBoundSafe</code>..<code>UBoundSafe</code> building <code>sb</code> with <code>;</code> separators; else call <code>NormalizeRefsToArray</code> to coerce then join, return scalar when input scalar. Empty returns <code>\&quot;\&quot;</code>.\n<strong>Complexity:</strong> O(r) where r = #refs.\n<strong>Notes:</strong> Uses <code>LBoundSafe</code>/<code>UBoundSafe</code> guards to tolerate non-standard arrays. Tests: 1D arrays, 2D arrays, scalar input. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>NZDouble(v) / NZString(v)</strong> — <em>nil-coalesce simple helpers</em><br><strong>Purpose:</strong> Small utility to safely coerce common VB types: <code>NZDouble</code> returns CDbl or 0; <code>NZString</code> returns CStr or empty.\n<strong>Complexity:</strong> O(1). Tests: numeric, string, Null, Empty. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>NZStringObj(obj, key, def) -> String</strong> — <em>object keyed string getter</em><br><strong>Purpose:</strong> Safely return <code>obj(key)</code> as string defaulting to <code>def</code>. Non-throwing.\n<strong>Behavior:</strong> <code>On Error Resume Next</code> then <code>DictHasKey</code>. Useful for small metadata reads used in audits. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>NormalizeRefsToArray(v) -> Variant</strong> — <em>robust refs normalizer (1-based arrays, 2D -> inner arrays, collections)</em><br><strong>Purpose:</strong> Same as <code>NormalizeLines</code> logic but focused on account references shapes.\n<strong>Behavior:</strong> Handles arrays (1D vs 2D), objects with <code>.count</code> and collections, fallback scalar. Returns <code>Empty</code> when appropriate.\n<strong>Complexity:</strong> O(r) to transform. Tests: varied shapes as for NormalizeLines. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>LBoundSafe(arr) / UBoundSafe(arr)</strong> — <em>safe LBound/UBound wrappers</em><br><strong>Purpose:</strong> Return safe lower/upper bounds with <code>On Error</code> fallback (LBoundSafe defaults to 1, UBoundSafe defaults to 0). Avoid raising when passed non-array or invalid arrays.\n<strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>SafeTimestampCompact() -> String</strong> — <em>compact local timestamp</em><br><strong>Purpose:</strong> Produce compact timestamp <code>YYYYMMDD_HHMMSS</code> based on <code>Now</code> for sheet naming and correlation suffixes.\n<strong>Security:</strong> Uses local <code>Now</code> not UTC; <code>SafeGetUtcIsoTimestamp</code> used elsewhere when UTC-like string preferred. Tests: format correctness. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>HostHas(procName) -> Boolean</strong> — <em>host capability probe with cache</em><br><strong>Purpose:</strong> Probe whether a host-level procedure is callable (via <code>TryRunReturn</code>) and memoize results in a static dictionary to avoid repeated probing.\n<strong>Behavior:</strong> On first call, attempts <code>TryRunReturn(procName, ret)</code> and caches True/False. Uses <code>On Error</code> guard to protect against COM errors. Returns cached value on subsequent calls.\n<strong>Complexity:</strong> O(1) amortized; first-call cost of Application.Run trial.\n<strong>Notes:</strong> Used across module to prefer host helpers for logging, JSON, sheet creation, error handling. Avoids repeated expensive <code>Application.Run</code> checks. Tests: host present vs absent simulation (mocking <code>TryRunReturn</code>). </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>SafeLog(m,p,d) / SafeHandleError(p,n,d) / SafeAuditStructured(category,action,metadata,note)</strong> — <em>integration to host logging & error hooks</em><br><strong>Purpose:</strong> Centralized wrappers that prefer host-level helpers (e.g., <code>LogAudit</code>, <code>HandleError</code>, <code>Audit_LogStructured</code>) but fall back to <code>modUtilities.*</code> or <code>AppendLocalAudit</code> if host helpers absent. These methods swallow host errors and prefer non-blocking "best-effort" reporting.\n<strong>Behavior:</strong> Each attempts <code>HostHas</code> then <code>TryRunReturn</code> host helper; if unsuccessful tries <code>modUtilities</code> equivalent; else fallback to local <code>AppendLocalAudit</code> or <code>SafeLog</code>. <code>SafeHandleError</code> passes to host <code>HandleError</code> or <code>modUtilities.HandleError</code> else appends to local audit with truncated description.\n<strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call host routines or append rows to <code>_IFRS_Audit</code> sheet (persistent local audit). Avoids throwing errors.\n<strong>Recommended tests:</strong> host helpers available, absent; simulate host helper error (throws) to exercise fallbacks; ensure no exception leaks. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>SafeNewCorrelationID() -> String</strong> — <em>correlation id generator with host preferred path</em><br><strong>Purpose:</strong> Prefer <code>NewCorrelationID</code> host helper; otherwise generate deterministic fallback <code>PKG-&lt;timestamp&gt;-&lt;rnd&gt;</code> using <code>SafeTimestampCompact</code> and <code>Rnd</code> seeded via <code>Randomize</code> on first run.\n<strong>Complexity:</strong> O(1).\n<strong>Notes:</strong> Correlation IDs are embedded into package metadata and snapshot name suffix — ensure length constraints when used in sheet names. Tests: host helper present vs absent. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>SafeGetUtcIsoTimestamp() -> String</strong> — <em>timestamp provider with host preference</em><br><strong>Purpose:</strong> Prefer host <code>GetUtcIsoTimestamp</code> for real UTC; fallback to local <code>Now</code> formatted as ISO-like string (note: not true UTC). Maintainers should prefer host helper for correctness in distributed systems.\n<strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>ResolveWorkbook(Optional wb As Workbook) -> Workbook</strong> — <em>resolve workbook via host helper or fallback to ThisWorkbook</em><br><strong>Purpose:</strong> Determine target workbook for operations. Prefers host <code>ResolveWorkbook</code> then <code>modUtilities.ResolveWorkbook</code>. If neither available returns <code>ThisWorkbook</code>.\n<strong>Behavior:</strong> Uses <code>HostHas</code>/<code>TryRunReturn</code> and <code>typeName(ret) = &quot;Workbook&quot;</code> checks with safe guards. Returns <code>Nothing</code> only if host helper returns invalid; otherwise <code>ThisWorkbook</code> fallback.\n<strong>Complexity:</strong> O(1).\n<strong>Recommended tests:</strong> call with explicit workbook, null with host helper present returning other workbook, fallback to ThisWorkbook. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>SafeGetWorksheet(wb, n) -> Worksheet</strong> — <em>safe worksheet getter that returns Nothing instead of error</em><br><strong>Purpose:</strong> Retrieve worksheet by name from workbook; return <code>Nothing</code> if absent or error rather than raising. Uses <code>On Error GoTo</code> wrapper.\n<strong>Complexity:</strong> O(1). Tests: existing vs missing sheet. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>SafeCreateSheet(...) -> Worksheet & SafeCreateSheetUnique(...) -> Worksheet</strong> — <em>host-prefer sheet creation with fallbacks & unique-name creation</em><br><strong>Purpose:</strong> Provide consistent sheet creation APIs. <code>SafeCreateSheet</code> attempts <code>HostHas(&quot;SafeCreateSheet&quot;)</code> then local behavior: delete existing sheet of same name(if present) then add new sheet after <code>afterSheet</code> or at workbook end, set <code>Visible</code> as <code>veryHidden</code> default and optional protect. <code>SafeCreateSheetUnique</code> tries host helper, then builds <code>candidate</code> name from <code>SafeSheetName(n)</code> and loops <code>candidate_k</code> until unique or k>1000; adds sheet and returns it.\n<strong>Complexity:</strong> loops bounded by 1000; largely dominated by Excel sheet add operations. Tests: name collision, host helper present. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>TryRun / TryRunReturn(procName, ret, ParamArray args) -> Boolean</strong> — <em>safe Application.Run wrappers</em><br><strong>Purpose:</strong> Invoke arbitrary named host procedures defensively with up to 8 arguments; <code>TryRunReturn</code> returns result via <code>ret</code>. On exception returns False and clears error. Used widely to optionally call host helpers without throwing.\n<strong>Behavior:</strong> Internally counts args and dispatches <code>Application.Run procName, args...</code> accordingly. Surrounds with <code>On Error</code> and returns boolean success indicator. <code>TryRun</code> discards any return value.\n<strong>Complexity:</strong> O(1) per call; cost of Application.Run dependent on host. Tests: successful run vs non-existent routine. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>AppendLocalAudit(msg) -> Sub</strong> — <em>local fallback audit sink</em><br><strong>Purpose:</strong> Best-effort local audit recording into <code>_IFRS_Audit</code> sheet when host logging not available. Creates audit sheet if missing with header row and marks it <code>xlSheetVeryHidden</code>.\n<strong>Behavior:</strong> Try host <code>AppendLocalAudit</code> via <code>TryRunReturn</code>; else ensure <code>_IFRS_Audit</code> sheet exists (create if missing), append row with timestamp, <code>Application.userName</code>, and message. Uses <code>SafeGetUtcIsoTimestamp</code> for timestamp.\n<strong>Complexity:</strong> O(1) per append (com depends on workbook size). Tests: when audit sheet creation collides on name, uses altName path. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>GetStableJson(d As Object) -> String / DictToJsonStable(d) -> String / EscapeJsonString(s) -> String</strong> — <em>deterministic JSON serialization with host helper preference</em><br><strong>Purpose:</strong> Produce stable, deterministic JSON representation of a <code>Scripting.Dictionary</code> for metadata storage and snapshot audit. Prefer host <code>DictToJsonStable</code> or <code>modUtilities.DictToJsonStable</code>. Local <code>DictToJsonStable</code> builds sorted key list (bubble-sort-like pass), iterates keys and serializes primitives and nested dictionaries recursively. <code>EscapeJsonString</code> escapes typical JSON characters. Falls back to <code>{}</code> on errors.\n<strong>Complexity:</strong> Sorting keys O(m^2) for m keys (bubble sort implemented), serialization O(total items). For moderate dictionary sizes this is acceptable; consider replacing bubble sort with native sort when needed.\n<strong>Security:</strong> JSON string stored into metadata sheet — potential sensitive content. Tests: nested dictionaries, non-dictionary objects presence, special characters escaping, large dictionaries performance. Notes: Replace bubble sort with a stable faster sort (e.g., insertion or using arrays + QuickSort) if dictionaries grow large. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>SanitizeForCell(txt) -> String</strong> — <em>avoid formula injection for cells</em><br><strong>Purpose:</strong> Prevent formula injection by prefixing <code>&#x27;</code> when <code>txt</code> begins with <code>=</code>, <code>+</code>, <code>-</code>, or <code>@</code>. Returns <code>&quot;&quot;</code> for Null/Empty, and otherwise string possibly prefixed with <code>&#x27;</code>.\n<strong>Complexity:</strong> O(1). Security critical: used before writing all header and text fields to sheet. Tests: values beginning with formula-leading characters, empty/null, numeric. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>SafeSheetName(raw) -> String</strong> — <em>sanitize string to valid Excel sheet name (remove invalid chars, trim, limit 31 chars)</em><br><strong>Purpose:</strong> Remove invalid characters <code>: / \ ? * [ ]</code>, trim and limit to 31 characters, fallback to <code>&quot;_sheet&quot;</code> if empty.\n<strong>Complexity:</strong> O(len(raw)). Tests: names with invalid chars, very long names. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>GetOrCreateSnapshotMetadataSheet(wb) -> Worksheet</strong> — <em>metadata sheet factory for snapshots</em><br><strong>Purpose:</strong> Ensure <code>_IFRS_Snapshots</code> sheet exists (create as <code>xlSheetVeryHidden</code> if needed) and return it. Initialize header A1:G1 with columns <code>SnapshotName, PackageID, CorrelationID, SchemaVersion, CreatedUTC, SourceSheet, PackageJson</code>.\n<strong>Behavior:</strong> Use <code>SafeGetWorksheet</code> then <code>Worksheets.Add</code> fallback; guard name collisions with <code>SafeTimestampCompact</code> suffix.\n<strong>Complexity:</strong> O(1). Tests: existing metadata sheet vs creation path. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>ModStatements_SelfTest() -> Sub</strong> — <em>deterministic self-tests & smoke suite</em><br><strong>Purpose:</strong> Provide module-level smoke tests exercising <code>NormalizeLines</code>, <code>AssembleStatementPackage</code>, <code>ValidateStatementPackage</code>, <code>RenderStatementToSheet</code>, <code>CreateStatementSnapshot</code>, <code>RestoreStatementSnapshot</code>, <code>ExportSheetToCsv</code>, and writing a README snippet. Writes results to <code>_IFRS_Statements_Test</code> visible worksheet with PASS/FAIL markers.\n<strong>Behavior:</strong> Creates a test sheet via <code>SafeCreateSheetUnique</code>, populates tests step-by-step: NormalizeLines (Dictionary), assemble roundtrip with two lines (L1/L2 balancing), validate, render into <code>_IFRS_Statements_Test_Render</code>, creates TB sheet <code>_IFRS_Statements_Test_TB</code> and calls <code>GenerateReconciliation</code>, calls <code>CreateStatementSnapshot</code> and <code>RestoreStatementSnapshot</code>, attempts <code>ExportSheetToCsv</code> into workbook folder if available, writes <code>_IFRS_Statements_Readme</code> hidden sheet with API snippet. Uses <code>SafeHandleError</code> to log internal exceptions. SelfTest is idempotent and meant for developer QA.\n<strong>Complexity:</strong> Multiple operations dominated by sheet creation & file IO; not suitable for running unattended at scale. Tests are deterministic except for path-dependant export. Use with workbook saved to test CSV path.\n<strong>Side-effects:</strong> Creates and modifies multiple worksheets (visible or <code>VeryHidden</code>), writes CSV file if workbook saved, logs audits. Should be executed in a test or dev copy of workbook only.\n<strong>Recommended tests:</strong> Run full self-test and inspect PASS/FAIL markers; run multiple iterations to ensure resource cleanup; test on unsaved workbook (ExportSheetToCsv skip path). </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>ModStatements_ReleaseChecklist(Optional iterations As Long = 10) -> Sub</strong> — <em>release verification harness</em><br><strong>Purpose:</strong> Run <code>UtilitiesSelfTest</code> if available and <code>ModStatements_SelfTest</code> multiple times to exercise potential leaks and resource stability before release. Writes logs to audit via <code>SafeLog</code> and <code>SafeHandleError</code> on failure.\n<strong>Behavior:</strong> Attempts <code>UtilitiesSelfTest</code> via <code>TryRunReturn</code>, then loops <code>iterations</code> times calling <code>ModStatements_SelfTest</code> inside <code>On Error Resume Next</code> to avoid aborting the checklist. Records progress in local audit.\n<strong>Complexity:</strong> Runs self-tests <code>iterations</code> times; heavy I/O for high iteration counts; default 10. Tests: run with iterations 1 and >100 to stress test resource usage.\n<strong>Notes:</strong> Not safe for production workbooks; intended for developer validation only. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>ModStatements_ConsistencyCheck() -> Sub</strong> — <em>static source-level check (VBIDE access optional)</em><br><strong>Purpose:</strong> When VBIDE access is available, read module text and count <code>Public Function</code> and <code>Public Sub</code> markers to detect API surface changes; append local audit. Disabled if VBIDE restricted (common in locked-down environments).\n<strong>Behavior:</strong> Wraps VBProject/CodeModule access in <code>On Error GoTo Disabled</code> to gracefully degrade when VBIDE access unavailable. Appends counts to <code>_IFRS_Audit</code> via <code>AppendLocalAudit</code>.\n<strong>Complexity:</strong> O(module text length). Tests: run with VBIDE access available and not available. Security note: VBIDE access often disabled; do not rely on this in production security-sensitive deployments. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>EscapeJsonString(s) -> String</strong> — <em>JSON string escaper</em><br><strong>Purpose:</strong> Helper used by <code>DictToJsonStable</code> to escape backslash, quotes, slashes and control characters. Returns safe JSON string segment.\n<strong>Notes:</strong> Escapes standard control chars; verify behavior against Excel string encoding edge cases (CR/LF/Tab). </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>Design & security notes (global)</strong> — <em>how this module fits & threats</em><br>- All public functions implement defensive input validation and centralized error handling via <code>SafeHandleError</code> to avoid unhandled exceptions reaching the user. <br>- All text written to cells is sanitized with <code>SanitizeForCell</code> to mitigate formula injection attacks. <br>- Snapshot metadata stores stable JSON of whole package in an internal sheet — this is a critical privacy surface; consider optional encryption, redaction, or host-provided secure store for production. <br>- Host helper preference (<code>TryRunReturn</code>) allows seamless integration with host-provided stronger implementations (e.g., real UTC, JSON serializers, secure logging). Validate host helpers are trusted. <br>- <code>DictToJsonStable</code> uses O(m^2) bubble sort; if package dictionaries may exceed a few hundred keys, replace with more efficient sort to avoid CPU spikes. <br>- <code>GetLineCount/NormalizeLines</code> intentionally produce 1-based arrays to match downstream Excel conventions. Keep that invariant or update calling sites if changed. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>Performance & operational notes</strong> — <em>practical tuning guidance</em><br>- <code>MAX_LINES_THRESHOLD</code> prevents runaway memory consumption; tune to environment memory/expected package size. <br>- <code>RenderStatementToSheet</code> uses batch <code>Range.Value</code> writes for performance — preserve this pattern when adding columns. <br>- JSON writing into <code>_IFRS_Snapshots</code> — avoid very large packages to prevent sheet row overflow; consider compressing or storing metadata externally if available. <br>- Replace bubble-sort in <code>DictToJsonStable</code> with a faster stable sort if you expect >100 keys frequently. <br>- <code>ExportSheetToCsv</code> normalizes decimal separator to <code>.</code> which is appropriate for CSV portability but be explicit to downstream consumers. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>Recommended test matrix (concise)</strong> — <em>must-run tests before release</em><br>1. Input shape coverage: scalar, 1D/2D arrays, Dictionary, Collection, iterables for <code>AssembleStatementPackage</code>/<code>NormalizeLines</code>.<br>2. Validation coverage: missing Lines, invalid line shapes, numeric coercions, tolerance edge (±STATEMENT_BALANCE_TOLERANCE).<br>3. Rendering: existing vs create-sheet paths, formula-leading text, header correctness, AccountRefs serialization, large N performance near threshold.<br>4. Snapshot lifecycle: create, metadata row content, very-hidden setting, restore to visible name collisions and temp-workbook fallback.<br>5. Reconciliation: tbRange format variations, case sensitivity, refs array and scalar shapes, cache usage correctness.<br>6. Export: CSV quoting, decimal normalization under different locale decimal separators, security helper deny path.<br>7. Integration: host helper present vs absent for <code>ResolveWorkbook</code>, <code>GetUtcIsoTimestamp</code>, <code>DictToJsonStable</code>, <code>HandleError</code>, and <code>LogAudit</code> to validate fallback behavior.<br>8. SelfTest / ReleaseChecklist: repeated runs (≥100) to detect resource leak / VBIDE conflicts. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>Maintenance notes for engineers</strong> — <em>practical do/don't guidance</em><br>- <strong>Do not</strong> change tokenizer / normalization semantics for <code>NormalizeLines</code> without wide compatibility tests: many callers expect 1-based arrays. <br>- When modifying JSON serialization, maintain <code>GetStableJson</code> stable ordering to preserve snapshot/diff stability (or version the schema). <br>- Any change to <code>STATEMENT_PACKAGE_SCHEMA</code> must be accompanied by a <code>MigrateStatementPackage</code> implementation and a bump in <code>ModuleRevision</code>. <br>- Avoid reintroducing <code>innerHTML</code>-like patterns or <code>Execute</code>/<code>Evaluate</code> of sheet cell contents — use <code>SanitizeForCell</code> and batch writes. <br>- If adding new public functions, update <code>ModStatements_ConsistencyCheck</code> (or better: add a unit-check tool) and README. </td></tr><tr><td data-label="Technical breakdown (modStatements)"> <strong>Final summary (one paragraph)</strong> — The <code>modStatements</code> module implements a conservative, defensive pipeline for building, validating, rendering, snapshotting and reconciling statement packages in VBA: robust input normalization, batch rendering with formula-injection mitigations, deterministic snapshot naming and metadata serialization, and reconciliation against a trial balance. It prefers host helpers for timing, logging and JSON where available, and provides fallbacks that are safe but less accurate (local timestamps, bubble-sort JSON). Key improvement opportunities: secure the snapshot metadata (privacy), replace the O(n²) key sorting in <code>DictToJsonStable</code> with an efficient stable sort, and consider configurable concurrency/size limits for extremely large packages. </td></tr></tbody></table></div><div class="row-count">Rows: 42</div></div><div class="table-caption" id="Table4" data-table="Docu_0161_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modStatementsHelpers)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modStatementsHelpers)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>Overview:</strong> This table documents every top-level and important helper function in <code>modStatementsHelpers</code> (the code you provided). Each entry is exhaustive and structured: purpose, signature, behavior, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended tests, and maintainer notes. Use it as authoritative inline documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>RenderSafeHtml(inputText)</strong> — <em>simple HTML-entity encoder for display</em><br><strong>Purpose:</strong> Convert arbitrary text into a small, safe HTML fragment by escaping the minimal dangerous characters and normalizing line endings to <code>&lt;br/&gt;</code> so text may be rendered inside HTML contexts safely (e.g., HTML preview widgets).<br><strong>Signature:</strong> <code>RenderSafeHtml(ByVal inputText As String) As String</code><br><strong>Behavior:</strong> Replaces <code>&amp; &lt; &gt; &quot; &#x27;</code> with HTML entities; normalizes CR/LF and CR to LF then LF to <code>&lt;br/&gt;</code>. Returns empty string on error (and calls error handler).<br><strong>Complexity:</strong> O(n) in length of <code>inputText</code>.<br><strong>Side-effects:</strong> None (pure).<br><strong>Invariants:</strong> Output contains no raw <code>&lt;</code> or <code>&amp;</code> for basic safety; newline semantics converted to <code>&lt;br/&gt;</code>.<br><strong>Failure modes:</strong> Unexpected non-string inputs are converted via <code>CStr</code> then processed; on unexpected exceptions returns <code>&quot;&quot;</code> and logs via <code>HandleLocalError</code>.<br><strong>Security/XSS:</strong> Suitable for embedding as innerHTML only if caller expects escaped markup; still avoid concatenating untrusted markup around attributes. Use <code>textContent</code> in DOM where possible.<br><strong>Tests:</strong> Strings with <code>&quot;&lt;script&gt;&quot;</code>, ampersands, quotes, and mixed newline styles should map to escaped form with <code>&lt;br/&gt;</code> markers. Verify no <code>&lt;</code> remains.<br><strong>Notes:</strong> Lightweight; not intended to be full HTML sanitizer (no tag-stripping beyond escaping). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>ValidateStatementAssembly(target)</strong> — <em>basic structural checks on a statement range</em><br><strong>Purpose:</strong> Light-weight validation (sanity checks) of candidate statement <code>Range</code> before assembling metadata or performing operations requiring a table-like range.<br><strong>Signature:</strong> <code>ValidateStatementAssembly(ByVal target As Range) As Object</code> (returns <code>Scripting.Dictionary</code> with keys <code>ok</code>, optionally <code>error</code> or <code>warning</code>).<br><strong>Behavior:</strong> If <code>target</code> is <code>Nothing</code> returns <code>ok=false</code> with <code>error</code>. If range has fewer than 2 rows or columns returns <code>ok=false</code> or <code>ok=false</code> plus <code>warning</code> depending on check. Always returns a dictionary (or <code>Nothing</code> on catastrophic failure).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> If returned object exists it contains an <code>ok</code> boolean key.<br><strong>Failure modes:</strong> If <code>target</code> is not a Range, error handler triggers and returns <code>Nothing</code>.<br><strong>Security:</strong> No sensitive operations.<br><strong>Tests:</strong> Pass valid range, empty range, single-cell range; assert <code>ok</code> values and presence of messages. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetStableTableID(target, Optional extraSeed)</strong> — <em>stable deterministic ID generator for a table</em><br><strong>Purpose:</strong> Produce a stable string key for a statement range suitable for using as metadata lookup key (written to metadata sheet). The key is deterministic but portable across workbook edits provided the header signature and workbook fingerprint are unchanged.<br><strong>Signature:</strong> <code>GetStableTableID(ByVal target As Range, Optional ByVal extraSeed As String = &quot;&quot;) As String</code><br><strong>Behavior:</strong> Concatenates <code>GetWorkbookFingerprint(ThisWorkbook)</code>, <code>GetHeaderSignature(target)</code>, and <code>extraSeed</code> (via <code>NzString</code>), passes through <code>CRC32_String</code> to produce a 32-bit checksum, converts to hex via <code>HexFromLong</code>, prefixes with <code>METADATA_KEY_PREFIX</code>, lowercases, returns. On error returns <code>METADATA_KEY_PREFIX &amp; &quot;unknown&quot;</code>.<br><strong>Complexity:</strong> O(h) where h = header content length; dominated by <code>CRC32_String</code> and <code>GetWorkbookFingerprint</code> file access. <br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Returned string always begins with <code>tblmeta_</code> and is 8-hex padded from <code>HexFromLong</code> according to implementation. Stable for unchanged header & workbook fingerprint.<br><strong>Failure modes:</strong> If <code>GetWorkbookFingerprint</code> cannot access file system for saved workbook returns fallback <code>&quot;unsaved|...&quot;</code> causing different IDs across sessions. Delegated CRC32 missing may return zero checksum depending on policy. Such cases are audited.<br><strong>Security:</strong> None special.<br><strong>Tests:</strong> Two identical ranges in same workbook produce same ID. Changing header cells should change ID. Unsaved workbook behaviour documented. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetTableMetadata(stableKey)</strong> — <em>read metadata JSON for key from metadata sheet</em><br><strong>Purpose:</strong> Return stored JSON string for <code>stableKey</code> from <code>_IFRS_Metadata</code> (column 2) or empty string if not found.<br><strong>Signature:</strong> <code>GetTableMetadata(ByVal stableKey As String) As String</code><br><strong>Behavior:</strong> Ensures metadata sheet exists via <code>EnsureMetadataSheetExists()</code>, finds the key with <code>SafeFindInColumn(sh, 1, stableKey)</code> and returns cell in column 2. Returns <code>&quot;&quot;</code> if not found or on error. Delegates reading through <code>SafeReadRange</code> which captures errors.<br><strong>Complexity:</strong> O(rows) — <code>Application.Match</code> is used; fallback linear scan also O(rows).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Returns literal string stored; does not parse JSON.<br><strong>Failure modes:</strong> If metadata sheet cannot be created/obtained returns <code>&quot;&quot;</code>. Corrupt sheet contents produce returned raw strings. <br><strong>Tests:</strong> Round-trip <code>SetTableMetadata</code> then <code>GetTableMetadata</code> returns same JSON when no chunking used. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SetTableMetadata(stableKey, metadataJson, Optional applyMigrationApproval)</strong> — <em>validate and write metadata atomically with auditing</em><br><strong>Purpose:</strong> Validate metadata JSON shape, enforce max length policies, optionally chunk and persist metadata under <code>stableKey</code> into metadata sheet using atomic-ish write approach, and emit structured audit events. Public stable API for setting metadata.<br><strong>Signature:</strong> <code>SetTableMetadata(ByVal stableKey As String, ByVal metadataJson As String, Optional ByVal applyMigrationApproval As Boolean = False) As Boolean</code><br><strong>Behavior (sequence):</strong><br>1. Ensure metadata sheet exists. Generate <code>corr</code> correlation ID. <br>2. If <code>metadataJson</code> length > <code>METADATA_MAX_LENGTH</code> then either attempt <code>ChunkMetadataAndStore</code> if runtime chunking enabled or reject and audit. <br>3. Call <code>ValidateMetadataJson</code> → if non-zero (error code), audit and return False. <br>4. Find existing row via <code>SafeFindInColumn</code>. Call <code>TryWithRetry_WriteToSheet(sh, found, stableKey, metadataJson, corr)</code> which performs the temporary-column atomic write and sanitization. <br>5. On success audit with CRC/hex, return True; else audit failure and return False. <br><strong>Complexity:</strong> O(rows) for find + write cost; write retries multiply cost. JSON size impacts cost. <br><strong>Side-effects:</strong> Writes to metadata sheet, emits audit rows via <code>Audit_LogStructured</code>. <br><strong>Invariants:</strong> On success metadata sheet column 2 contains sanitized JSON string; temporary col cleared. <code>ValidateMetadataJson</code> ensures <code>schemaVersion</code> present. <br><strong>Failure modes:</strong> Protected sheet (unwritable) causes retries and eventual failure; very large metadata triggers size policy or chunking; missing delegated functions (e.g., CRC32) change audit checksum content but do not prevent write. <br><strong>Security/PII:</strong> Metadata is stored in workbook; audit redaction applied when submitting subject/checksum to local audit. <code>SanitizeForCell</code> prevents formula injection. <br><strong>Recommended tests:</strong> <br>- Valid metadata round-trip; invalid <code>schemaVersion</code> rejected (vcode != 0). <br>- Very-large payload rejection vs chunking enabled path. <br>- Write while sheet protected yields audited failure. <br><strong>Notes:</strong> Relies on runtime policy toggles (chunking) and <code>ValidateMetadataJson</code> being kept in sync with schema version constant. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EnsureTableCaption(target, caption)</strong> — <em>idempotent caption insertion above table top-left</em><br><strong>Purpose:</strong> Ensure a caption cell exists immediately above the top-left of <code>target</code> range; if top row is row 1 inserts a new row (if writable) before writing caption. Sanitizes for safe cell value.<br><strong>Signature:</strong> <code>EnsureTableCaption(ByVal target As Range, ByVal caption As String) As Boolean</code><br><strong>Behavior:</strong> Resolves top-left cell via <code>GetTopLeftCellOfRange</code>. If top-left row > 1 writes to <code>Offset(-1,0)</code> otherwise inserts a row at row 1 if sheet writable and writes caption. Uses <code>SafeWriteRange</code> with <code>SanitizeForCell</code>. Returns True on success. <br><strong>Complexity:</strong> O(1) for address manipulation and write (plus <code>SafeWriteRange</code> retry loops).<br><strong>Side-effects:</strong> May insert a new row; changes worksheet content and triggers audit for write via <code>SafeWriteRange</code>. <br><strong>Invariants:</strong> Caption cell contains sanitized text; insertion respects sheet protection via <code>IsWorksheetWritable</code>. <br><strong>Failure modes:</strong> Unwritable sheet or inability to insert row returns False. <br><strong>Tests:</strong> Ensure insertion on top row, overwrite when caption exists; verify sanitized values (leading <code>=</code> etc become prefixed <code>&#x27;&#x27;</code>). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>InjectTOCReference(target, tocId)</strong> — <em>create idempotent workbook named-range for TOC cross-reference</em><br><strong>Purpose:</strong> Create a workbook-level named range <code>TOC_&lt;sanitized tocId&gt;</code> that refers to the top-left cell of <code>target</code> for TOC linking; idempotent and safe for recreation if different reference exists.<br><strong>Signature:</strong> <code>InjectTOCReference(ByVal target As Range, ByVal tocId As String) As Boolean</code><br><strong>Behavior:</strong> Builds <code>nmName = &quot;TOC_&quot; &amp; SanitizeName(tocId)</code>. If a Name exists, compares its <code>RefersTo</code> or <code>RefersToRange</code> address to top-left target; if different deletes old name and recreates. Adds name via <code>ThisWorkbook.Names.Add</code> bound to <code>topLeft</code>. Audits creation. Returns False on error. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Adds/deletes workbook-level Named Ranges; calls <code>Audit_LogStructured</code>. <br><strong>Invariants:</strong> If returns True the workbook contains <code>TOC_&lt;id&gt;</code> referring to <code>topLeft</code>. <br><strong>Failure modes:</strong> Protected workbook or VBProject restrictions may block name creation; function returns False and logs. <br><strong>Tests:</strong> Create name for a range, call again (idempotent), change target and call (recreates). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>AssembleStatementMetadata(target, Optional extras)</strong> — <em>build deterministic metadata dict → JSON string</em><br><strong>Purpose:</strong> Compose canonical metadata dictionary for a statement range: sheet name, stableId, headerSignature, rows, cols, workbookFingerprint, schemaVersion and optional extra keys. Returns deterministic JSON via <code>DictionaryToJson_MaxDepth</code> with depth limit.<br><strong>Signature:</strong> <code>AssembleStatementMetadata(ByVal target As Range, Optional ByVal extras As Object) As String</code><br><strong>Behavior:</strong> Builds <code>Scripting.Dictionary</code> <code>d</code> with required fields; merges keys from <code>extras</code> if <code>Dictionary</code>. Serializes with <code>DictionaryToJson_MaxDepth(d,0,DICT_TO_JSON_MAX_DEPTH)</code>. On error returns <code>&quot;{}&quot;</code>. <br><strong>Complexity:</strong> O(n) where n = number of keys & nested depth; serialization truncation may apply. <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Returned JSON contains <code>&quot;schemaVersion&quot;: METADATA_SCHEMA_VERSION</code>. <br><strong>Failure modes:</strong> Non-dictionary <code>extras</code> ignored; On failure returns <code>&quot;{}&quot;</code> and logs. <br><strong>Tests:</strong> Provide extras with nested dictionaries and verify truncated output if exceeding <code>DICT_TO_JSON_MAX_DEPTH</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SelfTest_ModStatementsHelpers()</strong> — <em>deterministic self-test harness that writes test results to hidden sheet</em><br><strong>Purpose:</strong> Run module-level deterministic tests (dictionary -> JSON, CRC consistency, metadata sheet existence, set/get metadata, depth truncation, ValidateStatementAssembly behaviour, JsonEscape invariants), write results to <code>TEST_RESULTS_SHEET</code>, and audit results. Designed for local dev/CI smoke checks.<br><strong>Signature:</strong> <code>Public Sub SelfTest_ModStatementsHelpers()</code> (no return) <br><strong>Behavior:</strong> Executes a sequence of tests producing a <code>Scripting.Dictionary</code> of results, writes them via <code>WriteSelfTestResults</code>, logs an audit call with checksum. Uses existing public APIs (<code>SetTableMetadata</code>, <code>GetTableMetadata</code>, <code>CRC32_String</code>, etc.).<br><strong>Complexity:</strong> Several O(n) operations depending on storage; dominated by write/read to metadata sheet. <br><strong>Side-effects:</strong> Writes to <code>TEST_RESULTS_SHEET</code> (creates if missing), writes to metadata sheet (creates keys), emits audits. <br><strong>Invariants:</strong> Tests are deterministic across runs unless external delegation (like CRC delegate) changes. <br><strong>Failure modes:</strong> Dependent modules missing (modUtilities) alter CRC behaviour; test still records results and audits. On fatal error uses <code>HandleLocalError</code>. <br><strong>Tests:</strong> This function itself is the test harness; CI should assert <code>readback_match</code> equals <code>pass</code>. <br><strong>Notes:</strong> Intended for human inspection and as CI gate; avoids destructive operations beyond writing test rows. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EnsureMetadataSchema()</strong> — <em>ensure metadata sheet header and schema version cell exist and run dry-run migration</em><br><strong>Purpose:</strong> Initialize metadata sheet header rows and schema version column; run <code>MigrateLegacyMetadataIfNeeded</code> in dry-run mode to surface migration candidates via audit. Called on sheet creation and first use.<br><strong>Signature:</strong> <code>Private Sub EnsureMetadataSchema()</code><br><strong>Behavior:</strong> Calls <code>EnsureMetadataSheetExists()</code>, writes header keys in row 1, sets <code>SchemaVersion</code> label and row 2 value if mismatch, calls <code>MigrateLegacyMetadataIfNeeded(sh, False, &quot;&quot;)</code>. <br><strong>Complexity:</strong> O(1) plus migration dry-run cost. <br><strong>Side-effects:</strong> May write to metadata sheet header cells; audits migration manifest via <code>MigrateLegacyMetadataIfNeeded</code>. <br><strong>Tests:</strong> Verify header set and <code>SchemaVersion</code> cell updated when old version present. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>MigrateLegacyMetadataIfNeeded(sh, Optional applyChanges, Optional approvalToken)</strong> — <em>detect and optionally apply conservative migration of legacy keys</em><br><strong>Purpose:</strong> Identify legacy metadata keys that do not start with <code>METADATA_KEY_PREFIX</code>, produce an audit manifest with guessed new key names and (optionally) rename rows if <code>applyChanges=True</code> and <code>approvalToken</code> provided. Designed to be conservative and require explicit approval to mutate data.<br><strong>Signature:</strong> <code>Private Sub MigrateLegacyMetadataIfNeeded(ByVal sh As Worksheet, Optional ByVal applyChanges As Boolean = False, Optional ByVal approvalToken As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Scans metadata rows from row 2 to lastRow; when finds keys not starting with prefix builds <code>guessedId = METADATA_KEY_PREFIX &amp; LCase(HexFromLong(CRC32_String(GetWorkbookFingerprint(ThisWorkbook) &amp; &quot;|&quot; &amp; sampleBefore)))</code>, records examples into <code>manifest(&quot;samples&quot;)</code>. If <code>applyChanges</code> and <code>approvalToken</code> non-empty and sheet writable, writes guessed id into column 1. Manifest is audited via <code>Audit_LogStructured</code>. Dry-run does not mutate. <br><strong>Complexity:</strong> O(rows). <br><strong>Side-effects:</strong> May rename keys if explicit approval and applyChanges set. Always emits audit manifest. <br><strong>Invariants:</strong> Non-destructive unless intentionally applied. <br><strong>Failure modes:</strong> Protected sheet prevents rename; function records <code>manifest(&quot;applied&quot;) = False</code>. <br><strong>Tests:</strong> Run on known legacy keys in a test sheet and assert manifest contents; verify no rename in dry-run. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>ValidateMetadataJson(json)</strong> — <em>simple token-based metadata schema validator</em><br><strong>Purpose:</strong> Lightweight deterministic validation for presence and version of <code>schemaVersion</code> token in the JSON string; returns error codes for missing/incorrect/invalid JSON shapes fast (no full JSON parse required).<br><strong>Signature:</strong> <code>Private Function ValidateMetadataJson(ByVal json As String) As Long</code> — returns <code>0</code> = OK, <code>1</code> missing token, <code>2</code> mismatched version, <code>3</code> invalid format/empty.<br><strong>Behavior:</strong> Checks for presence of token string <code>&quot;&quot;&quot;schemaVersion&quot;&quot;&quot;</code> (double-quote form). Then checks for exact token form <code>&quot;&quot;&quot;schemaVersion&quot;&quot;:&quot; &amp; METADATA_SCHEMA_VERSION</code>. Accepts alternative single-quote token form as fallback. If checks fail returns codes as above. <br><strong>Complexity:</strong> O(n) string search. <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Deterministic numeric codes. <br><strong>Failure modes:</strong> This is a heuristic: malformed but semantically correct JSON could fail; conversely token present with wrong numeric value flagged. <br><strong>Tests:</strong> Provide JSON strings with and without <code>schemaVersion</code> and with different numeric versions to confirm returned codes. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>DictionaryToJson_MaxDepth(dict, depth, maxDepth)</strong> — <em>stable deterministic JSON serializer with depth/cap truncation</em><br><strong>Purpose:</strong> Convert <code>Scripting.Dictionary</code> objects to stable JSON strings with deterministic key ordering and depth-limited traversal; truncates very large outputs to avoid huge cell writes and DoS vectors.<br><strong>Signature:</strong> <code>Private Function DictionaryToJson_MaxDepth(ByVal dict As Object, ByVal depth As Long, ByVal maxDepth As Long) As String</code><br><strong>Behavior:</strong> Returns <code>&quot;{}&quot;</code> for <code>Nothing</code> or empty dictionary. If depth > maxDepth returns <code>&quot;{}&quot;</code>. Copies keys into array and performs insertion-sort order by case-insensitive key comparison to ensure deterministic ordering across runs. For each key if value is <code>Dictionary</code> recursively call serializer; otherwise coerce via <code>NullSafeValue</code> and <code>JsonEscape</code>. Joins pairs with commas. After building <code>outJson</code>, if length > <code>JSON_OUTPUT_MAX_LENGTH</code> truncates to <code>Left(..., JSON_OUTPUT_MAX_LENGTH - 16) &amp; &quot;...[truncated]&quot;</code>. On error returns <code>&quot;{}&quot;</code> and logs.<br><strong>Complexity:</strong> O(k^2) worst-case due to insertion sort on keys where k is number of keys; recursion cost is depth-dependent and can be expensive for large nested dictionaries (hence depth limit). <br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Deterministic key order, limited depth, maximal output length. <br><strong>Failure modes:</strong> Very large dictionaries truncated; non-dictionary objects serialized as <code>&quot;[object]&quot;</code>. <br><strong>Security:</strong> Uses <code>JsonEscape</code> to escape strings and avoids <code>Eval</code> or <code>innerHTML</code> semantics. <br><strong>Tests:</strong> <br>- Ensure ordering of keys independent of insertion order. <br>- Deep nested dictionary truncated at <code>maxDepth</code>. <br>- Output truncation behavior when > <code>JSON_OUTPUT_MAX_LENGTH</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>DictionaryToJson(dict)</strong> — <em>compatibility wrapper with default depth</em><br><strong>Purpose:</strong> Convenience wrapper calling <code>DictionaryToJson_MaxDepth(dict, 0, DICT_TO_JSON_MAX_DEPTH)</code>.<br><strong>Signature:</strong> <code>Private Function DictionaryToJson(ByVal dict As Object) As String</code><br><strong>Behavior:</strong> Delegates to <code>DictionaryToJson_MaxDepth</code>. <br><strong>Complexity:</strong> Same as delegate. <br><strong>Tests:</strong> Consistency with <code>DictionaryToJson_MaxDepth</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SafeFindInColumn(sh, colIndex, what)</strong> — <em>robust column lookup with Match + linear fallback</em><br><strong>Purpose:</strong> Safely locate a string <code>what</code> in column <code>colIndex</code> of worksheet <code>sh</code> starting at row 2; tolerant to Match failing (use linear scan fallback). Returns <code>Range</code> or <code>Nothing</code>.<br><strong>Signature:</strong> <code>Private Function SafeFindInColumn(ByVal sh As Worksheet, ByVal colIndex As Long, ByVal what As String) As Range</code><br><strong>Behavior:</strong> Uses <code>Application.Match</code> against range from row 2 to lastRow. If <code>Match</code> returns a value, computes row. If <code>Match</code> errors or returns error, falls back to linear <code>For rr = 2 To lastRow</code> comparison of trimmed cell values. Returns <code>Nothing</code> if not found or no rows. Handles errors via Try/Catch style. <br><strong>Complexity:</strong> O(1) average with <code>Match</code>, O(rows) worst-case with linear fallback. <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Existing key at row N found; missing returns <code>Nothing</code>; trailing spaces trimmed. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>CreateNamedRangeForTOC(target, tocId, correlation_id)</strong> — <em>idempotent named-range create for TOC (internal)</em><br><strong>Purpose:</strong> Implementation detail for <code>InjectTOCReference</code> (idempotent creation with safe deletion of conflicting names).<br><strong>Signature:</strong> <code>Private Function CreateNamedRangeForTOC(ByVal target As Range, ByVal tocId As String, ByVal correlation_id As String) As Boolean</code><br><strong>Behavior:</strong> See <code>InjectTOCReference</code>. Additional audit event <code>CreateNamedRangeForTOC</code> emitted. <br><strong>Complexity/Notes:</strong> same as public wrapper. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>Audit_LogStructured(action, stable_id_or_name, correlation_id, outcome, metadata_checksum, algorithm_tag)</strong> — <em>structured audit sender with delegation to modAudit or fallback local audit</em><br><strong>Purpose:</strong> Central structured audit writer that tries to call <code>modAudit.LogAudit</code> or global <code>LogAudit</code> via <code>Application.Run</code> (best-effort) and if unavailable falls back to writing redacted entries into local <code>_IFRS_Audit</code> via <code>AppendLocalAuditStructured</code>.<br><strong>Signature:</strong> <code>Private Sub Audit_LogStructured(ByVal action As String, ByVal stable_id_or_name As String, ByVal correlation_id As String, ByVal outcome As String, ByVal metadata_checksum As String, ByVal algorithm_tag As String)</code><br><strong>Behavior:</strong> Attempts Application.Run for <code>modAudit.LogAudit</code>. If it fails tries <code>LogAudit</code>. If both fail writes to local audit sheet. Uses <code>RedactForAudit</code> to sanitize subjects/checksums for local entries. Catches errors and ensures fallback local audit always attempted. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Networkless local audit writes; calls external modules if present. <br><strong>Security & PII:</strong> Redaction logic applied prior to local logging to avoid leaking emails/long digits. <br><strong>Testing:</strong> Simulate presence/absence of <code>modAudit</code> and validate local <code>AppendLocalAuditStructured</code> receives correctly redacted rows. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>AppendLocalAuditStructured(action, subject, correlation_id, outcome, checksum, algorithm_tag)</strong> — <em>append structured row to <code>_IFRS_Audit</code> sheet</em><br><strong>Purpose:</strong> Low-level writer that appends timestamped structured audit rows to <code>_IFRS_Audit</code> sheet, including a tamper-evident row hash using <code>CRC32_String</code> on first three columns.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAuditStructured(ByVal action As String, ByVal subject As String, ByVal correlation_id As String, ByVal outcome As String, ByVal checksum As String, ByVal algorithm_tag As String)</code><br><strong>Behavior:</strong> Ensures sheet exists via <code>EnsureAuditSheetExists</code>, computes next row, writes timestamp, user, action, subject (truncated), correlation id, outcome, checksum (left 128 chars), algorithm, and rowhash <code>HexFromLong(CRC32_String(rowhashInput))</code>. On failure prints debug line. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Writes to <code>AUDIT_SHEET_NAME</code>. <br><strong>Tests:</strong> Confirm row appended, <code>RowHash</code> matches CRC32 of concatenated fields, redaction applied. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>AppendLocalAudit(message)</strong> — <em>compatibility wrapper that channels legacy short messages into structured audit</em><br><strong>Purpose:</strong> Provide backward-compatible short-message logging by routing to <code>Audit_LogStructured</code> with redaction. <br><strong>Signature:</strong> <code>Private Sub AppendLocalAudit(ByVal message As String)</code><br><strong>Behavior:</strong> Calls <code>Audit_LogStructured &quot;AppendLocalAudit&quot;, Left(RedactForAudit(message), AUDIT_REDACT_TRUNCATE), GenerateCorrelationID(), &quot;message&quot;, HexFromLong(CRC32_String(message)), &quot;local&quot;</code>. On failure prints debug. <br><strong>Tests:</strong> Legacy components calling this produce structured rows. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EnsureAuditSheetExists()</strong> — <em>create the local audit sheet idempotently and set headers</em><br><strong>Purpose:</strong> Ensure <code>_IFRS_Audit</code> sheet exists, initialize header row and make it very hidden; return worksheet reference or <code>Nothing</code> on failure.<br><strong>Signature:</strong> <code>Private Function EnsureAuditSheetExists() As Worksheet</code><br><strong>Behavior:</strong> Tries to get sheet by name; if not present creates via <code>SafeCreateSheetUnique</code>, sets <code>Visible = xlSheetVeryHidden</code>, writes header column names (Timestamp, User, Action, Subject, CorrelationID, Outcome, Checksum, Algorithm, RowHash). <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> May create a hidden worksheet. <br><strong>Tests:</strong> Called repeatedly is idempotent; header cells preserved. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>HandleLocalError(procName, errNum, errDesc)</strong> — <em>error forwarding/handler that tries modError.HandleError and falls back to local auditing</em><br><strong>Purpose:</strong> Centralized error handler that attempts to forward to <code>modError.HandleError</code> (or a global <code>HandleError</code>), and if not available writes a redacted audit entry. Prevents the logger itself from raising exceptions by using nested error-handling fallback paths.<br><strong>Signature:</strong> <code>Private Sub HandleLocalError(ByVal procName As String, ByVal errNum As Long, ByVal errDesc As String)</code><br><strong>Behavior:</strong> Attempts <code>Application.Run &quot;modError.HandleError&quot;</code>, else <code>Application.Run &quot;HandleError&quot;</code>. If neither present or returns error it prints <code>Debug.Print</code> and calls <code>Audit_LogStructured &quot;Error&quot;</code>. Includes fallback <code>Fallback</code> label to <code>Debug.Print</code> if the handler itself errors. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Emits audit entries. <br><strong>Tests:</strong> Simulate missing <code>modError</code> and verify audit fallback is executed and no unhandled errors escape. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>TryWithRetry_WriteToSheet(sh, found, keyName, json, correlation_id)</strong> — <em>atomic-ish write helper (temp column + sanitize) with retries and protection handling</em><br><strong>Purpose:</strong> Core safe-write routine: write key and JSON into a transient temp column (METADATA_TEMP_COL), copy sanitized value into real JSON column (col 2), clear temp cell, and restore application state; retries when sheet not writable up to <code>MAX_RETRIES</code> with exponential backoff controlled by <code>RETRY_WAIT_SECONDS</code>.<br><strong>Signature:</strong> <code>Private Function TryWithRetry_WriteToSheet(ByVal sh As Worksheet, ByVal found As Range, ByVal keyName As String, ByVal json As String, ByVal correlation_id As String) As Boolean</code><br><strong>Behavior (detailed):</strong><br>- Loop attempts 1..MAX_RETRIES: <br>  - If <code>IsWorksheetWritable(sh)</code> true: disable <code>ScreenUpdating</code> and <code>EnableEvents</code>; if <code>found</code> is Nothing append new row (rowIdx), write <code>SanitizeForCell(keyName)</code> into col1, write <code>json</code> into <code>METADATA_TEMP_COL</code> then copy sanitized temp-col value into col2 (avoids direct unsanitized write into JSON column), clear temp col; else same on found.row. Restore <code>EnableEvents</code>/<code>ScreenUpdating</code>. On success set function True. <br>  - If sheet not writable sleep <code>PauseSeconds(RETRY_WAIT_SECONDS * attempt)</code> and retry. <br>- On write errors uses <code>WriteFail</code> label to handle and continue; on exhaustion returns False. <br><strong>Complexity:</strong> O(retries) * O(1) operations; cost dominated by sheet write. <br><strong>Side-effects:</strong> Writes to sheet; may create new row. Audits via <code>SafeWriteRange</code> or <code>Audit_LogStructured</code> in calling code. <br><strong>Invariants:</strong> When returns True, column 2 contains sanitized JSON and temp column cleared. <br><strong>Failure modes:</strong> Protected sheet that cannot be unprotected triggers retries and eventual false; unexpected exceptions cause error handler call and return False. <br><strong>Security:</strong> Uses <code>SanitizeForCell</code> to prevent formula execution attack vectors. <br><strong>Tests:</strong> Simulate protected sheet (unprotect fails) to check retries; successful write on first attempt; ensure temp cell cleared. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>IsWorksheetWritable(sh)</strong> — <em>probe whether a worksheet is writable, attempt unprotect when possible</em><br><strong>Purpose:</strong> Determine whether the code can write to a worksheet and attempt <code>sh.Unprotect</code> when <code>ProtectContents</code> flagged; if unprotect fails logs an audit and returns False.<br><strong>Signature:</strong> <code>Private Function IsWorksheetWritable(ByVal sh As Worksheet) As Boolean</code><br><strong>Behavior:</strong> If <code>sh.ProtectContents</code> then attempts <code>sh.Unprotect</code> inside <code>On Error Resume Next</code>; if unprotect succeeded returns True else audit and return False. If not protected returns True. Uses <code>HandleLocalError</code> on exceptions. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> May modify sheet protection state by calling <code>Unprotect</code>. <br><strong>Tests:</strong> Protected sheet with and without password should behave as expected (unable to unprotect without password). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>CRC32_String(s)</strong> — <em>CRC32 canonicalization with delegate-first and controlled fallback</em><br><strong>Purpose:</strong> Compute a CRC32-style checksum for strings with a delegate-first policy to <code>modUtilities.CRC32_String</code> (preferred), else fall back to local byte-based CRC table or DJB2 fallback on fatal error. Emits an audit when fallback is used but only once (g_crcFallbackAudited). Policy controlled by <code>SetCRC32Policy</code> flags (<code>m_crcDelegateOnly</code>, <code>m_crcAllowFallback</code>).<br><strong>Signature:</strong> <code>Private Function CRC32_String(ByVal s As String) As Long</code><br><strong>Behavior (detailed):</strong><br>- If <code>Len(s)=0</code> returns 0. <code>InitRuntimePolicies</code> loads flags. <br>- Try <code>TryRunExternal(&quot;modUtilities.CRC32_String&quot;, s)</code> and if returned value not <code>Empty</code> use it. <br>- If <code>m_crcDelegateOnly</code> True then audit and return 0. <br>- If <code>m_crcAllowFallback</code> False audit and return 0. <br>- If allowed fallback, once audit fallback usage (g_crcFallbackAudited) then perform local CRC algorithm: <code>StrToBytes</code> to bytes (delegate to modUtilities.StrToBytes if present else <code>StrConv</code>), iterate bytes and use precomputed CRC32 table via <code>CRC32Table(index)</code>, return inverted crc masked to 32 bits. <br>- On error return DJB2_Hash(s) as last-resort fallback. <br><strong>Complexity:</strong> O(n) over bytes of string. <br><strong>Side-effects:</strong> Emits one-time audit when fallback used. <br><strong>Invariants:</strong> If delegate present then result comes from delegate; otherwise deterministic local CRC. <br><strong>Failure modes:</strong> Delegation absent and fallback disabled returns 0; potential collisions as with any 32-bit hash. <br><strong>Security/Notes:</strong> Auditing ensures operators see fallback. Recommended to supply <code>modUtilities</code> for canonical CRC across modules. <br><strong>Tests:</strong> Validate delegate path, fallback path, <code>m_crcDelegateOnly</code> True path, and DJB2 fallback when CRC algorithm errors. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>DJB2_Hash(s)</strong> — <em>cheap deterministic fallback hash</em><br><strong>Purpose:</strong> Provide a simple non-cryptographic fallback integer hash when CRC cannot be computed.<br><strong>Signature:</strong> <code>Private Function DJB2_Hash(ByVal s As String) As Long</code><br><strong>Behavior:</strong> Standard DJB2 loop (<code>h = 5381; h = h*33 + ch</code>) using <code>AscW</code> per character and masking to 31-bit signed. Returns Long. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Tests:</strong> Deterministic across runs; not a substitute for CRC compatibility. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>StrToBytes(s)</strong> — <em>convert string to byte array with delegate preferred</em><br><strong>Purpose:</strong> Convert VBA Unicode string to byte array for CRC computation. Delegates to <code>modUtilities.StrToBytes</code> if present. Falls back to <code>StrConv(s, vbFromUnicode)</code>.<br><strong>Signature:</strong> <code>Private Function StrToBytes(ByVal s As String) As Byte()</code><br><strong>Complexity:</strong> O(n). <br><strong>Tests:</strong> Delegate path and fallback path produce expected byte arrays; ensure consistent encoding (use workbook's expected encoding). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>CRC32Table(index)</strong> — <em>lazy-initialized CRC32 lookup table accessor</em><br><strong>Purpose:</strong> Provide the CRC polynomial table (EDB88320) used by local CRC calculation. Table is computed once and cached in static array. Returns <code>Long</code> table value for index 0..255.<br><strong>Signature:</strong> <code>Private Function CRC32Table(index As Long) As Long</code><br><strong>Behavior:</strong> On first call computes table with nested loops and stores in static <code>tbl(0..255)</code> and sets <code>tblInitialized</code> flag. Returns <code>tbl(index)</code>. <br><strong>Complexity:</strong> O(256*8) once initialization then O(1) per access. <br><strong>Tests:</strong> Table values equal known CRC32 polynomial table. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>HexFromLong(n)</strong> — <em>32-bit hex formatting helper</em><br><strong>Purpose:</strong> Format numeric <code>Long</code> as zero-padded 8-character hex string uppercase. <br><strong>Signature:</strong> <code>Private Function HexFromLong(ByVal n As Long) As String</code><br><strong>Behavior:</strong> <code>Right(&quot;00000000&quot; &amp; Hex((CLng(n) And &amp;HFFFFFFFF)), 8)</code> <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Check <code>HexFromLong(0)</code> -> <code>&quot;00000000&quot;</code>, <code>HexFromLong(&amp;HFFFFFFFF)</code> -> <code>&quot;FFFFFFFF&quot;</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SanitizeName(s)</strong> — <em>make safe short name for named-ranges</em><br><strong>Purpose:</strong> Replace characters illegal or inconvenient in named ranges with underscores and truncate to 50 chars. Used by <code>CreateNamedRangeForTOC</code> to propagate safe <code>TOC_</code> names.<br><strong>Signature:</strong> <code>Private Function SanitizeName(ByVal s As String) As String</code><br><strong>Behavior:</strong> Replaces <code> </code> <code>/ \ [ ] : ? * &#x27; </code> with <code>_</code>; truncates to 50 chars. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Tests:</strong> Input containing illegal chars yields underscores. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SanitizeForCell(s)</strong> — <em>prevent formula injection by prefixing <code>’</code> for dangerous leading chars</em><br><strong>Purpose:</strong> Ensure a cell's string value cannot be interpreted as a formula by Excel when a string begins with <code>= + - @</code>. Adds a leading single quote <code>&#x27;</code> when necessary.<br><strong>Signature:</strong> <code>Private Function SanitizeForCell(ByVal s As String) As String</code><br><strong>Behavior:</strong> If first char is one of <code>= + - @</code> then prefix with <code>&#x27;</code>. Returns unchanged otherwise. <br><strong>Tests:</strong> <code>&quot;=1+1&quot;</code> -> <code>&quot;&#x27;=1+1&quot;</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SafeWriteRange(r, v)</strong> — <em>reliable single-cell write with retries and sanitization</em><br><strong>Purpose:</strong> Write a value <code>v</code> into range <code>r</code> atomically with retries, using <code>SanitizeForCell</code> for strings and honoring worksheet protection via <code>IsWorksheetWritable</code>. Emits an <code>Audit_LogStructured</code> event with the cell address and correlation id on success/failure. <br><strong>Signature:</strong> <code>Private Sub SafeWriteRange(ByVal r As Range, ByVal v As Variant)</code><br><strong>Behavior:</strong> For attempts 1..MAX_RETRIES: if sheet writable then set <code>Application.ScreenUpdating=False</code>, <code>EnableEvents=False</code>, sanitize string values, assign <code>r.value = valueToWrite</code>, restore Application flags, audit <code>SafeWriteRange</code> success; else pause and retry. On failure audit <code>failed</code>. Uses <code>HandleLocalError</code> on exceptions. <br><strong>Complexity:</strong> O(retries). <br><strong>Side-effects:</strong> Writes to workbook, emits audit. <br><strong>Tests:</strong> Protected sheet yields retries and proper audit. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SafeReadRange(r)</strong> — <em>defensive single-cell read</em><br><strong>Purpose:</strong> Return <code>r.value</code> or <code>Null</code> on error while logging via <code>HandleLocalError</code>. <br><strong>Signature:</strong> <code>Private Function SafeReadRange(ByVal r As Range) As Variant</code><br><strong>Behavior:</strong> Returns <code>r.value</code> when <code>r</code> non-nil, otherwise <code>Null</code>. Errors routed through <code>HandleLocalError</code>. <br><strong>Tests:</strong> None special. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>PauseSeconds(seconds)</strong> — <em>sleep helper using Application.Wait</em><br><strong>Purpose:</strong> Pause execution for given seconds using <code>Application.Wait</code> and <code>DateAdd</code>. Caller uses this for retry backoff. <br><strong>Signature:</strong> <code>Private Sub PauseSeconds(ByVal seconds As Double)</code><br><strong>Notes:</strong> <code>Application.Wait</code> is coarse and blocks Excel UI thread. Used sparingly. <br><strong>Tests:</strong> Small wait durations. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GenerateCorrelationID()</strong> — <em>produce a stable non-guessable id; prefer delegate</em><br><strong>Purpose:</strong> Provide correlation IDs for audits and writes; attempt <code>modUtilities.GenerateCorrelationID</code> first; else use <code>Scriptlet.TypeLib</code>.guid or fallback to timestamp+timer heuristic.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Tries <code>TryRunExternal(&quot;modUtilities.GenerateCorrelationID&quot;)</code>. If empty uses COM <code>Scriptlet.TypeLib</code> GUID creation; strips braces; if fails uses <code>Format(Now,&quot;yyyymmddhhmmss&quot;) &amp; &quot;-&quot; &amp; Int(Timer*1000)</code>. On error returns <code>corr-yyyymm...</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Non-empty string returned; uniqueness across calls with short time separation. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>InitRuntimePolicies()</strong> — <em>load module-level policy flags from constants</em><br><strong>Purpose:</strong> Initialize runtime flags <code>m_crcDelegateOnly</code>, <code>m_crcAllowFallback</code>, and <code>m_chunkingEnabledRuntime</code> from module constants only once (lazy initialization).<br><strong>Signature:</strong> <code>Private Sub InitRuntimePolicies()</code><br><strong>Behavior:</strong> If not initialized sets booleans from respective CONSTs and marks flags true. <br><strong>Complexity:</strong> O(1). <br><strong>Notes:</strong> Public setters <code>SetCRC32Policy</code> and <code>SetMetadataChunkingEnabled</code> override runtime booleans for testing or runtime configuration. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SetCRC32Policy(delegateOnly, allowFallback)</strong> — <em>runtime override for CRC policy</em><br><strong>Purpose:</strong> Allow test/CI to set <code>m_crcDelegateOnly</code> and <code>m_crcAllowFallback</code> dynamically. <br><strong>Signature:</strong> <code>Public Sub SetCRC32Policy(ByVal delegateOnly As Boolean, ByVal allowFallback As Boolean)</code><br><strong>Behavior:</strong> Calls <code>InitRuntimePolicies</code> and sets flags. No return. <br><strong>Tests:</strong> Toggle flags and assert <code>CRC32_String</code> behavior changes accordingly. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SetMetadataChunkingEnabled(enabled)</strong> — <em>runtime toggle to enable chunking</em><br><strong>Purpose:</strong> Enable/disable metadata chunking at runtime for large metadata writes (controlled feature). <br><strong>Signature:</strong> <code>Public Sub SetMetadataChunkingEnabled(ByVal enabled As Boolean)</code><br><strong>Behavior:</strong> Calls <code>InitRuntimePolicies</code> and sets <code>m_chunkingEnabledRuntime</code>. <br><strong>Tests:</strong> Turn on chunking and verify <code>SetTableMetadata</code> with large payload stores chunk parts. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>WriteSelfTestResults(results)</strong> — <em>persist selftest result dictionary row to TEST_RESULTS_SHEET</em><br><strong>Purpose:</strong> Write deterministic test summary rows to hidden <code>TEST_RESULTS_SHEET</code> used by <code>SelfTest_ModStatementsHelpers</code> and CI checks. <br><strong>Signature:</strong> <code>Private Sub WriteSelfTestResults(ByVal results As Object)</code><br><strong>Behavior:</strong> Creates or opens <code>TEST_RESULTS_SHEET</code> with <code>SafeCreateSheetUnique</code>, sets <code>Visible = xlSheetVeryHidden</code> for privacy, writes timestamp and each key in <code>results</code> into header and the values in row. Uses <code>HandleLocalError</code> on failure. <br><strong>Complexity:</strong> O(#keys). <br><strong>Side-effects:</strong> Writes to workbook in hidden sheet. <br><strong>Tests:</strong> Called by self-tests; CI asserts presence and particular columns (e.g., <code>readback_match</code>). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetWorksheetFromRange(target)</strong> — <em>safe wrapper to obtain worksheet reference</em><br><strong>Purpose:</strong> Return worksheet containing <code>target</code> or default to first worksheet if <code>target</code> is <code>Nothing</code>. <br><strong>Signature:</strong> <code>Private Function GetWorksheetFromRange(ByVal target As Range) As Worksheet</code><br><strong>Behavior:</strong> If <code>target</code> is <code>Nothing</code> returns <code>ThisWorkbook.Worksheets(1)</code>; else returns <code>target.Worksheet</code>. Error handling falls back to <code>Worksheets(1)</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetTopLeftCellOfRange(target)</strong> — <em>safe wrapper returns top-left cell or (1,1)</em><br><strong>Purpose:</strong> Return the (1,1) cell of the range or workbook default if <code>target Is Nothing</code>. <br><strong>Signature:</strong> <code>Private Function GetTopLeftCellOfRange(ByVal target As Range) As Range</code><br><strong>Behavior:</strong> Returns <code>target.Cells(1,1)</code> or fallback to <code>Worksheets(1).Cells(1,1)</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetHeaderSignature(target)</strong> — <em>serialize first row values into pipe-delimited signature</em><br><strong>Purpose:</strong> Create a deterministic header signature by concatenating <code>Trim(CStr(cell.value))</code> separated by <code>|</code> for first row of <code>target</code>. Used by <code>GetStableTableID</code> to detect header changes.<br><strong>Signature:</strong> <code>Private Function GetHeaderSignature(ByVal target As Range) As String</code><br><strong>Behavior:</strong> Iterates <code>target.rows(1).Cells</code> concatenating <code>|</code> + trimmed cell text. Returns empty on error or if <code>target</code> <code>Nothing</code>. <br><strong>Complexity:</strong> O(cols). <br><strong>Tests:</strong> Mutating header cells should change signature accordingly. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EnsureMetadataSheetExists()</strong> — <em>create metadata sheet <code>_IFRS_Metadata</code> idempotently and initialize columns</em><br><strong>Purpose:</strong> Ensure metadata storage sheet exists and contains header labels, sets column widths, hides sheet, and calls <code>EnsureMetadataSchema</code>. Primary entry point for metadata functions.<br><strong>Signature:</strong> <code>Private Function EnsureMetadataSheetExists() As Worksheet</code><br><strong>Behavior:</strong> Attempts to get sheet by name; if not found calls <code>SafeCreateSheetUnique</code>, sets <code>Visible = xlSheetVeryHidden</code>, writes headers <code>METADATA_HDR_KEY</code> / <code>METADATA_HDR_JSON</code>, sets column widths; then calls <code>EnsureMetadataSchema</code>. Returns worksheet or <code>Nothing</code> on failure. <br><strong>Complexity:</strong> O(1) plus the cost of <code>EnsureMetadataSchema</code>. <br><strong>Side-effects:</strong> May create hidden sheet. <br><strong>Tests:</strong> Called repeatedly is idempotent, header remains. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SafeCreateSheetUnique(desiredName)</strong> — <em>create new sheet safely and attempt to set name, fallback to timestamped name on conflict</em><br><strong>Purpose:</strong> Add a worksheet and attempt to rename to <code>desiredName</code>. If rename fails (name collision/restrictions) append timestamp suffix. Returns created <code>Worksheet</code> or <code>Nothing</code> on failure. <br><strong>Signature:</strong> <code>Private Function SafeCreateSheetUnique(ByVal desiredName As String) As Worksheet</code><br><strong>Behavior:</strong> Adds sheet after last worksheet; tries <code>sh.Name = desiredName</code> inside <code>On Error Resume Next</code>; if error appends <code>_yyyymmddHHNNSS</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Concurrent creation with same desiredName yields unique suffixed names. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NullSafeValue(v)</strong> — <em>helper to stringify values for JSON serialization</em><br><strong>Purpose:</strong> Convert variant or nested <code>Dictionary</code> to string: if dictionary returns JSON via <code>DictionaryToJson_MaxDepth</code>, else convert to <code>&quot;&quot;</code> for Null/Empty and <code>CStr</code> otherwise.<br><strong>Signature:</strong> <code>Private Function NullSafeValue(ByVal v As Variant) As String</code><br><strong>Behavior:</strong> Handles <code>Dictionary</code> recursively; returns safe string for JSON serializer. <br><strong>Complexity:</strong> O(size) for nested dictionary handling (but bounded by serializer depth). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>SplitOnFirstColon(s)</strong> — <em>utility to split string on first non-quoted colon (aware of escape and quotes)</em><br><strong>Purpose:</strong> Return a 2-element string array <code>[left, right]</code> where split occurs at first colon not inside double quotes and not escaped. Used for parsing simple key:value like tokens inside some strings.<br><strong>Signature:</strong> <code>Private Function SplitOnFirstColon(ByVal s As String) As String()</code><br><strong>Behavior:</strong> Iterates through characters tracking <code>inQ</code> and <code>esc</code> flags; when encountering unquoted <code>:</code> returns left and right substrings; else returns <code>[s, &quot;&quot;]</code>. <br><strong>Complexity:</strong> O(n). <br><strong>Tests:</strong> Strings with <code>&quot;:&quot;</code> inside quotes should not split; escaped quotes handled. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>JsonEscape(s)</strong> — <em>escape backslash, double-quotes, and newlines for JSON string values; delegates if available</em><br><strong>Purpose:</strong> Provide safe JSON fragment escaping for strings. Prefer <code>modUtilities.JsonEscape</code> if present. Replace <code>\</code>-><code>\\</code>, <code>&quot;</code>-><code>\&quot;</code>, CRLF/CR/LF -> <code>\n</code> otherwise. <br><strong>Signature:</strong> <code>Private Function JsonEscape(ByVal s As String) As String</code><br><strong>Behavior:</strong> Delegation path via <code>TryRunExternal(&quot;modUtilities.JsonEscape&quot;, s)</code> if available. Fallback to replacements. On error returns <code>&quot;&quot;</code> and logs. <br><strong>Complexity:</strong> O(n). <br><strong>Tests:</strong> Strings with quotes and backslashes targeted. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>PII_Detect(s)</strong> — <em>heuristic to flag Personally Identifiable Information in strings</em><br><strong>Purpose:</strong> Quick heuristic to detect potential PII (emails, long digit sequences, token words like <code>ssn</code>, <code>password</code>, <code>secret</code>) for redaction decision points in audit or exposure paths.<br><strong>Signature:</strong> <code>Private Function PII_Detect(ByVal s As String) As Boolean</code><br><strong>Behavior:</strong> Lowercases string, checks for <code>@</code> and <code>.</code> (simple email), digit-only sequences >= 8, keywords <code>ssn</code>, <code>password</code>, <code>secret</code>. Returns True if any heuristic matched. On error returns False. <br><strong>Complexity:</strong> O(n). <br><strong>Notes:</strong> Heuristic only; false positives/negatives possible. Use for redaction heuristics only. <br><strong>Tests:</strong> Typical email and number inputs flagged. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NzString(v)</strong> — <em>Nvl helper for strings</em><br><strong>Purpose:</strong> Return empty string for <code>Null</code>/<code>Empty</code> else <code>CStr(v)</code>. <br><strong>Signature:</strong> <code>Private Function NzString(ByVal v As Variant) As String</code><br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>OnlyDigits(s)</strong> — <em>extract digits only</em><br><strong>Purpose:</strong> Return string containing only digit characters from input; used for PII detection/truncation. <br><strong>Signature:</strong> <code>Private Function OnlyDigits(ByVal s As String) As String</code><br><strong>Behavior:</strong> Iterates characters and keeps <code>0-9</code>. <br><strong>Complexity:</strong> O(n). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NzLong(v, Optional def = 0)</strong> — <em>safe numeric coercion</em><br><strong>Purpose:</strong> Convert numeric-like variant to <code>Long</code> or return default. <br><strong>Signature:</strong> <code>Private Function NzLong(ByVal v As Variant, Optional ByVal def As Long = 0) As Long</code><br><strong>Behavior:</strong> If <code>IsNumeric(v)</code> returns <code>CLng(v)</code> else <code>def</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>GetWorkbookFingerprint(wb)</strong> — <em>stable workbook fingerprint from saved path or VBProject name fallback</em><br><strong>Purpose:</strong> Provide a deterministic workbook identifier used in stable ID generation: <code>path + &quot;|&quot; + file.DateLastModified</code> when file exists; else uses <code>wb.VBProject.name</code> or workbook name prefixed with <code>unsaved|</code> fallback. <br><strong>Signature:</strong> <code>Private Function GetWorkbookFingerprint(ByVal wb As Workbook) As String</code><br><strong>Behavior:</strong> If <code>wb.FullName</code> exists and file exists in file system uses <code>FileSystemObject</code> to get <code>DateLastModified</code> and returns <code>path|timestamp</code>. If not saved, attempt <code>wb.VBProject.name</code> (requires access to VBProject trust) else fallback to <code>wb.name</code> and prefix <code>unsaved|</code>. On failure returns <code>&quot;unknown&quot;</code> and logs. <br><strong>Complexity:</strong> O(1) plus file I/O. <br><strong>Security/Notes:</strong> Accessing <code>VBProject</code> may be blocked by trust settings; this is handled with resume-on-error fallback. <br><strong>Tests:</strong> Saved workbook returns path+timestamp; unsaved returns <code>unsaved|&lt;name&gt;</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>RedactForAudit(s)</strong> — <em>redaction heuristic to reduce PII leakage in audit subjects</em><br><strong>Purpose:</strong> Remove or obfuscate emails and long digit sequences; truncate long strings to <code>AUDIT_REDACT_TRUNCATE</code> and use <code>...[truncated]</code> suffix. Used before writing local audit rows to reduce PII leakage in logs persisted in workbook.<br><strong>Signature:</strong> <code>Private Function RedactForAudit(ByVal s As String) As String</code><br><strong>Behavior:</strong> If <code>@</code> present attempts to identify contiguous email token and replace with <code>X...[redacted]</code> pattern preserving first char; for digit-only sequences >= 8 replaces with <code>first4...last2</code>; truncates strings longer than <code>AUDIT_REDACT_TRUNCATE</code>. Returns empty string if input empty. On error returns left-truncated input. <br><strong>Complexity:</strong> O(n). <br><strong>Tests:</strong> Input <code>&quot;alice@example.com&quot;</code> -> <code>&quot;a...@[redacted]&quot;</code>, long digit strings truncated. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>TryRunExternal(proc, ParamArray args())</strong> — <em>centralized <code>Application.Run</code> caller with ParamArray up to 15 args; returns <code>Empty</code> on failure</em><br><strong>Purpose:</strong> Robustly call external procedures (delegated module functions) via <code>Application.Run</code> in a safe manner with a controlled number of positional arguments (cases 0..15). Avoids raising errors into calling code by returning <code>Empty</code> on error. <br><strong>Signature:</strong> <code>Private Function TryRunExternal(ByVal proc As String, ParamArray args() As Variant) As Variant</code><br><strong>Behavior:</strong> Inspects <code>UBound(args)</code> to determine <code>argc</code>; selects matching <code>Application.Run</code> call signature for 0..15 parameters. If <code>argc</code> outside supported range returns <code>Empty</code>. Wraps all calls in error handlers; on any error clears error and returns <code>Empty</code>. <br><strong>Complexity:</strong> O(1) per call. <br><strong>Side-effects:</strong> Executes external code which may have side effects; caller must validate returned value not <code>Empty</code>. <br><strong>Tests:</strong> Mock <code>modUtilities</code> functions and verify delegation returns expected values and <code>Empty</code> if not found. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>RunSelfTestsForCI()</strong> — <em>CI-oriented runner that performs pre-checks and raises on failure</em><br><strong>Purpose:</strong> Run CI-friendly self-tests and prechecks: delegate availability check for <code>modUtilities.CRC32_String</code>, run <code>SelfTest_ModStatementsHelpers</code>, ensure metadata sheet exists, dry-run migration, run <code>AdditionalSelfTests_ModStatementsHelpers</code>, attempt <code>UtilitiesSelfTest</code> (best-effort), verify <code>TEST_RESULTS_SHEET</code> contains <code>readback_match=pass</code>; write <code>_IFRS_CI</code> visible sheet on failure with a diagnostic row for CI logs.<br><strong>Signature:</strong> <code>Public Sub RunSelfTestsForCI()</code><br><strong>Behavior:</strong> Performs the steps above; on fatal failures raises errors with <code>Err.Raise</code> codes to surface to CI runner. On error writes a diagnostic row to <code>_IFRS_CI</code> visible sheet. Uses <code>Audit_LogStructured</code> for precheck missing delegates. <br><strong>Complexity:</strong> Entire harness cost depends on tests (IO heavy). <br><strong>Side-effects:</strong> Writes to test and CI sheets and audits. <br><strong>Tests:</strong> Runs under CI; ensures deterministic checks. <br><strong>Notes:</strong> Designed to fail loudly for CI integration. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>AdditionalSelfTests_ModStatementsHelpers()</strong> — <em>supplemental unit tests (TryWithRetry_WriteToSheet, SafeFindInColumn, normalize helpers)</em><br><strong>Purpose:</strong> Complement <code>SelfTest_ModStatementsHelpers</code> with extra scenarios meant for CI: ensure metadata sheet exists; test <code>SafeFindInColumn</code> (by writing a temporary row and finding it); test <code>SetTableMetadata</code> -> <code>GetTableMetadata</code> round-trip; verify size rejection; <code>NormalizeLines</code> and <code>NormalizeRefsToArray</code> helpers. Writes results to <code>TEST_RESULTS_SHEET</code> and audits completion.<br><strong>Signature:</strong> <code>Public Sub AdditionalSelfTests_ModStatementsHelpers()</code><br><strong>Behavior:</strong> See purpose. <br><strong>Tests:</strong> The function itself performs tests; CI should assert expected pass entries in test results sheet. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NormalizeLines(s)</strong> — <em>normalize line endings and trim each line</em><br><strong>Purpose:</strong> Convert CRLF/CR to LF, split into lines, trim each line, then re-join with LF. Used to produce canonical line-normalized strings for comparison/storage.<br><strong>Signature:</strong> <code>Private Function NormalizeLines(ByVal s As String) As String</code><br><strong>Behavior:</strong> Uses <code>Replace</code> to convert CRLF & CR to LF, <code>Split</code> on LF, <code>Trim</code> each part, then <code>Join</code> with LF. Returns <code>NzString(s)</code> on error. <br><strong>Complexity:</strong> O(n). <br><strong>Tests:</strong> <code>&quot;a\r\n b\r\n&quot;</code> -> <code>&quot;a\nb&quot;</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NormalizeRefsToArray(refs)</strong> — <em>split references string into array tokens using multiple separators</em><br><strong>Purpose:</strong> Convert <code>refs</code> string with separators <code>, ;</code> or tabs into an array of trimmed non-empty tokens. Returns empty array for empty input. <br><strong>Signature:</strong> <code>Private Function NormalizeRefsToArray(ByVal refs As String) As Variant</code> (returns Variant array) <br><strong>Behavior:</strong> Replaces <code>;</code> and tabs with commas, splits by comma, trims tokens and compacts into a new array of non-empty tokens. <br><strong>Complexity:</strong> O(n). <br><strong>Tests:</strong> <code>&quot;ref1, ref2;ref3  , ref4&quot;</code> -> 4 entries. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>DictionarySizeEstimate(dict, maxNodes)</strong> — <em>heuristic BFS count of nested dictionary nodes up to cap</em><br><strong>Purpose:</strong> Estimate traversal size for nested dictionaries to decide whether to attempt deep serialization or to abort/truncate. Returns node count or >maxNodes to indicate overflow. <br><strong>Signature:</strong> <code>Private Function DictionarySizeEstimate(ByVal dict As Object, ByVal maxNodes As Long) As Long</code><br><strong>Behavior:</strong> Uses <code>Collection</code> as queue performing BFS adding nested dictionaries encountered; increments <code>cnt</code> until <code>maxNodes</code> reached then returns. Returns <code>maxNodes+1</code> on error. <br><strong>Complexity:</strong> O(number of dictionary nodes up to maxNodes). <br><strong>Tests:</strong> Nested dictionaries produce expected counts and early exit at cap. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>ChunkMetadataAndStore(sh, stableKey, metadataJson, corr)</strong> — <em>optional chunking store for very large metadata payloads</em><br><strong>Purpose:</strong> When large metadata payloads exceed <code>METADATA_MAX_LENGTH</code> and chunking enabled (and permitted by <code>METADATA_CHUNKING_ENABLED</code>), split the JSON into <code>METADATA_CHUNK_SIZE</code> slices and store each slice as separate rows using key <code>stableKey &amp; &quot;_part_###&quot;</code>. Also store manifest row <code>stableKey &amp; &quot;_manifest&quot;</code> containing <code>{schemaVersion, chunked:true, parts:N}</code>. Idempotent cleanup clears previous parts for the same base key first.<br><strong>Signature:</strong> <code>Private Function ChunkMetadataAndStore(ByVal sh As Worksheet, ByVal stableKey As String, ByVal metadataJson As String, ByVal corr As String) As Boolean</code><br><strong>Behavior:</strong> If <code>Len(metadataJson) &lt;= METADATA_MAX_LENGTH</code> returns quickly (no-op). If chunking not enabled returns False. Otherwise computes <code>parts = Ceil(totalLen / METADATA_CHUNK_SIZE)</code>. Deletes previous <code>baseKey</code> rows then writes each chunk row with <code>SanitizeForCell</code> on column 2 and writes manifest row. Emits <code>Audit_LogStructured</code> "chunked". Returns True on success. <br><strong>Complexity:</strong> O(parts) writes; I/O heavy. <br><strong>Side-effects:</strong> Writes multiple rows; potential leftover parts if failure mid-run—function attempts idempotent delete prior to writing but not transactional. <br><strong>Failure modes:</strong> Partial writes leave inconsistent state; no atomic rollback implemented. <br><strong>Tests:</strong> Enable chunking and ensure large JSON is split and manifest present; simulate repeated runs ensure idempotency. <br><strong>Notes:</strong> Disabled by default; exercising requires governance. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>CheckRevisionPlanCompliance()</strong> — <em>return deterministic JSON summary of revision-plan compliance for CI</em><br><strong>Purpose:</strong> Provide a stable, machine-readable summary of module compliance against the listed revision plan items (consolidation, schema, atomic writes, CRC policy, tests, audit, etc.). Intended for an external verification orchestrator to call and assert deterministic compliance keys. <br><strong>Signature:</strong> <code>Public Function CheckRevisionPlanCompliance() As String</code><br><strong>Behavior:</strong> Builds <code>Scripting.Dictionary</code> <code>status</code> with multiple feature keys (0..20) and a <code>delegation_health</code> entry from <code>DelegationHealthCheck()</code>. Serializes via <code>DictionaryToJson_MaxDepth(status,0,4)</code>. Uses <code>TryRunExternal</code> to check for delegated functions. <br><strong>Complexity:</strong> O(1) plus delegation health checks. <br><strong>Tests:</strong> Run multiple times and call <code>RunRevisionVerification10</code> to verify deterministic checksums. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>DelegationHealthCheck()</strong> — <em>small JSON string with presence/absence of delegated utility functions</em><br><strong>Purpose:</strong> Probe presence of delegated functions (<code>modUtilities.CRC32_String</code>, <code>modUtilities.StrToBytes</code>, <code>modUtilities.JsonEscape</code>, <code>modAudit.LogAudit</code>, <code>modError.HandleError</code>) via <code>TryRunExternal</code> and return their presence as JSON. <br><strong>Signature:</strong> <code>Private Function DelegationHealthCheck() As String</code><br><strong>Behavior:</strong> Returns <code>DictionaryToJson_MaxDepth</code> JSON mapping each probe to <code>&quot;present&quot;</code> or <code>&quot;missing&quot;</code>. <br><strong>Complexity:</strong> O(1) per probe. <br><strong>Tests:</strong> Alter availability of <code>modUtilities</code> to confirm values. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>RunRevisionVerification10()</strong> — <em>run CheckRevisionPlanCompliance 10x and return consistent checksum map</em><br><strong>Purpose:</strong> Execute <code>CheckRevisionPlanCompliance</code> 10 times, compute CRC32 checksums per run and return JSON summarizing <code>consistent</code> boolean and per-run checksums. Useful to detect non-determinism across runs. Emits an audit event <code>RunRevisionVerification10</code> with final checksum.<br><strong>Signature:</strong> <code>Public Function RunRevisionVerification10() As String</code><br><strong>Behavior:</strong> Calls <code>CheckRevisionPlanCompliance</code> in loop 1..10, collects hex checksums (via <code>CRC32_String</code>), determines if identical across runs, writes audit, returns JSON with correlation id and checksums. <br><strong>Complexity:</strong> 10x <code>CheckRevisionPlanCompliance</code>. <br><strong>Tests:</strong> Deterministic environment should report <code>consistent = &quot;true&quot;</code>. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>EstimateJsonSizeFromDict(dict, Optional maxNodes = 2000)</strong> — <em>heuristic size estimator for dictionary serialization</em><br><strong>Purpose:</strong> Heuristically estimate serialized JSON size without performing full JSON serialization; used for policy decisions (chunking, aborting) to avoid heavy serialization work for huge dictionaries.<br><strong>Signature:</strong> <code>Private Function EstimateJsonSizeFromDict(ByVal dict As Object, Optional ByVal maxNodes As Long = 2000) As Long</code><br><strong>Behavior:</strong> BFS traversal of nested dictionaries estimating overhead per key/value using <code>Len(key)</code> and <code>Len(NullSafeValue(v))</code> approximations. Returns estimated byte count; if error returns <code>JSON_OUTPUT_MAX_LENGTH + 1</code>. <br><strong>Complexity:</strong> O(nodes up to maxNodes). <br><strong>Tests:</strong> Edge cases with many keys produce estimates above threshold; robust to nested dictionaries. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>NormalizeLines / NormalizeRefsToArray / DictionarySizeEstimate (helpers)</strong> — <em>collection of small normalizers described above</em><br><strong>Purpose:</strong> Utilities used by tests and UI plumbing (normalize newlines, parse comma/semicolon/tab separated refs, estimate nested dictionary size). See each individual entry above for details. </td></tr><tr><td data-label="Technical breakdown (modStatementsHelpers)"> <strong>Other notes & cross-cutting concerns</strong><br><strong>Delegation-first design:</strong> Most heavy or environment-specific tasks (CRC, StrToBytes, JsonEscape, correlation id generation) attempt to delegate to <code>modUtilities</code> or <code>modAudit</code> and fall back to local implementations. Delegation improves cross-module consistency but must be present in production to ensure canonical behaviours. <br><strong>Atomic-ish writes:</strong> <code>TryWithRetry_WriteToSheet</code> implements a best-effort atomic pattern (temp column → sanitized column) but is not transactional across failures; chunked writes are not atomic across multiple rows. Consider adding write-versioning or write-lock row to make operations safer in concurrent Add-in scenarios. <br><strong>Security & PII:</strong> <code>RedactForAudit</code> applied before local audit storage; <code>SanitizeForCell</code> used everywhere cells are written to mitigate formula-injection; <code>ValidateMetadataJson</code> restricts schema version before accepting writes. However, PII detection is heuristic — do not rely on it for compliance-grade redaction. <br><strong>Performance limits & tunables:</strong> <code>METADATA_MAX_LENGTH</code>, <code>JSON_OUTPUT_MAX_LENGTH</code>, <code>METADATA_CHUNK_SIZE</code>, <code>METADATA_CHUNKING_ENABLED</code> are tunables; chunking disabled by default. <code>DictionaryToJson_MaxDepth</code> and <code>DICT_TO_JSON_MAX_DEPTH</code> prevent runaway recursion. <br><strong>CI & deterministic checks:</strong> <code>SelfTest_ModStatementsHelpers</code>, <code>AdditionalSelfTests_ModStatementsHelpers</code>, <code>RunSelfTestsForCI</code>, <code>CheckRevisionPlanCompliance</code>, and <code>RunRevisionVerification10</code> provide deterministic checks tailored for CI gating. Keep <code>DictionaryToJson_MaxDepth</code> deterministic ordering and CRC delegation consistent across environments for reproducible checksums. <br><strong>Recommended improvements (high-priority):</strong> <br>- Make chunked writes atomic by writing a manifest first with a “in-progress” flag then parts, then mark complete—so readers can detect partial state. <br>- When using local fallback CRC, ensure fallback algorithm is stable across platforms and tested to match delegation results where possible. <br>- Consider adding an optional <code>maxParallelWrites</code> guard or single-writer lock to avoid concurrent writes from different add-in instances. <br>- Expand <code>ValidateMetadataJson</code> to run a minimal JSON parse if available (to robustly validate shape rather than string token checks). <br><strong>Recommended tests (concise):</strong> <br>1. Round-trip <code>SetTableMetadata</code>/<code>GetTableMetadata</code> with normal-sized JSON. <br>2. Chunking: enable chunking and store <code>METADATA_MAX_LENGTH+N</code> payload → read parts & manifest. <br>3. Protected-sheet write: simulate protected metadata sheet to ensure retries and audit. <br>4. Delegate absent/present: run <code>CRC32_String</code> with <code>modUtilities</code> present & absent and verify audit reported once on fallback. <br>5. Self-test deterministic run and CI gate: <code>RunRevisionVerification10</code> returns <code>consistent=true</code>. <br>6. TOC named-range idempotency and recreation on changed location. <br>7. XSS/Formula injection: test <code>SanitizeForCell</code> and <code>RenderSafeHtml</code> with leading <code>=</code> and <code>&quot;&lt;script&gt;&quot;</code>. <br>8. Stress test <code>DictionaryToJson_MaxDepth</code> with very large nested dictionaries to ensure truncation and no crashes. </td></tr></tbody></table></div><div class="row-count">Rows: 66</div></div><div class="table-caption" id="Table5" data-table="Docu_0161_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modUtilities)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modUtilities)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modUtilities)"> <strong>EnsureCaches()</strong> — <em>idempotent module cache initialization</em><br><strong>Purpose:</strong> Initialise in-memory caches and default runtime toggles used across the utilities module (named-range cache, COM negative-cache, feature toggles).<br><strong>Signature:</strong> <code>EnsureCaches()</code><br><strong>Behavior:</strong> Creates <code>Scripting.Dictionary</code> objects for <code>g_namedRangeCache</code> and <code>g_comCache</code> if missing, sets sensible defaults (<code>g_comNegativeCacheTTL = 600</code>, <code>g_namedRangeCacheMaxSize</code>), seeds <code>Randomize</code>, marks <code>g_cacheInitialized = True</code>, and clears ADODB/certutil tri-state markers. Silent on failure (uses <code>On Error Resume Next</code>).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Allocates module-level objects and sets global flags. Safe to call repeatedly (idempotent).<br><strong>Invariants:</strong> After successful call, caches exist or are known unavailable; <code>g_cacheInitialized</code> true. Callers may rely on caches being present. <br><strong>Failure modes:</strong> Creation of <code>Scripting.Dictionary</code> can fail under restricted hosts; method swallows errors but leaves caches <code>Nothing</code>. Consumers must handle cache absence. <br><strong>Security/XSS:</strong> Not applicable. <br><strong>Recommended tests:</strong> Call from a clean process, assert <code>g_cacheInitialized = True</code> and dictionaries exist or remain <code>Nothing</code> under restricted hosts. <br><strong>Notes for maintainers:</strong> Keep defaults centralised here; changing negative cache TTL or default size should be deliberate and versioned. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ResetCaches()</strong> — <em>clear & re-init caches</em><br><strong>Purpose:</strong> Remove all entries from caches and force reinitialization. Useful during tests or after workbook changes.<br><strong>Signature:</strong> <code>ResetCaches()</code><br><strong>Behavior:</strong> Clears <code>g_namedRangeCache</code> and <code>g_comCache</code> if present, resets ADODB/certutil tri-state, flips <code>g_cacheInitialized = False</code>, then calls <code>EnsureCaches()</code> to reinitialize. Uses defensive <code>On Error Resume Next</code> to remain robust in restricted hosts.<br><strong>Complexity:</strong> O(N) in cache size to remove items. <br><strong>Side-effects:</strong> Empties cached data; may cause slightly higher latency on next operations that rebuild caches. <br><strong>Invariants:</strong> After return, caches either empty and reinitialized or left <code>Nothing</code> in restricted environments. <br><strong>Failure modes:</strong> If <code>EnsureCaches</code> fails, caches may remain uninitialized; callers should tolerate that. <br><strong>Tests:</strong> Populate caches, call ResetCaches, assert caches empty and <code>g_cacheInitialized = True</code>. <br><strong>Notes:</strong> Designed for idempotent test harness usage. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SetComNegativeCacheTTL(seconds As Long)</strong> — <em>tune COM negative cache TTL</em><br><strong>Purpose:</strong> Allow runtime tuning of negative caching for CreateObject failures to reduce repeated expensive attempts to create unavailable COM ProgIDs.<br><strong>Signature:</strong> <code>SetComNegativeCacheTTL(ByVal seconds As Long)</code><br><strong>Behavior:</strong> Validates <code>seconds &gt; 0</code> then updates <code>g_comNegativeCacheTTL</code>. Calls <code>EnsureCaches</code> first. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Alters retry behavior for COM object creation (affects CreateObjectSafe).<br><strong>Tests:</strong> Set small TTL, simulate failing CreateObject, confirm CreateObjectSafe respects TTL. <br><strong>Notes:</strong> Changes affect system resiliency in environments with transient COM availability. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeLogAudit(src, message)</strong> — <em>delegated audit logging with redaction</em><br><strong>Purpose:</strong> Centralised, redaction-aware wrapper that delegates audit messages to <code>modAudit.LogAudit</code> when available; does not implement local fallbacks. <br><strong>Signature:</strong> <code>SafeLogAudit(ByVal src As String, ByVal message As String)</code><br><strong>Behavior:</strong> Redacts likely secrets (<code>RedactSecrets</code>) then <code>Application.Run &quot;modAudit.LogAudit&quot;, src, msg</code>. If <code>Application</code> unavailable, writes to <code>Debug.Print</code>. Swallows errors (no fallback audit file).<br><strong>Complexity:</strong> O(len(message)).<br><strong>Side-effects:</strong> Calls external <code>modAudit</code> if present; may produce console output in non-Excel hosts. <br><strong>Invariants:</strong> Audit entries are always redacted before delegation. <br><strong>Failure modes:</strong> If <code>modAudit</code> missing or fails, function intentionally does not try complex local fallbacks (design decision). <br><strong>Security:</strong> Ensures sensitive tokens in messages are redacted. <br><strong>Tests:</strong> Supply message containing <code>password=</code> and assert output contains <code>[REDACTED]</code>; verify no raises when <code>modAudit</code> absent. <br><strong>Notes:</strong> Keep this thin—avoid adding local persistence here to maintain single source of truth for audits. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeLogStructuredAudit(src, jsonPayload)</strong> — <em>best-effort structured audit wrapper</em><br><strong>Purpose:</strong> Attempt to send structured JSON-like payloads to <code>modAudit.LogAudit</code> while still redacting secrets; falls back to <code>SafeLogAudit</code> if modAudit rejects structured call. <br><strong>Signature:</strong> <code>SafeLogStructuredAudit(ByVal src As String, ByVal jsonPayload As String)</code><br><strong>Behavior:</strong> Redacts payload, runs <code>modAudit.LogAudit</code> and on error calls <code>SafeLogAudit</code>. Intentionally tolerant to avoid raising from telemetry attempts.<br><strong>Complexity:</strong> O(len(payload)).<br><strong>Side-effects:</strong> Audit call delegation. <br><strong>Tests:</strong> Validate redaction + fallback when modAudit errors. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeHandleError(procName, errNum, errDesc)</strong> — <em>tolerant centralized error report</em><br><strong>Purpose:</strong> Central funnel for error reporting that calls <code>modError.HandleError</code> if present, and otherwise falls back to logging and <code>Debug.Print</code>. Always redacts secrets and never raises.<br><strong>Signature:</strong> <code>SafeHandleError(ByVal procName As String, ByVal errNum As Long, ByVal errDesc As String)</code><br><strong>Behavior:</strong> Builds payload <code>(&lt;errNum&gt;) &lt;redacted desc&gt;</code>, tries <code>Application.Run &quot;modError.HandleError&quot;, procName, errNum, payload</code>. If that fails, calls <code>SafeLogAudit</code> as fallback and <code>Debug.Print</code>. Silent and idempotent on exceptions.<br><strong>Complexity:</strong> O(len(errDesc)).<br><strong>Side-effects:</strong> Delegates to modError and audit; may produce console output. <br><strong>Failure modes:</strong> Swallows its own errors; guaranteed not to raise. <br><strong>Tests:</strong> Simulate <code>modError</code> missing; ensure SafeLogAudit invoked and no exceptions escape. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ResolveWorkbook(Optional targetWb)</strong> — <em>deterministic workbook resolver</em><br><strong>Purpose:</strong> Find the workbook to operate on using the priority: explicit object -> <code>Application.ActiveWorkbook</code> -> <code>ThisWorkbook</code>.<br><strong>Signature:</strong> <code>ResolveWorkbook(Optional ByVal targetWb As Variant) As Workbook</code><br><strong>Behavior:</strong> If <code>targetWb</code> provided and is <code>Workbook</code> returns it; else returns <code>Application.ActiveWorkbook</code> if present, otherwise <code>ThisWorkbook</code>. Defensive <code>On Error Resume Next</code> to handle unusual hosts.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Returns a <code>Workbook</code> reference or <code>Nothing</code>. <br><strong>Tests:</strong> Provide explicit workbook, remove ActiveWorkbook, ensure fallback to ThisWorkbook. <br><strong>Notes:</strong> Many helpers call this; keep stable. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>WorkbookFingerprint(wb As Workbook)</strong> — <em>stable fingerprint for cache keys</em><br><strong>Purpose:</strong> Produce a string key combining workbook FullName and file modification timestamp (when file exists) to bind cached named-range entries to specific file state.<br><strong>Signature:</strong> <code>WorkbookFingerprint(ByVal wb As Workbook) As String</code><br><strong>Behavior:</strong> If <code>wb.FullName</code> empty returns <code>wb.Name</code>. If file on disk, appends <code>FileDateTime(full)</code>. Returns <code>&quot;&quot;</code> for <code>Nothing</code> input. <br><strong>Complexity:</strong> O(1) + cheap file stat. <br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Same workbook on disk yields same fingerprint until file modification timestamp changes. <br><strong>Tests:</strong> Create workbook, save-as, call fingerprint before/after save to show timestamp changes. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SheetExists(name, Optional targetWb)</strong> — <em>existence check</em><br><strong>Purpose:</strong> Return whether a worksheet with given name exists in target workbook. <br><strong>Signature:</strong> <code>SheetExists(ByVal name As String, Optional ByVal targetWb As Variant) As Boolean</code><br><strong>Behavior:</strong> Resolves workbook, attempts <code>wb.Worksheets(name)</code> under <code>On Error Resume Next</code>, returns boolean; logs errors via SafeHandleError on unexpected failure. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> If workbook unresolved returns False. <br><strong>Tests:</strong> Create/delete sheet and confirm detection. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeGetWorksheet(targetWb, Optional sheetName)</strong> — <em>safe worksheet fetch</em><br><strong>Purpose:</strong> Return <code>Worksheet</code> object if present; otherwise <code>Nothing</code>. <br><strong>Signature:</strong> <code>SafeGetWorksheet(ByVal targetWb As Variant, Optional ByVal sheetName As String = &quot;&quot;) As Worksheet</code><br><strong>Behavior:</strong> Resolves workbook, validates non-empty <code>sheetName</code>, returns <code>wb.Worksheets(sheetName)</code> or <code>Nothing</code>. Errors handled and reported via SafeHandleError. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Known workbook & sheet vs missing sheet. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeCreateSheet(sheetName, Optional targetWb, Optional beforeSheet, Optional veryHidden=True, Optional backupIfExists=True)</strong> — <em>create (or backup) worksheet safely</em><br><strong>Purpose:</strong> Create a worksheet with name collision handling, optional backup of existing sheet, and optional visibility control; returns created or existing Worksheet. <br><strong>Signature:</strong> <code>SafeCreateSheet(ByVal sheetName As String, Optional ByVal targetWb As Variant, Optional ByVal beforeSheet As Variant, Optional ByVal veryHidden As Boolean = True, Optional ByVal backupIfExists As Boolean = True) As Worksheet</code><br><strong>Behavior:</strong> Resolves workbook, if sheet exists optionally backs it up (BackupSheet) and returns it. Otherwise adds a new worksheet (before/after handling), attempts to set the name and falls back to a safe unique name on collision (base + <code>_n</code> loop capped at 1000). If <code>veryHidden</code> sets <code>xlSheetVeryHidden</code>. Returns the worksheet. <br><strong>Complexity:</strong> O(convergence) for name generation; typical O(1). <br><strong>Side-effects:</strong> May add sheet, create backups, change visibility. <br><strong>Failure modes:</strong> If no workbook available logs <code>UTIL_ERROR_BASE + 1</code>. Name assignment issues handled. <br><strong>Tests:</strong> Create when name free, create when name collides frequently to force unique-name loop. <br><strong>Notes:</strong> Designed to be idempotent when <code>backupIfExists = True</code>. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeDeleteSheet(sheetName, Optional targetWb, Optional backupBeforeDelete=True)</strong> — <em>safe delete with optional backup</em><br><strong>Purpose:</strong> Delete a named worksheet after optional backup. <br><strong>Signature:</strong> <code>SafeDeleteSheet(ByVal sheetName As String, Optional ByVal targetWb As Variant, Optional ByVal backupBeforeDelete As Boolean = True)</code><br><strong>Behavior:</strong> Resolves workbook and sheet, optionally calls <code>BackupSheet</code>, disables <code>Application.DisplayAlerts</code> to delete safely, and restores alerts. Errors routed to SafeHandleError. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Deletes sheet from workbook; may create backup file. <br><strong>Tests:</strong> Delete existing sheet with backup and without. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>BackupSheet(wb, ws)</strong> — <em>export single-sheet backup workbook</em><br><strong>Purpose:</strong> Make an idempotent copy of a single worksheet into a new temporary workbook and save to temp folder for safety before destructive operations. <br><strong>Signature:</strong> <code>BackupSheet(wb As Workbook, ws As Worksheet)</code> (Private)<br><strong>Behavior:</strong> Determines temp path via <code>GetTempFolder</code> or fallbacks, creates a new workbook, copies <code>ws</code> before first sheet, saves tmp workbook as <code>.xlsx</code> with a timestamped <code>TEMP_PREFIX</code>, closes it. Logs via SafeLogAudit on success. <br><strong>Complexity:</strong> O(size of sheet) for save. <br><strong>Side-effects:</strong> Creates temp .xlsx file. <br><strong>Failure modes:</strong> No temp path yields logged error <code>UTIL_ERROR_BASE + 2</code>; failures to save are handled and logged. <br><strong>Tests:</strong> Backup large sheets and verify saved file and no exception. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeSheetName(s As String)</strong> — <em>sanitize sheet name</em><br><strong>Purpose:</strong> Produce a safe name valid for Excel sheets by removing invalid characters and truncating to 31 chars. <br><strong>Signature:</strong> <code>SafeSheetName(ByVal s As String) As String</code> (Private)<br><strong>Behavior:</strong> Replaces <code>/ \ : ? * [ ]</code> with <code>_</code> and takes <code>Left$(s,31)</code>. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Tests:</strong> Inputs with invalid characters become sanitized. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>NamedRangeExists(rangeName, Optional targetWb)</strong> — <em>check presence of named range</em><br><strong>Purpose:</strong> Return whether a workbook-level named range exists. <br><strong>Signature:</strong> <code>NamedRangeExists(ByVal rangeName As String, Optional ByVal targetWb As Variant) As Boolean</code><br><strong>Behavior:</strong> Resolves workbook and checks <code>wb.Names(rangeName)</code> under <code>On Error Resume Next</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Create and delete name. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GetNamedRangeValue(rangeName, Optional targetWb)</strong> — <em>cached read of named range value</em><br><strong>Purpose:</strong> Return the value of a named range (range value or <code>RefersTo</code> text) and cache result using workbook fingerprint for performance. <br><strong>Signature:</strong> <code>GetNamedRangeValue(ByVal rangeName As String, Optional ByVal targetWb As Variant) As Variant</code><br><strong>Behavior:</strong> Resolves workbook, looks up <code>g_namedRangeCache</code> using <code>rangeNameKey</code> (WorkbookFingerprint + <code>|</code> + name). If cached returns cached value and updates timestamp for LRU. Otherwise reads <code>wb.Names(rangeName)</code>, if <code>RefersToRange</code> exists returns <code>rng.Value</code> else returns <code>nm.RefersTo</code>. Then caches <code>Array(value, Timer)</code> and calls <code>EnforceNamedRangeCacheLimit</code>. <br><strong>Complexity:</strong> O(1) typical; cache lookup O(1). <br><strong>Side-effects:</strong> Updates <code>g_namedRangeCache</code>. <br><strong>Invariants:</strong> Cache entries shape <code>Array(value, tick)</code> for eviction policy. <br><strong>Failure modes:</strong> Name may refer to external or formula—function returns <code>RefersTo</code> string. On errors returns <code>Empty</code>. <br><strong>Tests:</strong> Read name pointing to a cell and a name that is formula/external. Validate caching by changing sheet and calling <code>InvalidateNamedRangeCacheForWorkbook</code>. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SetNamedRangeValue(rangeName, value, Optional targetWb)</strong> — <em>create or set named range value</em><br><strong>Purpose:</strong> Ensure a workbook-level name exists and set its value (create backing single-cell reference if needed). <br><strong>Signature:</strong> <code>SetNamedRangeValue(ByVal rangeName As String, ByVal value As Variant, Optional ByVal targetWb As Variant)</code><br><strong>Behavior:</strong> Resolves workbook, tries to find <code>wb.Names(rangeName)</code>. If missing, writes <code>value</code> into <code>Worksheets(1).Range(&quot;A1&quot;)</code> and creates the name pointing to that cell. If the name exists but does not refer to a range, attempts to set <code>RefersTo</code> to <code>= &#x27;Sheet&#x27;!$A$1</code> then set the cell value. Updates <code>g_namedRangeCache</code> with new value and timestamp. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> May write to sheet cell A1, create a workbook name. <br><strong>Failure modes:</strong> If workbook inaccessible or sheet missing, logs via SafeHandleError. <br><strong>Tests:</strong> Set new named value, set value when existing name is formula, verify value & cache. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>CreateOrUpdateNamedRange(rangeName, rng, Optional targetWb)</strong> — <em>strongly-typed named range creation</em><br><strong>Purpose:</strong> Create or update a workbook-scoped named range that points to the supplied Range object. <br><strong>Signature:</strong> <code>CreateOrUpdateNamedRange(ByVal rangeName As String, ByVal rng As Range, Optional ByVal targetWb As Variant)</code><br><strong>Behavior:</strong> Resolves workbook, builds <code>= &#x27;sheet&#x27;!A1:A2</code> style <code>RefersTo</code> string and attempts <code>wb.Names.Add</code>. If add fails, attempts to set <code>wb.Names(rangeName).RefersTo = ref</code>. Updates the cache with <code>rng.Value</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Creates or updates workbook name. <br><strong>Tests:</strong> Create on empty workbook, update existing name to new range. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>rangeNameKey(wb, rangeName)</strong> — <em>internal cache key builder</em><br><strong>Purpose:</strong> Build a stable cache key joining workbook fingerprint and name. <br><strong>Signature:</strong> <code>rangeNameKey(wb As Workbook, rangeName As String) As String</code> (Private)<br><strong>Behavior:</strong> If <code>wb</code> <code>Nothing</code> returns <code>|name</code> else <code>WorkbookFingerprint(wb) &amp; &quot;|&quot; &amp; rangeName</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ClearNamedRangeCache()</strong> — <em>evict entire named-range cache</em><br><strong>Purpose:</strong> Remove all cached named-range entries. <br><strong>Signature:</strong> <code>ClearNamedRangeCache()</code><br><strong>Behavior:</strong> Calls <code>g_namedRangeCache.RemoveAll</code> if dictionary exists. <br><strong>Complexity:</strong> O(N). <br><strong>Tests:</strong> Populate cache and clear. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>InvalidateNamedRangeCacheForWorkbook(Optional wb)</strong> — <em>targeted cache invalidation</em><br><strong>Purpose:</strong> Remove cached named-range entries that belong to a specific workbook fingerprint; used by save/close handlers to keep cache consistent. <br><strong>Signature:</strong> <code>InvalidateNamedRangeCacheForWorkbook(Optional ByVal wb As Variant)</code><br><strong>Behavior:</strong> Resolves workbook, iterates <code>g_namedRangeCache.keys</code>, collects keys starting with <code>WorkbookFingerprint(actual)</code> and removes them. Uses a <code>Collection</code> to avoid mutating during enumeration. <br><strong>Complexity:</strong> O(M) where M is number of cached entries. <br><strong>Side-effects:</strong> Removes matching cache entries. <br><strong>Tests:</strong> Cache values for two workbooks and invalidate one, verify remaining entries. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>EnforceNamedRangeCacheLimit()</strong> — <em>LRU eviction</em><br><strong>Purpose:</strong> Keep <code>g_namedRangeCache</code> below <code>g_namedRangeCacheMaxSize</code> by evicting least recently used entry. <br><strong>Signature:</strong> <code>EnforceNamedRangeCacheLimit()</code> (Private)<br><strong>Behavior:</strong> If cache count exceeds max, scans entries to find min timestamp from <code>Array(value,tick)</code> and removes that key. Single eviction per call. <br><strong>Complexity:</strong> O(N) scan; acceptable given modest default max (300). <br><strong>Tests:</strong> Fill cache beyond limit and confirm eviction order approximates LRU. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeWriteRange(ws, topRow, topCol, data)</strong> — <em>fast bulk write into sheet</em><br><strong>Purpose:</strong> Write 2D or 1D arrays and scalars to a worksheet in a robust manner handling 0-based arrays and single-dimension arrays gracefully. <br><strong>Signature:</strong> <code>SafeWriteRange(ws As Worksheet, topRow As Long, topCol As Long, data As Variant)</code><br><strong>Behavior:</strong> If <code>data</code> is array tries <code>LBound/UBound</code> for two dimensions; if fails treats as 1D and converts to 2D column variant; handles 0-based arrays by re-indexing into new 1-based VB array; then sets <code>.Cells(topRow,topCol).Resize(rCount,cCount).Value = outArr</code>. If scalar, writes single cell. Exceptions routed to <code>SafeHandleError</code>. <br><strong>Complexity:</strong> O(r*c) to reindex zero-based arrays; direct write O(1) in COM to transfer. <br><strong>Side-effects:</strong> Mutates worksheet cell values. <br><strong>Failure modes:</strong> Invalid ws <code>Nothing</code> results in no-op. <br><strong>Tests:</strong> 2D 1-based, 2D 0-based, 1D arrays, scalar. Verify values in sheet and performance on moderate arrays. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeReadRange(ws, topRow, topCol, rows, cols)</strong> — <em>fast bulk read</em><br><strong>Purpose:</strong> Read a rectangular block and return as variant (Excel's native variant 2D). <br><strong>Signature:</strong> <code>SafeReadRange(ws As Worksheet, topRow As Long, topCol As Long, rows As Long, cols As Long) As Variant</code><br><strong>Behavior:</strong> Validates inputs and returns <code>ws.Cells(...).Resize(...).Value</code>. Errors return <code>Empty</code> and are handled. <br><strong>Complexity:</strong> O(rows*cols) for data transfer. <br><strong>Tests:</strong> Read written block and verify match. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeKill(path)</strong> — <em>delete file safely</em><br><strong>Purpose:</strong> Remove a filesystem path if it exists; swallow errors. <br><strong>Signature:</strong> <code>SafeKill(ByVal path As String)</code> (Private)<br><strong>Behavior:</strong> If path non-empty and <code>Dir(path)</code> exists then <code>Kill path</code> under <code>On Error Resume Next</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Deletes file. <br><strong>Tests:</strong> Create temp file and ensure removal. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SafeReleaseStream(stm)</strong> — <em>close and release COM stream</em><br><strong>Purpose:</strong> Defensive close and <code>Set stm = Nothing</code> for ADODB streams. <br><strong>Signature:</strong> <code>SafeReleaseStream(ByRef stm As Object)</code> (Private)<br><strong>Behavior:</strong> Calls <code>stm.Close</code> inside <code>On Error Resume Next</code> then <code>Set stm = Nothing</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Release created ADODB.Stream without raising. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>AtomicWriteFile(fullPath, content) As Boolean</strong> — <em>robust atomic writer (text & binary)</em><br><strong>Purpose:</strong> Write content to <code>fullPath</code> atomically using tmp-file → rename or FSO copy fallback, with retries/backoff, UTF-8 support (BOM), ADODB.Stream preferred, and structured diagnostics. <br><strong>Signature:</strong> <code>AtomicWriteFile(ByVal fullPath As String, ByVal content As Variant) As Boolean</code><br><strong>Behavior (high level):</strong><br>- Determines folder for fullPath or falls back to temp defaults.<br>- Generates tmpName using <code>GenerateTempFileName()</code> in that folder.<br>- Attempts up to <code>MAX_ATOMIC_ATTEMPTS</code> tries: remove stale tmp, write content to tmp using ADODB.Stream when available (binary/text handling with UTF-8 + BOM logic), else fallback to <code>WriteToFileBinary</code> using native file IO.<br>- After write attempts <code>Name tmpName As fullPath</code> (atomic rename). If rename fails tries <code>Scripting.FileSystemObject.CopyFile tmpName -&gt; fullPath</code> after deleting existing target. If success logs and exits. On failure, removes tmp and sleeps with <code>WaitWithJitter</code> backoff and tries again. <br>- On failure after all attempts sets <code>g_lastAtomicWriteErr</code> and <code>g_lastAtomicWriteDiag</code> and calls <code>SafeHandleError</code> or <code>SafeLogAudit</code> depending on <code>g_verboseAtomicDiagnostics</code>. Ensures tmp cleanup. <br><strong>Complexity:</strong> O(attempts * write-cost). Write cost depends on content size and chosen writer. <br><strong>Side-effects:</strong> Creates temporary files and may call external certutil for checks if verbose diag requested. Updates module-level <code>g_lastAtomicWriteErr/Diag</code>. <br><strong>Invariants:</strong> If returns <code>True</code>, file at <code>fullPath</code> should be completely written and replaced atomically (best-effort); temporary file removed. <br><strong>Failure modes:</strong> Permission denied, locked files preventing rename/copy, ADODB absent, antivirus locking, disk full. <br><strong>Security:</strong> Avoids writing sensitive temporary files in world-readable locations; relies on callers to provide safe paths. <br><strong>Recommended tests:</strong> Normal successful write, target locked by handle to force copy fallback, ADODB unavailable path, binary content write (array of bytes), extremely large files to observe retries, aggressive concurrent locking (manual). Validate <code>g_lastAtomicWriteDiag</code>. <br><strong>Notes:</strong> Very careful to cleanup tmp files and to record structured diagnostics when <code>g_verboseAtomicDiagnostics = True</code>. Keep BOM handling consistent with reading routines. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GetLastAtomicWriteError() / GetLastAtomicWriteDiagnostic()</strong> — <em>atomic op observability</em><br><strong>Purpose:</strong> Expose last atomic write error code and diagnostics for caller diagnostics. <br><strong>Signature:</strong> <code>GetLastAtomicWriteError() As Long</code>, <code>GetLastAtomicWriteDiagnostic() As String</code><br><strong>Behavior:</strong> Return module-level <code>g_lastAtomicWriteErr</code> and <code>g_lastAtomicWriteDiag</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Cause write failure and assert values reflect last attempt. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ByteArrayFromVariant(arr)</strong> — <em>construct ADODB-style byte array</em><br><strong>Purpose:</strong> Convert a simple variant array of numeric values into a byte-array variant suitable for ADODB.Stream <code>.Write</code>. <br><strong>Signature:</strong> <code>ByteArrayFromVariant(arr As Variant) As Variant</code> (Private) <br><strong>Behavior:</strong> ReDims <code>b()</code> as Byte and assigns <code>CByte(arr(i))</code>. Returns byte variant. <br><strong>Complexity:</strong> O(n). <br><strong>Failure modes:</strong> Non-numeric entries will raise; callers must pass numeric bytes. <br><strong>Tests:</strong> Array of ints -> produces byte array of same length. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>WriteToFileBinary(path, content)</strong> — <em>lowest-level file output fallback</em><br><strong>Purpose:</strong> Write binary or text content to <code>path</code> using ADODB.Stream where available or fallback to native binary file <code>Open ... For Binary</code> or <code>Print</code> for ANSI text. <br><strong>Signature:</strong> <code>WriteToFileBinary(ByVal path As String, ByVal content As Variant)</code> (Private) <br><strong>Behavior:</strong> Tries ADODB binary write where available; if not, opens file For Binary and writes raw content or text. Errors bubble up to caller (they re-raise). <br><strong>Complexity:</strong> O(n) write. <br><strong>Security:</strong> Binary writes must be handled with care for untrusted inputs. <br><strong>Tests:</strong> Binary array write and UTF-8 text fallback. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ComputeFileSHA256_Certutil(path) As String</strong> — <em>optional checksum via certutil</em><br><strong>Purpose:</strong> Compute and return SHA256 hex using external <code>certutil</code> (Windows) when available. Optional diagnostic utility; returns <code>&quot;&quot;</code> on failure. <br><strong>Signature:</strong> <code>ComputeFileSHA256_Certutil(ByVal path As String) As String</code> (Private) <br><strong>Behavior:</strong> Uses <code>CreateObjectSafe(&quot;WScript.Shell&quot;)</code> to <code>Exec(&quot;cmd /c certutil -hashfile ... SHA256&quot;)</code>, reads StdOut when <code>exec</code> finishes, parses lines for 64-hex-digit line and returns it; caches whether certutil available. <br><strong>Complexity:</strong> I/O + process spawn. <br><strong>Failure modes:</strong> Not available on non-Windows hosts; returns empty. <br><strong>Tests:</strong> On Windows ensure output matches known checksum. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GetFolderForPath(fullPath) As String</strong> — <em>helper to extract folder portion</em><br><strong>Purpose:</strong> Return directory portion of a full path string. <br><strong>Signature:</strong> <code>GetFolderForPath(ByVal fullPath As String) As String</code> (Private) <br><strong>Behavior:</strong> Finds last <code>Application.PathSeparator</code> and returns left substring up to it; otherwise <code>&quot;&quot;</code>. <br><strong>Complexity:</strong> O(len). </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GenerateTempFileName() As String</strong> — <em>pseudo-GUID temp name generator with security toggle</em><br><strong>Purpose:</strong> Produce a unique temp file name using <code>Scriptlet.TypeLib</code> GUID when allowed (<code>g_allowScriptletTypeLib</code>), otherwise uses timestamp + random. <br><strong>Signature:</strong> <code>GenerateTempFileName() As String</code> (Private) <br><strong>Behavior:</strong> If <code>g_allowScriptletTypeLib</code> <code>True</code> attempts <code>CreateObjectSafe(&quot;Scriptlet.TypeLib&quot;)</code> to get a GUID; if not allowed or unavailable, generates <code>TEMP_PREFIX + timestamp + rnd</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Security:</strong> Use of Scriptlet.TypeLib disabled by default; enabling must be security-reviewed. <br><strong>Tests:</strong> Toggle <code>g_allowScriptletTypeLib</code> and confirm schema of returned string. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>WaitWithJitter(baseMs) As Long</strong> — <em>jittered backoff calculation</em><br><strong>Purpose:</strong> Return baseMs plus up-to-20% random jitter for exponential-backoff sleeps. <br><strong>Signature:</strong> <code>WaitWithJitter(ByVal baseMs As Long) As Long</code> (Private) <br><strong>Behavior:</strong> Computes jitter = <code>CLng(baseMs * 0.2 * Rnd())</code> and returns <code>baseMs + jitter</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Statistical checks that jitter in expected range. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>SleepMs(ms)</strong> — <em>cooperative millisecond sleep that pumps DoEvents</em><br><strong>Purpose:</strong> Sleep for <code>ms</code> milliseconds while calling <code>DoEvents</code> to keep host responsive in long retry loops. <br><strong>Signature:</strong> <code>SleepMs(ByVal ms As Long)</code> (Private) <br><strong>Behavior:</strong> Busy-wait using <code>Timer</code> loop with <code>DoEvents</code> and wrap-around handling for midnight <code>Timer</code> reset. <br><strong>Complexity:</strong> CPU spinning but yields via DoEvents. <br><strong>Caveat:</strong> Avoid in UI-critical contexts because it allows reentrancy. <br><strong>Tests:</strong> SleepMs(100) -> approx 100ms elapsed. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>IsADODBStreamAvailable() As Boolean / GetADODBStream() As Object</strong> — <em>ADODB availability checks & factory</em><br><strong>Purpose:</strong> Detect ADODB.Stream and create instances when available; cache tri-state in <code>g_adodbAvailable</code>. <br><strong>Signature:</strong> <code>IsADODBStreamAvailable() As Boolean</code>, <code>GetADODBStream() As Object</code><br><strong>Behavior:</strong> Attempts <code>CreateObjectSafe(&quot;ADODB.Stream&quot;)</code>, caches boolean. <code>GetADODBStream</code> returns new instance via <code>CreateObjectSafe</code> or <code>Nothing</code> if unavailable. <br><strong>Complexity:</strong> O(1) per check. <br><strong>Side-effects:</strong> Updates <code>g_adodbAvailable</code>. <br><strong>Tests:</strong> Return True on Windows with ADO installed; return False otherwise. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>CreateObjectSafe(progId) As Object</strong> — <em>COM factory with negative caching</em><br><strong>Purpose:</strong> Robust wrapper for <code>CreateObject</code> that caches availability per ProgID (positive & negative) to avoid repeated failing attempts; negative entries expire after TTL. <br><strong>Signature:</strong> <code>CreateObjectSafe(ByVal progId As String) As Object</code><br><strong>Behavior:</strong> Ensures caches, inspects <code>g_comCache</code> for an entry: if positive cached attempts to create a new instance and returns it; if negative cached and within TTL returns Nothing; otherwise tries <code>CreateObject(progId)</code>. On success caches positive availability; on failure caches negative entry with timestamp and <code>Err.Number</code>. Does not throw to callers—returns <code>Nothing</code> on failure. <br><strong>Complexity:</strong> O(1) with occasional CreateObject overhead. <br><strong>Side-effects:</strong> Updates <code>g_comCache</code>. <br><strong>Failure modes:</strong> ProgIDs that intermittently fail will be negative-cached for TTL duration; callers must handle <code>Nothing</code>. <br><strong>Tests:</strong> Try valid ProgIDs (e.g., <code>Scripting.FileSystemObject</code>), invalid ProgID and ensure negative cache kicks in, TTL expiry test. <br><strong>Notes:</strong> Essential for hosts with COM restrictions. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>IsCertutilAvailable() As Boolean</strong> — <em>detect external certutil presence</em><br><strong>Purpose:</strong> Determine if <code>certutil</code> command is available (Windows) and cache result. <br><strong>Signature:</strong> <code>IsCertutilAvailable() As Boolean</code><br><strong>Behavior:</strong> Uses <code>WScript.Shell.Exec(&quot;cmd /c certutil -?&quot;)</code>, reads StdOut non-empty to decide availability. Caches result in <code>g_certutilAvailable</code>. <br><strong>Complexity:</strong> Process spawn + I/O. <br><strong>Tests:</strong> On Windows expect correct boolean; on other OS returns False. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>IsPathWritable(fullPath) / IsPathWritableEx(fullPath, Optional reason)</strong> — <em>check write permission heuristics</em><br><strong>Purpose:</strong> Test whether the path's folder is writable by attempting to create and remove a temporary file. <code>IsPathWritable</code> returns boolean short wrapper; <code>IsPathWritableEx</code> returns boolean and sets <code>reason</code> string. <br><strong>Signature:</strong> <code>IsPathWritable(ByVal fullPath As String) As Boolean</code>, <code>IsPathWritableEx(ByVal fullPath As String, Optional ByRef reason As String) As Boolean</code><br><strong>Behavior:</strong> Resolves folder from path or falls back to <code>GetTempFolder</code>, <code>Environ(&quot;TEMP&quot;)</code>, <code>Application.DefaultFilePath</code>. Attempts <code>Open testFile For Output</code> and <code>Print &quot;test&quot;</code>, then deletes it. Returns success or diagnostic reason. Exceptions logged via SafeHandleError. <br><strong>Complexity:</strong> O(1). <br><strong>Failure modes:</strong> Filesystems with special permissions or network drives may behave unexpectedly; locking may cause false negatives. <br><strong>Tests:</strong> Known writable folder vs known read-only folder (e.g., system directory). </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>EnsureFolderPathEndsWith(folder) As String</strong> — <em>normalize trailing slash</em><br><strong>Purpose:</strong> Ensure provided folder path ends with platform-appropriate separator and normalise simplistic POSIX/Windows differences. <br><strong>Signature:</strong> <code>EnsureFolderPathEndsWith(ByVal folder As String) As String</code><br><strong>Behavior:</strong> If path uses forward slashes only keeps <code>/</code> style; otherwise appends <code>Application.PathSeparator</code> if missing. Returns <code>&quot;&quot;</code> for empty input. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Pass <code>&quot;C:\temp&quot;</code>, <code>&quot;~\dir/&quot;</code>, <code>&quot;posix/path&quot;</code> and assert trailing separator consistency. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GetTempFolder(Optional wb) As String</strong> — <em>multi-source temp folder discovery</em><br><strong>Purpose:</strong> Find an appropriate temp/work folder using precedence: WScript.Shell <code>%TMP%/%TEMP%</code>, <code>Environ</code> variables (<code>TMP</code>, <code>TEMP</code>, <code>TMPDIR</code>, <code>HOME</code>), <code>Application.DefaultFilePath</code>, workbook path, and MacScript fallback when on Mac. <br><strong>Signature:</strong> <code>GetTempFolder(Optional ByVal wb As Variant) As String</code><br><strong>Behavior:</strong> Calls <code>CreateObjectSafe(&quot;WScript.Shell&quot;)</code> to expand env vars, checks <code>Environ</code> vars, fallback to <code>Application.DefaultFilePath</code>, then workbook path and MacScript path on Mac. Uses <code>ExpandTildePath</code> for leading <code>~</code>. Returns empty string if none found. <br><strong>Complexity:</strong> O(1) with environment access. <br><strong>Failure modes:</strong> Limited in sandboxed hosts; returns <code>&quot;&quot;</code> which callers must handle. <br><strong>Tests:</strong> Simulate env vars and workbook paths. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ExpandTildePath(p) As String / NormalizePathSeparators(p) As String</strong> — <em>tilde expansion and separator normalisation</em><br><strong>Purpose:</strong> <code>ExpandTildePath</code> replaces leading <code>~</code> with <code>HOME</code> or <code>%USERPROFILE%</code> fallback; <code>NormalizePathSeparators</code> adjusts separators for platform conventions. <br><strong>Signature:</strong> <code>ExpandTildePath(ByVal p As String) As String</code>, <code>NormalizePathSeparators(ByVal p As String) As String</code> (Private) <br><strong>Behavior:</strong> Lookup <code>Environ(&quot;HOME&quot;)</code> or <code>WScript.Shell.ExpandEnvironmentStrings(&quot;%USERPROFILE%&quot;)</code>. <code>NormalizePathSeparators</code> maps <code>\</code> ↔ <code>/</code> depending on <code>Application.OperatingSystem</code>. <br><strong>Tests:</strong> <code>~/.cache</code> expands to absolute path; separators normalized on Mac vs Windows. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>StreamImportCsvLines(fullPath, lineHandlerName) As Boolean</strong> — <em>stream & handler-driven CSV reader</em><br><strong>Purpose:</strong> Read a CSV/text file line-by-line in a UTF-8-aware manner and call a provided VBA handler name <code>Application.Run lineHandlerName, line</code> for each non-empty line; robust to BOM and supports ADODB stream vs native <code>Line Input</code>. <br><strong>Signature:</strong> <code>StreamImportCsvLines(ByVal fullPath As String, ByVal lineHandlerName As String) As Boolean</code><br><strong>Behavior:</strong> If ADODB available loads file binary then switches stream to text with <code>utf-8</code> charset and <code>ReadText</code>, normalises line endings and splits on <code>vbCrLf</code> then iterates lines calling the handler. If ADODB unavailable falls back to <code>Open ... For Input</code> and <code>Line Input</code>, strips BOM if present on first line. All handler errors are caught and logged via <code>SafeLogAudit</code>. Returns True on success. <br><strong>Complexity:</strong> O(file size). <br><strong>Side-effects:</strong> Calls external handler repeatedly (which may perform arbitrary actions). <br><strong>Failure modes:</strong> If handler name wrong or handler raises exceptions, those exceptions are logged but import continues; if file unreadable returns False and logs error. <br><strong>Security:</strong> Handlers executed via <code>Application.Run</code> can run arbitrary VBA—careful when feeding untrusted CSVs. <br><strong>Tests:</strong> UTF-8 with BOM file, ANSI-only file, file with CR-only line endings, large file streaming. <br><strong>Notes:</strong> This is the preferred import path for robust encodings; handlers should be idempotent and quick to avoid UI blocking. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ExportRangeToCsv(rng, fullPath) As Boolean</strong> — <em>CSV exporter with UTF-8 BOM and atomic save</em><br><strong>Purpose:</strong> Export a range to a CSV file using UTF-8 (BOM) when ADODB available, escaping per RFC4180, and perform an atomic move into destination. <br><strong>Signature:</strong> <code>ExportRangeToCsv(ByVal rng As Range, ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong> Validates <code>rng</code> and destination folder; writes rows iteratively converting fields to CSV-escaped strings; uses ADODB to accumulate binary stream with BOM when available, or falls back to incremental ANSI writes. Writes to temporary CSV and then moves into place using <code>AtomicWriteFileMove</code>. On success logs audit; on failure sets error codes and calls <code>SafeHandleError</code>. <br><strong>Complexity:</strong> O(r*c) for traversal and I/O. <br><strong>Side-effects:</strong> Creates temporary CSV file in folder or temp area; final atomic move ensures consumer sees complete file. <br><strong>Failure modes:</strong> ADODB not available leads to ANSI output; failing atomic move returns error. <br><strong>Tests:</strong> Cells with commas, quotes, CR/LF inside cells, large ranges, ADODB absent scenario, destination locked scenario. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>AtomicWriteFileMove(srcFile, destFile) As Boolean</strong> — <em>atomic move helper with retries</em><br><strong>Purpose:</strong> Move file from tmp to destination atomically using <code>Name</code> and FSO <code>CopyFile</code> as fallback with retry/backoff. <br><strong>Signature:</strong> <code>AtomicWriteFileMove(ByVal srcFile As String, ByVal destFile As String) As Boolean</code> (Private)<br><strong>Behavior:</strong> Tries <code>Name srcFile As destFile</code>; if fails uses <code>Scripting.FileSystemObject</code> to delete target and <code>CopyFile</code> repeated up to <code>MAX_ATOMIC_ATTEMPTS</code> with jittered backoff. Logs errors. <br><strong>Complexity:</strong> O(attempts); each attempt O(I/O). <br><strong>Tests:</strong> Locked destination, simple rename success, fallback copy success. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ReadCustomXMLPart(rootElement) As String / AddOrUpdateCustomXMLPart(xml) As Boolean</strong> — <em>CustomXMLParts helpers</em><br><strong>Purpose:</strong> Read the first CustomXMLPart with a specific <code>rootElement</code> tag and add-or-replace a CustomXMLPart safely. <br><strong>Signatures:</strong> <code>ReadCustomXMLPart(ByVal rootElement As String) As String</code>, <code>AddOrUpdateCustomXMLPart(ByVal xml As String) As Boolean</code><br><strong>Behavior:</strong> Scans <code>ThisWorkbook.CustomXMLParts</code> for matching root element substring, returns <code>.xml</code> or <code>&quot;&quot;</code>. <code>AddOrUpdateCustomXMLPart</code> computes root element from <code>GetRootElementNameFromXml</code>, deletes existing matching parts, adds the new XML, and returns True; errors handled and reported. <br><strong>Complexity:</strong> O(#customxmlparts) for scan. <br><strong>Tests:</strong> Add, update, malformed xml returns False. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GetRootElementNameFromXml(xml) As String</strong> — <em>extract root element name</em><br><strong>Purpose:</strong> Utility to extract the root element name string from an XML snippet for part matching. <br><strong>Signature:</strong> <code>GetRootElementNameFromXml(ByVal xml As String) As String</code> (Private)<br><strong>Behavior:</strong> Finds first <code>&lt;</code>, then next space or <code>&gt;</code> and returns the token between. Robust to leading whitespace. <br><strong>Tests:</strong> Typical XML, XML with attributes, invalid XML. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>CreateObjectSafe / IsCertutilAvailable / IsADODBStreamAvailable / GetADODBStream</strong> — <em>environment & COM helpers (grouped)</em><br><strong>Purpose:</strong> Suite of helpers described above that detect and create external dependencies (ADODB, certutil, COM ProgIDs) with caching and negative caching. <br><strong>Recommended tests:</strong> Validate across permutations: ADODB present/absent, certutil present/absent, invalid ProgIDs, TTL expiry. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>ReadFileToString(fullPath) As String</strong> — <em>UTF-8-aware file reader</em><br><strong>Purpose:</strong> Read entire file as string, attempt ADODB path first, fallback to binary read + BOM detection, and return file contents as VBA string. <br><strong>Signature:</strong> <code>ReadFileToString(ByVal fullPath As String) As String</code> (Private)<br><strong>Behavior:</strong> If ADODB available loads file into binary stream, converts to text with <code>utf-8</code> charset; otherwise opens binary with <code>Open ... For Binary</code> and <code>Input$</code>, strips UTF-8 BOM if present, returns string. Errors return <code>&quot;&quot;</code>. <br><strong>Complexity:</strong> O(file size). <br><strong>Tests:</strong> Read UTF-8 with BOM, UTF-8 without BOM, ANSI files. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>UtilitiesSelfTest() As Boolean</strong> — <em>idempotent self-check suite</em><br><strong>Purpose:</strong> Run a suite of quick, idempotent unit checks exercising critical helpers: type conversions, atomic write, named-range cache, COM negative cache, SafeWrite/Read, ExportRangeToCsv basics, duplication audit and benchmark; logs results via SafeLogAudit. <br><strong>Signature:</strong> <code>UtilitiesSelfTest() As Boolean</code><br><strong>Behavior:</strong> Resets caches, runs discrete checks (ToDoubleSafe, ToLongSafe, Nz), attempts AtomicWriteFile to temp path, named range set/get, SafeWriteRange/SafeReadRange test on a <code>_UTILS_TEST</code> sheet (keeps sheet), ExportRangeToCsv to temp path, calls <code>DuplicateUtilitiesAudit</code>, runs <code>BenchmarkSafeWriteRange</code>, and logs findings. Returns True if all checks passed; errors reported via <code>SafeHandleError</code>. <br><strong>Complexity:</strong> O(number of tests + I/O). <br><strong>Side-effects:</strong> Writes temp files, may create <code>_UTILS_TEST</code> sheet, leaves minimal artifacts but attempts cleanup. <br><strong>Recommended tests:</strong> Run on clean environment, ensure no growth in resources across repeated runs. <br><strong>Notes:</strong> Designed for CI/lightweight smoke checks; heavy tests optional. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>DuplicateUtilitiesAudit() As Collection</strong> — <em>scan workbook code for duplicate helper names</em><br><strong>Purpose:</strong> Heuristic detection of duplicate helper function names across modules by scanning <code>ThisWorkbook.VBProject</code> components for listed names, returning a <code>Collection</code> of findings. <br><strong>Signature:</strong> <code>DuplicateUtilitiesAudit() As Collection</code><br><strong>Behavior:</strong> Accesses <code>ThisWorkbook.VBProject</code>, iterates <code>VBComponents</code>, inspects <code>CodeModule.lines</code> for tracked helper names. If VBProject access is blocked (<code>Trust access</code> disabled) returns a collection with a single string warning. Uses defensive error handling. <br><strong>Complexity:</strong> O(total lines of code) for scan. <br><strong>Security/Permissions:</strong> Requires <code>Trust access to VBA project object model</code>—may be unavailable; function handles that case gracefully. <br><strong>Tests:</strong> Run in workbook with duplicates to ensure detection; verify graceful fallback when VBProject not accessible. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>BenchmarkSafeWriteRange(rows, cols) As Long</strong> — <em>micro-benchmark for SafeWriteRange</em><br><strong>Purpose:</strong> Write a moderate-sized array (default 200x100) to <code>_UTILS_BENCH</code> sheet and return elapsed milliseconds to help gauge performance. <br><strong>Signature:</strong> <code>BenchmarkSafeWriteRange(Optional ByVal rows As Long = 200, Optional ByVal cols As Long = 100) As Long</code><br><strong>Behavior:</strong> Creates or reuses <code>_UTILS_BENCH</code> sheet, constructs sample array (0-based), measures time via <code>Timer</code> before/after <code>SafeWriteRange</code>, clears contents (keeps sheet), returns elapsed ms or -1 on error. <br><strong>Complexity:</strong> O(rows*cols). <br><strong>Tests:</strong> Run repeatedly to observe variance; store results in telemetry if desired. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>RetryWithBackoffByName(functionName, attempts, initialDelayMs, Optional lastErrNum, Optional args)</strong> — <em>generic retry wrapper for Application.Run</em><br><strong>Purpose:</strong> Call an arbitrary VBA function by name via <code>Application.Run</code> with retry/backoff semantics and flexible argument handling (supports up to 8 args explicitly). Returns True on first successful truthy result or any non-empty non-error result. <br><strong>Signature:</strong> <code>RetryWithBackoffByName(ByVal functionName As String, Optional ByVal attempts As Long = 3, Optional ByVal initialDelayMs As Long = 200, Optional ByRef lastErrNum As Variant, Optional args As Variant) As Boolean</code><br><strong>Behavior:</strong> Determines argument shape, attempts <code>Application.Run</code> with supplied args, if call yields <code>Err.Number = 0</code> and returns boolean True or non-empty value treats as success. On failure logs via <code>SafeLogAudit</code>, sleeps with exponential backoff (doubled delay) and jitter between attempts. Catches fatal errors and sets <code>lastErrNum</code>. <br><strong>Complexity:</strong> O(attempts * call cost). <br><strong>Side-effects:</strong> May call arbitrary function names; caller must ensure idempotence if function does more than read. <br><strong>Tests:</strong> Wrap a flaky helper (e.g., network-backed function) and confirm retries. <br><strong>Notes:</strong> Use sparingly for non-idempotent operations. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Export / Verification helpers: RunVerificationChecklist(outputFile) / GenerateVerificationReport()</strong> — <em>CI-friendly verification and artifact generation</em><br><strong>Purpose:</strong> Run multiple <code>UtilitiesSelfTest</code> rounds, collect results, run duplication audit and benchmark, assemble a JSON report and attempt an atomic write to <code>outputFile</code> (RunVerificationChecklist) or just return JSON string (GenerateVerificationReport). <br><strong>Signature:</strong> <code>RunVerificationChecklist(ByVal outputFile As String) As Boolean</code>, <code>GenerateVerificationReport() As String</code><br><strong>Behavior:</strong> Executes <code>UtilitiesSelfTest</code> 10 times, collects <code>pass/fail</code> array, runs <code>DuplicateUtilitiesAudit</code>, <code>BenchmarkSafeWriteRange</code>, composes JSON with timestamp and diagnostics, writes via <code>AtomicWriteFile</code> when requested. Returns boolean for success of write + overallOk (RunVerificationChecklist) or JSON string (GenerateVerificationReport). <br><strong>Complexity:</strong> Heavy; runs tests multiple times and performs I/O. <br><strong>Side-effects:</strong> Creates JSON artifact and temp files. <br><strong>Recommended tests:</strong> Run in CI to validate reproducibility and ensure atomic write of artifact succeeds. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>EscapeJsonString(s) As String</strong> — <em>minimal JSON string escaper</em><br><strong>Purpose:</strong> Escape backslashes, quotes, and newlines for naive JSON embedding. <br><strong>Signature:</strong> <code>EscapeJsonString(ByVal s As String) As String</code> (Private) <br><strong>Behavior:</strong> Replaces <code>\</code> -> <code>\\</code>, <code>&quot;</code> -> <code>\&quot;</code>, CR/LF -> <code>\n</code>. Lightweight; not a full JSON serializer but adequate for trace strings. <br><strong>Tests:</strong> Strings with quotes, backslashes and newlines produce escaped output. <br><strong>Notes:</strong> If you require robust JSON, consider a proper serializer or library. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Nz(v, Optional alt) / Coalesce(ParamArray) / ToDoubleSafe / ToLongSafe / ToDateSafe</strong> — <em>small type & null helpers</em><br><strong>Purpose:</strong> Provide safe, compact conversions & null coalescing that behave predictably across common variant states (Empty, Null, Error, empty string). <br><strong>Signatures:</strong> <code>Nz(ByVal v As Variant, Optional ByVal alt As Variant = &quot;&quot;) As Variant</code>, <code>Coalesce(ParamArray vals() As Variant) As Variant</code>, <code>ToDoubleSafe(ByVal v As Variant, Optional ByVal defaultValue As Double = 0#) As Double</code>, <code>ToLongSafe(ByVal v As Variant, Optional ByVal defaultValue As Long = 0) As Long</code>, <code>ToDateSafe(ByVal v As Variant, Optional ByVal defaultValue As Date = 0) As Date</code><br><strong>Behavior:</strong> Defensive conversions with <code>On Error</code> guards returning defaults on invalid input. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Various invalid inputs (Error(), Null, Empty, strings) return defaults. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>GenerateVerificationReport / RunVerificationChecklist</strong> — <em>already covered in Export/Verification helpers</em> </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Additional private helpers (GetFolderForPath, GetRootElementNameFromXml, NormalizePathSeparators, ExpandTildePath, ReadFileToString)</strong> — <em>utility primitives used by public functions</em><br><strong>Purpose:</strong> Small focused helpers to keep public functions simple and testable: path parsing, XML root extraction, path normalization, tilde expansion, file reading with BOM handling. <br><strong>Tests:</strong> Unit-test each helper with edge-cases (empty input, invalid path, BOM present). </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Security & Operational Summary (module-level)</strong><br>- <strong>Safety-first design:</strong> All external/io operations use defensive <code>On Error</code> handling and centralized <code>SafeHandleError</code>/<code>SafeLogAudit</code>. Named-range cache uses workbook fingerprinting to avoid stale reads. <br>- <strong>Atomicity:</strong> File writes use a tmp-file → rename or FSO copy fallback with jittered exponential backoff and multi-attempt retry; <code>ExportRangeToCsv</code> and <code>AtomicSaveWorkbookAs</code> use this pattern. <br>- <strong>Encoding:</strong> ADODB.Stream is preferred for UTF-8/BOM handling; code contains fallbacks to native binary I/O for restricted hosts. <br>- <strong>COM resilience:</strong> <code>CreateObjectSafe</code> negative-caches failing ProgIDs to avoid repeated expensive attempts; TTL configurable. <br>- <strong>Resource safety:</strong> <code>SafeReleaseStream</code> and <code>SafeKill</code> ensure resources are closed and temporary artifacts removed; <code>UtilitiesSelfTest</code> attempts idempotent cleanup. <br>- <strong>Telemetry & diagnostics:</strong> <code>g_verboseAtomicDiagnostics</code> emits structured JSON-like diagnostics (including optional SHA256 via certutil) but is off by default. Audit calls are delegated to <code>modAudit</code> only. <br>- <strong>Reentrancy caution:</strong> Long-running operations (Atomic writes, Export) call <code>DoEvents</code> via <code>SleepMs</code> and may re-enter host event loops—callers must avoid reentrancy hazards. <br><strong>Recommended integration tests:</strong> atomic write / save under file-lock conditions, ADODB present/absent permutations, COM negative cache TTL coverage, named-range cache invalidation on Save/Close, CSV export round-trips, and duplicate-audit behavior when VBProject access is blocked. </td></tr><tr><td data-label="Technical breakdown (modUtilities)"> <strong>Maintainability notes</strong><br>- Preserve public signatures — other modules depend on them. <br>- If changing tokenization of cache keys (WorkbookFingerprint), add migration or invalidate caches robustly. <br>- Keep <code>Scriptlet.TypeLib</code> usage gated behind <code>g_allowScriptletTypeLib</code> and document security review requirements. <br>- When modifying atomic write flow: keep tmp-file cleanup and diagnostic emission consistent; revoke any created blob or temporary handles immediately when created. <br>- Add CI smoke test that runs <code>RunVerificationChecklist</code> in a hermetic runner to guard regressions. </td></tr></tbody></table></div><div class="row-count">Rows: 60</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>