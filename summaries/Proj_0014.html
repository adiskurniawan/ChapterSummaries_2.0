<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1764743483">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      // Delegate addEventListener/removeEventListener to visible button
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      // Delegate onclick assignments
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      // Delegate focus/blur
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
      // If legacy code used direct addEventListener earlier than this script, listeners would already exist
      // on alias element; attempt to re-dispatch those by cloning them to visible button is non-trivial.
      // This approach covers the common case where legacy scripts query the alias and bind after DOM ready.
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li>
<li class="toc-item"><a class="toc-link" href="#Table6">Table 6</a></li>
<li class="toc-item"><a class="toc-link" href="#Table7">Table 7</a></li>
<li class="toc-item"><a class="toc-link" href="#Table8">Table 8</a></li>
<li class="toc-item"><a class="toc-link" href="#Table9">Table 9</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Proj_0014_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Module"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Module</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Module"> <strong>1) modCalc</strong><br><strong>Responsibilities:</strong> Implement TER selection flow (canonicalize → exact → alt prefix → alias → wildcard → default/fail) and honor <code>STRICT_TER_MAP</code>; integrate alias table logic and alias JSON parsing; BPJS aggregation & precedence (amount vs percent precedence; employer vs employee handling; <code>include_employer_bpjs_in_gross</code> flag; <code>MAX_PREMI_ASURANSI_PCT</code> check + WARN); gross-up handling (preserve <code>gross_up_flag</code> semantics, provide <code>SolveGrossUp</code> call/point); NPWP penalty application (<code>npwp_penalty_pct</code> normalization and multiplier usage); annualization/<code>period_type</code> handling and TER eligibility gates (<code>period_type</code>, <code>is_regular_monthly</code>, final-month); produce per-row audit fields: <code>canonical_ptkp</code>, <code>ter_table</code>, <code>ter_map_lookup_key</code>, <code>ter_map_match_type</code>, <code>ter_map_load_id</code>, <code>ter_map_error</code>.<br><strong>Tests:</strong> Unit tests for canonicalization and alias→canonical resolution; TER lookup tests (A/B vectors); BPJS precedence tests (amount vs percent); NPWP penalty tests; gross-up end-to-end test.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>2) modIO</strong><br><strong>Responsibilities:</strong> Read/write <code>tblInput</code>, <code>tblParams</code>, <code>tblBrackets</code>, and <code>TER_*</code> tables non-destructively (preserve extra columns); <code>QueryTable</code> import fallback to streaming parser; ensure <code>nip</code>/<code>npwp</code> preserved as Text; CSV writers: atomic write (<code>.tmp</code> → rename), UTF-8 BOM toggle, stable header ordering, export audit fields; implement <code>LoadMappingDryRun()</code> and <code>SetTERTables(..., commit=True)</code> I/O paths accepting inline JSON or <code>TER_TABLE_MAP_FILE</code>; <code>SafeMoveFile</code>/<code>DeleteFileIfExists</code> with retry/backoff and cross-volume-safe copy; create <code>OUTPUT_BASE\JOB_ID</code> folder with retry/backoff.<br><strong>Tests:</strong> File atomicity/rename semantics; <code>QueryTable</code> vs streaming fallback preserving NPWP/NIP; CSV encoding and BOM behavior for Excel; create/delete race condition tests.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>3) modManifest</strong><br><strong>Responsibilities:</strong> Compute SHA-256 for CSVs, TER lampiran files, and mapping JSON (normalized) and include in <code>manifest.json</code>; write manifest fields: <code>job_id</code>, <code>generated_at</code> (ISO8601 using TIMEZONE), <code>files</code> array (path, size, modified, sha256), <code>total_size_bytes</code>, <code>import_error</code> (nullable), <code>ter_table_load_id</code>, <code>mapping_hash</code>; persist <code>ter_map_snapshot/&lt;ter_table_load_id&gt;.json</code> and reference it in manifest; record <code>mapping_hash</code> and <code>ter_table_load_id</code> into Logs and manifest upon commit.<br><strong>Tests:</strong> SHA-256 correctness for sample files; manifest JSON schema validation; roundtrip: compute hash → write manifest → verify file exists and hash matches.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>4) modUtils</strong><br><strong>Responsibilities:</strong> Canonicalization helpers (trim, normalize separators, insert slash between letters/digits, collapse whitespace, uppercase, remove <code>PTKP_</code> prefix while preserving raw in audit); percent parsing utilities (accept "5%", "0.05", "5", normalize to fraction; strict percent format enforcement); numeric parsing and <code>NzNumericSafe</code> with blank→0 handling and <code>STRICT_BPJS</code> toggle; retry/backoff helpers and <code>SafeMoveFile</code> logic; secure masking helper for Logs (mask NIP/NPWP); validation helpers for settings/<code>tblParams</code> types and ranges.<br><strong>Tests:</strong> Canonicalization unit tests across variants; percent parsing edge cases; retry/backoff timing and retry counts.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>5) modIO / modTER (TER loader)</strong><br><strong>Responsibilities:</strong> <code>LoadMappingDryRun()</code> implementation: parse inline JSON or file, validate schema (<code>exact</code>, <code>alias</code>, <code>wildcard</code>, <code>default</code>), detect duplicate keys, wildcard validity and ambiguous wildcard detection, preview mapping for distinct PTKP values, return structured <code>errors[]</code>/<code>warnings[]</code>/<code>preview_mappings</code>; <code>SetTERTables(..., commit=True)</code>: commit path that snapshots normalized mapping, <code>ter_table_load_id</code>, and swaps runtime snapshot atomically; effective date, open-ended GrossHigh rules, overlap detection (<code>ERR_TER_OVERLAP</code>, <code>ERR_TER_MULTIPLE_OPEN</code>); TER placeholder table creation/seeding (TER_A..TER_D) with import notes.<br><strong>Tests:</strong> Dry-run error/warning cases (malformed JSON, invalid wildcard, missing mapping keys, ambiguous wildcards); commit snapshot creation and restore/rollback behavior.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>6) modMain</strong><br><strong>Responsibilities:</strong> Orchestrator <code>pph21_RunAll</code>: call settings read → validate sheets/tables → Generate <code>JOB_ID</code> → create output folder → call <code>SetTERTables</code> dry-run/commit → load <code>tblInput</code> → call <code>modCalc.ProcessRow</code>/<code>ComputeTax</code> per row → build and write CSVs atomically → call <code>modManifest</code> to write manifest → append Logs; integrate <code>Test_RunAll</code> macro into orchestrator (test harness entry, non-destructive); respect settings toggles (<code>STRICT_TER_MAP</code>, <code>INCLUDE_BPJS_FIELDS</code>, <code>VERBOSECALC</code>, etc.); implement job-level error handling and graceful abort with Logs appended.<br><strong>Tests:</strong> End-to-end run on sample inputs (<code>Test_RunAll</code>); failure-in-the-middle simulation to ensure partial outputs not left (atomic semantics).<br><strong>Priority:</strong> Medium </td></tr><tr><td data-label="Module"> <strong>7) modManifest / modLogging (logging & logs export)</strong><br><strong>Responsibilities:</strong> Logs sheet formatting: <code>Timestamp</code>, <code>Level</code>, <code>Message</code>, <code>Context</code>; mask sensitive digits; append-only behavior and replication into manifest context (<code>import_error</code>); write <code>TER_ChangeLog</code> entries and ensure <code>ENFORCE_CHANGELOG</code> enforcement at commit.<br><strong>Tests:</strong> Log masking tests and log append idempotency; <code>ENFORCE_CHANGELOG</code> blocking behavior.<br><strong>Priority:</strong> Medium </td></tr><tr><td data-label="Module"> <strong>8) modTest (new recommended)</strong><br><strong>Responsibilities:</strong> Implement <code>Test_RunAll</code> macro per guide: populate <code>tblInput</code> with sample rows, run orchestrator, assert output files and manifest exist, validate sample outputs (<code>bukti_potong.csv</code>, <code>per11_payload.csv</code>, <code>manifest.json</code>); automate microtests: bracket boundaries, BPJS precedence, NPWP penalty, currency/FX conversions, TER lookup assertions.<br><strong>Tests:</strong> CI-level unit and integration tests running in workbook copy, non-destructive assertions.<br><strong>Priority:</strong> Medium </td></tr><tr><td data-label="Module"> <strong>9) modIO / modCSV (CSV schema enforcement)</strong><br><strong>Responsibilities:</strong> Enforce CSV schemas for <code>bukti_potong.csv</code> and <code>per11_payload.csv</code> header order and optional BOM handling; support optional UTF-8 BOM toggle and <code>CSV_ENCODING</code> setting; include audit columns appended at the end.<br><strong>Tests:</strong> CSV consumers (Excel / downstream loader) acceptance tests with BOM/no-BOM combinations.<br><strong>Priority:</strong> Medium </td></tr><tr><td data-label="Module"> <strong>10) modSecurity / ACL integration (new recommended)</strong><br><strong>Responsibilities:</strong> Guard edits to Settings/<code>tblParams</code> (or document requirement to use workbook-level ACLs); ensure <code>OUTPUT_BASE</code> permissions and job folder ACLs before commit.<br><strong>Tests:</strong> Permission check tests; simulate unauthorized edits and confirm block.<br><strong>Priority:</strong> Low/Medium </td></tr><tr><td data-label="Module"> <strong>Cross-module integration & migration notes</strong><br><strong>Responsibilities:</strong> Preserve function signatures (<code>ComputeTax</code>, <code>ProcessRow</code>, IO helpers)—modify internals only; add unit tests for changed functions and full E2E test for orchestrator; bump <code>MOD_VERSION</code> when changing headers/calculation semantics/TER mapping behavior; ensure backward compatibility with archived snapshots or provide migration note; implement feature flags (<code>VERBOSECALC</code>, <code>STRICT_TER_MAP</code>) for rollout.<br><strong>Priority:</strong> (applies across modules) High for compatibility, testing, and versioning. </td></tr></tbody></table></div><div class="row-count">Rows: 11</div></div><div class="table-caption" id="Table2" data-table="Proj_0014_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Key"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Key</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Value (recommended)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Value (recommended)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Type &amp; notes"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Type & notes</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Key"> TER_TABLE_MAP </td><td data-label="Value (recommended)"> (see JSON block below) </td><td data-label="Type &amp; notes"> JSON string.<br>Preferred canonical mapping: contains <code>exact</code>, <code>alias</code>, <code>wildcard</code>, <code>default</code> sections.<br>Must validate with <code>LoadMappingDryRun</code> before commit. </td></tr><tr><td data-label="Key"> STRICT_TER_MAP </td><td data-label="Value (recommended)"> TRUE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, missing PTKP→TER map is fatal. Recommended TRUE for production. </td></tr><tr><td data-label="Key"> TER_TABLE_DEFAULT </td><td data-label="Value (recommended)"> (blank recommended) </td><td data-label="Type &amp; notes"> TER choice when <code>STRICT_TER_MAP = FALSE</code>.<br>Allowed: <code>TER_A</code> | <code>TER_B</code> | <code>TER_C</code> | <code>TER_D</code> or blank. Prefer blank. </td></tr><tr><td data-label="Key"> STRICT_PERCENT_FORMAT </td><td data-label="Value (recommended)"> TRUE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, TER_percent must be explicit (<code>0.0125</code> or <code>1.25%</code> when loader configured); disallow ambiguous integers. </td></tr><tr><td data-label="Key"> npwp_penalty_pct </td><td data-label="Value (recommended)"> 20 </td><td data-label="Type &amp; notes"> numeric (percent or number).<br>Enter <code>20</code> for 20%; loader normalizes to <code>0.20</code>. </td></tr><tr><td data-label="Key"> dtp_pct </td><td data-label="Value (recommended)"> 0 </td><td data-label="Type &amp; notes"> numeric (percent/fraction).<br>Default <code>0</code>. </td></tr><tr><td data-label="Key"> annualization_default </td><td data-label="Value (recommended)"> 12 </td><td data-label="Type &amp; notes"> integer.<br>Months used for annualization. </td></tr><tr><td data-label="Key"> include_employer_bpjs_in_gross </td><td data-label="Value (recommended)"> FALSE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE employer BPJS aggregates added to gross before TER lookup. </td></tr><tr><td data-label="Key"> INCLUDE_BPJS_FIELDS </td><td data-label="Value (recommended)"> TRUE </td><td data-label="Type &amp; notes"> boolean.<br>Enable BPJS column validation and aggregation logic. </td></tr><tr><td data-label="Key"> allow_employee_bpjs_deduction </td><td data-label="Value (recommended)"> TRUE </td><td data-label="Type &amp; notes"> boolean.<br>Allow employee BPJS deduction in progressive flow. </td></tr><tr><td data-label="Key"> STRICT_BPJS </td><td data-label="Value (recommended)"> FALSE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, missing BPJS columns cause hard error. Default FALSE for compatibility. </td></tr><tr><td data-label="Key"> INCLUDE_BPJS_FIELDS_LIST </td><td data-label="Value (recommended)"> bpjs_ke_emp,bpjs_jkk_emp,bpjs_jkm_emp,bpjs_jht_emp,bpjs_other_emp,premi_asuransi_dari_pemberi_kerja,iuran_bpjs_employee </td><td data-label="Type &amp; notes"> CSV string.<br>Column names expected in <code>tblInput</code> when <code>INCLUDE_BPJS_FIELDS=TRUE</code>.<br>Case-insensitive match. </td></tr><tr><td data-label="Key"> MAX_PREMI_ASURANSI_PCT </td><td data-label="Value (recommended)"> 0.5 </td><td data-label="Type &amp; notes"> fraction.<br>Cap for <code>premi_asuransi_employer</code> as fraction of gross; triggers <code>WARN_BPJS_PREMI_EXCEEDS_CAP</code> if exceeded. </td></tr><tr><td data-label="Key"> VERBOSECALC </td><td data-label="Value (recommended)"> FALSE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, write per-row verbose calculation logs (debug only). </td></tr><tr><td data-label="Key"> ROUNDMIDPOINTRULE </td><td data-label="Value (recommended)"> BANKERS </td><td data-label="Type &amp; notes"> Enum: <code>BANKERS</code> / <code>HALF_UP</code> / <code>TRUNCATE</code>.<br>Recommended <code>BANKERS</code>. </td></tr><tr><td data-label="Key"> CALC_MODE </td><td data-label="Value (recommended)"> STANDARD </td><td data-label="Type &amp; notes"> string.<br>Do not change without authorization. </td></tr><tr><td data-label="Key"> ENFORCE_CHANGELOG </td><td data-label="Value (recommended)"> TRUE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, commits to TER mappings or TER tables require <code>TER_ChangeLog</code> entry. </td></tr><tr><td data-label="Key"> OVERRIDE_TER_TABLE_MAP </td><td data-label="Value (recommended)"> (blank) </td><td data-label="Type &amp; notes"> JSON string or blank.<br>Ephemeral override mapping for hotfixes (must be removed after job). Has precedence if present. </td></tr><tr><td data-label="Key"> ALIAS_TABLE </td><td data-label="Value (recommended)"> (see JSON block below or leave blank) </td><td data-label="Type &amp; notes"> JSON string.<br>Mapping shorthand → canonical (optional if using <code>TER_TABLE_MAP.alias</code>). Use only small curated sets. </td></tr><tr><td data-label="Key"> TER_IMPORT_EFFECTIVE_DATE_POLICY </td><td data-label="Value (recommended)"> STRICT </td><td data-label="Type &amp; notes"> Enum: <code>STRICT</code> / <code>LENIENT</code>.<br><code>STRICT</code> rejects overlapping effective ranges; <code>LENIENT</code> logs warnings. </td></tr><tr><td data-label="Key"> TER_ALLOW_MULTIPLE_OPEN_ENDED </td><td data-label="Value (recommended)"> FALSE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE allows more than one open-ended <code>GrossHigh</code> per table (not recommended). </td></tr><tr><td data-label="Key"> TER_SOURCE_FOLDER </td><td data-label="Value (recommended)"> (blank) </td><td data-label="Type &amp; notes"> path string.<br>Folder where lampiran CSVs are staged before <code>SetTERTables</code>. Use secure folder. </td></tr><tr><td data-label="Key"> TER_VERIFY_SHA_ON_IMPORT </td><td data-label="Value (recommended)"> TRUE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, loader expects SHA256 for each lampiran file and verifies before commit. </td></tr><tr><td data-label="Key"> TER_ChangeLog_Path </td><td data-label="Value (recommended)"> ter_changelog.csv </td><td data-label="Type &amp; notes"> string.<br>File created/appended in job folder on commit. </td></tr><tr><td data-label="Key"> TER_LOAD_RETENTION_DAYS </td><td data-label="Value (recommended)"> 3650 </td><td data-label="Type &amp; notes"> integer.<br>Retention for ter_map snapshots (days). </td></tr><tr><td data-label="Key"> NPWP_PENALTY_MULTIPLIER </td><td data-label="Value (recommended)"> 1.20 </td><td data-label="Type &amp; notes"> numeric.<br>Alternative representation; loader calculates from <code>npwp_penalty_pct</code>. Keep consistent. </td></tr><tr><td data-label="Key"> STRICT_PERCENT_ALLOW_INTEGER </td><td data-label="Value (recommended)"> FALSE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, integer like <code>5</code> will be interpreted as <code>5%</code> (not recommended). </td></tr><tr><td data-label="Key"> BPJS_PERCENT_BASE </td><td data-label="Value (recommended)"> gross </td><td data-label="Type &amp; notes"> string.<br><code>gross</code> or <code>premi_base</code> — base used when percent-based BPJS present. Default <code>gross</code>. </td></tr><tr><td data-label="Key"> LOG_MASK_SENSITIVE </td><td data-label="Value (recommended)"> TRUE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, mask full NIP/NPWP in Logs. </td></tr><tr><td data-label="Key"> MANDATORY_TERRULE_COLUMNS </td><td data-label="Value (recommended)"> row_id,GrossLow,GrossHigh,TER_percent </td><td data-label="Type &amp; notes"> CSV string.<br>Loader enforces presence. </td></tr><tr><td data-label="Key"> PREVIEW_SAMPLE_KEYS_LIMIT </td><td data-label="Value (recommended)"> 500 </td><td data-label="Type &amp; notes"> integer.<br>Max distinct PTKP keys to preview in dry-run; if exceeded, only first N returned. </td></tr><tr><td data-label="Key"> LOADMAP_DRYRUN_FAIL_ON_WARN </td><td data-label="Value (recommended)"> FALSE </td><td data-label="Type &amp; notes"> boolean.<br>If TRUE, treat warnings as errors in dry-run. Default FALSE. </td></tr><tr><td data-label="Key"> TER_MAP_VALID_TARGETS </td><td data-label="Value (recommended)"> TER_A,TER_B,TER_C,TER_D </td><td data-label="Type &amp; notes"> CSV string.<br>Valid TER table names. </td></tr><tr><td data-label="Key"> MAPPING_HASH_FIELD </td><td data-label="Value (recommended)"> mapping_hash </td><td data-label="Type &amp; notes"> string.<br>Field name used in manifest and snapshots. </td></tr><tr><td data-label="Key"> AUDIT_EXPORT_FIELDS </td><td data-label="Value (recommended)"> canonical_ptkp,ter_table,ter_map_lookup_key,ter_map_match_type,ter_map_load_id,ter_map_hash,ter_map_warning_codes </td><td data-label="Type &amp; notes"> CSV string.<br>Fields appended to output CSVs when <code>EXPORT_INCLUDE_AUDIT_FIELDS=TRUE</code>. </td></tr><tr><td data-label="Key"> DRYRUN_NOTIFY_EMAIL </td><td data-label="Value (recommended)"> (blank) </td><td data-label="Type &amp; notes"> string.<br>Optional notification email for dry-run errors/warnings. </td></tr><tr><td data-label="Key"> TG_RETRY_ATTEMPTS </td><td data-label="Value (recommended)"> 3 </td><td data-label="Type &amp; notes"> integer.<br>Internal retries for ter table file verification. </td></tr><tr><td data-label="Key"> TG_RETRY_DELAY_MS </td><td data-label="Value (recommended)"> 500 </td><td data-label="Type &amp; notes"> integer.<br>Delay (ms) for ter table file verification retries. </td></tr></tbody></table></div><div class="row-count">Rows: 38</div></div><div class="table-caption" id="Table3" data-table="Proj_0014_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Key"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Key</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Value (example / recommended)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Value (example / recommended)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Type &amp; allowed values"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Type & allowed values</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th><th class="tv-col" role="button" aria-label="Sort by Purpose / Validation"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Purpose / Validation</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Key"> OUTPUT_BASE </td><td data-label="Value (example / recommended)"> C:\Payroll\pph21_outputs </td><td data-label="Type &amp; allowed values"> string (absolute path) </td><td data-label="Purpose / Validation"> Base folder where job folders (OUTPUT_BASE\JOB_ID) are created. Must be writable. Validate existence and permissions at job start. </td></tr><tr><td data-label="Key"> JOB_ID </td><td data-label="Value (example / recommended)"> (blank) </td><td data-label="Type &amp; allowed values"> string or blank </td><td data-label="Purpose / Validation"> If blank, system generates <code>job_YYYYMMDD_HHNNSS</code> and writes it back. If prefilled, that folder is used and outputs overwritten per atomic rules. Must contain only safe filename chars; no path separators. </td></tr><tr><td data-label="Key"> RETRY_ATTEMPTS </td><td data-label="Value (example / recommended)"> 3 </td><td data-label="Type &amp; allowed values"> integer ≥ 0 </td><td data-label="Purpose / Validation"> Number of retry attempts for file operations (create folder, safe move). </td></tr><tr><td data-label="Key"> RETRY_DELAY_MS </td><td data-label="Value (example / recommended)"> 500 </td><td data-label="Type &amp; allowed values"> integer ≥ 0 </td><td data-label="Purpose / Validation"> Base delay in milliseconds between retries (use exponential backoff). </td></tr><tr><td data-label="Key"> MOD_VERSION </td><td data-label="Value (example / recommended)"> 1.0.0 </td><td data-label="Type &amp; allowed values"> string (semantic version) </td><td data-label="Purpose / Validation"> Module version. Bump when table headers or logic change. </td></tr><tr><td data-label="Key"> INCLUDE_BPJS_FIELDS </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE, loader expects BPJS employer/employee fields and performs aggregation logic. If FALSE, BPJS fields ignored. </td></tr><tr><td data-label="Key"> include_employer_bpjs_in_gross </td><td data-label="Value (example / recommended)"> FALSE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE employer BPJS aggregates are added to gross before TER lookup (per rules). </td></tr><tr><td data-label="Key"> allow_employee_bpjs_deduction </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE employee BPJS (iuran_bpjs_employee) is allowed as deduction in progressive flow. </td></tr><tr><td data-label="Key"> STRICT_BPJS </td><td data-label="Value (example / recommended)"> FALSE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE, missing BPJS columns cause hard error. Default FALSE for backward compatibility. </td></tr><tr><td data-label="Key"> STRICT_TER_MAP </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE, missing PTKP→TER mapping is fatal (ERR_TER_MISSING_PTKP_MAP). Recommended TRUE in production. </td></tr><tr><td data-label="Key"> ENFORCE_CHANGELOG </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE, commit blocked unless TER_ChangeLog entry exists for mapping changes. Recommended TRUE. </td></tr><tr><td data-label="Key"> OVERRIDE_TER_TABLE_MAP </td><td data-label="Value (example / recommended)"> (blank) </td><td data-label="Type &amp; allowed values"> JSON string or blank </td><td data-label="Purpose / Validation"> Optional ephemeral override mapping (same format as TER_TABLE_MAP). Use only for hotfixes; must be removed after job. If present, loader uses it with higher precedence. </td></tr><tr><td data-label="Key"> TER_TABLE_DEFAULT </td><td data-label="Value (example / recommended)"> (blank) </td><td data-label="Type &amp; allowed values"> TER_A | TER_B | TER_C | TER_D or blank </td><td data-label="Purpose / Validation"> Default table used only when STRICT_TER_MAP = FALSE and mapping missing. Prefer blank in strict production. </td></tr><tr><td data-label="Key"> NPWP_PENALTY_PCT </td><td data-label="Value (example / recommended)"> 20 </td><td data-label="Type &amp; allowed values"> numeric or percent (20 or 0.20 or "20%") </td><td data-label="Purpose / Validation"> NPWP penalty percent. Loader will normalize to fraction (0.20). Recommended 20 (i.e., 20%). </td></tr><tr><td data-label="Key"> dtp_pct </td><td data-label="Value (example / recommended)"> 0 </td><td data-label="Type &amp; allowed values"> numeric (fraction or percent) </td><td data-label="Purpose / Validation"> DTP percentage (if used). Normalize to fraction. Default 0 if not used. </td></tr><tr><td data-label="Key"> annualization_default </td><td data-label="Value (example / recommended)"> 12 </td><td data-label="Type &amp; allowed values"> integer (e.g., 12) </td><td data-label="Purpose / Validation"> Months used when annualizing monthly gross (default 12). </td></tr><tr><td data-label="Key"> CALC_MODE </td><td data-label="Value (example / recommended)"> STANDARD </td><td data-label="Type &amp; allowed values"> string (STANDARD / ALTERNATE) </td><td data-label="Purpose / Validation"> Calculation mode. Do not change unless authorized. </td></tr><tr><td data-label="Key"> VERBOSECALC </td><td data-label="Value (example / recommended)"> FALSE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE, produce verbose per-row calculation logs (useful for debugging; avoid in large runs). </td></tr><tr><td data-label="Key"> ROUNDMIDPOINTRULE </td><td data-label="Value (example / recommended)"> BANKERS </td><td data-label="Type &amp; allowed values"> string (BANKERS / HALF_UP / TRUNCATE) </td><td data-label="Purpose / Validation"> Rounding rule used for final monetary outputs. BANKERS recommended. </td></tr><tr><td data-label="Key"> OUTPUT_CSV_BOM </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE, writers add UTF-8 BOM to CSVs for Windows Excel compatibility. Choose based on downstream consumers. </td></tr><tr><td data-label="Key"> CSV_ENCODING </td><td data-label="Value (example / recommended)"> UTF-8 </td><td data-label="Type &amp; allowed values"> string (UTF-8 / UTF-8-SIG / ANSI) </td><td data-label="Purpose / Validation"> Encoding for CSV output. Use UTF-8 or UTF-8-SIG if OUTPUT_CSV_BOM=TRUE. </td></tr><tr><td data-label="Key"> MAX_PREMI_ASURANSI_PCT </td><td data-label="Value (example / recommended)"> 0.5 </td><td data-label="Type &amp; allowed values"> numeric (fraction) </td><td data-label="Purpose / Validation"> Optional cap for premi_asuransi_employer as fraction of gross. If exceeded, loader issues WARN_BPJS_PREMI_EXCEEDS_CAP. Default 0.5 (50%). </td></tr><tr><td data-label="Key"> INCLUDE_BPJS_FIELDS_LIST </td><td data-label="Value (example / recommended)"> bpjs_ke_emp,bpjs_jkk_emp,bpjs_jkm_emp,bpjs_jht_emp,bpjs_other_emp,premi_asuransi_dari_pemberi_kerja,iuran_bpjs_employee </td><td data-label="Type &amp; allowed values"> CSV string </td><td data-label="Purpose / Validation"> List of BPJS-related columns expected when INCLUDE_BPJS_FIELDS=TRUE. Used for validation. </td></tr><tr><td data-label="Key"> QUERYTABLE_IMPORT_MODE </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE, use QueryTable import with text-preserve for nip/npwp; if FALSE, use streaming parser fallback. </td></tr><tr><td data-label="Key"> JOB_AUDIT_RETENTION_DAYS </td><td data-label="Value (example / recommended)"> 3650 </td><td data-label="Type &amp; allowed values"> integer </td><td data-label="Purpose / Validation"> Retention period for job snapshots and logs (days). Default 10 years (3650). </td></tr><tr><td data-label="Key"> SAFE_MOVE_RETRIES </td><td data-label="Value (example / recommended)"> 5 </td><td data-label="Type &amp; allowed values"> integer </td><td data-label="Purpose / Validation"> Retries used by SafeMoveFile/DeleteFileIfExists. Must be ≥ 1. </td></tr><tr><td data-label="Key"> SAFE_MOVE_BACKOFF_MS </td><td data-label="Value (example / recommended)"> 250 </td><td data-label="Type &amp; allowed values"> integer </td><td data-label="Purpose / Validation"> Milliseconds base backoff for safe-move retries. </td></tr><tr><td data-label="Key"> TIMEZONE </td><td data-label="Value (example / recommended)"> Asia/Jakarta </td><td data-label="Type &amp; allowed values"> TZ string </td><td data-label="Purpose / Validation"> Use for generated_at and job timestamps. Matches your environment. </td></tr><tr><td data-label="Key"> GENERATED_BY </td><td data-label="Value (example / recommended)"> [operator name] </td><td data-label="Type &amp; allowed values"> string </td><td data-label="Purpose / Validation"> The user/operator name; stored in manifest on job creation. Replace with actual operator. </td></tr><tr><td data-label="Key"> FX_DEFAULT_RATE </td><td data-label="Value (example / recommended)"> (blank) </td><td data-label="Type &amp; allowed values"> numeric or blank </td><td data-label="Purpose / Validation"> Default FX rate if you want implicit fallbacks. Recommended blank — force explicit fx_rate per row when currency != IDR. </td></tr><tr><td data-label="Key"> FX_FAIL_ON_MISSING </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean (TRUE / FALSE) </td><td data-label="Purpose / Validation"> If TRUE and currency != IDR and fx_rate blank, treat as validation error; recommended TRUE. </td></tr><tr><td data-label="Key"> DTP_ALLOW_NEGATIVE </td><td data-label="Value (example / recommended)"> FALSE </td><td data-label="Type &amp; allowed values"> boolean </td><td data-label="Purpose / Validation"> Prevent negative DTP adjustments. </td></tr><tr><td data-label="Key"> LOG_MASK_SENSITIVE </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean </td><td data-label="Purpose / Validation"> If TRUE, mask sensitive digits (full NPWP, NIP) in Logs. Recommended TRUE for PII protection. </td></tr><tr><td data-label="Key"> EXPORT_INCLUDE_AUDIT_FIELDS </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean </td><td data-label="Purpose / Validation"> If TRUE, append ter_map audit fields and calculation audit columns to output CSVs. Recommended TRUE for compliance. </td></tr><tr><td data-label="Key"> TEST_RUNALL_AUTOMATE </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean </td><td data-label="Purpose / Validation"> If TRUE, Test_RunAll macro will run as part of test harness in non-production copies; recommended FALSE in production workbook unless CI gating used. </td></tr><tr><td data-label="Key"> SAFE_WORKBOOK_COPY_BEFORE_MOD </td><td data-label="Value (example / recommended)"> TRUE </td><td data-label="Type &amp; allowed values"> boolean </td><td data-label="Purpose / Validation"> If TRUE, macros create a backup copy of the workbook before modifying macros/rules. Strongly recommended TRUE. </td></tr></tbody></table></div><div class="row-count">Rows: 36</div></div><div class="table-caption" id="Table4" data-table="Proj_0014_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by TER table mapping &amp; PTKP — operational guide"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">TER table mapping & PTKP — operational guide</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>1. Key concepts — full narrative expansion</strong><br>1) TER table mapping defines exactly which TER table (TER_A, TER_B, TER_C, TER_D) an employee must use, based entirely on their PTKP status. This linkage is not optional; it is the foundation for deterministic TER selection during monthly payroll calculation. Without a correct mapping, modCalc cannot reliably choose between TER regimes and will protect itself by halting the workflow through <code>ERR_TER_MISSING_PTKP_MAP</code>.<br>2) PTKP statuses originate from government definitions of household dependents and marital status. Although simple on paper (TK, K, dependents 0–3), real-world payroll systems often store PTKP in inconsistent formats: as text, numeric codes, concatenated forms, human abbreviations, or legacy internal formats. The mapping subsystem solves this by enforcing canonicalization rules that convert any plausible variation into the strict normalized form that the engine uses internally.<br>3) Each TER table embodies a structured set of gross-income ranges and their associated rates or absolute monthly deductions. PTKP→TER mapping tells the system: “For employees with PTKP X, always use TER table Y when evaluating monthly TER eligibility.” This is crucial because TER regimes can differ dramatically, and selecting the wrong table results in regulatory violations or financial exposure.<br>4) The reason mapping must be deterministic is that payroll auditing depends on reproducibility. When auditors ask why TER_B was applied to a particular employee six months ago, modCalc must produce evidence: the employee’s PTKP, its canonicalized form, the mapping snapshot used at the time, and the exact matching rule that generated the decision. Any ambiguity erodes audit reliability and exposes the operation to compliance risks.<br>5) Human input variability (spacing, hyphens, lowercase, malformed separators, invisible characters) is common in Excel files, especially when data originates from HR forms, upstream CSV exports, or manual edits. Canonicalization protects against this by using strict normalization steps — trimming whitespace, unifying separators, splitting alphabetic from numeric parts, removing meaningless prefixes — before performing the lookup.<br>6) The mapping cannot rely on heuristic or fuzzy matching. modCalc must never infer intent. It must work only through: exact match → alternate prefix match → alias → wildcard → explicit DEFAULT (only when strict disabled) → fail. This strict chain ensures the same input always produces the same outcome regardless of human inconsistencies. </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>2. Storage format in tblParams — complete narrative</strong><br>1) The preferred storage mechanism for <code>TER_TABLE_MAP</code> is a JSON dictionary stored as text in tblParams. This approach is chosen because JSON is structured, predictable, and unambiguous. It avoids the frustrations and inconsistencies introduced by spreadsheet cell formatting, hidden characters, or newline variability.<br>2) A minimal example JSON map may look like: <code>{&quot;TK/0&quot;:&quot;TER_A&quot;,&quot;K/0&quot;:&quot;TER_A&quot;,&quot;TK/1&quot;:&quot;TER_B&quot;,&quot;TK/*&quot;:&quot;TER_B&quot;,&quot;DEFAULT&quot;:&quot;TER_C&quot;}</code>. This dictionary expresses priority rules clearly: exact matches override wildcard, and wildcard overrides DEFAULT when strict mode allows it.<br>3) JSON eliminates delimiter confusion. Without JSON, users often mix commas, semicolons, or inconsistent key-value connectors. JSON forces a single standardized structure, reducing parsing failures during dry-run validation.<br>4) To ensure integrity, the loader computes a SHA256 hash of the JSON string exactly as written. This hash is stored in the manifest and the mapping snapshot, allowing auditors to confirm whether the mapping in production is identical to the original loaded content byte-for-byte.<br>5) JSON must remain flat. Nested objects, arrays, or composite rules are prohibited, as they complicate deterministic flattening logic and severely increase ambiguity risk. Every mapping must be expressed as a single-level key-value pair.<br>6) When operators use multi-line “CSV-like” key-value text (allowed but discouraged), the loader still applies strict parsing, expects lines of the form <code>source=target</code>, and rejects malformed ones. This mode requires additional governance discipline since newline-based formats are error-prone.<br>7) Whether JSON or fallback format is used, the loader’s normalized mapping is stored in the snapshot and must never be auto-corrected or rewritten; preserving human intent exactly is critical for compliance traceability.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>3. Canonicalization rules — long-form technical narrative</strong><br>1) The canonicalization engine transforms raw PTKP input into a predictable string. First, it strips whitespace — including normal spaces, non-breaking spaces, zero-width spaces, tab characters, trailing CRLF residues, and any characters generated by copy-paste from scanned PDFs.<br>2) Next, it normalizes separators. HR data often uses dashes or underscores (e.g., <code>TK-1</code>, <code>TK_2</code>, <code>K.3</code>). All these variations are interpreted as separators and unified into <code>/</code>, resulting in <code>TK/1</code>, <code>TK/2</code>, <code>K/3</code>. This unification allows employees’ data from different legacy systems to remain interoperable.<br>3) Alphabetic and numeric pieces are separated algorithmically. For example, <code>TK1</code> or <code>K03</code> must be recognized as containing both a letter group and a digit group. The canonicalization algorithm identifies the boundary and inserts <code>/</code> automatically, converting them to <code>TK/1</code> and <code>K/3</code>.<br>4) All content is uppercased after trimming. The system defines PTKP categories strictly in uppercase. Lowercase forms like <code>tk0</code>, <code>k1</code>, or mixed forms like <code>Tk/2</code> convert to uppercase deterministically.<br>5) Canonicalization removes optional prefixes (<code>PTKP_</code>) after normalization, because mapping keys are defined in canonical PTKP space without that prefix. However, for traceability the raw value is always stored unmodified in the audit log.<br>6) Invalid patterns produce immediate warnings or errors. Examples include keys with no letters (<code>&quot;0&quot;</code>), keys containing multiple digit clusters (<code>&quot;TK12&quot;</code> without separator), keys containing symbols (<code>&quot;TK@1&quot;</code>), or keys that collapse to an empty string once whitespace and separators are removed.<br>7) The loader displays canonical and raw forms side-by-side in audit fields so operators can validate that the system interpreted the PTKP correctly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>4. Mapping resolution algorithm — fully expanded operational detail</strong><br>1) The lookup algorithm is executed for every row in tblInput. After canonicalization, modCalc attempts to match the canonical form against the mapping.<br>2) Step A: exact match. If canonical PTKP equals any key in the mapping dictionary (e.g., <code>&quot;TK/1&quot;</code>), that table is returned immediately. This is the highest-priority match type and produces the most explicit audit trace.<br>3) Step B: alternate prefix match. Legacy deployments sometimes kept the <code>PTKP_</code> prefix. The loader tries <code>PTKP_TK/1</code> as a secondary check. This step maintains compatibility with older spreadsheets and avoids mapping failures when older templates are still in circulation.<br>4) Step C: alias resolution. Alias tables define canonical equivalents of common human variations. For example, <code>&quot;1&quot;</code> might be alias for <code>&quot;K/1&quot;</code>, or <code>&quot;TK&quot;</code> might alias <code>&quot;TK/0&quot;</code> in specific business rules. Aliases are curated manually and must be part of governance.<br>5) Step D: wildcard resolution. Wildcards match families of PTKP categories. For example, <code>&quot;TK/*&quot;</code> means all TK categories regardless of number of dependents. Wildcard rules must always end with <code>&quot;/*&quot;</code> and may not appear in the middle of the string. The loader sorts wildcard keys by length to ensure specific patterns (like <code>&quot;TK/3&quot;</code>) win over generic ones.<br>6) Step E: default. If strict mode disabled and <code>&quot;DEFAULT&quot;</code> exists, unmapped statuses fall back to this default table. This mechanism is intended for deployments with incomplete PTKP coverage but must be heavily audited. Every use triggers a warning.<br>7) Step F: failure. If no rule matches, loader raises <code>ERR_TER_MISSING_PTKP_MAP</code>, stopping the workflow. This guardrail prevents silent tax misclassification, which is far more dangerous than workflow interruption.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>5. Supported features and limitations — long-form expansion</strong><br>1) Exact mapping is mandatory for all formally recognized PTKP categories. Wildcards and default are convenience tools, not substitutes for correct governance.<br>2) Wildcards cannot reference invalid root categories. <code>&quot;TX/*&quot;</code> or <code>&quot;EMPLOYEE/*&quot;</code> must be rejected immediately. Only categories recognized in regulation (primarily TK and K) may appear.<br>3) Alias tables must remain intentionally small. Excessive alias use increases the probability of ambiguous matches. For example, alias <code>&quot;TK&quot;</code> → <code>&quot;TK/0&quot;</code> must never be combined with an alias <code>&quot;0&quot;</code> → <code>&quot;TK/0&quot;</code> because raw input <code>&quot;0&quot;</code> would resolve ambiguously.<br>4) Mapping cannot reference tables other than TER_A–TER_D. Custom tables or experimental tables are not allowed. If the mapping references <code>&quot;TER_X&quot;</code> or <code>&quot;TER_2024&quot;</code>, dry-run must reject the rule.<br>5) Mapping cannot override runtime gating (eligibility gates). Even if mapping assigns <code>&quot;TK/1&quot;</code>→<code>&quot;TER_A&quot;</code>, TER still applies only if monthly rules allow it (employee regular monthly, not final month, not contractor, etc.).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>6. Alias and normalization table — in-depth operational narrative</strong><br>1) Alias tables are designed to protect against inconsistent HR data entry, especially in systems where PTKP selection appears as a dropdown without strict validation. Aliases allow the system to unify sloppy but common patterns without interrupting the payroll run.<br>2) Aliases themselves undergo canonicalization and must evaluate to valid canonical PTKP categories. If someone attempts to create alias <code>&quot;PTKP_UNKNOWN&quot;</code> → <code>&quot;TK/0&quot;</code>, loader must reject it.<br>3) Alias application is always logged. It records: original raw value, canonical form, alias key triggered, alias target, and resulting PTKP for lookup. This creates a transparent audit trail and avoids silent reinterpretation of employee categorization.<br>4) Alias sets should be versioned and governed the same way TER tables are governed. Each modification must produce a TER_ChangeLog entry documenting who changed what and why.<br>5) Alias rules must never create infinite loops or circular mappings. Loader must check for cycles such as alias A→B and alias B→A.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>7. Loader dry-run behavior & error catalog — detailed narrative</strong><br>1) Dry-run is a simulation mode that validates all components of the mapping without committing them. Operators must always run dry-run before committing, because TER mapping errors can cause widespread payroll inconsistencies.<br>2) Dry-run verifies JSON integrity, checks for duplicated keys, inspects wildcard validity, validates aliases, and ensures that every mapped value corresponds to a real TER table.<br>3) It then scans tblInput to detect all distinct PTKP values that will be encountered during actual payroll calculation. Any PTKP that cannot be mapped triggers fatal errors.<br>4) The loader performs deep structural validation: ensuring no wildcard patterns appear in the wrong format, rejecting embedded spaces in keys, detecting nested wildcard forms, and checking that no mapping key is an empty string.<br>5) Dry-run returns a rich report including: errors, warnings, the normalized form of the mapping, preview of lookup results for all PTKP observed, and a SHA256 hash. The operator must review all results and correct issues before proceeding.<br>6) Fatal errors include: malformed JSON, duplicate mapping keys, ambiguous wildcard resolution, references to nonexistent TER tables, alias cycles, invalid separators, and unresolved PTKP statuses.<br>7) Warnings include: use of default mapping, use of wildcard for official government categories, alias triggered unexpectedly often, malformed but correctable spacing removed during canonicalization, or deprecated patterns detected.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>8. Runtime behavior after commit — expanded operational discipline</strong><br>1) After commit, mapping becomes part of the active runtime snapshot tied to a unique <code>ter_table_load_id</code>. This ensures that if you rerun a payroll from six months ago with that load id, modCalc produces identical results.<br>2) Every calculation row stores mapping metadata: raw PTKP, canonical PTKP, match type (exact, alias, wildcard, default), the selected TER table, and any relevant warnings. These metadata are stored in the row audit so operators can trace every decision.<br>3) Snapshot immutability is crucial. Once committed, neither operators nor automated processes may edit the mapping or TER tables without triggering a new load id. This ensures consistent and auditable state across time.<br>4) Export files must include mapping audit fields so downstream systems, compliance auditors, or back-office divisions can confirm PTKP classification correctness.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>9. Tests & sample vectors — deeply elaborated narrative</strong><br>1) Test exact matches thoroughly by inputting multiple common variants to ensure they all lead to the same canonical form and mapping result.<br>2) Test alias-based mappings, ensuring alias triggers exactly when intended and never masks valid canonical inputs.<br>3) Test wildcard ordering by including multiple wildcard rules and verifying that the most specific fires first.<br>4) Test strict mode vs non-strict mode by intentionally omitting a mapping for a PTKP that appears rarely. Strict mode should stop commit; non-strict should fallback to default and warn.<br>5) Test regressions by loading multiple previous snapshots and verifying that audit outputs remain unchanged.<br>6) Test structural failures intentionally: invalid JSON, duplicated keys, invalid characters, malformed separators, or using invalid TER table names.<br>7) Test in realistic payroll scenarios by running calc batches with low-, mid-, and high-income employees across all PTKP categories.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>10. Implementation guidance — expanded technical deep dive</strong><br>1) Canonicalization must be pure and stateless; all components requiring PTKP should rely on the same function to avoid inconsistencies.<br>2) Internally, the mapping should be represented as three data structures: exact map (key→table), alias map (aliasKey→canonicalTarget), and wildcard list sorted by specificity.<br>3) Wildcard matching must avoid partial or fuzzy matching. Patterns like <code>&quot;TK/*&quot;</code> can only match <code>&quot;TK/anything&quot;</code> with the exact prefix followed by a slash.<br>4) Mapping parser must reject trailing delimiters (e.g., <code>&quot;TK/1/&quot;: &quot;TER_A&quot;</code>).<br>5) Ensure mapping is serialized for snapshot storage precisely as originally provided, preserving ordering and whitespace to maintain auditability.<br>6) Implement clear error messages with actionable guidance, listing both the failing key and the expected canonical pattern.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>11. Logging, error codes, remediation — extended description</strong><br>1) Every mapping load operation must produce a structured log containing operator identity, timestamp, mapping hash, load id, and validation details.<br>2) Error codes must remain stable across versions so that operational playbooks and governance documents continue to function without update churn.<br>3) Logs must contain contextual evidence for remediation: raw key, canonical form, failed mapping rule, candidate wildcard matches, and recommended correction.<br>4) After fixes, rerun dry-run to ensure all remediation succeeded. Only then proceed to commit.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>12. Governance & change control — detailed procedural narrative</strong><br>1) Mapping is a compliance-sensitive artifact. Any modification requires justification, regulatory reference, testing, sign-off, and snapshot creation.<br>2) Governance rules prohibit ad-hoc changes without documentation. Every change must appear in TER_ChangeLog with user identity, reason, supporting documents, and SHA256 of source mapping file.<br>3) Emergency overrides may only persist for a single batch run. Within 24 hours the mapping must be updated formally, documented, and committed to ensure audit integrity.<br>4) Quarterly mapping review is recommended. This review checks for deprecated wildcard rules, unused alias rules, or inconsistencies with updated regulatory guidance.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>13. Export & manifest requirements — expanded</strong><br>1) The manifest must include complete metadata for both TER tables and mapping (hashes, load id, timestamps, file metadata).<br>2) Snapshots must be archived in a controlled directory and tagged with the load id. Deleting or modifying old snapshots is prohibited.<br>3) Exports referencing payroll calculations must include audit fields, enabling external systems to reconstruct the PTKP classification decision path without ambiguity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>14. Minimal operational checklist — expanded procedural detail</strong><br>1) Confirm mapping JSON is valid and strict canonicalization produces expected results.<br>2) Detect all raw PTKP values in tblInput and verify none remain unmapped.<br>3) Evaluate all warnings; confirm no governance violation. Append decision notes to TER_ChangeLog.<br>4) Commit only after mapping passes dry-run with zero errors. Validate load id, rerun sample dataset, inspect audit outputs, archive snapshot.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>15. Concrete examples & audit expectations — expanded</strong><br>1) Example mapping: <code>{&quot;TK/0&quot;:&quot;TER_A&quot;,&quot;K/1&quot;:&quot;TER_B&quot;,&quot;TK/*&quot;:&quot;TER_B&quot;,&quot;DEFAULT&quot;:&quot;TER_C&quot;}</code>.<br>2) For raw <code>&quot; tk0 &quot;</code>, canonical is <code>&quot;TK/0&quot;</code>, match_type is EXACT, and audit logs show lookup_key <code>&quot;TK/0&quot;</code> mapping to <code>TER_A</code>.<br>3) For raw <code>&quot;TK5&quot;</code> in a setup where <code>&quot;TK/*&quot;</code> exists, canonical <code>&quot;TK/5&quot;</code> matches wildcard and is logged accordingly.<br>4) For raw blank PTKP, behavior depends on strict: strict errors; non-strict uses DEFAULT and logs a warning.<br>5) For alias <code>&quot;1&quot;</code>→<code>&quot;K/1&quot;</code>, audit logs show alias triggered and resulting PTKP resolved normally.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>16. Tests to run now — extended</strong><br>1) Test JSON edge cases: embedded quotes, unescaped characters, trailing commas.<br>2) Test table name validity: referencing TER_D only if allowed, rejecting nonexistent tables.<br>3) Test strict vs non-strict interaction with DEFAULT.<br>4) Test wildcard priority ordering extensively with multiple wildcard layers.<br>5) Test alias cycles, ambiguous legacy data, malformed inputs, unicode-laden keys.<br>6) Test full payroll dataset end-to-end to ensure mapping behaves identically with realistic volumes and diverse PTKP ranges.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>17. Frequent mistakes & mitigation — expanded</strong><br>1) Mistake: relying on implicit defaults instead of explicitly defining mapping keys. Mitigation: strict mode and governance policies forbid implicit mapping for regulated categories.<br>2) Mistake: overusing wildcard rules. Mitigation: enforce wildcard governance checklist and require business justification for coverage expansion.<br>3) Mistake: forgetting changelog entries. Mitigation: commit workflow requires blocking commit until changelog included.<br>4) Mistake: inconsistent separators or malformed human edits. Mitigation: canonicalization and strict dry-run validation catch these early.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational guide"> <strong>18. Final authoritative checklist — fully expanded</strong><br>1) Always canonicalize first; never skip or modify the canonicalization pipeline.<br>2) Follow strict matching order: exact → prefix-compatible → alias → wildcard → default (strict disabled only) → fail.<br>3) Maintain snapshot immutability: once committed, mapping must never be altered; introduce a new snapshot for every change.<br>4) Ensure all governance artifacts are complete: changelog, mapping hash, load id, timestamps, and supporting documents.<br>5) Validate that every calculated payroll row can be explained months later by referencing the exact snapshot, PTKP, audit logs, and mapping.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td></tr></tbody></table></div><div class="row-count">Rows: 18</div></div><div class="table-caption" id="Table5" data-table="Proj_0014_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">TER table mapping & PTKP — operational analysis, edge-cases, telemetry, tests, and remediation</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>Overview</strong><br>Mapping is small surface area with outsized risk: a single mis-mapped PTKP can misapply months of taxation, trigger audits, and cause payroll rework. “Thinking longer” means anticipating failure modes, designing observability, automating repeatable tests, and locking governance so that human error cannot silently change outcomes. The sections below add concrete operational, forensic, and monitoring guidance beyond the canonical loader logic.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>1. Forensic sample: concrete audit record for one failing row</strong><br>1) Raw input: rowIndex=42, nip=0002042, ter_category="tk0 ", period=2025-11, gross=7,500,000, currency=IDR.<br>2) Canonicalize step: raw_trim -> "tk0" -> replace separators -> "TK0" -> insert slash -> "TK/0". Record canonical_ptkp="TK/0".<br>3) Mapping lookup: mapping does not contain "TK/0" but contains wildcard "TK/<em>". Wildcard match selected; ter_table=TER_B; ter_map_match_type=WILDCARD; ter_map_lookup_key="TK/</em>".<br>4) Audit output row: include fields canonical_ptkp, ter_table, ter_map_match_type, ter_map_lookup_key, ter_table_load_id, mapping_hash, mapping_source (tblParams), mapping_commit_user, mapping_commit_ts, warnings=[ "Used wildcard TK/*; no exact match for TK/0"].<br>5) Forensic action: operator inspects Logs and TER_ChangeLog; if mapping was intended to be TER_A for TK/0, operator must create TER_ChangeLog entry, correct mapping, run dry-run, rerun CalcBatch with same ter_table_load_id new snapshot, and then perform corrective payroll reconciliation. </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>2. Observability & telemetry (must-have signals)</strong><br>1) Metric: percent_rows_defaulted = (# rows that used DEFAULT mapping) / (# processed rows). Alert if > 0.5% for a payroll run.<br>2) Metric: percent_rows_wildcard = (# rows resolved by wildcard) / total. Track trend weekly; wildcards should be stable and rare for regulated categories.<br>3) Metric: distinct_unmapped_ptkp_preview_count returned by dry-run. If > 0, block commit unless governance explicitly approves.<br>4) Event: mapping_commit_success (emit mapping_hash, ter_table_load_id, user, ts). Store in centralized audit DB along with job_id.<br>5) Log-level: for each row where alias/wildcard/default is used, log a structured JSON event with raw, canonical, chosen_key, match_type, ter_table_load_id, mapping_hash, and a short human message. Retain logs for min 2 years.                                                                                                                                                                                                                  </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>3. Real-world ambiguous input examples & strict responses</strong><br>1) Input: "1" — ambiguous. If alias exists for "1" → K/1, loader uses alias; else fail under strict. Always require alias to be explicit; never infer "1" → "K/1" automatically without alias.<br>2) Input: "TK00" — ambiguous numeric padding. Canonicalize to "TK/0" by trimming leading zeros on numeric segment; log transformation "TK00"→"TK/0". If transformation required, produce a WARN_TRANSFORMED_CANONICAL and surface for operator approval during dry-run.<br>3) Input: "PTKP_ K2" — loader should remove PTKP_ prefix and canonicalize; if downstream mapping uses <code>K/2</code> ensure both <code>K/2</code> and <code>PTKP_K/2</code> alternate lookup is attempted.                                                                                                                                                                                                                                                                                                                                                                </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>4. Fail-safe patterns (design): quick rules to abort safely</strong><br>1) Abort commit if dry-run.errors contains any ERR_TER_MISSING_PTKP_MAP unless operator sets EXPLICIT_OVERRIDE=true with an audit entry.<br>2) Reject any mapping that references non-existent TER tables. This prevents misrouting to unexpected code paths.<br>3) If ambiguous wildcard matches exist (ERR_TER_AMBIGUOUS_MAP), block commit and require mapping refinement. Do not allow automated tie-breakers.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>5. Remediation playbook for ERR_TER_MISSING_PTKP_MAP</strong><br>1) Triage: extract unique list of missing canonical keys and sample rows (nip, rowIndex, raw value).<br>2) Decide: (A) add mapping for each missing key, (B) add alias mapping, (C) designate DEFAULT with documented rationale and governance approval. Record decision in TER_ChangeLog.<br>3) Implement change in staging: update tblParams.TER_TABLE_MAP, run LoadMappingDryRun(); ensure errors=0.<br>4) Commit new mapping snapshot; re-run CalcBatch on affected rows. Produce reconciliation CSV comparing old output vs new output for legal/finance teams.                                                                                                                                                                                                                                                                                                                                                                                                                                                         </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>6. Test matrix — coverage you must implement</strong><br>1) Canonicalization tests: list 50 human variations (spacing, punctuation, non-ASCII) and assert canonical_ptkp is deterministic.<br>2) Mapping tests: exact hits, alias hits, wildcard hits, default hits, ambiguous wildcards. For each test assert ter_map_match_type and ter_map_lookup_key.<br>3) Dry-run vs commit parity: confirm dry-run preview results equal runtime results for the same mapping snapshot.<br>4) Backfill simulation: populate historical run with older mapping snapshot and verify outputs match archived payroll. This ensures snapshot immutability.                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>7. Rollback & emergency procedures (precise steps)</strong><br>1) If an erroneous mapping was committed and used, immediately create TER_ChangeLog entry explaining emergency rollback and fix.<br>2) Create a new mapping snapshot that restores previous mapping (use ter_table_load_id from archive). Run dry-run to confirm zero errors.<br>3) Publish rollback snapshot and set it as active; re-run CalcBatch for the affected job or create reconciliation entries for downstream posting systems.<br>4) Always document corrective entries in payroll ledger with cross-reference to ter_table_load_id and TER_ChangeLog.                                                                                                                                                                                                                                                                                                                                                                                                                                                             </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>8. Example manifest additions (fields you must include)</strong><br>1) ter_table_load_id: unique string.<br>2) mapping_hash: sha256 of mapping JSON.<br>3) mapping_source: "tblParams" or "override".<br>4) mapping_commit_user & mapping_commit_ts.<br>5) mapping_preview_count and mapping_unmapped_preview (array).<br>6) ter_map_snapshot_path and ter_map_snapshot_sha256. These ensure machine and human auditors can verify chain-of-custody easily.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>9. Row-level audit CSV schema (append to bukti_potong.csv)</strong><br>1) canonical_ptkp, ter_table, ter_map_lookup_key, ter_map_match_type, ter_map_load_id, ter_map_source, ter_map_hash, ter_map_warning_codes (array), ter_map_error_code (nullable).<br>2) Keep these columns at the end of CSV to preserve compatibility with older integrations. Ensure CSV writers support UTF-8 BOM toggle per settings.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>10. Monitoring dashboards (suggested panels & alerts)</strong><br>1) Panel: weekly trend of percent_rows_wildcard and percent_rows_default; alert threshold configurable (example: 1% for wildcard, 0.1% for default).<br>2) Panel: mapping_commit_rate (commits per month) with drilldown to change authors and TER_ChangeLog entries.<br>3) Alert: any ERR_TER_MISSING_PTKP_MAP during dry-run should open a Sev-2 incident and notify payroll ops.<br>4) Panel: top 20 unmapped canonical_ptkp samples across last 30 days.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>11. Example log messages (format & content)</strong><br>1) INFO: mapping_commit_success — {user, ter_table_load_id, mapping_hash, ts}.<br>2) WARN: wildcard_used — {rowIndex, raw, canonical, wildcard_key, ter_table_load_id}.<br>3) ERROR: ERR_TER_MISSING_PTKP_MAP — {missing_keys:[...], sample_rows:[{nip,rowIndex,raw}], mapping_hash}.<br>4) REMEDIATION entries appended to Logs when TER_ChangeLog is created. Logs must be immutable (append-only) and exportable.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>12. Edge-case: concurrent commits & consistency</strong><br>1) Prevent race conditions: mapping commit must obtain exclusive lock on ter_map snapshot namespace. If two operators attempt commit concurrently, second commit must fail with <code>ERR_TER_CONCURRENT_COMMIT</code> and require retry after rebase.<br>2) If override is applied in Settings (OVERRIDE_TER_TABLE_MAP), record override_user and override_expiry_ts; ensure override is ephemeral and expires at job end or explicit revoke.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>13. Security & access control</strong><br>1) Only authorized roles (mapping_admin) can edit tblParams.TER_TABLE_MAP or create OVERRIDE_TER_TABLE_MAP. Enforce via workbook-level ACLs or external orchestration system.<br>2) Mapping files and snapshots must be stored in an access-controlled output folder with audited access logs. Do not store mapping JSON inline in email or chat logs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>14. Performance considerations (scale)</strong><br>1) Mapping lookup is O(1) for exact/alias and O(n) for wildcard where n = number of wildcard keys; keep wildcard list small (recommended < 50).<br>2) Dry-run validation scales with number of distinct PTKP in tblInput; if tblInput has hundreds of thousands of rows, first compute distinct values and validate those only. This reduces I/O and speeds the dry-run.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>15. Governance policy template (minimal)</strong><br>1) Title: TER Mapping Change Policy.<br>2) Purpose: ensure deterministic mapping changes with auditability.<br>3) Scope: any edits to TER_TABLE_MAP or TER_TABLE_DEFAULT or alias definitions.<br>4) Approval: change requires 2 approvers (Payroll Lead + Compliance) for production commits. Emergency override allowed with 1 approver but must be followed by 2-approver commit within 24 hours.<br>5) Retention: keep TER_ChangeLog and snapshots for 7 years.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>16. Extended test scaffold (automation blueprint)</strong><br>1) Unit tests: canonicalization suite of 200 strings, mapping parse tests, alias cycle detection. Run in CI on every PR that touches mapping code.<br>2) Integration tests: create synthetic tblInput with all PTKP variants and assert mapping match_type distribution unchanged across code releases.<br>3) Regression tests: snapshot replay — run CalcBatch using archived ter_table_load_id and assert outputs identical to archived job outputs.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>17. Example remediation ticket template</strong><br>1) Title: [URGENT] Missing PTKP mapping for 'TK/4' in ter_table_load_id t2025-11-001.<br>2) Description: include sample rows, count of affected employees, payroll impacts (estimated monetary variance), and suggested mapping fix.<br>3) Urgency: high. Action: update mapping, dry-run, commit, and create adjustment entries. Attach TER_ChangeLog entry and manifest.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </td></tr><tr><td data-label="TER table mapping &amp; PTKP — operational analysis, edge-cases, telemetry, tests, and remediation"> <strong>18. Final operational checklist (condensed actionable steps)</strong><br>1) Run LoadMappingDryRun(); confirm errors=[] and warnings reviewed.<br>2) Ensure TER_ChangeLog entry exists with justification for changes.<br>3) Commit mapping snapshot; record ter_table_load_id & mapping_hash in manifest and Logs.<br>4) Run CalcBatch for representative sample and publish audit CSV with mapping fields appended.<br>5) Monitor telemetry for anomalies (wildcard/default usage) for the first three payroll cycles after change.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </td></tr></tbody></table></div><div class="row-count">Rows: 19</div></div><div class="table-caption" id="Table6" data-table="Proj_0014_06" style="margin-top:2mm;margin-left:3mm;"><strong>Table 6</strong></div>
<div class="table-wrapper" data-table-id="table-6"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Row summary"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Row summary</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Row summary"> Row 1 — rowIndex 1, nip 0012345, name Test User<br>gross: 10,000,000 IDR; currency: IDR; gross_for_tax: 10,000,000; annual_gross: 120,000,000<br>employerBPJS: 357,000; employeeBPJS: 200,000<br>NPWP: has (no penalty); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p (p = TER_percent from LookupTERRow). </td></tr><tr><td data-label="Row summary"> Row 2 — rowIndex 2, nip 0001001, name Sari Wijaya<br>gross: 8,500,000 IDR; currency: IDR; gross_for_tax: 8,500,000; annual_gross: 102,000,000<br>employerBPJS: 130,500; employeeBPJS: 150,000<br>NPWP: has (no penalty); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p (absolute BPJS values take precedence over percent). </td></tr><tr><td data-label="Row summary"> Row 3 — rowIndex 3, nip 0001002, name Agus Pratama<br>gross: 12,000,000 IDR; currency: IDR; gross_for_tax: 12,000,000; annual_gross: 144,000,000<br>employerBPJS: 0; employeeBPJS (default 2%): 240,000<br>NPWP: none → NPWP penalty applies (default ×1.20); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p × 1.20. </td></tr><tr><td data-label="Row summary"> Row 4 — rowIndex 4, nip 0001003, name Lina Hartati<br>gross: 7,000,000 IDR; currency: IDR; gross_for_tax: 7,000,000; annual_gross: 84,000,000<br>employerBPJS: 94,200; employeeBPJS: 120,000<br>NPWP: has (no penalty); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p. </td></tr><tr><td data-label="Row summary"> Row 5 — rowIndex 5, nip 0001004, name Budi Santoso<br>gross: 15,000,000 IDR; currency: IDR; gross_for_tax: 15,000,000; annual_gross: 180,000,000<br>employerBPJS: 208,500; employeeBPJS: 225,000<br>NPWP: has (no penalty); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p. </td></tr><tr><td data-label="Row summary"> Row 6 — rowIndex 6, nip 0001005, name Maya Putri<br>gross: 4,500,000 IDR; currency: IDR; gross_for_tax: 4,500,000; annual_gross: 54,000,000<br>employerBPJS: 78,500; employeeBPJS: 90,000<br>NPWP: has (no penalty); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p (compare percent-derived vs absolute and log differences). </td></tr><tr><td data-label="Row summary"> Row 7 — rowIndex 7, nip 0001006, name Rudi Kurnia<br>gross: 20,000,000 IDR; currency: IDR; gross_for_tax (if no SolveGrossUp): 20,000,000; annual_gross: 240,000,000<br>employerBPJS: 311,000; employeeBPJS: 300,000<br>NPWP: has (no penalty); gross_up_flag: true — <strong>run SolveGrossUp before CalcRow if gross-up semantics required</strong><br>monthly_withholding = gross_for_tax × p (or recomputed after SolveGrossUp). </td></tr><tr><td data-label="Row summary"> Row 8 — rowIndex 8, nip 0001007, name Indah Lestari<br>gross: 9,500,000 IDR; currency: IDR; gross_for_tax: 9,500,000; annual_gross: 114,000,000<br>employerBPJS: 115,000; employeeBPJS: 180,000<br>NPWP: none → NPWP penalty applies (×1.20); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p × 1.20. </td></tr><tr><td data-label="Row summary"> Row 9 — rowIndex 9, nip 0001008, name Hendra Wijaya<br>gross: 3,000,000 IDR; currency: IDR; gross_for_tax: 3,000,000; annual_gross: 36,000,000<br>employerBPJS: 47,100; employeeBPJS: 50,000<br>NPWP: has (no penalty); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p. </td></tr><tr><td data-label="Row summary"> Row 10 — rowIndex 10, nip 0001009, name Farah Ningsih<br>gross: 18,000,000 IDR; currency: IDR; gross_for_tax: 18,000,000; annual_gross: 216,000,000<br>employerBPJS: 259,800; employeeBPJS: 315,000<br>NPWP: has (no penalty); gross_up_flag: false<br>monthly_withholding = gross_for_tax × p. </td></tr></tbody></table></div><div class="row-count">Rows: 10</div></div><div class="table-caption" id="Table7" data-table="Proj_0014_07" style="margin-top:2mm;margin-left:3mm;"><strong>Table 7</strong></div>
<div class="table-wrapper" data-table-id="table-7"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by TER_TABLE_MAP"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">TER_TABLE_MAP</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="TER_TABLE_MAP"> <strong>Purpose (one sentence)</strong><br>Provide a fully-detailed, single-source plan and paste-ready artifacts so the loader canonicalizes human-entered PTKP tokens via an alias table, validates with <code>LoadMappingDryRun()</code>, and snaps the mapping with <code>SetTERTables(..., commit=True)</code>. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Storage options (choose one & record in TER_ChangeLog)</strong><br>Option A — Inline in <code>TER_TABLE_MAP.alias</code> (recommended for small/medium mappings; single snapshot).<br>Option B — Separate <code>ALIAS_TABLE</code> key in <code>tblParams</code> (recommended for heavy or frequently-edited alias lists).<br>Document chosen option and source (who/why/JSON) in <code>TER_ChangeLog</code> before commit. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Canonicalization rules (exact algorithm you must enforce)</strong><br>1. Trim leading/trailing whitespace.<br>2. Replace runs of whitespace with single space; remove internal non-alphanumeric separators except preserve <code>/</code> as canonical separator.<br>3. Insert <code>/</code> between letter groups and numeric groups when missing (e.g., <code>TK0</code> → <code>TK/0</code>).<br>4. Uppercase all letters.<br>5. Remove <code>PTKP_</code> prefix for alias-checking but preserve raw for audit.<br>6. Collapse repeated slashes. <br>Store both the <em>raw</em> and <em>canonicalized</em> token in preview output. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Lookup precedence (strict order loader must use)</strong><br>1) canonicalized string → exact lookup in <code>TER_TABLE_MAP.exact</code>.<br>2) alias lookup (on both raw and canonicalized forms — attempt both) → maps alias key → canonical key (NOT to TER table).<br>3) wildcard rules (apply only if no exact/alias found).<br>4) <code>default</code> mapping (if <code>STRICT_TER_MAP = FALSE</code>).<br>5) error (if <code>STRICT_TER_MAP = TRUE</code>). </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Alias constraints & rules</strong><br>- Alias values must be canonical keys (e.g., <code>&quot;TK0&quot;:&quot;TK/0&quot;</code>).<br>- Do NOT map aliases directly to <code>TER_X</code> values.<br>- No circular aliases (A→B and B→A).<br>- Alias keys matched case-insensitively after canonicalization; loader should normalize alias keys on load.<br>- Prefer including both common raw variants and the most-likely canonicalized forms to maximize hit-rate (e.g., include <code>TK0</code> and <code>TK/0</code> only if you want explicit alias behavior). </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Wildcard semantics</strong><br>- Wildcards allowed only in <code>TER_TABLE_MAP.wildcard</code> with explicit validation (no ambiguous patterns like <code>*</code> that match everything).<br>- Wildcard precedence is lowest (after alias).<br>- Loader must detect overlapping wildcard rules and raise <code>ERR_TER_OVERLAP</code> in STRICT import. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Validation & dry-run contract</strong><br><code>LoadMappingDryRun()</code> must return a structured result: <code>{ mapping_parsed: bool, mapping_hash: str, errors: [], warnings: [], preview_mappings: [{ raw, canonical, lookup_key, match_type, alias_target?, ter_table? }], distinct_keys_count: int }</code>.<br><code>errors[]</code> must be non-empty for fatal problems (parse failure, circular alias, alias→non-canonical target).<br><code>warnings[]</code> for non-fatal: duplicate alias definitions that agree, alias mapping to unrecognized canonical key (if permitted as warning), overlap in wildcard rules (LENIENT policy), JSON length near Excel limit. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Top 20 checks to run in dry-run & post-commit (exhaustive)</strong><br>1. JSON parse success (<code>mapping_parsed = true</code>).<br>2. mapping_hash computed and stable.<br>3. No <code>ERR_TER_MAP_PARSE_ERROR</code>.<br>4. No circular alias detected.<br>5. All alias values resolve to canonical keys that either exist in <code>exact</code> or follow canonical pattern (e.g., <code>^[A-Z]+\/\d+$</code>).<br>6. Duplicate alias with conflicting targets → error.<br>7. Alias collisions across <code>TER_TABLE_MAP.alias</code> and separate <code>ALIAS_TABLE</code> → warning or error depending on precedence policy.<br>8. Preview contains representative samples (TK0, k1, PTKP_TK0, 1, K/I).<br>9. match_type correctness (EXACT vs ALIAS vs WILDCARD vs DEFAULT).<br>10. Distinct preview_keys <= <code>PREVIEW_SAMPLE_KEYS_LIMIT</code> (or truncated with warning).<br>11. Wildcard overlap detection. <br>12. Effective date overlaps (if TER entries are time-scoped).<br>13. <code>TER_MAP_VALID_TARGETS</code> enforcement (only TER_A..TER_D).<br>14. Mapping JSON size < Excel cell limit if pasted inline. <br>15. <code>ENFORCE_CHANGELOG</code> entry present before commit. <br>16. <code>TER_ChangeLog</code> row inserted and persisted. <br>17. Snapshot file <code>ter_map_snapshot/&lt;ter_table_load_id&gt;.json</code> created with same mapping_hash. <br>18. Manifest contains mapping_hash and ter_table_load_id. <br>19. Audit fields appear in sample output CSVs. <br>20. No <code>ERR_TER_MISSING_PTKP_MAP</code> for validated sample set when <code>STRICT_TER_MAP=TRUE</code>. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Suggested automated unit & integration tests (CI)</strong><br>- Canonicalization unit tests: dozens of variants including whitespace, separators, prefix removal.<br>- Alias-only mapping tests: alias resolves to canonical then to TER.<br>- Exact vs alias precedence tests: ensure exact wins.<br>- Alias->non-canonical detection test (should error).<br>- Circular alias detection test.<br>- Wildcard overlap and precedence tests.<br>- Dry-run → commit → manifest roundtrip test (hash consistency).<br>- Excel paste limit test (>32k chars triggers file path fallback). </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Error codes & remediation mapping (quick)</strong><br>- <code>ERR_TER_MAP_PARSE_ERROR</code> → fix JSON quoting/trailing commas/line breaks.<br>- <code>ERR_TER_ALIAS_CIRCULAR</code> → remove circular entries or add exact mapping.<br>- <code>ERR_TER_ALIAS_TARGET_UNKNOWN</code> → add canonical key to <code>exact</code> or correct alias target.<br>- <code>ERR_TER_OVERLAP</code> → tighten wildcard rules or make absolute exact entries.<br>- <code>ERR_TER_MISSING_PTKP_MAP</code> → add exact or alias mapping; if acceptable, set <code>TER_TABLE_DEFAULT</code> when <code>STRICT_TER_MAP=FALSE</code>. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Excel-specific operational rules (practical)</strong><br>- Prefer single-line JSON in Formula Bar to avoid embedded CR/LF.<br>- If multi-line must be used, ensure loader strips CR/LF before JSON parse.<br>- Paste via Notepad → Formula Bar to avoid Autofill/Autoformat.<br>- If JSON > 32,000 chars, place file in <code>TER_SOURCE_FOLDER</code> and set <code>TER_SOURCE</code> reference instead of inline cell. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Audit fields & CSV behavior required</strong><br>- After commit and run, outputs must include <code>canonical_ptkp</code>, <code>ter_table</code>, <code>ter_map_lookup_key</code>, <code>ter_map_match_type</code>, <code>ter_map_load_id</code>, <code>ter_map_hash</code> (if <code>EXPORT_INCLUDE_AUDIT_FIELDS=TRUE</code>).<br>- CSV writing must be atomic (<code>.tmp</code> → rename), BOM behavior per <code>OUTPUT_CSV_BOM</code>/<code>CSV_ENCODING</code>. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Security & governance</strong><br>- <code>ENFORCE_CHANGELOG = TRUE</code> must block commit if <code>TER_ChangeLog</code> missing.<br>- Log masking per <code>LOG_MASK_SENSITIVE</code> for NPWP/NIP when writing Logs or manifest metadata.<br>- Only operators with appropriate ACLs should be allowed to change <code>TER_TABLE_MAP</code> or <code>ALIAS_TABLE</code> keys; record <code>GENERATED_BY</code>. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Operational playbook (step-by-step, explicit)</strong><br>1. Choose storage option (A recommended). Record in TER_ChangeLog draft.<br>2. Backup workbook copy (SAFE_WORKBOOK_COPY_BEFORE_MOD=true).<br>3. Paste single-line JSON into <code>tblParams</code> TER_TABLE_MAP value cell.<br>4. Run lightweight canonicalization spot-check on a 10-row sample from <code>tblInput</code>.<br>5. Run <code>LoadMappingDryRun()</code> — inspect <code>errors[]</code> first, then <code>warnings[]</code>, then <code>preview_mappings</code>.<br>6. Fix any <code>errors[]</code>; iterate until <code>errors</code> empty and <code>preview_mappings</code> satisfy expectations.<br>7. Add <code>TER_ChangeLog</code> entry (who/why/JSON hash).<br>8. Run <code>SetTERTables(..., commit=True)</code> — confirm <code>ter_table_load_id</code> and <code>mapping_hash</code> returned.<br>9. Run <code>CalcBatch</code> on representative dataset; confirm audit fields in outputs.<br>10. Persist manifest and snapshots. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Merged single-line TER_TABLE_MAP JSON (Option A example — paste-ready)</strong><br><em>Adjust exact→TER assignments to your real TER mapping before commit.</em><br><strong>Single-line JSON (merged exact + alias + empty wildcard + blank default):</strong><br><code>{&quot;exact&quot;:{&quot;TK/0&quot;:&quot;TER_A&quot;,&quot;K/0&quot;:&quot;TER_A&quot;,&quot;K/1&quot;:&quot;TER_B&quot;,&quot;K/2&quot;:&quot;TER_B&quot;,&quot;K/3&quot;:&quot;TER_C&quot;,&quot;TK/1&quot;:&quot;TER_A&quot;,&quot;K/I0&quot;:&quot;TER_C&quot;},&quot;alias&quot;:{&quot;TK0&quot;:&quot;TK/0&quot;,&quot;TK1&quot;:&quot;TK/1&quot;,&quot;TK2&quot;:&quot;TK/2&quot;,&quot;TK3&quot;:&quot;TK/3&quot;,&quot;K0&quot;:&quot;K/0&quot;,&quot;K1&quot;:&quot;K/1&quot;,&quot;K2&quot;:&quot;K/2&quot;,&quot;K3&quot;:&quot;K/3&quot;,&quot;PTKP_TK0&quot;:&quot;TK/0&quot;,&quot;PTKP_K1&quot;:&quot;K/1&quot;,&quot;1&quot;:&quot;K/1&quot;,&quot;0&quot;:&quot;TK/0&quot;,&quot;TK&quot;:&quot;TK/0&quot;,&quot;K&quot;:&quot;K/0&quot;,&quot;K/I&quot;:&quot;K/I0&quot;},&quot;wildcard&quot;:{},&quot;default&quot;:&quot;&quot;}</code> </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>LoadMappingDryRun() simulation (example output for common tokens)</strong><br><code>{ &quot;mapping_parsed&quot;: true, &quot;mapping_hash&quot;:&quot;abc123...sha256&quot;, &quot;errors&quot;: [], &quot;warnings&quot;: [], &quot;distinct_keys_count&quot;: 7, &quot;preview_mappings&quot;: [ {&quot;raw&quot;:&quot;TK0&quot;,&quot;canonical&quot;:&quot;TK/0&quot;,&quot;lookup_key&quot;:&quot;TK0&quot;,&quot;match_type&quot;:&quot;ALIAS&quot;,&quot;alias_target&quot;:&quot;TK/0&quot;,&quot;ter_table&quot;:&quot;TER_A&quot;}, {&quot;raw&quot;:&quot;k1&quot;,&quot;canonical&quot;:&quot;K/1&quot;,&quot;lookup_key&quot;:&quot;K/1&quot;,&quot;match_type&quot;:&quot;EXACT&quot;,&quot;alias_target&quot;:null,&quot;ter_table&quot;:&quot;TER_B&quot;}, {&quot;raw&quot;:&quot;1&quot;,&quot;canonical&quot;:&quot;1&quot;,&quot;lookup_key&quot;:&quot;1&quot;,&quot;match_type&quot;:&quot;ALIAS&quot;,&quot;alias_target&quot;:&quot;K/1&quot;,&quot;ter_table&quot;:&quot;TER_B&quot;}, {&quot;raw&quot;:&quot;PTKP_TK0&quot;,&quot;canonical&quot;:&quot;PTKP/TK/0&quot;,&quot;lookup_key&quot;:&quot;PTKP_TK0&quot;,&quot;match_type&quot;:&quot;ALIAS&quot;,&quot;alias_target&quot;:&quot;TK/0&quot;,&quot;ter_table&quot;:&quot;TER_A&quot;} ] }</code> </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>Full remediation & CI checklist to run automatically</strong><br>- Run JSON linting and stable canonicalization before accepting cell paste.<br>- Execute <code>LoadMappingDryRun()</code> and fail CI on any <code>errors[]</code>.<br>- If <code>warnings[]</code> exist and <code>LOADMAP_DRYRUN_FAIL_ON_WARN = TRUE</code>, fail CI; otherwise log warnings and require human review.<br>- Run <code>CalcBatch</code> smoke test on 50 representative rows and assert: audit fields present, no <code>ERR_TER_MISSING_PTKP_MAP</code> for those rows, manifest mapping_hash matches snapshot. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>What I will do now (no question)</strong><br>- I have produced both artifacts you previously requested: (A) a merged single-line <code>TER_TABLE_MAP</code> JSON above ready to paste, and (B) a <code>LoadMappingDryRun()</code> simulation example showing expected structure for sample tokens. Use the merged JSON as your inline alias+exact mapping, or extract the <code>alias</code> block into <code>ALIAS_TABLE</code> if you prefer Option B. </td></tr><tr><td data-label="TER_TABLE_MAP"> <strong>If you want me to proceed further</strong><br>- I can (1) generate a variant with a larger <code>exact</code> section matching your real TER assignments, or (2) run a simulated dry-run over a specific list of <code>tblInput</code> PTKP tokens you paste here and return the simulated <code>preview_mappings</code>. Provide the list and I will simulate immediately. </td></tr></tbody></table></div><div class="row-count">Rows: 19</div></div><div class="table-caption" id="Table8" data-table="Proj_0014_08" style="margin-top:2mm;margin-left:3mm;"><strong>Table 8</strong></div>
<div class="table-wrapper" data-table-id="table-8"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modCalc ↦ Requirement checklist (scan complete)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modCalc ↦ Requirement checklist (scan complete)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> TER selection flow (canonicalize → exact → alt-prefix → alias → wildcard → default/fail): PARTIAL — exact/uppercasing and deterministic range lookup implemented (SetTERTables / BuildSortedCandidates / LookupTERRow). <strong>Missing:</strong> alias table ingestion, wildcard matching, alt-prefix resolution and explicit default/fail routing. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Honor STRICT_TER_MAP: PARTIAL/NOT FULLY SAFE — code paths reference STRICT_TER_MAP logic and set ter_map_error, but runtime depends on external mapping state (<code>g_TER_map</code>) and helper <code>GetCurrentTERMapLoadId()</code> which are not present in the provided module. Requires modTER/modIO mapping integration for full enforcement. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Integrate alias table logic & alias JSON parsing: NOT IMPLEMENTED — no stable alias JSON parser / alias-to-canonical resolution integrated into SetTERTables / LookupTERRow. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> BPJS aggregation & precedence (amount vs percent; employer vs employee; include_employer_bpjs_in_gross; MAX_PREMI_ASURANSI_PCT + WARN): LARGELY IMPLEMENTED — amounts preferred, percent fallbacks used, employer inclusion flag honored (TREATEMPLOYERBPJSASGROSS). Configurable max-prem check added in CalcRow (reads MAX_PREMI_ASURANSI_PCT). </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Gross-up handling (preserve gross_up_flag semantics; SolveGrossUp entry point): IMPLEMENTED — SolveGrossUp present, uses CalcRow and preserves gross_up_flag semantics by caller-managed row template. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> NPWP penalty normalization & application: IMPLEMENTED — GetConfig normalizes NPWP_PENALTY_PCT; CalcRow applies penalty multiplier when npwp_status indicates missing. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Annualization / period_type handling and TER eligibility gates (period_type, is_regular_monthly, final-month): IMPLEMENTED — annualization, period_type variants, and IsTERApplicable (final-month, regular, exclude contractor/expat/daily) present and corrected. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Per-row audit fields: canonical_ptkp, ter_table, ter_map_lookup_key, ter_map_match_type, ter_map_load_id, ter_map_error: PARTIAL — CalcRow now emits canonical_ptkp, ter_map_* audit fields, but values depend on terAudit population from LookupTERRow and mapping helpers (<code>g_TER_map</code>, <code>GetCurrentTERMapLoadId</code>) that are not implemented in this module. ter_table (matched source) and ter_table_load_id are present via existing TER load id. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Deterministic TER tie-breaking & stable selection: IMPLEMENTED — BuildSortedCandidates sorts by rangeWidth, priority, insertion_index (stable deterministic selection). </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Defensive ingestion, open-ended GrossHigh handling, range validation, insertion_index: IMPLEMENTED — SetTERTables normalizes open-ended GrossHigh to sentinel, computes _meta_rangeWidth, _meta_insertion_index, and logs warnings for overlaps/malformed rows. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Diagnostic / verbose trace (decision_summary / diag when VERBOSECALC=True): IMPLEMENTED — diag and compact decision_summary produced and optionally included in out("diag") when VERBOSECALC true. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Unit tests / test hooks for TER selection and gross-up: PARTIAL — RunMODCALCUnitTests and Test_GetConfig_Unit exist (basic flows). Full canonicalization/alias/BPJS/NPWP/gross-up test matrix described in plan is not present. </td></tr><tr><td data-label="modCalc ↦ Requirement checklist (scan complete)"> Overall compliance vs revision plan: PARTIAL — Core calculation, deterministic TER range lookup, BPJS aggregation, NPWP penalty, annualization, gross-up solver, rounding, and diagnostics are implemented robustly. <strong>Remaining work required:</strong> alias/wildcard mapping ingestion and resolution, stable STRICT_TER_MAP enforcement (requires mapping subsystem), mapping load id helpers and global mapping state (<code>g_TER_map</code>, <code>GetCurrentTERMapLoadId</code>), and the extended unit test matrix. </td></tr></tbody></table></div><div class="row-count">Rows: 13</div></div><div class="table-caption" id="Table9" data-table="Proj_0014_09" style="margin-top:2mm;margin-left:3mm;"><strong>Table 9</strong></div>
<div class="table-wrapper" data-table-id="table-9"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Module"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Module</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Module"> <strong>1) modCalc</strong><br><strong>Responsibilities:</strong> Implement TER selection flow precisely: canonicalize input → exact match → alt-prefix handling (PTKP_ variants) → alias table resolution → wildcard pattern match (clear precedence rules) → default/fail behavior. Honor <code>STRICT_TER_MAP</code> to fail-fast on unmapped PTKP when enabled. Integrate alias JSON parsing and alias→canonical resolution. Implement BPJS aggregation & precedence rules: amount vs percent precedence, employer vs employee handling, <code>include_employer_bpjs_in_gross</code> flag, and apply <code>MAX_PREMI_ASURANSI_PCT</code> ceiling with WARN logging. Preserve and expose <code>gross_up_flag</code> semantics and provide a clear <code>SolveGrossUp</code> call point for iterative gross-up solving. Normalize and apply <code>npwp_penalty_pct</code> (accept percent formats) to tax calculation where applicable. Enforce TER eligibility gates: <code>period_type</code>, <code>is_regular_monthly</code>, final-month rules, and annualization logic. Emit per-row audit fields: <code>canonical_ptkp</code>, <code>ter_table</code>, <code>ter_map_lookup_key</code>, <code>ter_map_match_type</code> (exact<code>|</code>alias<code>|</code>alt-prefix<code>|</code>wildcard<code>|</code>default<code>|</code>none), <code>ter_map_load_id</code>, <code>ter_map_error</code> (nullable). Keep public APIs <code>ComputeTax</code>, <code>ProcessRow</code>, <code>SolveGrossUp</code> unchanged in signature.<br><strong>Tests:</strong> Unit tests for canonicalization permutations and alias→canonical resolution; TER lookup vectors (exact/alias/wildcard/default); BPJS precedence tests (amount vs percent; employer vs employee; <code>include_employer_bpjs_in_gross</code> true/false); NPWP penalty normalization and application; gross-up end-to-end convergence test with known expected gross/net pairs.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>2) modIO</strong><br><strong>Responsibilities:</strong> Non-destructive read/write of <code>tblInput</code>, <code>tblParams</code>, <code>tblBrackets</code>, <code>TER_*</code> tables—preserve extra/unexpected columns. Provide <code>QueryTable</code> import fallback to a streaming CSV parser when Excel table import fails; ensure <code>nip</code>/<code>npwp</code> preserved as Text not numeric. Implement atomic CSV writers (<code>.tmp</code> → SafeMoveFile rename), UTF-8 BOM toggle, stable header ordering (configurable), and append audit columns at end. Implement <code>LoadMappingDryRun()</code> to accept inline JSON or file path and return <code>{errors[], warnings[], preview_mappings}</code>; implement <code>SetTERTables(tables, commit=True)</code> that accepts normalized mapping object or file and on commit snapshots mapping and sets runtime ter_table_load_id. Provide <code>SafeMoveFile</code>/<code>SafeDeleteFileIfExists</code> using retry/backoff and cross-volume-safe copy+delete fallback. Create <code>OUTPUT_BASE\JOB_ID</code> folder with <code>EnsureFolderExistsWithRetry</code> semantics and log actions. Provide robust CSV encoding handling for Excel compatibility (BOM, CRLF).<br><strong>Tests:</strong> Atomicity/rename semantics tests (simulate rename fail and verify copy-delete fallback); <code>QueryTable</code> vs streaming fallback preserving NPWP/NIP types; CSV encoding and BOM behavior validated in Excel open/import; create/delete race condition tests for folder creation and file cleanup.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>3) modManifest</strong><br><strong>Responsibilities:</strong> Produce <code>manifest.json</code> with fields: <code>job_id</code>, <code>generated_at</code> (ISO8601 using workbook/TIMEZONE or workbook local timezone), <code>files</code> array (each entry: relative_path, size_bytes, last_modified_iso, sha256_hex), <code>total_size_bytes</code>, <code>import_error</code> (nullable), <code>ter_table_load_id</code> (nullable), <code>mapping_hash</code> (normalized mapping SHA256). Compute SHA-256 for CSVs and mapping JSON reliably (prefer system certutil when available, else internal SHA256 implementation). Write manifest atomically and persist <code>ter_map_snapshot/&lt;ter_table_load_id&gt;.json</code> when mapping committed; reference snapshot path in manifest. Log manifest write success/failure and include <code>mapping_hash</code> and <code>ter_table_load_id</code> in Logs. Maintain <code>MODMANIFEST_VERSION</code> constant.<br><strong>Tests:</strong> SHA-256 correctness test for sample text/binary files (compare with known hash); manifest JSON schema validation (simple parser roundtrip); roundtrip test: compute hashes → write manifest → read manifest and re-verify hashes match actual files; atomicity test (.tmp → final rename) to ensure no partial manifests visible.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>4) modUtils</strong><br><strong>Responsibilities:</strong> Robust canonicalization utilities (trim, collapse whitespace, normalize separators, insert canonical separator between letter/digit sequences where expected, uppercase, strip <code>PTKP_</code> prefix while retaining raw input for audit). Percent parsing helpers that accept <code>&quot;5%&quot;</code>, <code>&quot;0.05&quot;</code>, or <code>&quot;5&quot;</code> and normalize to fraction (0.05) with strictness toggles. Numeric parsing utilities and <code>NzNumericSafe</code> (blank→0) honoring <code>STRICT_BPJS</code> and other flags. Retry/backoff helpers: <code>EnsureFolderExistsWithRetry(folderPath, maxRetries, baseDelayMs)</code>, exponential backoff, safe fallback to <code>MkDir</code> with parameter validation. File helpers: <code>SafeMoveFile(src,dst)</code>, <code>SafeDeleteFileIfExists(path)</code> supporting cross-volume moves (Name rename → copy+verify→delete) and size/hash verification. Secure masking helper <code>MaskSensitiveForLog(s)</code> to mask long digit sequences (keep rightmost 4 digits). Settings validation helpers (range checks for <code>tblParams</code>, BPJS limits, percent ranges). Non-throwing defensive behavior and consistent LogMsg wrapper that calls host <code>modUtils.LogMsg</code> when present, else Debug.Print. Provide <code>NormalizePathForCompare</code> for consistent relative path calculations.<br><strong>Tests:</strong> Extensive canonicalization unit tests across textual variants; percent parsing edge-cases and invalid inputs; retry/backoff timing and retry-count behavior (simulate transient failures); SafeMoveFile cross-volume simulation (force rename to fail and verify copy-delete path); masking tests for NIP/NPWP patterns.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>5) modIO / modTER (TER loader)</strong><br><strong>Responsibilities:</strong> Implement <code>LoadMappingDryRun()</code> that accepts either inline JSON or file path; strictly validate mapping schema keys (<code>exact</code>, <code>alias</code>, <code>wildcard</code>, <code>default</code>), types, and value shapes. Detect duplicate/overlapping keys, invalid wildcard patterns, ambiguous wildcard matches (report warnings with examples), and missing required fields. Return structured <code>{errors[], warnings[], preview_mappings}</code> including sample lookups for distinct PTKP inputs. Implement <code>SetTERTables(mappingObj, commit=True)</code> commit path: normalize mapping (canonical keys), snapshot normalized JSON to <code>ter_map_snapshot/&lt;ter_table_load_id&gt;.json</code>, compute <code>mapping_hash</code>, set runtime <code>ter_table_load_id</code> atomically, and emit <code>TER mapping committed: ter_table_load_id=&lt;id&gt;</code> log. Validate TER numeric ranges for overlaps and open-endedness; introduce error codes <code>ERR_TER_OVERLAP</code>, <code>ERR_TER_MULTIPLE_OPEN</code> for deterministic handling. Seed in-memory TER placeholder tables (TER_A..TER_D) if needed for legacy consumers, with import notes. Provide rollback semantics: if commit fails, restore prior snapshot and runtime pointer.<br><strong>Tests:</strong> Dry-run malformed JSON and schema errors; wildcard ambiguity detection tests; commit snapshot creation and restore/rollback behavior; overlap/open-ended range detection tests with expected error codes emitted.<br><strong>Priority:</strong> High </td></tr><tr><td data-label="Module"> <strong>6) modMain</strong><br><strong>Responsibilities:</strong> <code>pph21_RunAll</code> orchestrator: read settings and validate sheets/tables; <code>GenerateJobIdIfEmpty</code> → create output folder → call <code>SetTERTables</code> dry-run and (if approved) commit → load <code>tblInput</code> (non-destructive) → loop <code>ProcessRow</code>/<code>ComputeTax</code> with optional parallelization guard (single-threaded by default) → collect outputs → use atomic writers to write CSVs (<code>bukti_potong.csv</code>, <code>per11_payload.csv</code>, <code>tblBrackets.csv</code>, <code>settings.csv</code>) → call <code>modManifest.WriteManifest</code> → append Logs and change tracking. Integrate <code>Test_RunAll</code> harness invocation option (non-destructive mode that writes to temp job folder). Respect and enforce flags: <code>STRICT_TER_MAP</code>, <code>INCLUDE_BPJS_FIELDS</code>, <code>VERBOSECALC</code>, <code>ENFORCE_CHANGELOG</code>. Implement graceful abort: on fatal error, log ERROR and ensure partial outputs are either cleaned (.tmp removed) or left with clear <code>.partial</code> marker; ensure manifest is only written on success. Ensure job snapshots (TER/mapping/job manifest) are included in output folder and their IDs recorded in Logs.<br><strong>Tests:</strong> End-to-end <code>Test_RunAll</code> on representative sample dataset; simulate mid-run failure to verify atomicity and cleanup behavior; verify outputs presence and manifest integrity on success; log lines verification for key events (job create, TER commit, manifest write, run completed counts).<br><strong>Priority:</strong> Medium </td></tr><tr><td data-label="Module"> <strong>7) modManifest / modLogging (logging & logs export)</strong><br><strong>Responsibilities:</strong> Standardize Logs sheet format with columns: <code>Timestamp (ISO8601)</code>, <code>Level</code> (DEBUG/INFO/WARN/ERROR), <code>Message</code>, <code>Context</code> (JSON or text). Enforce append-only behavior and ensure sensitive values (NIP/NPWP/long digit strings) are masked by <code>MaskSensitiveForLog</code>. Export Logs metadata into manifest context (<code>import_error</code>, <code>mapping_hash</code>, <code>ter_table_load_id</code>). Implement <code>TER_ChangeLog</code> entries recording mapping author, reason, diff summary, and <code>ter_table_load_id</code>. Honor <code>ENFORCE_CHANGELOG</code>: block mapping commit unless <code>TER_ChangeLog</code> entry present when enabled. Provide a <code>LogMsgLocal</code> wrapper that centralizes masking and level formatting. Ensure logs are idempotent and can be queried by <code>modTest</code> harness.<br><strong>Tests:</strong> Log masking and append idempotency tests; <code>ENFORCE_CHANGELOG</code> blocking/unblocking behavior tests; export manifest inclusion verification.<br><strong>Priority:</strong> Medium </td></tr><tr><td data-label="Module"> <strong>8) modTest (new recommended)</strong><br><strong>Responsibilities:</strong> Implement <code>Test_RunAll</code> macro that creates a temporary workbook copy or uses an isolated job folder, populates <code>tblInput</code> with curated test rows (bracket boundaries, BPJS amount vs percent, NPWP present/absent, final-month cases, gross-up examples), runs orchestrator in non-destructive mode, and asserts expected outputs exist and contain expected sample rows. Provide microtest suites callable individually: <code>Test_Canonicalization</code>, <code>Test_TERLookup</code>, <code>Test_BPJSPrecedence</code>, <code>Test_NPWP_Penalty</code>, <code>Test_GrossUp</code>, <code>Test_CSVAtomicity</code>. Produce machine-readable test report (CSV or worksheet) with pass/fail and diagnostic messages. Allow toggles to run only unit tests or full E2E. Include simple helper to auto-clean temp artifacts.<br><strong>Tests:</strong> CI-style unit & integration tests running in workbook copy; non-destructive assertions and clear failure diagnostics; reproducible test data and expected result vectors included in module.<br><strong>Priority:</strong> Medium </td></tr><tr><td data-label="Module"> <strong>9) modIO / modCSV (CSV schema enforcement)</strong><br><strong>Responsibilities:</strong> Enforce canonical CSV schemas for <code>bukti_potong.csv</code> and <code>per11_payload.csv</code>: required headers list and stable ordering, optional columns appended (audit fields) at the end. Provide <code>CSV_ENCODING</code> setting (UTF-8 BOM on/off) and ensure Excel-friendly line endings (CRLF). Implement exporter that writes headers exactly and serializes values with correct quoting/escaping. Validate output against schema post-write and emit WARN/ERROR if mismatch. Allow compatibility mode for legacy consumers that expect different header order via <code>CSV_SCHEMA_VERSION</code> flag.<br><strong>Tests:</strong> Excel acceptance tests with BOM/no-BOM combinations; header ordering verification; schema mismatch detection test; downstream ingestion simulation (if provided).<br><strong>Priority:</strong> Medium </td></tr><tr><td data-label="Module"> <strong>10) modSecurity / ACL integration (new recommended)</strong><br><strong>Responsibilities:</strong> Provide pre-commit permission checks for <code>OUTPUT_BASE</code> and job folder (attempt to create test file and report permission error). Document recommended workbook-level ACL or protected ranges for <code>tblParams</code> and Settings; optionally provide a simple password-protect/write-lock mechanism for critical ranges. Ensure manifest write and snapshot operations check and log file system permissions and fail gracefully with actionable messages. Record security checks in Logs and manifest <code>import_error</code> when permissions block commit.<br><strong>Tests:</strong> Permission check tests (simulate read-only output folder and verify error reported and manifest not written); unauthorized edit simulation to demonstrate logging and optional preventative behavior.<br><strong>Priority:</strong> Low/Medium </td></tr><tr><td data-label="Module"> <strong>Cross-module integration & migration notes</strong><br><strong>Responsibilities:</strong> Preserve all public function names/signatures (no breaking API changes). Bump <code>MOD_VERSION</code> only for semantic changes (calculation, TER mapping, CSV schema). Provide a migration note when header changes or TER semantics change. Add feature flags (<code>VERBOSECALC</code>, <code>STRICT_TER_MAP</code>, <code>CSV_SCHEMA_VERSION</code>) to support staged rollout. Ensure unit tests cover both legacy and new behaviors where feasible. Add per-module backup strategy: before modifying each module create <code>module_name.vba.bak</code> and a workbook snapshot <code>.xlsm.bak</code> and record entries in <code>rollback_manifest.txt</code> with timestamps. Maintain clear logging lines to search for during verification: <code>EnsureFolderExistsWithRetry created: &lt;path&gt;</code>, <code>SafeMoveFile succeeded: &lt;src&gt; -&gt; &lt;dst&gt;</code>, <code>WriteManifest success: manifest.json at &lt;path&gt;</code>, <code>TER mapping committed: ter_table_load_id=&lt;id&gt;</code>, <code>pph21_RunAll Run completed: processed=&lt;n&gt;, failed=&lt;m&gt;</code>.<br><strong>Priority:</strong> High </td></tr></tbody></table></div><div class="row-count">Rows: 11</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>