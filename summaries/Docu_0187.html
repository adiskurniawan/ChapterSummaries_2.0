<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771304660">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0187_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modApply — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modApply — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Scope & purpose (concise):</strong> <code>modApply</code> is the authoritative orchestration layer responsible for converting analyst-accepted JE suggestions into persisted exports and/or authoritative GL postings, ensuring governance, immutability, idempotency, forensic replayability, and safe revertability. The module's contracts require: persisted immutable descriptors prior to any mutative action, deterministic idempotency tokens, ephemeral credential use for direct postings, canonical serialization and canonicalVersion stamping, sha256: checksums, full audit events at each lifecycle transition, and chain-of-custody evidenceRefs for every artifact. This document expands every persisted row type, provides full function contracts (inputs, outputs, responsibilities, invariants, failure modes, telemetry, CI tests), worked examples, PQ pilot guidance, conceptual DAX measures and reporting patterns for operations and audit teams. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Top-level invariants & global rules (always apply):</strong> <br>1. Any mutative action (a <code>post_direct</code> or server-side change) MUST be preceded by a persisted immutable <code>applyDescriptor</code> (canonicalized and checksummed).<br>2. All canonical artifacts must include <code>canonicalVersion</code> and be serialized in the exact field ordering defined by schema; hashes must be computed on UTF-8 bytes and stored as <code>sha256:&lt;hex&gt;</code>; identical canonical inputs + canonicalVersion must produce identical checksums across runtimes.<br>3. Idempotency tokens MUST be derived deterministically from <code>applyId</code> and canonical payload hash (optionally HMAC'd with a KMS secret) and recorded as derivation metadata in the <code>applyDescriptor</code> but never storing raw secrets.<br>4. Ephemeral credentials (STS tokens) MUST be requested for <code>post_direct</code> and never logged or persisted in plaintext. Audit rows record tokenId and expiry only.<br>5. All persisted artifacts (descriptor, export, applyResult, revertDescriptor, forensic manifests) MUST be written atomically (tmp file + fsync + rename / object store multi-part commit semantics) and confirmed before emitting downstream audit events that assume persistence. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Canonical persisted row narratives & forensic semantics (extremely detailed)</strong> </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Row: <code>applyDescriptor</code> (immutable pre-apply record)</strong> <br><strong>Core concept:</strong> The <code>applyDescriptor</code> is the immutable legal/instrumental record of intent to perform a mutation. It documents the inputs, approvals, operator, and the exact canonical fingerprints that were present at the moment of the decision to apply. The descriptor is the single source of truth for forensic reconstruction — it must be persisted before any external side effects. <br><strong>Fields & per-field semantics:</strong> <br>- <code>applyId</code> (string): stable unique identifier for the apply action. Use a strong random UUID (v4) or deterministic composite (runHash + monotonic sequence) by policy. Must be included verbatim in all related audit events and subsequent artifacts. <br>- <code>runId</code> (string): link back to the depreciationRunManifest or previewRef used to generate acceptedJEs. This ties the apply to the computed schedules. <br>- <code>acceptedJEsHash</code> (sha256:hex): canonical hash over the accepted JE list (canonicalized with canonicalVersion). This hash is used to detect change/replay and to compute idempotency tokens. <br>- <code>beforeChecksums</code> (object): include <code>assetIngestChecksum</code>, <code>capexIngestChecksum</code>, <code>runHash</code>, <code>exportChecksum</code> (optional if export produced prior). Used to validate that the evidence used to decide the apply has not changed before posting. <br>- <code>approvalsRef</code> (<code>evidenceRef|null</code>): pointer to stored approval artifacts (digital signatures, two-person approvals). Null only in policies that allow operator-only applies. When present it must include who approved and timestamps. <br>- <code>operatorId</code> (string): authenticated operator identity; must match the identity provider record. <br>- <code>mode</code> (enum): <code>create_export</code> or <code>post_direct</code>. Immutable once persisted. <br>- <code>paramsHash</code> (sha256:hex): checksum of mode parameters (exportSpecRef, chunking, target endpoint, post options) canonicalized and included so reruns against the same <code>applyId</code> can be proven deterministic. <br>- <code>descriptorChecksum</code> (sha256:hex): checksum of the canonical serialization of the descriptor (fixed field order). Compute and persist as top-level property. <br>- <code>createdTs</code> (ISO): timestamp when persisted. <br><strong>Forensic responsibilities & invariants:</strong> <br>1. The descriptor must be canonicalized using the official field order and canonicalization recipe; compute <code>descriptorChecksum</code> and persist with <code>sha256:</code> prefix. <br>2. Persistence must be atomic. Once written the descriptor is immutable; corrections are implemented via new descriptors referencing <code>correctionOf</code> and must preserve the original <code>descriptorChecksum</code> chain. <br>3. The descriptor's <code>beforeChecksums</code> must be validated prior to execution; if any <code>beforeChecksum</code> differs on-run, the apply must halt and require operator re-approval. <br><strong>Failure modes & remediation:</strong> <br>- <em>Persist failure:</em> abort apply; surface staging path and correlationId; do not proceed with manual postings. <br>- <em>Approval mismatch:</em> if approvalsRef missing or revoked between persist and execution, block <code>post_direct</code>. <br>- <em>Stale <code>beforeChecksums</code> detected at execution time:</em> mark apply <code>stale</code>, notify operator and require explicit re-approval documented by a new <code>applyDescriptor</code>. <br><strong>Telemetry & observability:</strong> <code>apply.descriptor.persist.latencyMs</code>, <code>apply.descriptor.failures</code>, <code>apply.descriptor.stale_detected</code>. <br><strong>CI tests:</strong> canonicalization parity tests for descriptor, atomic-write simulation under partial-IO conditions, approval-matrix gating tests. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Row: <code>exportManifest</code> & <code>FA_JE_Export</code> artifact (canonical export descriptor)</strong> <br><strong>Core concept:</strong> When <code>create_export</code> mode is used, this row documents the persisted loader payload and its curated manifest. The manifest is the canonical contract between FA system and downstream loader. <br><strong>Fields & semantics:</strong> <br>- <code>exportPath</code> (string): object store path. <br>- <code>exportChecksum</code> (sha256:hex): canonical checksum of stored payload bytes (specify whether checksum computed pre- or post-compression in manifest). <br>- <code>exportSpecRef</code> (string): reference to the export format spec used (field order, date/number formats, sign conventions). <br>- <code>rowsCount</code>, <code>bundlesCount</code> (integers): counts for quick validation. <br>- <code>operatorId</code>, <code>createdTs</code>, <code>canonicalVersion</code>, <code>policyHash</code>. <br><strong>Forensic responsibilities & invariants:</strong> <br>1. Serialization rules must be deterministic and recorded: text normalization, escaping rules, newline policy (LF vs CRLF), BOM usage, encoding (UTF-8 without BOM recommended). <br>2. The manifest must indicate whether checksum was computed over raw canonical bytes or the persisted bytes (post-compression). <br>3. Persist atomically and set object metadata with checksum and canonicalVersion to support fast verification. <br><strong>Failure modes & remediation:</strong> <br>- <em>Checksum mismatch between manifest and object store:</em> quarantine artifact, run parity verification job, do not <code>post_direct</code> from suspect artifact. <br>- <em>Loader rejection due to spec mismatch:</em> produce a loader-test artifact and diagnostic mapping for loader team; correct <code>exportSpec</code> or re-serialize. <br><strong>Observability:</strong> <code>je.export.latencyMs</code>, <code>je.export.failures</code>, <code>exportChecksum</code>. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Row: <code>applyResult</code> (authoritative post outcome)</strong> <br><strong>Core concept:</strong> After an attempted apply, <code>applyResult</code> is the persisted authoritative record of what happened: per-bundle statuses, postedJournalIds, errors, and any downstream mutations recorded as <code>afterChecksums</code>. This row is essential for reconciliation and revert flows. <br><strong>Fields & semantics:</strong> <br>- <code>applyId</code>, <code>status</code> (<code>success|partial_success|failed</code>), <code>perBundleStatus[]</code> (bundleId, status, errorCode, diagnostics, postedJournalId if available), <code>postedJournalIds[]</code>, <code>afterChecksums</code> (if posting wrote back to GL snapshot), <code>applyTs</code>, <code>operatorNotes</code>. <br><strong>Forensic responsibilities & invariants:</strong> <br>1. Persist atomically and include evidenceRefs linking to the exportManifest / acceptedJEs and <code>applyDescriptor</code>. <br>2. If <code>partial_success</code> persist exactly which bundles were accepted and which failed with failure codes and GL server diagnostics. <br>3. For accepted bundles include server-provided postedJournalIds if returned, exact as returned, and the server timestamp or confirmation id. <br><strong>Failure modes & remediation:</strong> <br>- <em>Lost postedJournalIds due to network/timeouts:</em> persist any server responses and mark <code>postedJournalIds</code> as best effort; open a manual reconciliation ticket. <br>- <em>Inconsistent <code>afterChecksums</code> recorded (downstream mutated independently):</em> generate forensic manifest and run parity verification. <br><strong>Observability:</strong> <code>apply.successRate</code>, <code>apply.partialFailureCount</code>. <br><strong>CI tests:</strong> applyResult atomicity, per-bundle mapping correctness under simulated GL behaviors. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Row: <code>revertDescriptor</code> (pre-revert contract & evidence)</strong> <br><strong>Core concept:</strong> The revertDescriptor is the persisted plan to revert already-posted journals. It is created when an apply has successful postings but later requires a reversal. It documents which postedJournalIds must be reverted, the operator requesting the revert, evidenceRefs to the original apply, and deterministic revert id. <br><strong>Fields & semantics:</strong> <br>- <code>revertId</code> (sha256:): deterministic id composed from <code>applyId | normalizedRevertTs</code> to ensure reproducible idempotency. <br>- <code>applyId</code>, <code>postedJournalIds[]</code>, <code>beforeChecksums</code>, <code>requestedBy</code>, <code>reason</code>, <code>createdTs</code>. <br><strong>Forensic responsibilities & invariants:</strong> <br>1. Persist immediately prior to initiating automated revert actions. <br>2. Check idempotency: if <code>revertDescriptor</code> already exists for the same <code>applyId</code> and <code>postedJournalIds</code>, treat revert request as idempotent no-op. <br><strong>Failure modes & remediation:</strong> <br>- <em>Missing revertDescriptor while postedJournalIds exist:</em> escalate — this suggests poor persistence guarantees; prepare forensic manifest manually and halt further applies until resolved. <br><strong>Observability:</strong> <code>revert.automatedSuccessRate</code>, <code>revert.pendingManualCount</code>. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Row: <code>reversalArtifact.csv</code> & <code>forensic_manifest.json</code> (manual revert artifacts)</strong> <br><strong>Core concept:</strong> When automated GL reversal is impossible, <code>modApply</code> must produce a human-actionable reversal artifact (CSV) plus a <code>forensic_manifest</code> packaging all evidenceRefs and instructions for GL/finance teams to perform a manual reversal. This must be comprehensive and auditable. <br><strong>Forensic responsibilities & required contents:</strong> <br>1. <code>reversalArtifact.csv</code> contains recommended reversing JE lines with GL account codes, amounts, cost centers, narratives referencing <code>applyId</code> and evidenceRefs, and sign conventions matching GL expectations. <br>2. <code>forensic_manifest.json</code> lists all evidenceRefs (applyDescriptor, applyResult, exportManifest, ingestManifests), chain-of-custody steps, operator contact, legalTags, and an audit trail for manual posting. <br>3. Both artifacts are persisted to evidence store and a <code>fa.je.revert.manual_prepared</code> audit emitted. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function-level breakdowns (complete, per-function exhaustive contracts)</strong> </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>GenerateJEExport(acceptedJEs, exportSpec, operatorId, options)</code></strong> <br><strong>Purpose:</strong> deterministically serialize accepted JEs into a loader-ready artifact, validate bundle balance and schema, produce canonical checksum and export manifest, persist artifact atomically, and emit audit; supports compression and optional pre-signing. <br><strong>Inputs:</strong> <code>acceptedJEs[]</code> (canonical JE objects with evidenceRefs), <code>exportSpec</code> (field order, types, date/number formats, sign conventions), <code>operatorId</code> (string), <code>options</code> object with optional keys: <code>filenameTemplate</code>, <code>roundingScaleOverride</code>, <code>compress</code> (boolean), <code>chunking</code> (for large exports), <code>canonicalVersion</code> override (rare). <br><strong>Outputs:</strong> <code>exportPath</code> (object store path), <code>exportManifest</code> persisted, <code>exportChecksum</code> (<code>sha256:</code>), audit <code>fa.je.exported</code>. <br><strong>Detailed responsibilities & deterministic steps:</strong> <br>1. Validate input schema: ensure all acceptedJEs have required fields (<code>jeId</code>, <code>jeLines[]</code>, <code>evidenceRefs[]</code>, <code>bundleSequence</code>). If missing fields, fail with structured diagnostics listing offending bundleIds. <br>2. For each bundle, verify balance at policy's <code>roundingScale</code> using canonical rounding rules (round-half-to-even if policy). If imbalance within tolerance, apply deterministic intra-bundle residual absorption rules (absorb into line with largest preRounded absolute amount; if tie break by lexicographic <code>jeId</code>). Document residualAbsorbed in diagnostics and schedule rows where absorption occurred. If imbalance exceeds tolerance, fail export with deterministic diagnostics. <br>3. Map canonical fields to <code>exportSpec</code> columns deterministically: explicit mapping of <code>account</code>, <code>debitCredit</code>, <code>amount</code>, <code>narrative</code>, <code>costCenter</code>, <code>currency</code>, <code>evidenceRef</code> fields with type coercion rules; preserve <code>amountMinorUnits</code> where required. <br>4. Canonicalize textual fields per canonicalization recipe: Unicode NFKC → trim → collapse whitespace → optional diacritic strip per <code>policySnapshot.localeHandling</code> → casefold depending on spec. Numeric canonicalization: format decimal strings zero-padded to the <code>scale</code> specified by <code>exportSpec</code>/policy and compute <code>amountMinorUnits</code> integer if requested. Date canonicalization: <code>YYYY-MM-DD</code> or ISO 8601 per spec. <br>5. Serialize payload deterministically to bytes using specified delimiter, quoting, and newline policy (no trailing newline unless spec requests). Use UTF-8 encoding without BOM unless loader requires BOM. Escape field delimiters and quote characters deterministically (e.g., RFC4180 style with deterministic quoting rules). <br>6. Compute <code>payloadHash = sha256(payloadBytes)</code>; if compression applied compute <code>exportChecksum = sha256(compressedBytes)</code> or document pre/post choice in manifest; prefix with <code>sha256:</code> in manifest. <br>7. Persist artifact atomically: write to staging path, fsync, rename to final <code>FA_JE_Export_&lt;runId&gt;_&lt;exportChecksum&gt;.&lt;ext&gt;</code>; set object metadata: <code>exportChecksum</code>, <code>canonicalVersion</code>, <code>policyHash</code>, <code>retentionPolicy</code>, <code>legalTags</code>. <br>8. Build <code>exportManifest</code> with fields: <code>runId</code>, <code>exportPath</code>, <code>exportChecksum</code>, <code>rowsCount</code>, <code>bundlesCount</code>, <code>operatorId</code>, <code>createdTs</code>, <code>exportSpecRef</code>, <code>evidenceRefs[]</code> (include acceptedJEsHash and applyDescriptorRef if present), <code>canonicalVersion</code>. Persist manifest and emit audit <code>fa.je.exported</code>. <br><strong>Invariants:</strong> identical <code>acceptedJEs</code> + <code>exportSpec</code> + <code>canonicalVersion</code> → identical <code>exportChecksum</code> bytes across runtimes. <br><strong>Failure modes & remediation:</strong> <br>- <em>Bundle unbalanced beyond tolerance</em> → fail export and return structured diagnostics including sample offending rows and recommended actions (mapping fix, roundingScale change, manual override). <br>- <em>Serialization/IO failure</em> → retry with exponential backoff; on persistent failure create guarded local staging artifact and emit <code>fa.je.export.warning</code> with stagingRef for operator retrieval. <br>- <em>Loader acceptance test failure</em> → generate a loader-debug payload (with local loader acceptance flags) and provide deterministic mapping suggestions; escalate to loader integration owners. <br><strong>Telemetry & observability:</strong> <code>je.export.latencyMs</code>, <code>je.export.rows</code>, <code>je.export.bundles</code>, <code>je.export.failures</code>, <code>exportChecksum</code>. <br><strong>CI tests & golden checks:</strong> schema conformance tests, sign-convention permutations, char encoding and escaping tests, golden payload checksum parity across runtime matrix (PQ pilot vs backend). <br><strong>Runbook (excerpt):</strong> on <code>fa.je.exported</code> verify object store checksum equals manifest <code>exportChecksum</code>; if mismatch quarantine and run parity job. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>PersistApplyDescriptor(applyDescriptor)</code></strong> <br><strong>Purpose:</strong> canonicalize and atomically persist the <code>applyDescriptor</code> prior to any mutative action; compute <code>descriptorChecksum</code>; enforce approval gating. <br><strong>Inputs:</strong> <code>applyDescriptor</code> object with required keys: <code>applyId</code>, <code>runId</code>, <code>acceptedJEsHash</code>, <code>beforeChecksums</code> (<code>assetIngestChecksum</code>, <code>capexIngestChecksum</code>, <code>runHash</code>), <code>approvalsRef</code>, <code>operatorId</code>, <code>mode</code>, <code>paramsHash</code>, <code>createdTs</code>. <br><strong>Outputs:</strong> persisted <code>apply_&lt;applyId&gt;.json</code> evidenceRef; <code>descriptorChecksum</code> (<code>sha256:</code>), audit <code>fa.je.apply.descriptor.persisted</code>. <br><strong>Detailed responsibilities & steps:</strong> <br>1. Validate <code>applyDescriptor</code> schema. Consult <code>policySnapshot.approvalMatrix</code> to verify approvalsRef sufficiency. If approvals are required but missing, return deterministic <code>approval_missing</code> error and do not persist. <br>2. Canonicalize descriptor JSON following canonicalization recipe (fixed field order, NFKC on textual tokens where necessary, numeric fixed-scale formatting). <br>3. Compute <code>descriptorChecksum = sha256(canonicalDescriptorBytes)</code> and attach it to the descriptor. <br>4. Persist artifact atomically: write <code>.tmp</code> → fsync → rename to <code>apply_&lt;applyId&gt;.json</code> in evidence store. Add object metadata: <code>descriptorChecksum</code>, <code>canonicalVersion</code>, <code>policyHash</code>, <code>retentionPolicy</code>, <code>legalTags</code>. <br>5. Emit audit <code>fa.je.apply.descriptor.persisted</code> with <code>applyId</code>, <code>descriptorChecksum</code>, <code>evidenceRef</code>. <br><strong>Invariants:</strong> No mutative apply may commence without a persisted <code>applyDescriptor</code> for that <code>applyId</code>. <br><strong>Failure modes & remediation:</strong> <br>- <em>Persist failure</em> → return clear diagnostics to operator, store stagingRef; do not allow manual posting without persisted descriptor. <br>- <em>Approval mismatch discovered after persist</em> → mark descriptor <code>blocked</code>; require new approvalsRef and re-persist a new descriptor referencing previous with <code>correctionOf</code>. <br><strong>Telemetry & tests:</strong> <code>apply.descriptor.persist.latencyMs</code>, atomic write parity tests, permission/approval gating tests. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>BuildIdempotencyToken(applyId, payloadHash, secretContext)</code></strong> <br><strong>Purpose:</strong> compute deterministic idempotency token used in GL posting headers to guarantee safe retries and deduplication. <br><strong>Inputs:</strong> <code>applyId</code>, <code>payloadHash</code> (<code>sha256:</code> canonical payload), optional <code>secretContext</code> (KMS/HMAC key handle). <br><strong>Outputs:</strong> <code>idempotencyToken</code> string (opaque), <code>derivationMetadata</code> (algorithmVersion, inputs hashed) recorded in <code>applyDescriptor</code>. <br><strong>Detailed responsibilities & strategy:</strong> <br>1. Canonicalize inputs: <code>canonicalInput = applyId | &#x27;|&#x27; | payloadHash | &#x27;|&#x27; | canonicalVersion</code>. <br>2. If a KMS-secret is available compute <code>token = &#x27;hmac:&#x27; + base64url(HMAC-SHA256(secretKey, canonicalInput))</code> and persist <code>derivationMetadata</code> (algorithm, keyId, canonicalInputHash) in the <code>applyDescriptor</code> but not the secret or full token. <br>3. If no secret is available compute <code>token = &#x27;det:&#x27; + base64url(sha256(canonicalInput))</code> and emit compliance flag in telemetry. <br>4. Ensure token length and charset conform to GL idempotency header constraints; if necessary hash or encode to permitted size using deterministic steps. <br><strong>Invariants:</strong> same <code>applyId</code> + <code>payloadHash</code> + <code>canonicalVersion</code> → same idempotency token; derivation metadata stored for forensic reconstruction but not secret material. <br><strong>Failure modes & remediation:</strong> <br>- <em>Secret service (KMS) outage</em> → fall back to deterministic non-secret token and alert compliance; block <code>post_direct</code> if policy forbids fallback. <br>- <em>Key rotation differences</em> → derive tokens with explicit keyId noted in <code>derivationMetadata</code> for traceability; rotated keys must not change previously persisted <code>applyDescriptor</code>s. <br><strong>CI tests:</strong> deterministic parity, KMS outage fallback tests, secret-not-logged verification. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>RequestEphemeralToken(operatorId, scope, approvalsRef)</code></strong> <br><strong>Purpose:</strong> request short-lived least-privilege credentials for <code>post_direct</code> actions tied to approvals evidence. <br><strong>Inputs:</strong> <code>operatorId</code>, <code>scope</code> (scoped GL posting allowances), <code>approvalsRef</code> (evidenceRef for approvals). <br><strong>Outputs:</strong> <code>tokenHandle</code> (opaque), comprising <code>tokenId</code>, <code>tokenExpiryTs</code>, <code>scope</code>, <code>tokenMetadataRef</code>; audit <code>fa.token.issued</code>. <br><strong>Detailed responsibilities:</strong> <br>1. Validate that <code>approvalsRef</code> satisfies <code>policySnapshot.approvalMatrix</code> for the requested <code>scope</code>; return deterministic rejection if insufficient. <br>2. Request ephemeral credential from secure token service with requested scope and TTL; receive <code>tokenId</code> and expiry. The raw secret token is provided to the caller in memory only and must not be persisted. <br>3. Persist an issuance audit event recording <code>tokenId</code>, <code>expiry</code>, <code>operatorId</code>, <code>scope</code>, <code>approvalsRef</code>. Do NOT log the raw token value. <br>4. Return <code>tokenHandle</code> to calling process for immediate use; the calling process must use token in-memory and discard after use. <br><strong>Invariants:</strong> tokens are short-lived and single-run; token issuance audit references approvalsRef. <br><strong>Failure modes & remediation:</strong> <br>- <em>STS (token service) unavailable</em> → retry/backoff; if persistent, block <code>post_direct</code> and surface <code>token_unavailable</code> error. <br>- <em>Approval verification mismatch</em> → reject and return structured error referencing required approver roles. <br><strong>Telemetry:</strong> <code>token.issued.count</code>, <code>token.failure.count</code>. <br><strong>CI tests:</strong> token issuance success/failure, insufficient approvals rejection. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>PostToGL(payloadBytes, endpointConfig, tokenHandle, idempotencyToken, options)</code></strong> <br><strong>Purpose:</strong> perform idempotent, secure posting to the GL endpoint(s); handle chunking/resume for large payloads; parse GL responses and classify per-bundle statuses; return postedJournalIds and diagnostics. <br><strong>Inputs:</strong> <code>payloadBytes</code> (canonical), <code>endpointConfig</code> (URL, headers, expected response format), <code>tokenHandle</code> (ephemeral token), <code>idempotencyToken</code>, <code>options</code> (<code>chunkSize</code>, <code>timeout</code>, <code>retryPolicy</code>). <br><strong>Outputs:</strong> structured <code>{postedJournalIds[], perBundleStatus[], diagnostics[]}</code> persisted into <code>applyResult</code>. <br><strong>Detailed responsibilities & behavior:</strong> <br>1. Resolve ephemeral token from <code>tokenHandle</code> in-memory and attach in Authorization header; attach <code>Idempotency-Key</code> header with idempotencyToken; ensure TLS+mutual-auth where available. <br>2. If payload exceeds <code>chunkSize</code>, perform chunked upload with resume support; use the same idempotencyToken for all chunks and ensure server-side resume semantics are compatible. <br>3. Observe GL API semantics for synchronous vs asynchronous posting; support both: if asynchronous, poll with idempotencyToken and map final statuses accordingly. <br>4. Parse GL responses; canonicalize postedJournalIds returned by GL; classify individual bundle responses as <code>accepted</code> (with postedJournalId), <code>rejected_permanent</code> (do not retry), <code>rejected_transient</code> (retry allowed), or <code>duplicate</code> (map to previous postedJournal). Return structured diagnostics for operator. <br>5. Respect server-side dedup semantics: if GL returns "already processed" map to success and capture server-provided id if present. <br><strong>Idempotency & replay semantics:</strong> callers must reuse same <code>applyId</code> and <code>idempotencyToken</code> for retries; server-dedup plus idempotencyKey prevents duplicate postings. <br><strong>Failure modes & remediation:</strong> <br>- <em>Transient network or 5xx errors:</em> retry with exponential backoff and preserve idempotencyToken. <br>- <em>Partial success:</em> persist successes and failures; prepare <code>revertDescriptor</code> for successes if the decision is to revert them. <br>- <em>Permanent rejection (4xx):</em> do not retry; persist diagnostics and require manual remediation. <br>- <em>Duplicate responses without server id:</em> apply conservative mapping (store server diagnostic and mark as <code>duplicate_unknown</code>) and open reconciliation ticket. <br><strong>Observability:</strong> <code>gl.post.latencyMs</code>, <code>gl.post.successRate</code>, <code>gl.post.partialFailureCount</code>. <br><strong>CI tests:</strong> simulate GL responses: success, duplicate, partial, permanent reject, transient errors; chunking/resume tests; idempotency replay tests. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>ApplyCorrections(acceptedJEs|exportPath, mode, operatorId, approvalsRef, options)</code> — orchestrator (full flow)</strong> <br><strong>Purpose:</strong> perform the full apply orchestration: pre-checks, persist applyDescriptor, create export or post direct, record applyResult, persist revertDescriptor as needed, emit audits. This is the single high-level function callers interact with to apply JEs. <br><strong>Inputs:</strong> either <code>acceptedJEs[]</code> (then <code>GenerateJEExport</code> may be called) or an <code>exportPath</code> already persisted, <code>mode</code> (<code>create_export | post_direct</code>), <code>operatorId</code>, <code>approvalsRef</code>, <code>options</code> (<code>chunking</code>, <code>timeout</code>, <code>forceManual</code> gating). <br><strong>Outputs:</strong> persisted <code>applyDescriptor</code>, <code>applyResult</code>, <code>revertDescriptor</code> where appropriate, audit events <code>fa.je.apply.start</code>, <code>fa.je.apply.complete</code>/<code>fail</code>. <br><strong>Ordered stepwise algorithm (deterministic):</strong> <br>1. <strong>Gate & validation:</strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;a. Validate operator identity and role matches <code>policySnapshot</code> requirements; consult <code>approvalMatrix</code> and require approvalsRef when policy dictates (e.g., postings over threshold). <br>&nbsp;&nbsp;&nbsp;&nbsp;b. Validate <code>beforeChecksums</code> supplied by caller; if any mismatch between provided <code>beforeChecksums</code> and current store values abort and require new run. <br>2. <strong>Persist <code>applyDescriptor</code>:</strong> canonicalize and persist descriptor (call <code>PersistApplyDescriptor</code>) — abort if persist fails. <br>3. <strong>Emit <code>fa.je.apply.start</code></strong> with <code>applyId</code> and minimal metadata. <br>4. <strong>Mode branching:</strong> <br>&nbsp;&nbsp;&nbsp;&nbsp;a. <code>create_export</code>: ensure <code>exportManifest</code> exists or call <code>GenerateJEExport</code> to produce artifact; persist export manifest if produced; set <code>applyResult.status=success</code> (no GL side effects) and persist <code>applyResult</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;b. <code>post_direct</code>: <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i. Ensure <code>exportPath</code> exists (if not, call <code>GenerateJEExport</code> to create it). <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii. Request ephemeral token: <code>RequestEphemeralToken(operatorId, scope, approvalsRef)</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iii. Compute <code>idempotencyToken = BuildIdempotencyToken(applyId, acceptedJEsHash)</code> and record derivation metadata in <code>applyDescriptor</code>. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iv. Post payload using <code>PostToGL</code> (with chunking/resume), collect <code>postedJournalIds</code> and per-bundle statuses. <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v. Persist <code>applyResult</code> with full per-bundle statuses and <code>postedJournalIds</code>. If any successful postings exist persist <code>revertDescriptor</code> immediately. <br>5. <strong>Finalization:</strong> Emit <code>fa.je.apply.complete</code> with summary counts and evidenceRefs; if errors occurred emit <code>fa.je.apply.fail</code> with diagnosticRef. <br><strong>Invariants:</strong> <code>applyDescriptor</code> must be persisted prior to step 4; idempotencyToken derivation saved in descriptor; ephemeral token never persisted. <br><strong>Failure modes & remediation (comprehensive):</strong> <br>- <em>Partial success:</em> persist successes/failures; prepare <code>revertDescriptor</code> for successes; decide between governed retry for failures or paired revert + remediation; all decisions recorded in audit. <br>- <em>Token issuance failure:</em> abort <code>post_direct</code> and surface that <code>tokenUnavailable</code> to operator. <br>- <em>Approval missing mid-execution:</em> abort, persist partial results and do not attempt further mutations; escalate compliance. <br>- <em>Network/service failure during chunked posting:</em> resume using same <code>idempotencyToken</code> when available; if not recoverable persist staged artifact and escalate. <br><strong>Observability & telemetry:</strong> <code>apply.durationMs</code>, <code>apply.successRate</code>, <code>apply.partialFailureCount</code>, <code>apply.postedJournalCount</code>. <br><strong>CI tests:</strong> idempotency replay (same apply -> no duplicates), partial-failure simulation, token lifecycle test, approval gating tests, chunking/resume tests, golden parity tests for descriptor and export. <br><strong>Operator runbook (concise steps):</strong> <br>1. Verify <code>applyDescriptor</code> persisted and approvalsRef present. <br>2. Start apply and monitor <code>fa.je.apply.start</code> telemetry. <br>3. On partial failure examine <code>applyResult</code> and choose retry vs revert; use <code>revertDescriptor</code> for accepted bundles where revert is required. <br>4. If revert needed and automation fails prepare <code>reversalArtifact.csv</code> and escalate to GL operations with <code>forensic_manifest</code> evidence. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>RecordApplyResult(applyId, postedJournalIds[], perBundleStatus[], errors[])</code></strong> <br><strong>Purpose:</strong> atomically persist the final apply outcome, produce <code>revertDescriptor</code> to allow safe reverts, compute <code>afterChecksums</code> if downstream state changed, and emit final audits. <br><strong>Inputs:</strong> <code>applyId</code>, <code>postedJournalIds[]</code>, <code>perBundleStatus[]</code>, <code>errors[]</code>. <br><strong>Outputs:</strong> persisted <code>applyResult</code> evidenceRef, persisted <code>revertDescriptor</code> evidenceRef (if any postedJournalIds), audit <code>fa.je.apply.complete</code>/<code>fail</code>. <br><strong>Responsibilities & details:</strong> <br>1. Canonicalize <code>applyResult</code> JSON and persist atomically with metadata linking to <code>applyDescriptor</code>, <code>exportManifest</code>, and ingest manifests. <br>2. Compute <code>afterChecksums</code> if the GL or downstream system provides a post-apply snapshot; include in <code>applyResult</code> to facilitate recon. <br>3. Build and persist <code>revertDescriptor</code> containing <code>postedJournalIds</code>, <code>beforeChecksums</code>, <code>applyId</code>, <code>requestedBy</code> (system operator or automation agent), <code>createdTs</code>. This persist must occur before any attempt to revert. <br>4. Emit <code>fa.je.apply.complete</code> with summary counters and evidenceRefs; on failure emit <code>fa.je.apply.fail</code> with diagnosticRef. <br><strong>Failure modes:</strong> <br>- <em>Persist failure:</em> create durable local staging copy and create incident with correlationId; ensure postedJournalIds are never lost. <br><strong>CI tests:</strong> atomic persist verification, replay tests, revertDescriptor completeness. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>PrepareRevertArtifacts(applyDescriptor, postedJournalIds, reason, operatorId)</code></strong> <br><strong>Purpose:</strong> produce human-readable reversal artifacts and a forensic manifest for manual GL operations when automated reversal fails or is unsupported. <br><strong>Inputs:</strong> <code>applyDescriptor</code>, <code>postedJournalIds[]</code>, <code>reason</code>, <code>operatorId</code>. <br><strong>Outputs:</strong> <code>reversalArtifact.csv</code> persisted, <code>forensic_manifest.json</code> persisted, audit <code>fa.je.revert.manual_prepared</code>. <br><strong>Detailed responsibilities:</strong> <br>1. Generate recommended reversing JEs: balanced lines, GL account mappings, amounts, cost centers, narratives referencing <code>applyId</code> and <code>evidenceRefs</code>, and recommended approver signatures. <br>2. Assemble <code>forensic_manifest.json</code> including: references to the <code>applyDescriptor</code>, <code>applyResult</code>, <code>exportManifest</code>, ingest manifests, legalTags, chain-of-custody instructions, and contact points. <br>3. Persist artifacts with retention/legalTags and produce an audit event. <br><strong>CI tests:</strong> artifact format checks, inclusion of evidenceRefs, parity checks for reversing sums. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Function: <code>RevertJEs(applyId, operatorId, options)</code></strong> <br><strong>Purpose:</strong> attempt automated GL reversal; if GL reversal unsupported or partial, produce manual artifacts and persist <code>revertDescriptor</code> and <code>revertResult</code>. <br><strong>Inputs:</strong> <code>applyId</code>, <code>operatorId</code>, <code>options</code> like <code>forceManual</code>, <code>timeout</code>. <br><strong>Outputs:</strong> <code>revertDescriptor</code> persisted, <code>revertResult</code> per-journal status persisted, audit <code>fa.je.revert</code>. <br><strong>Detailed responsibilities & algorithm:</strong> <br>1. Fetch <code>applyDescriptor</code> and <code>applyResult</code> to obtain postedJournalIds; if missing emit <code>fa.revert.noSnapshot</code> and stop. <br>2. Compute <code>revertId = sha256(applyId | normalizedRevertTs)</code> for idempotent revert targets; check existing <code>revertDescriptor</code> to avoid duplicate attempts. <br>3. If GL supports reversal endpoints attempt automated reversal using ephemeral tokens and idempotency tokens; capture per-journal statuses. <br>4. If GL rejects reversal or supports manual only, call <code>PrepareRevertArtifacts</code> to produce reversal CSV and forensic manifest and persist evidence. <br>5. Persist <code>revertDescriptor</code> and <code>revertResult</code> atomically and emit <code>fa.je.revert</code>. <br><strong>Failure modes & remediation:</strong> partial revert → retry transient errors; if repeated fail produce manual artifacts and escalate. <br><strong>CI tests:</strong> idempotent revert replay, partial revert handling, manual artifact generation parity. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Cross-function governance, telemetry & audit event contract (must be implemented)</strong> <br>1. Audit events to emit at minimum: <code>fa.je.exported</code>, <code>fa.je.apply.descriptor.persisted</code>, <code>fa.je.apply.start</code>, <code>fa.je.apply.complete</code>, <code>fa.je.apply.fail</code>, <code>fa.token.issued</code>, <code>fa.je.revert</code>, <code>fa.je.revert.manual_prepared</code>. Each audit row must include <code>correlationId</code>, <code>applyId</code>/<code>runId</code>, <code>evidenceRefs</code>, <code>operatorId</code>, <code>paramsHash</code>, and any relevant checksums (<code>descriptorChecksum</code>, <code>exportChecksum</code>, <code>runHash</code>).<br>2. Telemetry metrics required: <code>apply.durationMs</code>, <code>je.export.latencyMs</code>, <code>apply.successRate</code>, <code>apply.partialFailureCount</code>, <code>gl.post.latencyMs</code>, <code>gl.post.partialFailureCount</code>, <code>token.issued.count</code>, <code>revert.automatedSuccessRate</code>. Tag all metrics with <code>runId</code>, <code>policyHash</code>, <code>operatorId</code>, and <code>environment</code>.<br>3. Evidence store metadata: every persisted artifact must include <code>createdTs</code>, <code>checksum</code>, <code>canonicalVersion</code>, <code>policyHash</code> and <code>retentionPolicy</code>/<code>legalTags</code>. Evidence retrieval APIs must be approval-gated for PII. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Deterministic tie-breakers & selection rules (applies across functions)</strong> <br>1. When deterministic selection required (e.g., residual absorption, candidate ordering) the order of precedence is: highest primary metric (amount absolute), then lexicographic smallest <code>assetId</code>/<code>jeId</code>, then seeded deterministic pseudo-random fallback derived from <code>runHash|elementId</code> where seed composition is included in the manifest. <br>2. When GL returns multiple postedJournalIds prefer server-provided canonical id (first non-empty), else lexicographic ordering. <br>3. When retries occur choose deterministic order of bundles for retries (descending amount, then bundleId). </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Security & secrets handling (strict contract)</strong> <br>1. Ephemeral tokens never logged or persisted raw; only <code>tokenId</code> and <code>expiry</code> are audited. <br>2. HMAC/KMS secrets used for idempotency tokens are stored in KMS with rotation policy; keyId is recorded in <code>applyDescriptor.derivationMetadata</code> but not secret. <br>3. Evidence artifacts with PII encrypted at rest; retrieval requires approvalsRef and chain-of-custody audit. <br>4. Access control: only roles with explicit <code>apply</code> permission may persist descriptors; only roles with <code>approve</code> permission may create approvalsRef for required approvals. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Extremely detailed worked examples (full forensic narratives)</strong> </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Example 1 — Controlled <code>create_export</code> apply with golden parity and audit (narrative):</strong> <br>1. Analyst produces <code>jePreview</code> for run <code>run-2026-01</code> and accepts 250 JE suggestions; system computes <code>acceptedJEsHash = sha256:...</code>. <br>2. Operator (alice) calls <code>GenerateJEExport</code> with <code>exportSpec=ERP_JE_v2</code>, <code>roundingScale=2</code>, <code>compress=true</code>. System validates balance rules and serializes canonical payload; computes <code>exportChecksum = sha256:...</code> and persists <code>FA_JE_Export_run-202601_&lt;exportChecksum&gt;.zip</code> atomically. <br>3. Alice calls <code>ApplyCorrections</code> in <code>create_export</code> mode. <code>PersistApplyDescriptor</code> records descriptor with <code>beforeChecksums</code> linking to ingest manifests and <code>acceptedJEsHash</code>. Descriptor persisted and <code>descriptorChecksum</code> computed. <br>4. <code>ApplyCorrections</code> records <code>fa.je.apply.start</code> and then <code>fa.je.apply.complete</code> (no GL mutation) attaching <code>exportManifest</code>. <code>applyResult</code> persisted as success referencing export. <br>5. Audit trail contains <code>applyDescriptor</code>, <code>exportManifest</code>, <code>applyResult</code> with checksums and <code>fa.je.exported</code> and <code>fa.je.apply.complete</code> events. Forensic replay of the export reconstructs identical bytes given same canonicalVersion. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Example 2 — High-value <code>post_direct</code> with two-person approval, partial rejects, and mixed automated/manual revert (narrative):</strong> <br>1. Run <code>run-2026-07</code> produced <code>acceptedJEsHash = sha256:...</code>. Operator (bob) prepares <code>ApplyCorrections</code> for 90 bundles totaling $1.2M; policy requires two-person approval. <br>2. <code>PersistApplyDescriptor</code> persisted with <code>approvalsRef</code> referencing approvals from bob and compliance approver. <code>descriptorChecksum</code> computed. <br>3. System requests ephemeral token (tokenId=tok-20260715-xyz) tied to approvalsRef and obtains <code>idempotencyToken = hmac:...</code> (derivation metadata stored in descriptor). <br>4. <code>PostToGL</code> posts payload; GL accepts 80 bundles and permanently rejects 10 due to account-level validation failures returning per-bundle error codes and no postedJournalIds for rejected ones. <br>5. <code>RecordApplyResult</code> persists <code>applyResult</code> with <code>status=partial_success</code> and lists 80 postedJournalIds. Immediately a <code>revertDescriptor</code> is persisted for the 80 successful journals in case downstream decision is to revert them. <br>6. Finance decides to revert accepted journals and rework failed ones offline. <code>RevertJEs</code> attempts automated reversal; GL accepts 75 reversals and rejects 5 because they were already reversed by downstream processes; system produces <code>reversalArtifact.csv</code> and <code>forensic_manifest.json</code> for manual reversal of the remaining 5. Audits: <code>fa.je.apply.start</code>, <code>fa.je.apply.complete</code>, <code>fa.je.revert</code> and <code>fa.je.revert.manual_prepared</code>. <br>7. All evidenceRefs are stored with legalTags; chain-of-custody is produced for auditors. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Example 3 — Descriptor staleness detection & corrective flow (narrative):</strong> <br>1. Operator persists <code>applyDescriptor</code> referencing <code>beforeChecksums</code> that included <code>runHash</code> computed at T0. <br>2. Between descriptor persist and execution a policy migration changed GL mapping resulting in new <code>exportChecksum</code> for a regenerated payload. At execution time system detects <code>beforeChecksums.runHash != currentRunHash</code> and marks apply as <code>stale</code>. <br>3. System blocks <code>post_direct</code>, emits <code>fa.je.apply.stale</code>, notifies operator to re-run preview and re-acquire approvals. Operator re-runs <code>ComputeDepreciation</code> and <code>GenerateJEExport</code>, produces new <code>acceptedJEsHash</code> and persists new descriptor referencing new <code>beforeChecksums</code>; apply resumes only after re-approval. <br>4. All events (stale detection, re-run, new descriptor) persisted for audit. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Power Query (PQ) conceptual guidance for <code>modApply</code> pilots (no code)</strong> </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>When PQ is appropriate:</strong> <br>1. PQ is suitable for analyst preview, small cohort exports (< ~5k rows depending on complexity), and generating <code>jePreviewArtifact</code> for human review where interactive transformation is valuable. <br>2. PQ is <em>not</em> recommended for production <code>post_direct</code> flows or large exports due to limited high-precision decimal math and scalability; PQ should be used only for pilot and parity checks. <br><strong>Architectural patterns for PQ pilot workflows:</strong> <br>1. Divide PQ logic into clearly named queries: <code>AcceptedJEs_Staging</code>, <code>ExportSpec_Param</code>, <code>DescriptorBuilder</code>, <code>Export_Serializer</code>. This separation makes intermediate steps inspectable and testable. <br>2. Store <code>policySnapshot</code> as a parameterized, versioned query (e.g., <code>PolicySnapshot_V2026_01</code>) and compute a local <code>policyHash</code> canonical string; record <code>canonicalVersion</code> constant within PQ to enable parity checks. <br>3. Implement header mapping and canonicalization as deterministic steps: <code>Text.Trim</code> → <code>Text.Clean</code> → controlled diacritic mapping tables when platform lacks NFKC; maintain raw fields in <code>rawPayloadRef</code> columns for forensic replay. <br>4. Compute <code>descriptorChecksum</code> and <code>exportChecksum</code> by composing the canonical CSV string in PQ and delegating SHA256 to a helper (host OS call or small helper service) where PQ lacks native hashing; always include <code>canonicalVersion</code> in the canonical string. <br><strong>Canonicalization steps in PQ (conceptual):</strong> <br>1. <strong>Text:</strong> NFKC equivalent via mapping tables where <code>Text.Normalize</code> is not available; <code>Text.Trim</code>, collapse multiple whitespace to single space; explicit casefolding where policy demands. <br>2. <strong>Numeric:</strong> pre-clean thousand separators; normalize decimal separator to <code>.</code>; use <code>Number.FromText</code> with explicit culture; compute <code>amountMinorUnits</code> by rounding to <code>roundingScale</code> and multiply by 10^scale. For high precision pre-round values store as strings for backend verification. <br>3. <strong>Date:</strong> parse using <code>Date.FromText</code> with explicit culture; store <code>rawDateString</code> when parse fails and capture diagnostics in <code>issues[]</code>. <br>4. <strong>Serialization & checksum:</strong> build canonical CSV string via deterministic step names and produce a canonical payload; if PQ cannot compute SHA256 locally, export canonical payload to a helper script that computes hash and returns <code>sha256:</code> value. <br><strong>PQ anti-patterns & mitigations:</strong> <br>1. Row-by-row custom functions in PQ scale badly—use table-buffered transforms and merges instead. <br>2. Large joins in-memory cause timeouts—sample for preview and push full run to backend. <br>3. HMAC & ephemeral token derivation should be done in secure backend; PQ should never hold secrets in local files. <br><strong>PQ parity & testing guidance:</strong> <br>1. Maintain PQ golden fixtures for <code>descriptorChecksum</code> and <code>exportChecksum</code> and compare with backend outputs; flagged parity failures should emit <code>fa.verify.parity.failed</code>. <br>2. Include explicit <code>canonicalVersion</code> in PQ outputs so parity is reproducible. <br><strong>Operational flow when PQ used for preview:</strong> <br>1. Analysts generate preview artifact using PQ and attach <code>preview_manifest</code> including <code>previewHash</code>. <br>2. Backend parity job replays the same inputs and <code>policyHash</code> and asserts <code>runHash</code> parity; mismatches trigger investigation and block promotion. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX measures & reporting patterns for modApply (no code)</strong> </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Modeling principles:</strong> <br>1. Use canonical keys for model relationships: <code>applyId</code>, <code>runId</code>, <code>exportChecksum</code>, <code>policyHash</code>. <br>2. Avoid showing PII in visuals; link to evidenceRefs via controlled drillthrough UX that enforces approval before showing raw artifacts. <br>3. Build measures oriented to operations and auditability: success rates, partial failures, latency distributions, open manual reverts workload. <br><strong>Core measures (conceptual):</strong> <br>1. <code>ApplySuccessRate = DIVIDE(COUNTROWS(ApplyResults WHERE status=&#x27;success&#x27;), COUNTROWS(ApplyResults), 0)</code> — posture metric for apply reliability. <br>2. <code>ApplyDurationP50 = PERCENTILEX.EXC(ApplyEvents, ApplyEvents[durationMs], 0.5)</code> — median apply latency. <br>3. <code>PartialFailureCount = COUNTROWS(ApplyResults WHERE status=&#x27;partial_success&#x27;)</code> — count of partially successful applies requiring manual work. <br>4. <code>OpenManualReverts = COUNTROWS(RevertRequests WHERE status=&#x27;pending_manual_revert&#x27;)</code> — pending manual workload for GL team. <br>5. <code>ExportParityFailures = COUNTROWS(Runs WHERE parityStatus=&#x27;failed&#x27;)</code> — golden parity detection. <br><strong>Operational visuals & UX patterns:</strong> <br>1. Time series of <code>ApplySuccessRate</code> and <code>ApplyDurationP50</code> annotated with <code>policyHash</code> promotions and canary windows to highlight when a policy change impacted apply behavior. <br>2. A matrix <code>controlGLAccount × costCenter</code> with <code>PartialFailureCount</code> heatmap and drillthrough into <code>applyResult</code> and <code>reversalArtifact</code> evidenceRefs. <br>3. A "top incidents" table listing <code>applyId</code>, <code>status</code>, <code>PartialFailureCount</code>, <code>postedJournalCount</code>, <code>revertRequired</code>, and links to <code>forensic_manifest</code>. <br><strong>Drillthrough & approvals UX:</strong> <br>1. From a failing apply cell allow drillthrough to <code>applyDescriptor</code>, <code>exportManifest</code>, <code>applyResult</code>, and <code>reversalArtifact</code> (approval-gated retrieval). <br>2. Provide a CTA to generate a prepopulated approval request (with <code>applyId</code>, <code>operatorId</code>, evidenceRefs) to accelerate two-person approvals; track approval status in the model. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Failure modes, exhaustive mitigation patterns, and operator runbooks (expanded)</strong> </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Fault A — <code>applyDescriptor</code> persist failure:</strong> <br><strong>Symptom:</strong> <code>fa.je.apply.descriptor.persisted</code> not emitted; operator receives <code>descriptor_persist_failed</code>. <br><strong>Triage:</strong> <br>1. Capture <code>correlationId</code> and inspect staging path; retrieve local <code>.tmp</code> if present. <br>2. Check object store permissions, quotas, and fsync capability. <br>3. If object store outage, put descriptor <code>.tmp</code> in guarded staging with restricted access and create incident ticket. <br><strong>Remediation steps:</strong> <br>1. Fix storage issue, atomically rename <code>.tmp</code> to final key, and emit <code>fa.je.apply.descriptor.persisted</code> retroactively linking to prior <code>correlationId</code>. <br>2. If manual posting was attempted despite missing descriptor, create <code>forensic_manifest</code> describing deviations and escalate compliance. <br><strong>Runbook snippet:</strong> always stop and do not proceed with direct GL posting without persisted descriptor; if the operator did post manually, record that action and run a forensic investigation. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Fault B — partial post with permanent rejects:</strong> <br><strong>Symptom:</strong> <code>applyResult.status = partial_success</code> with some bundles permanently rejected. <br><strong>Triage:</strong> <br>1. Fetch <code>applyResult</code>, <code>perBundleStatus[]</code>, and GL diagnostics. <br>2. For each rejected bundle, extract error codes and determine whether error is data mapping, GL account problem, or GL configuration. <br><strong>Remediation options:</strong> <br>1. For data/mapping fixes: regenerate corrected export for failed bundles and re-run apply for only failed bundles using same <code>applyId</code> and idempotencyToken when permitted. <br>2. If accepted bundles must be reversed, trigger <code>RevertJEs</code> for postedJournalIds; if automated reversal not supported prepare <code>reversalArtifact.csv</code> and escalate. <br>3. Persist all decisions and evidenceRefs; mark incident as finance/integration depending on root cause. <br><strong>Runbook steps:</strong> preserve postedJournalIds, persist <code>revertDescriptor</code>, escalate to GL team for permanent rejects when GL-side changes needed. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Fault C — export checksum mismatch (parity failure):</strong> <br><strong>Symptom:</strong> object store computed checksum differs from <code>exportManifest.exportChecksum</code>. <br><strong>Triage:</strong> <br>1. Quarantine artifact, set run <code>suspect</code> flag. <br>2. Recompute payload from <code>acceptedJEs</code> using canonicalVersion in codebase and compare checksums. <br>3. If mismatch originates from serialization differences (newline/escaping/BOM), isolate the canonicalization difference and produce a migrationManifest if change is intentional. <br><strong>Remediation:</strong> <br>1. Replace artifact with canonical re-serialized file where safe; otherwise block <code>post_direct</code> until parity verified. <br>2. If the change was deliberate (e.g., canonicalVersion bumped) produce migrationManifest, run canary, and document approvals. <br><strong>Runbook:</strong> block any <code>post_direct</code> for the affected runs until parity restored or an approved exception exists. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>CI & golden parity strategy (exhaustive)</strong> <br>1. Maintain canonical fixtures for <code>acceptedJEs</code>, <code>exportSpec</code>, <code>applyDescriptor</code> canonical JSON, and expected <code>exportChecksum</code> for a curated set of representative cases (multi-currency, disposals, component additions, rounding pathologies).<br>2. CI matrix includes runtimes: backend worker, PQ pilot (where applicable), and any alternative implementations. All must produce identical <code>descriptorChecksum</code> and <code>exportChecksum</code> over fixtures. Golden diffs block merges. <br>3. Property tests: idempotency token determinism, descriptor immutability, apply→revert idempotency, ordered independence of input rows. <br>4. Integration smoke tests: persist descriptor, produce export, simulate GL success/partial/failure responses, test <code>RevertJEs</code> flows. <br>5. Performance tests: export generation memory and time for 1k/10k/100k row payloads; GL posting throughput and chunking/resume behavior. <br>6. Security & privacy tests: ensure ephemeral tokens not persisted, secrets not logged, evidence artifacts encrypted for PII. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Performance & scale guidance (apply-specific)</strong> <br>1. Export generation is IO-bound and should stream; avoid building giant in-memory strings for large payloads. <br>2. For large batches (>10k lines), use chunked serialization and commit chunks atomically; persist per-chunk checksums if multi-part object store used. <br>3. For GL posting choose chunk size based on GL SLA (typical 1000 bundles per chunk) and test resume semantics. <br>4. Parallelize posting across shards (by <code>bundleId</code> ranges); preserve deterministic ordering for any ordering that affects canonical checksum (e.g., top-level export bytes) — for canonical parity choose a consistent global ordering rule (e.g., sort by <code>bundleSequence</code>, then by <code>jeId</code>). <br>5. Monitor queue depth and autoscale posting workers; prefer limited concurrency with backpressure to avoid GL throttling. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Acceptance & release gating for <code>post_direct</code> (apply readiness)</strong> <br>1. Golden parity for <code>exportChecksum</code> and <code>descriptorChecksum</code> must pass in CI across all supported runtimes. <br>2. Approval gating tests (two-person rules) must pass in automated gating. <br>3. Token service health and KMS health checks must be green. <br>4. Loader acceptance test harness must accept exportSpec versions in test environment. <br>5. For regulated GL ranges additional compliance approvals must be recorded in <code>approvalsRef</code> and validated by automated gating. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Operator CLI patterns (examples, conceptual)</strong> <br>1. <code>fa.generate-je --preview &lt;previewRef&gt; --accept all --exportSpec ERP_JE_v2 --operator alice</code> → produces <code>FA_JE_Export_&lt;runId&gt;_&lt;exportChecksum&gt;.zip</code> and <code>exportManifest</code>. <br>2. <code>fa.apply --export &lt;exportPath&gt; --mode create_export --operator alice --approvalsRef ap-123</code> → persists descriptor and records apply as export-only. <br>3. <code>fa.apply --export &lt;exportPath&gt; --mode post_direct --operator alice --approvalsRef ap-123 --force</code> → persist descriptor, request token, post to GL, record applyResult and revertDescriptor. <br>4. <code>fa.revert --applyId &lt;applyId&gt; --operator bob --forceManual</code> → attempts automated revert; if unsupported prepares reversal artifact and forensic manifest. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Operator runbook highlights (explicit steps)</strong> <br>1. <strong>Before apply:</strong> verify <code>exportManifest</code> and <code>descriptorChecksum</code> match object store checksums; ensure <code>approvalsRef</code> present for regulated ranges. <br>2. <strong>Start apply:</strong> persist descriptor and monitor <code>fa.je.apply.start</code>; capture <code>correlationId</code>. <br>3. <strong>During apply:</strong> watch posting metrics and GL responses; do not attempt manual posting if descriptor was not persisted. <br>4. <strong>On <code>partial_success</code>:</strong> decide between retry for failed bundles or revert accepted bundles; persist decision and evidence. <br>5. <strong>On revert failure:</strong> prepare manual reversal using <code>reversalArtifact.csv</code> and <code>forensic_manifest</code>; coordinate with GL team and compliance. <br>6. <strong>Post incident:</strong> run parity verification and retention of all artifacts for the retention window specified in policy. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Migration & policy-change governance for apply flows (essential)</strong> <br>1. Any change in canonicalization, serialization, or idempotency computation that could affect <code>exportChecksum</code> or <code>descriptorChecksum</code> requires a <code>migrationManifest</code> with sample fixtures, expected golden checksums, estimated affected count, canary plan, rollback plan, approvals, and test matrix. <br>2. Execute a canary on a small cohort and monitor KPIs: <code>ApplySuccessRate_change</code>, <code>DepnExpenseDeltaPct</code>, <code>ExportParityFailureRate</code>. <br>3. Only promote policy change to production after canary KPIs within thresholds and recorded approvals. If migration changes canonicalVersion, ensure CI golden fixtures updated and all runtimes produce parity. <br>4. Persist migration artifact and emit <code>fa.policy.migration.completed</code>. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Evidence naming, checksum conventions & retention (concrete)</strong> <br>1. <code>applyDescriptor</code>: <code>apply_&lt;applyId&gt;.json</code> persisted prior to side effects. <br>2. <code>export</code>: <code>FA_JE_Export_&lt;runId&gt;_&lt;exportChecksum&gt;.&lt;ext&gt;</code> and <code>export_manifest.json</code>. <br>3. <code>applyResult</code>: <code>apply_result_&lt;applyId&gt;_&lt;ts&gt;.json</code>. <br>4. <code>revertDescriptor</code>: <code>revert_&lt;revertId&gt;.json</code>. <br>5. <code>reversalArtifact</code>: <code>reversal_&lt;applyId&gt;_&lt;revertId&gt;.csv</code> and <code>forensic_manifest_&lt;applyId&gt;_&lt;revertId&gt;.json</code>. <br><strong>Checksum policy:</strong> use <code>sha256</code> over canonical bytes and prefix with <code>sha256:</code>. Record <code>checksumAlgorithm</code> and <code>canonicalVersion</code> in all manifests. <br><strong>Retention:</strong> evidence retention controlled per <code>policySnapshot.retentionPolicy</code> and legalTags for compliance; PII artifacts require explicit approvals for retrieval and chain-of-custody audit. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Final acceptance checklist for implementers (explicit)</strong> <br>1. Implement atomic persist for <code>applyDescriptor</code> with canonicalization and <code>descriptorChecksum</code>. <br>2. Implement <code>GenerateJEExport</code> with deterministic serialization and <code>exportChecksum</code> parity against CI fixtures. <br>3. Implement secure <code>RequestEphemeralToken</code> flow that ties to approvalsRef and does not persist raw tokens. <br>4. Implement <code>BuildIdempotencyToken</code> using HMAC with KMS secret where policy requires; support deterministic fallback with compliance flag. <br>5. Implement <code>PostToGL</code> with chunking, resume, idempotencyKey header support, deterministic response parsing, and structured diagnostics. <br>6. Implement <code>RecordApplyResult</code> and <code>PrepareRevertArtifacts</code> to make reverts safe and auditable. <br>7. Add CI golden fixtures and tests ensuring descriptor & export checksum parity across runtimes (backend and PQ pilot where used). <br>8. Implement SLO-based alerting for <code>apply.successRate</code> and <code>je.export.latencyMs</code>. </td></tr><tr><td data-label="modApply — Per-function Expert Technical Breakdown"> <strong>Next artifacts I can produce (pick one or more):</strong> <br>1. Formal JSON Schema for <code>applyDescriptor</code>, <code>applyResult</code>, <code>revertDescriptor</code>, and <code>exportManifest</code> with exact field ordering used for canonical hashing. <br>2. Canonical CSV golden fixtures (representative cases) and expected <code>sha256:</code> checksums for CI. <br>3. Step-by-step Power Query recipe (conceptual) to compute <code>descriptorChecksum</code> and <code>exportChecksum</code> for PQ pilots. <br>4. Compact runbook PDF summarizing apply and revert triage steps for operations teams. <br>Choose desired artifact(s) and I will generate them next. </td></tr></tbody></table></div><div class="row-count">Rows: 42</div></div><div class="table-caption" id="Table2" data-table="Docu_0187_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modRevert — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modRevert — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Document purpose & audience:</strong> This document is an authoritative, implementation-grade blueprint for <code>modRevert</code> — the Fixed Assets Journal Entry (JE) revert subsystem that supports safe, auditable, idempotent reversal of previously applied JE bundles. Intended readers: backend engineers, QA, SRE, GL integrators, PQ pilot analysts, finance controllers, compliance, legal, and auditors who will implement, operate, test, or govern revert flows. <br> <strong>Scope:</strong> artifact definitions and field semantics, deterministic canonicalization rules, full function contracts (inputs/outputs/responsibilities/invariants/failure modes/telemetry/CI tests/runbook steps), extensive worked examples and edge cases, conceptual Power Query guidance, conceptual DAX measures & UX patterns for monitoring/troubleshooting, acceptance gates, and forensic packaging rules. All numbered lists use <code>&lt;br&gt;</code> line breaks for downstream renderers. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Executive summary (short):</strong> <code>modRevert</code> provides a deterministic, evidence-first pipeline for reverting previously applied JE bundles. It depends on an immutable <code>applyDescriptor</code> created at apply time, produces an append-only <code>revertDescriptor</code> for idempotency and resume, uses ephemeral credentials for GL interactions, attempts automated reversals via vendor adapters where supported, and falls back to canonical forensic artifacts (<code>reversalArtifact.csv</code> + <code>forensic_manifest.json</code>) when automation fails. Policy snapshots and migration manifests govern approvals, two-person controls for regulated ranges, and canary migration requirements. All artifacts use canonical serialization and <code>sha256:</code> checksums to enable cross-runtime parity and forensic replay. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Design principles (global):</strong> <br> 1. Evidence-first: every mutative action is preceded by persisted descriptors and matching audit events to create a complete chain-of-custody. <br> 2. Deterministic canonicalization: canonical text normalization, numeric minor-units, date normalization, canonical field ordering and <code>sha256:</code> hashing. <br> 3. Idempotency & resume: deterministic <code>revertId</code> and append-only <code>revertDescriptor</code> supporting single-winner semantics and restart/resume. <br> 4. Least-privilege & ephemeral credentials: GL reversal calls only with ephemeral tokens; token material never persisted or logged. <br> 5. PII minimization & approval gating: analyst surfaces redact PII; raw evidence retrieval requires <code>approvalRef</code> and logs chain-of-custody. <br> 6. Policy governance & migration control: policy changes require documented <code>migrationManifest</code> and canary plan before affecting revert behavior. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Canonical artifact set (high level)</strong> <br> 1. <code>applyDescriptor</code> — immutable pre-apply manifest describing accepted JEs and postedJournalIds. <br> 2. <code>revertDescriptor</code> — append-only revert lifecycle record used for idempotency, progress, and audit. <br> 3. <code>reversalArtifact.csv</code> — human/GL-desk CSV used for manual reversal when automation fails. <br> 4. <code>forensic_manifest.json</code> — canonical bundle linking all relevant artifacts (apply, revert, previews, run manifests, forensic CSVs) with instructions. <br> 5. <code>postRevertReport</code> — verification summary after revert attempts (confirmed vs pending). <br> 6. <code>evidenceRef</code> — pointer format used across artifacts to reference persisted store objects. <br> 7. <code>fa.*</code> audit events — every important lifecycle transition emits an audit event with correlation metadata. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Per-row canonical narratives & invariants (exhaustive)</strong> </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>ApplyDescriptor — canonical narrative & field semantics (detailed):</strong> <br> • <strong>Purpose:</strong> Persist the canonical accepted JE payload and associated metadata <strong>before</strong> any mutative GL action, serving as the single source-of-truth for later reverts and forensic replay. <br> • <strong>Primary fields:</strong> <br> 1. <code>applyId</code> (string): unique identifier; recommended deterministic <code>sha256:</code> of canonicalApplyKey or UUID per enterprise policy. <br> 2. <code>runId</code> (string): pointer to depreciation run/preview. <br> 3. <code>acceptedJEsHash</code> (<code>sha256:&lt;hex&gt;</code>): canonical checksum of accepted JE payload serialized under <code>jeTemplateSpec</code> canonical field order. <br> 4. <code>beforeChecksums</code> object: <code>{ assetIngestChecksum, capexIngestChecksum, depreciationRunHash, policyHash, previewHash? }</code> that pin input artifacts. <br> 5. <code>postedJournalIds[]</code> (array): each object <code>{ originalJeId, postedJournalId, postTs (ISO), postResponseRef (evidenceRef), postResponseChecksum, postStatus }</code>. <br> 6. <code>exportManifestRef</code> (for create_export mode), <code>operatorId</code>, <code>approvalsRef</code> (evidenceRef), <code>mode</code> (<code>post_direct | create_export</code>), <code>applyTs</code> (ISO), <code>applyChecksum</code> (<code>sha256:</code> over canonical subset), <code>canonicalVersion</code>. <br> • <strong>Invariants & rules:</strong> <br> 1. Persisted atomically before posting or exporting. <br> 2. Immutable for revert purposes — corrections must be new descriptor versions with <code>correctionOf</code> link. <br> 3. Checksums computed with documented canonicalization recipe (Appendix A). <br> • <strong>Failure modes & remediation:</strong> <br> 1. Missing descriptor blocks revert (<code>fa.revert.noSnapshot</code>) — remediation: restore from staging or re-create accepted JEs under compliance. <br> 2. Checksum mismatch → forensic freeze and infra investigation. <br> • <strong>Observability:</strong> emit <code>fa.je.apply.created{applyId}</code> with evidenceRefs and <code>paramsHash</code>. <br> • <strong>CI tests:</strong> parse fixtures, compute acceptedJEsHash parity tests, approvalsRef validation tests. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>RevertDescriptor — canonical narrative & field semantics (detailed):</strong> <br> • <strong>Purpose:</strong> Persisted append-only record capturing the entire revert attempt with per-journal timelines, enabling idempotency, resume, and forensic reproducibility. <br> • <strong>Primary fields:</strong> <br> 1. <code>revertId</code> (<code>sha256:&lt;hex&gt;</code>): deterministic id derived from <code>applyId|normalizedRevertTs|policyHash</code> with canonical separators. <br> 2. <code>applyId</code>, <code>operatorId</code>, <code>revertTs</code> (ISO), <code>status</code> enum (<code>in_progress | partial_completed | completed | failed | failed_auth | pending_manual_revert</code>). <br> 3. <code>postedJournalIds[]</code> array: each item <code>{ postedJournalId, originalJeId, amountMinorUnits, currency, status, attempts, lastAttemptTs, lastErrorCode, glReversalId, lastResponseRef }</code>. <br> 4. <code>perJournalProgress[]</code>: append-only entries capturing each attempt (ts, operatorId, attemptDetailRef, correlationId). <br> 5. <code>reversalArtifactRef</code>, <code>forensicManifestRef</code>, <code>postRevertReportRef</code>. <br> 6. <code>revertDescriptorChecksum</code> (<code>sha256:</code>), <code>prevVersionRef</code>, <code>canonicalVersion</code>. <br> • <strong>Invariants & rules:</strong> <br> 1. Persisted before any GL reversal calls to enforce idempotency. <br> 2. Storage must support conditional create-if-not-exists to ensure single-winner descriptor creation. <br> 3. Updates must be appended as new versions with <code>prevVersionRef</code> to preserve CHAIN. <br> 4. <code>perJournalProgress</code> timestamps must be strictly monotonic within each descriptor version. <br> • <strong>Failure modes & remediation:</strong> <br> 1. Worker crash → resume from last persisted progress. <br> 2. Storage collision → read existing descriptor and adopt single-winner semantics; escalate if multiple active descriptors exist for same <code>revertId</code>. <br> 3. Token auth failure mid-batch → obtain new ephemeral token and retry remaining; if token service unavailable fallback to forensic artifact generation. <br> • <strong>Observability:</strong> <code>fa.je.revert.started</code>, frequent <code>fa.je.revert.progress</code> events, <code>fa.je.revert.complete</code> or <code>fa.je.revert.partial</code>. <br> • <strong>CI tests:</strong> concurrency single-winner tests, resume from checkpoint tests, version chain integrity. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>reversalArtifact.csv — row-level semantics (detailed):</strong> <br> • <strong>Purpose:</strong> Canonical CSV used by GL desk/manual processes to perform reversals when automation is unavailable or fails. <br> • <strong>Canonical columns (recommended order):</strong> <br> 1. <code>originalJournalId</code> (vendor posted id). <br> 2. <code>originalJeId</code> (internal JE id). <br> 3. <code>reversalAmountMinorUnits</code> (integer representing amount × 10^scale). <br> 4. <code>currency</code> (ISO4217). <br> 5. <code>reversalNarrative</code> (controlled template referencing <code>applyId</code> & <code>revertId</code>; PII redacted). <br> 6. <code>idempotencyHint</code> (<code>revertId</code>). <br> 7. <code>evidenceRefs</code> (serialized list: applyDescriptorRef, runManifestRef, other supporting refs). <br> • <strong>Filename & checksum:</strong> <code>reversal_&lt;applyId&gt;_&lt;revertId&gt;_&lt;ts&gt;.csv</code> with canonical CSV string used to compute <code>sha256:</code> hash persisted with <code>reversalArtifactRef</code>. <br> • <strong>PII & security:</strong> CSV must minimize PII; raw records with PII remain in evidence store and require <code>approvalRef</code> to access. <br> • <strong>CI tests:</strong> CSV schema validation; canonicalization parity across runtime environments; <code>sha256:</code> golden checks. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>forensic_manifest.json — narrative & fields (detailed):</strong> <br> • <strong>Purpose:</strong> Machine+human manifest bundling all evidence required for manual reversal, audit, or regulatory review. <br> • <strong>Primary fields:</strong> <code>forensicManifestId</code> (<code>sha256:</code>), <code>applyDescriptorRef</code>, <code>revertDescriptorRef</code>, <code>reversalArtifactRef</code>, <code>postRevertReportRef</code>, <code>depreciationRunManifestRef</code>, <code>previewManifestRef</code>, <code>assetIngestManifestRef</code>, <code>capexIngestManifestRef</code>, <code>humanSummary</code>, <code>nextSteps</code>, <code>legalTags</code>, <code>retentionPolicy</code>, <code>chainOfCustodyTemplate</code>. <br> • <strong>Invariants:</strong> Canonical ordering of listed refs and checksums; retrieval is approval-gated and any retrieval action writes a <code>chainOfCustody</code> entry. <br> • <strong>CI tests:</strong> completeness checks, canonical ordering parity tests, <code>sha256:</code> golden fixtures. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>postRevertReport — narrative & fields (detailed):</strong> <br> • <strong>Purpose:</strong> Post-execution verification summary that lists confirmed reversals, pending manual items, and reconciliation discrepancies. <br> • <strong>Primary fields:</strong> <code>revertId</code>, <code>confirmedReversals[]</code> (with <code>postedJournalId</code>, <code>glConfirmationRef</code>), <code>pendingManual[]</code>, <code>discrepancies[]</code> (with <code>postedJournalId</code>, <code>expected</code>, <code>observed</code>, <code>glNotesRef</code>), <code>reportChecksum</code>, <code>createdTs</code>. <br> • <strong>Use:</strong> consumed by <code>ReconcileFAtoGL</code> and compliance. <br> • <strong>CI tests:</strong> test reconciliation logic with simulated GL feeds showing eventual consistency delays. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Canonicalization & hashing — exact recipes (authoritative)</strong> <br> 1. <strong>Text normalization:</strong> Unicode NFKC; <code>Trim()</code> leading/trailing whitespace; collapse internal whitespace sequences to single U+0020; for hashing use casefold (lowercase) and optionally strip or normalize diacritics only when <code>policySnapshot.localeHandling</code> mandates; always persist raw payload in <code>rawPayloadRef</code>. <br> 2. <strong>Numeric canonicalization:</strong> persist <code>amountMinorUnits</code> integer and explicit <code>scale</code>. When serializing for hashing format decimal string with zero-padding to <code>scale</code>. Negative zero normalized to zero. <br> 3. <strong>Date/time canonicalization:</strong> Use <code>YYYY-MM-DD</code> for date-only contexts; use <code>YYYY-MM-DDTHH:MM:SSZ</code> for timestamps normalized to UTC; truncate milliseconds deterministically per <code>canonicalVersion</code>. <br> 4. <strong>Serialization for hashing:</strong> each artifact defines exact field order (Appendix A). Join fields with <code>|</code> separators; arrays are serialized as canonical JSON with keys sorted and without whitespace; exclude transient provenance fields (unless policy requires inclusion). <br> 5. <strong>Encoding & hashing:</strong> encode canonical string as UTF-8, compute sha256 hex digest, prefix with <code>sha256:</code> and persist along with <code>canonicalVersion</code> metadata. <br> 6. <strong>Deterministic tie-breakers:</strong> when deterministic selection is required apply rules in exact order: highest absolute preRounded amount → lexicographically smallest <code>postedJournalId</code> → deterministic seed from <code>revertId</code>. Document tie-breaker usage in <code>revertDescriptor</code> for forensic replay. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Full function-level breakdowns — exhaustive contracts</strong> </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Style:</strong> Each function below includes Purpose, Inputs, Outputs, Responsibilities (ordered), Preconditions & invariants, Failure modes & remediation, Observability/Telemetry, CI tests, and Operator runbook actions. Numbered lists use <code>&lt;br&gt;</code> line breaks. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>ValidateRevertPreconditions(applyId As String, operatorId As String) : RevertPreconditionResult</code> <br> <strong>Purpose:</strong> preflight guard validating existence of <code>applyDescriptor</code>, approvals, evidence availability, operator privileges, and migration/policy gating before any revert. <br> <strong>Inputs:</strong> <code>applyId</code>, <code>operatorId</code>. <br> <strong>Outputs:</strong> <code>RevertPreconditionResult</code> object: <code>{ canProceed Boolean, reasonCodes[], applyDescriptorRef, postedJournalIds[], requiredApprovals[] }</code>. <br> <strong>Responsibilities (ordered):</strong> <br> 1. Load <code>applyDescriptor</code> via <code>LoadApplyDescriptor</code>. <br> 2. Confirm <code>postedJournalIds[]</code> presence (for <code>post_direct</code>) or <code>exportManifestRef</code> presence (for <code>create_export</code>). <br> 3. Validate <code>approvalsRef</code> meets <code>policySnapshot.approvalMatrix</code> thresholds (two-person approval for regulated ranges). <br> 4. Verify evidence referenced by <code>beforeChecksums</code> present in evidence store and not archived without retrieval path. <br> 5. Validate <code>operatorId</code> role against <code>policySnapshot.roleMatrix</code>. <br> 6. Check <code>policyHash</code> mismatch with current snapshot and consult <code>migrationManifest</code> if present — block if migration requires approval. <br> <strong>Preconditions & invariants:</strong> deterministic and side-effect free; returns same outcome unless evidence or approvals change. <br> <strong>Failure modes & remediation:</strong> <br> 1. Missing <code>applyDescriptor</code> → <code>fa.revert.noSnapshot</code>: remediate via artifact restore or recreate under compliance. <br> 2. Missing/insufficient approvals → <code>fa.revert.missing_approvals</code>: remediate by collecting approvals and persisting <code>approvalsRef</code>. <br> 3. Evidence archived → <code>evidence_missing</code> with <code>archiveRetrievalRef</code>: remediate by retrieving from archive. <br> 4. Migration block → consult <code>migrationManifest</code> and obtain approvals or perform canary plan. <br> <strong>Observability:</strong> metrics <code>revert.precheck.latencyMs</code>, counters for <code>revert.precheck.failures</code> and reasons. <br> <strong>CI tests:</strong> fixtures covering valid and failing approval scenarios, archived evidence, migration blocking. <br> <strong>Operator runbook:</strong> steps to locate staging apply artifact, run approvals workflow, and re-attempt precheck. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>LoadApplyDescriptor(applyId As String) : ApplyDescriptor</code> <br> <strong>Purpose:</strong> deterministic retrieval and schema-validation of an <code>applyDescriptor</code> persisted in evidence. <br> <strong>Inputs:</strong> <code>applyId</code>. <br> <strong>Outputs:</strong> parsed <code>ApplyDescriptor</code> object or errors (<code>APD_NOT_FOUND</code>, <code>APD_CHECKSUM_MISMATCH</code>, <code>APD_SCHEMA_INVALID</code>). <br> <strong>Responsibilities:</strong> <br> 1. Resolve <code>apply_&lt;applyId&gt;.json</code> via index. <br> 2. Fetch artifact, compute sha256 and compare to stored <code>applyChecksum</code>. <br> 3. Schema-validate required fields and return parsed object. <br> <strong>Preconditions & invariants:</strong> read-only; deterministic. <br> <strong>Failure modes & remediation:</strong> <br> 1. Not found → <code>APD_NOT_FOUND</code>: retrieve from staging or recreate. <br> 2. Checksum mismatch → <code>APD_CHECKSUM_MISMATCH</code>: freeze and escalate to infra, create <code>forensic_manifest</code>. <br> <strong>Observability:</strong> <code>applyDescriptor.load.ms</code>, <code>applyDescriptor.checksum_mismatch</code>. <br> <strong>CI tests:</strong> corrupted JSON, missing required field cases. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>ComputeRevertId(applyId As String, normalizedRevertTs As String, policyHash As String) : String</code> <br> <strong>Purpose:</strong> compute deterministic <code>revertId</code> used for idempotency, token idempotency tokens, and evidence anchors. <br> <strong>Inputs:</strong> <code>applyId</code>, <code>normalizedRevertTs</code> (<code>YYYY-MM-DDTHH:MM:SSZ</code>), <code>policyHash</code> optional. <br> <strong>Outputs:</strong> <code>revertId</code> string <code>sha256:&lt;hex&gt;</code>. <br> <strong>Responsibilities:</strong> <br> 1. Canonical concatenation <code>applyId|normalizedRevertTs|policyHash</code> (policyHash empty if nil). <br> 2. UTF-8 encode and compute sha256 hex digest; prefix <code>sha256:</code>. <br> 3. Return <code>revertId</code>. <br> <strong>Preconditions & invariants:</strong> deterministic across runtimes; requires <code>canonicalVersion</code> for parity. <br> <strong>Failure modes & remediation:</strong> invalid timestamp → <code>ERR_INVALID_TS</code> and attempt canonicalization; else abort. <br> <strong>Observability:</strong> <code>revert.id.compute.ms</code>. <br> <strong>CI tests:</strong> deterministic vectors across locales and timezones. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>IdempotencyCheck(revertId As String) : IdempotencyResult</code> <br> <strong>Purpose:</strong> ensure repeated revert attempts are no-ops when a revert already exists or is in progress. <br> <strong>Inputs:</strong> <code>revertId</code>. <br> <strong>Outputs:</strong> <code>IdempotencyResult</code> { <code>isAlreadyReverted</code>, <code>existingDescriptorRef</code>, <code>status</code> }. <br> <strong>Responsibilities:</strong> <br> 1. Query evidence index for existing <code>revertDescriptor</code> keyed by <code>revertId</code>. <br> 2. If found and <code>status = completed</code> return <code>isAlreadyReverted=True</code>. If <code>in_progress</code> return <code>True</code> and present <code>in_progress</code> metadata to block concurrency. <br> <strong>Preconditions & invariants:</strong> storage reads must be linearizable; conditional create-if-not-exists semantics used on persist path. <br> <strong>Failure modes & remediation:</strong> read-after-write inconsistency → short re-check/backoff; abort if unresolved. <br> <strong>Observability:</strong> <code>revert.idempotency.hits/misses/raceErrors</code>. <br> <strong>CI tests:</strong> concurrent create simulation ensuring single-winner semantics. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>PersistRevertDescriptor(revertDescriptor As RevertDescriptor) : persistedRef</code> <br> <strong>Purpose:</strong> create initial <code>revertDescriptor</code> or append update versions; guarantee single-winner semantics for concurrent attempts. <br> <strong>Inputs:</strong> <code>revertDescriptor</code> object (fields: <code>revertId</code>, <code>applyId</code>, <code>postedJournalIds[]</code>, <code>status = in_progress</code>). <br> <strong>Outputs:</strong> <code>persistedRef</code> (<code>path</code> + <code>sha256:</code>). <br> <strong>Responsibilities:</strong> <br> 1. Use storage conditional create-if-not-exists to guarantee single-winner create. <br> 2. Append metadata <code>createdBy</code>, <code>createdTs</code>, <code>canonicalVersion</code>. <br> 3. If descriptor exists return existing ref (no override). <br> 4. Emit <code>fa.je.revert.started{revertId}</code> with <code>correlationId</code> and evidenceRefs. <br> <strong>Preconditions & invariants:</strong> append-only; <code>prevVersionRef</code> used for version linkage. <br> <strong>Failure modes & remediation:</strong> storage write failure → <code>RetryPolicy</code> then stage locally and emit <code>fa.revert.persist_failure</code>; escalate on repeated failure. <br> <strong>Observability:</strong> <code>revert.descriptor.persist.ms</code>, <code>revert.descriptor.persist.failures</code>. <br> <strong>CI tests:</strong> concurrent create tests ensuring atomic single-winner behavior and version chain tests. <br> <strong>Operator runbook:</strong> steps for resolving persistent storage failures and staging artifact recovery. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>ObtainEphemeralToken(operatorId As String, actionScope As String, revertId As String) : EphemeralToken</code> <br> <strong>Purpose:</strong> acquire ephemeral credentials from secure token service for GL reversal calls; only tokenId & expiryTs audited—token value never persisted or logged. <br> <strong>Inputs:</strong> <code>operatorId</code>, <code>actionScope</code> (e.g., <code>gl:reversal:erp-v1</code>), <code>revertId</code>. <br> <strong>Outputs:</strong> <code>EphemeralToken</code> { <code>tokenId</code>, <code>expiryTs</code>, <code>scope</code>, <code>auditRef</code> }. <br> <strong>Responsibilities:</strong> <br> 1. Request token including <code>revertId</code> and <code>operatorId</code> for auditable issuance. <br> 2. Emit <code>fa.token.issued{tokenId, expiryTs}</code> (no material). <br> 3. Return token object for immediate use only; ensure token material not persisted in logs. <br> <strong>Preconditions & invariants:</strong> short TTL; revocation support. <br> <strong>Failure modes & remediation:</strong> token service outage → create forensic artifact and abort automated reversal; do not proceed without tokens. <br> <strong>Observability:</strong> <code>token.request.latency</code>, <code>token.request.failures</code>. <br> <strong>CI tests:</strong> token service stub tests and token expiry handling. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>CallGLReversalAPI(postedJournalId As String, revertId As String, operatorId As String, ephemeralToken As EphemeralToken) : GLReversalResult</code> <br> <strong>Purpose:</strong> execute single GL reversal API call via vendor adapter, using idempotency token and robust mapping of vendor errors to canonical error codes; persist vendor raw response. <br> <strong>Inputs:</strong> <code>postedJournalId</code>, <code>revertId</code>, <code>operatorId</code>, <code>ephemeralToken</code>. <br> <strong>Outputs:</strong> <code>GLReversalResult</code> { <code>success</code> boolean, <code>statusCode</code>, <code>responseRef</code> (evidenceRef), <code>glReversalId</code>, <code>errorCode</code>, <code>retryable</code> boolean }. <br> <strong>Responsibilities:</strong> <br> 1. Build payload per vendor adapter and include <code>idempotencyToken = revertId|postedJournalId</code>. <br> 2. Send request using ephemeral token; do not log token value. <br> 3. Persist raw response body <code>responseRef</code> and compute <code>responseChecksum</code>. <br> 4. Map vendor responses to canonical error codes: <code>GL_404_NOT_FOUND</code>, <code>GL_409_ALREADY_REVERSED</code>, <code>GL_401_AUTH</code>, <code>GL_5XX_TRANSIENT</code>. <br> 5. Use <code>RetryPolicy</code> for transient responses and rate-limit handling. <br> <strong>Preconditions & invariants:</strong> every request includes idempotency token and audit correlation data. <br> <strong>Failure modes & remediation:</strong> <br> 1. <code>404</code>: mark <code>manual_required</code> and include vendor diagnostics; gather evidence for <code>reversalArtifact</code>. <br> 2. <code>409</code>: treat as success but annotate <code>already_reversed</code>. <br> 3. <code>401</code>: obtain new ephemeral token and retry once; if persist fail with <code>fa.revert.auth_failure</code>. <br> 4. <code>5xx</code>: retry with backoff then mark as <code>failed_transient</code> and produce forensic artifact if unresolved. <br> <strong>Observability:</strong> <code>revert.gl.call.latencyMs</code>, <code>revert.gl.call.retryCount</code>, <code>revert.gl.call.successRate</code>. <br> <strong>CI tests:</strong> adapter stubs for canonical responses and idempotency replay tests. <br> <strong>Runbook:</strong> create manual <code>reversalArtifact</code> for <code>manual_required</code> items and notify GL desk. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>BatchCallGLReversals(postedJournalIds As Collection, revertId As String, operatorId As String, parallelism As Integer) : BatchRevertResult</code> <br> <strong>Purpose:</strong> orchestrate multiple GL reversal calls concurrently with per-item persistence and resume semantics. <br> <strong>Inputs:</strong> <code>postedJournalIds</code> (collection), <code>revertId</code>, <code>operatorId</code>, <code>parallelism</code>. <br> <strong>Outputs:</strong> <code>BatchRevertResult</code> { <code>succeededIds[]</code>, <code>failedDetails[]</code>, <code>partialSuccess</code> boolean, <code>durationMs</code> }. <br> <strong>Responsibilities:</strong> <br> 1. Partition work across worker pool respecting <code>parallelism</code> and vendor rate-limits. <br> 2. For each item call <code>CallGLReversalAPI</code> wrapped by <code>RetryPolicy</code>. <br> 3. Persist per-item results using <code>UpdateRevertDescriptorProgress</code> after each attempt so restarts resume only pending items. <br> 4. Aggregate results and return <code>BatchRevertResult</code>. <br> <strong>Preconditions & invariants:</strong> <code>revertDescriptor</code> persisted before batch start. <br> <strong>Failure modes & remediation:</strong> worker crash → restart and resume from persisted <code>perJournalProgress</code>; persistent auth failure → abort batch and generate forensic artifacts for pending items. <br> <strong>Observability:</strong> <code>revert.batch.durationMs</code>, <code>revert.batch.partialFailureRate</code>. <br> <strong>CI tests:</strong> mixed outcome batch with resume, backoff, and rate-limit response tests. <br> <strong>Runbook:</strong> escalate if vendor rate-limit or throttling reduces throughput below critical SLA. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>UpdateRevertDescriptorProgress(revertId As String, perJournalUpdate As Collection) : persistedRef</code> <br> <strong>Purpose:</strong> append per-journal progress entries to the <code>revertDescriptor</code> enabling precise resume and audit. <br> <strong>Inputs:</strong> <code>revertId</code>, <code>perJournalUpdate</code> collection containing entries <code>{ postedJournalId, status, glReversalId, attempts, lastError, ts }</code>. <br> <strong>Outputs:</strong> persisted updated descriptor ref. <br> <strong>Responsibilities:</strong> <br> 1. Append a new progress entry with <code>ts</code>, <code>operatorId</code>, and <code>correlationId</code>. <br> 2. Maintain ordering by <code>ts</code>; include <code>prevVersionRef</code> linking versions. <br> 3. Emit <code>fa.je.revert.progress</code> audit event with counts (succeeded/failed/pending). <br> <strong>Preconditions & invariants:</strong> append-only; updates idempotent if identical. <br> <strong>Failure modes & remediation:</strong> persist failure → local checkpoint and retry; raise infra alert on repeated failures. <br> <strong>Observability:</strong> <code>revert.progress.update.ms</code>, <code>revert.progress.update.failures</code>. <br> <strong>CI tests:</strong> ordering checks, resume tests, idempotency of repeated identical updates. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>GenerateReversalArtifact(failedJournalDetails[], applyDescriptor, reasonText) : reversalArtifactRef</code> <br> <strong>Purpose:</strong> build canonical <code>reversalArtifact.csv</code> and <code>forensic_manifest.json</code> for manual GL desk reversal when automation fails or vendor lacks API. <br> <strong>Inputs:</strong> <code>failedJournalDetails[]</code> (object per row with <code>postedJournalId</code>, <code>originalJeId</code>, <code>amountMinorUnits</code>, <code>currency</code>, <code>narrative</code>, <code>evidenceRefs</code>), <code>applyDescriptor</code>, <code>reasonText</code>. <br> <strong>Outputs:</strong> <code>reversalArtifactRef</code> (CSV evidenceRef), <code>forensicManifestRef</code> (JSON evidenceRef). <br> <strong>Responsibilities:</strong> <br> 1. Compose canonical CSV with ordered columns, include <code>idempotencyHint=revertId</code>, and evidenceRefs. <br> 2. Build <code>forensic_manifest.json</code> linking <code>applyDescriptorRef</code>, <code>revertDescriptorRef</code>, <code>depreciationRunManifestRef</code>, <code>previewManifestRef</code>, and containing <code>humanSummary</code> and explicit <code>nextSteps</code> for GL desk. <br> 3. Persist both artifacts atomically; compute <code>sha256:</code> checksums; tag with <code>legalTags</code> and retention policy. <br> <strong>Preconditions & invariants:</strong> minimal PII in CSV; full evidence available in manifest accessible under approvals. <br> <strong>Failure modes & remediation:</strong> persistence failure -> stage locally and emit <code>fa.revert.forensic_staged</code>; notify infra. <br> <strong>Observability:</strong> <code>revert.forensic.artifactsCreated</code>, artifact sizes and counts. <br> <strong>CI tests:</strong> CSV schema tests, manifest completeness, checksum parity with golden fixtures. <br> <strong>Runbook:</strong> deliver artifact to GL desk with <code>correlationId</code> and require <code>ackRef</code> on manual posting. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>PostRevertValidation(revertId As String) : PostRevertReport</code> <br> <strong>Purpose:</strong> validate GL state after reversal attempts; produce <code>postRevertReport</code> summarizing confirmations and discrepancies. <br> <strong>Inputs:</strong> <code>revertId</code>. <br> <strong>Outputs:</strong> <code>PostRevertReport</code> persisted with <code>confirmedReversals[]</code>, <code>pendingManual[]</code>, <code>discrepancies[]</code>, <code>reportRef</code>. <br> <strong>Responsibilities:</strong> <br> 1. Query GL or reconcile via GL ingestion pipeline to verify each <code>postedJournalId</code> reversal status. <br> 2. Create <code>confirmedReversals[]</code> for items verified as reversed and <code>pendingManual[]</code> for items that require manual posting. <br> 3. Persist <code>fa_revert_report_&lt;revertId&gt;_&lt;hash&gt;.json</code> and emit <code>fa.je.revert.postValidation</code>. <br> <strong>Preconditions & invariants:</strong> GL query or ingestion pipeline available; reconciliation logic must tolerate eventual consistency windows. <br> <strong>Failure modes & remediation:</strong> GL eventual consistency -> retry windows and escalate if breach of SLA. <br> <strong>Observability:</strong> <code>revert.postValidation.durationMs</code>, <code>revert.postValidation.discrepancyCount</code>. <br> <strong>CI tests:</strong> GL delay simulation fixtures, mismatch detection. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>BuildForensicManifest(applyDescriptorRef, revertDescriptorRef, relatedEvidenceRefs[]) : forensicManifestRef</code> <br> <strong>Purpose:</strong> assemble canonical, audit-ready evidence bundle for manual processing and compliance. <br> <strong>Inputs:</strong> <code>applyDescriptorRef</code>, <code>revertDescriptorRef</code>, <code>relatedEvidenceRefs[]</code>. <br> <strong>Outputs:</strong> <code>forensicManifestRef</code> persisted with checksum. <br> <strong>Responsibilities:</strong> <br> 1. Canonically list artifacts and compute checksums; include <code>humanSummary</code>, <code>nextSteps</code>, <code>legalTags</code>, <code>retentionPolicy</code>, and <code>chainOfCustodyTemplate</code>. <br> 2. Persist manifest immutably and ensure retrieval requires <code>approvalRef</code>. <br> <strong>Preconditions & invariants:</strong> all included artifacts accessible or flagged in <code>missingEvidence[]</code>. <br> <strong>Failure modes & remediation:</strong> missing evidence annotated; provide retrieval procedure. <br> <strong>Observability:</strong> <code>forensic.build.durationMs</code>. <br> <strong>CI tests:</strong> manifest parity tests; ordering guarantees. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>NotifyStakeholders(revertId, recipients[], summary, severity) : NotificationResult</code> <br> <strong>Purpose:</strong> deliver non-PII summary & procedural notifications (start/partial/final) to GL desk, compliance, operators, and app owners; PII gating and approval instructions included where necessary. <br> <strong>Inputs:</strong> <code>revertId</code>, <code>recipients[]</code> (roles/emails), <code>summary</code>, <code>severity</code> (<code>info|warning|critical</code>). <br> <strong>Outputs:</strong> <code>NotificationResult</code> with per-recipient delivery status and <code>notificationAuditRef</code>. <br> <strong>Responsibilities:</strong> <br> 1. Produce templated message with counts (succeeded/failed/manual), <code>forensicManifestRef</code> if manual action required, and instructions for requesting raw evidence (approvalRef). <br> 2. Redact PII, attach only tokenized links; persist audit row <code>fa.je.revert.notified</code>. <br> <strong>Preconditions & invariants:</strong> must not include token material or unapproved PII; recipients validated against access roles. <br> <strong>Failure modes & remediation:</strong> delivery failures retried; fallback to pager/ticket as necessary. <br> <strong>Observability:</strong> <code>revert.notify.latencyMs</code>, <code>revert.notify.failures</code>. <br> <strong>CI tests:</strong> template & redaction tests. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Function:</strong> <code>CleanupAndFinalize(revertId As String) : FinalizationResult</code> <br> <strong>Purpose:</strong> final housekeeping: retention tagging, SLA checks, final audit emission, revoke ephemeral tokens where applicable (audit only). <br> <strong>Inputs:</strong> <code>revertId</code>. <br> <strong>Outputs:</strong> <code>fa.je.revert.finalized</code> audit event ref and updated artifact tags. <br> <strong>Responsibilities:</strong> <br> 1. Persist final <code>revertDescriptor</code> with final <code>status</code> and <code>prevVersionRef</code>. <br> 2. Apply <code>legalTags</code> and <code>retentionPolicy</code> labels to artifacts created by revert. <br> 3. Revoke ephemeral tokens (audit-only revocation), emit <code>fa.token.revoked</code> events with <code>tokenId</code>. <br> 4. Emit final SLA metrics and flag <code>sla_breach</code> if exceeded. <br> <strong>Preconditions & invariants:</strong> cannot delete evidence; only tagging and archival. <br> <strong>Failure modes & remediation:</strong> tagging failures scheduled for background reconciliation and infra alerting. <br> <strong>Observability:</strong> <code>revert.cleanup.ms</code>, <code>revert.retention.taggingFailures</code>. <br> <strong>CI tests:</strong> finalization and tagging verification. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Utility:</strong> <code>RetryPolicy(attemptFunc, retryCount, baseDelayMs, classifyError) : RetryResult</code> <br> <strong>Purpose:</strong> standardized exponential backoff + jitter policy used by GL calls and storage operations. <br> <strong>Inputs:</strong> <code>attemptFunc</code> callable, <code>retryCount</code>, <code>baseDelayMs</code>, <code>classifyError</code> callable returning <code>transient</code> or <code>permanent</code>. <br> <strong>Outputs:</strong> <code>RetryResult</code> { <code>success</code> boolean, <code>attempts</code> int, <code>lastError</code> }. <br> <strong>Responsibilities:</strong> <br> 1. Retry transient errors up to <code>retryCount</code> with exponential backoff and jitter; stop on permanent errors. <br> 2. Enforce <code>maxWallTimeMs</code> to avoid runaway attempts. <br> <strong>Preconditions & invariants:</strong> classify error properly to avoid retrying permanent failures. <br> <strong>Failure modes & remediation:</strong> retries exhausted -> return <code>transient_failure</code> to caller for manual fallback. <br> <strong>Observability:</strong> <code>retry.attempts</code>, <code>retry.totalDelayMs</code>. <br> <strong>CI tests:</strong> backoff timing patterns, transient/permanent classification tests. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Security & governance constraints (module-level)</strong> <br> 1. Ephemeral token policy: ephemeral tokens required for GL calls; token values must never be logged or persisted; <code>tokenId</code> and <code>expiryTs</code> audited. <br> 2. Approvals: <code>ValidateRevertPreconditions</code> enforces <code>policySnapshot.approvalMatrix</code> including two-person signoffs for regulated GL accounts. <br> 3. Evidence access: retrieval of raw artifacts requires <code>approvalRef</code>, must generate <code>chainOfCustody</code> audit entry including who retrieved, why, and when. <br> 4. Append-only evidence: descriptors and manifests are immutable; updates appended as new versions linked via <code>prevVersionRef</code>. <br> 5. Legal/regulatory tagging: forensic artifacts must include <code>legalTags</code> and retention policy metadata. <br> 6. Audit events: every lifecycle step emits <code>fa.*</code> event carrying <code>correlationId</code>, <code>applyId</code>, <code>revertId</code>, <code>operatorId</code>, and <code>paramsHash</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Observability & telemetry (recommended)</strong> <br> 1. <code>revert.durationMs</code> (P50/P95/P99) — run latency. <br> 2. <code>revert.automatedSuccessRate</code> — automated reversals / total targeted journals. <br> 3. <code>revert.pendingManualCount</code> — outstanding manual items. <br> 4. <code>revert.idempotency.hits</code>/<code>misses</code>. <br> 5. <code>revert.gl.latencyP50/P95</code> per vendor. <br> 6. <code>revert.forensicArtifactsCreated</code> and artifact sizes. <br> 7. <code>revert.notify.failures</code>. <br> 8. <code>revert.goldenParityFailures</code> from nightly parity checks. <br> 9. Distributed trace linking <code>applyDescriptor</code>, <code>revertDescriptor</code>, <code>postRevertReport</code>, and <code>forensicManifest</code> via <code>correlationId</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>CI & testing matrix (comprehensive)</strong> <br> 1. Unit tests: canonicalization (NFKC, amountMinorUnits, date normalization), <code>ComputeRevertId</code> vectors, <code>PersistRevertDescriptor</code> create-if-not-exists semantics. <br> 2. Integration tests: full end-to-end flows with GL stubs covering success/404/409/5xx/401 behavior and idempotency tests. <br> 3. Idempotency tests: repeated revert with same <code>revertId</code> returns existing descriptor and does not replicate GL reversals. <br> 4. Concurrency tests: two concurrent revert requests for same apply produce single-winner descriptor; resume correctness. <br> 5. Resume & crash recovery tests: worker drops mid-batch and resumes from <code>perJournalProgress</code>. <br> 6. Forensic/golden parity tests: canonical <code>reversalArtifact.csv</code> and <code>forensic_manifest.json</code> <code>sha256:</code> checks across PQ pilot and backend. <br> 7. Security tests: ensure token values not logged, approvals enforced, chainOfCustody created on retrieval. <br> 8. Performance tests: large batch throughput (100/1k/10k), worker scaling, evidence store throughput. <br> 9. Chaos tests: vendor outages, token service failures, storage transient errors and ensure fallback manual artifacts generated. <br> 10. Acceptance tests: <code>ReconcileFAtoGL</code> end-to-end with GL test fixtures verifying final GL balances. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Extremely detailed worked examples & edge-case narratives (no code)</strong> </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Example 1 — Full automated revert (very detailed):</strong> <br> 1. <code>applyId=ap-2026-001</code> persisted with <code>acceptedJEsHash=sha256:AAA...</code>, <code>postedJournalIds[]</code> of 240 items; approvals recorded under <code>approvalsRef</code> with two approvers. <br> 2. Operator <code>alice</code> begins <code>RevertJEs(ap-2026-001, alice)</code>. System loads <code>applyDescriptor</code> and runs <code>ValidateRevertPreconditions</code> — passes. <br> 3. <code>ComputeRevertId</code> computes <code>revertId=sha256:BBB...</code>; <code>IdempotencyCheck</code> returns no existing descriptor. <br> 4. <code>PersistRevertDescriptor</code> creates initial <code>in_progress</code> descriptor version (single-winner semantics). <br> 5. <code>ObtainEphemeralToken</code> requests token (audited <code>tokenId</code> only). <br> 6. <code>BatchCallGLReversals</code> with <code>parallelism=20</code> calls <code>CallGLReversalAPI</code> for each <code>postedJournalId</code> with <code>idempotencyToken = revertId|postedJournalId</code>. Vendor returns <code>200 OK</code> with <code>glReversalId</code> for each call; raw responses persisted. <br> 7. Each per-journal success appended to <code>revertDescriptor.perJournalProgress</code>. After all, <code>PostRevertValidation</code> queries GL and confirms all reversals. <br> 8. <code>revertDescriptor.status=completed</code> persisted, <code>forensicManifest</code> assembled for archival, <code>CleanupAndFinalize</code> applies legal tags and emits <code>fa.je.revert.complete</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Example 2 — Partial automation + manual fallback (very detailed):</strong> <br> 1. <code>applyId=ap-2026-078</code> posted 60 journals. GL adapter returns <code>200 OK</code> for 44 items, <code>409</code> for 4 already reversed, and <code>404</code> for 12 legacy journals not present in vendor ledger. <br> 2. System marks 44 <code>reversed</code>, 4 <code>already_reversed</code>, and 12 <code>manual_required</code>. <br> 3. <code>GenerateReversalArtifact</code> creates <code>reversal_ap-2026-078_&lt;revertId&gt;.csv</code> with those 12 rows including <code>idempotencyHint</code> and <code>evidenceRefs</code> to applyDescriptor and schedule rows. <code>forensic_manifest.json</code> links artifacts and next-steps. <br> 4. <code>NotifyStakeholders</code> sends redacted summary referencing <code>forensicManifestRef</code>; GL desk retrieves manifest under approval and performs manual posting returning <code>ackRef</code>. <br> 5. Operator uploads <code>ackRef</code>; <code>PostRevertValidation</code> confirms all reversals and system finalizes descriptor as <code>completed</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Example 3 — Idempotent replay / race resolution (very detailed):</strong> <br> 1. Two operators concurrently call <code>RevertJEs</code> for same <code>applyId</code>. Both compute identical <code>revertId</code>. <br> 2. Storage conditional create-if-not-exists semantics allow only one <code>PersistRevertDescriptor</code> to succeed (single-winner). Second worker reads existing <code>revertDescriptor</code> and either resumes or observes <code>in_progress</code> and waits if policy requires exclusive run. <br> 3. Workers coordinate via <code>perJournalProgress</code> persisted updates; GL idempotency tokens (derived from <code>revertId|postedJournalId</code>) protect against duplicate postings at vendor-side. <br> 4. Final <code>revertDescriptor</code> with complete progress chain persists; audit events show single run. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Example 4 — Token expiry mid-run & rotation (very detailed):</strong> <br> 1. Long batch with token TTL 10 minutes causes token expiry mid-batch; worker receives <code>401</code> for some calls. <br> 2. Worker calls <code>ObtainEphemeralToken</code> again, obtains new <code>tokenId</code> (audited), resumes calls. Token rotation events appended to <code>revertDescriptor.perJournalProgress</code> with no token material logged. <br> 3. Revert completes successfully; <code>perJournalProgress</code> includes token rotation entries for auditing. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Example 5 — Policy migration & canary reverts (very detailed):</strong> <br> 1. <code>policySnapshot</code> changed after original apply, altering mapping semantics. <code>ValidateRevertPreconditions</code> finds <code>applyDescriptor.beforeChecksums.policyHash</code> differs from current snapshot; <code>migrationManifest</code> lookup required. <br> 2. Without <code>migrationManifest</code> approval the revert is blocked. With <code>migrationManifest</code> containing <code>revertImpactAssessment</code> and <code>canaryPlan</code>, platform runs a small canary revert and monitors <code>DepnExpenseDeltaPct</code>, <code>RunParityChange</code>, and <code>SuggestionAcceptanceRate</code>. If KPIs within threshold, escalate approvals to full run; else rollback and investigate. <br> 3. Revert code always uses <code>applyDescriptor.acceptedJEsHash</code> as canonical source to compute reversal mapping to avoid recomputing JEs under new policy semantics. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Extended edge-cases & operational decisions (explicit):</strong> <br> 1. <strong>Partial-amount journals:</strong> vendor returns partial posting; treat as <code>manual_required</code> unless adapter supports partial reversal semantics; include <code>postResponseRef</code> data for GL ops. <br> 2. <strong>Cross-currency reversals:</strong> include <code>fxRateRef</code> in <code>revertDescriptor</code> and ensure <code>reversalAmountMinorUnits</code> use minor units of the currency the GL expects; record <code>fxRateRef</code> for audit. <br> 3. <strong>Large applies:</strong> support partial revert subsets (by cost center, vendor, period) to reduce blast radius and operator workload. <br> 4. <strong>High-value regulated GL ranges:</strong> two-person approval enforced, and revert not allowed without explicit compliance signoff. <br> 5. <strong>Archive retrieval:</strong> if evidence archived, <code>ValidateRevertPreconditions</code> should return <code>evidence_missing</code> with <code>archiveRetrievalRef</code> and abort until retrieval completes. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Operational runbooks & playbooks (concise actionable steps)</strong> </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Playbook — Standard automated revert:</strong> <br> 1. Confirm <code>applyDescriptorRef</code> exists and <code>ValidateRevertPreconditions</code> returns <code>canProceed=true</code>. <br> 2. Compute <code>revertId</code> and run <code>IdempotencyCheck</code>. <br> 3. Persist <code>revertDescriptor</code> (<code>status=in_progress</code>). <br> 4. Obtain ephemeral token (<code>ObtainEphemeralToken</code>). <br> 5. Run <code>BatchCallGLReversals</code> with tuned <code>parallelism</code>. <br> 6. Persist per-journal progress via <code>UpdateRevertDescriptorProgress</code>. <br> 7. On all success set <code>status=completed</code>, else <code>partial_completed</code> or <code>pending_manual_revert</code>. <br> 8. Run <code>PostRevertValidation</code>. <br> 9. If manual items exist, <code>GenerateReversalArtifact</code> and <code>BuildForensicManifest</code>, <code>NotifyStakeholders</code>, then obtain <code>ackRef</code> and revalidate. <br> 10. Finalize via <code>CleanupAndFinalize</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Playbook — Partial/manual fallback:</strong> <br> 1. Generate <code>reversalArtifact.csv</code> and <code>forensic_manifest.json</code>. <br> 2. Notify GL desk and compliance with <code>forensicManifestRef</code> and retrieval instructions (approval required). <br> 3. GL desk performs manual postings; returns <code>ackRef</code>. <br> 4. Operator uploads <code>ackRef</code>; <code>PostRevertValidation</code> confirms final state; finalize. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Playbook — Idempotency conflict or storage collision:</strong> <br> 1. If concurrent create attempts detected, use single-winner <code>revertDescriptor</code>. <br> 2. Second callers must read existing <code>perJournalProgress</code> and either resume or exit as per policy. <br> 3. If storage shows conflicting descriptors for same <code>revertId</code>, escalate to infra; reconcile using <code>prevVersionRef</code> chain and <code>correlationId</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Playbook — Checksum mismatch / suspected tamper:</strong> <br> 1. On <code>APD_CHECKSUM_MISMATCH</code> freeze operations and capture <code>correlationId</code>. <br> 2. Create <code>forensic_manifest</code> including all evidenceRefs and notify compliance & infra. <br> 3. Do not attempt revert until issue resolved and checksum parity restored. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Conceptual Power Query (PQ) guidance for pilots (no snippets)</strong> </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>When to use PQ:</strong> PQ is recommended for small-sample previews, analyst review of <code>applyDescriptor</code>, building candidate <code>reversalArtifact.csv</code> samples, and canary cohort previews. PQ is not suitable for large-scale automated reversal due to tokenization, precision and scalability constraints. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>PQ pilot architecture (conceptual):</strong> <br> 1. <code>ApplyDescriptor_Staging</code> — parameterized load of <code>apply_&lt;applyId&gt;.json</code> for interactive inspection. <br> 2. <code>PostedJournal_Sample</code> — sample extraction of <code>postedJournalIds[]</code> with optional filters by <code>costCenter</code> or <code>vendor</code>. <br> 3. <code>ReversalArtifact_Preview</code> — transforms sample rows into canonical CSV columns (strings for <code>amountMinorUnits</code>) for GL desk review. <br> 4. <code>PreviewManifest</code> — store PQ preview hash <code>previewHash</code> linked to backend <code>previewArtifact</code> for parity testing. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Canonicalization in PQ (conceptual):</strong> <br> 1. Text: apply <code>Text.Trim</code> and safe normalization; if PQ lacks robust Unicode NFKC use mapping tables or mark for backend normalization. <br> 2. Numeric: avoid floating arithmetic; compute <code>amountMinorUnits</code> as string via integer arithmetic using string functions when PQ numeric precision is insufficient. <br> 3. Date: format preview <code>revertTs</code> as <code>YYYY-MM-DDTHH:MM:SSZ</code> and compare to backend <code>revertId</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>PQ anti-patterns & mitigations:</strong> <br> 1. Never store ephemeral tokens in PQ; use PQ only for preview and rely on backend for tokenized network calls. <br> 2. Avoid per-row API calls in PQ — use PQ only for sample previews. <br> 3. Avoid heavy numeric math in PQ; offload exact rounding and financial math to backend compute to preserve parity. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Parity testing for PQ pilots:</strong> <br> 1. Golden fixtures: <code>applyDescriptor.json</code> sample and expected <code>reversalArtifact.csv</code> preview. <br> 2. PQ preview must produce identical <code>revertId</code> and sample CSV rows to backend computation for small sample; any mismatch blocks promotion. <br> 3. Record and triage PQ parity diffs (locale parsing, rounding, field ordering). </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Operational PQ flow:</strong> <br> 1. Analyst runs PQ sample preview, creates <code>previewManifest</code> with <code>previewHash</code>. <br> 2. Backend parity job replays canonical inputs and asserts <code>revertId</code> and <code>reversalArtifact</code> sample parity before full-run proceed. <br> 3. If parity passes and approvals present, trigger backend <code>RevertJEs</code> for full scope. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX measures, reporting patterns & UX (no snippets)</strong> </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Modeling principles:</strong> <br> 1. Use canonical keys (<code>applyId</code>, <code>revertId</code>, <code>runId</code>, <code>policyHash</code>) to build relationships and join tables. <br> 2. Store monetary amounts as <code>amountMinorUnits</code> plus <code>scale</code> and convert to display units in visuals to avoid rounding ambiguity. <br> 3. Tokenize or obfuscate PII on analyst dashboards; provide a secure path for auditors to request raw evidence with <code>approvalRef</code> and chain-of-custody logging. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Core DAX measure concepts (conceptual formulas):</strong> <br> 1. <code>Revert_AutomationRate = DIVIDE( SUM(RevertLines[automatedReversedCount]), SUM(RevertLines[totalToReverse]) , 0 )</code> — proportion of journals reversed automatically. <br> 2. <code>Revert_SuccessRate = DIVIDE( SUM(RevertLines[reversedCount]), SUM(RevertLines[attemptedCount]) , 0 )</code> — overall success ratio. <br> 3. <code>AvgRevertDuration = AVERAGE( RevertHeader[completedTs] - RevertHeader[startTs] )</code> — average run duration. <br> 4. <code>Revert_PendingManualAmount = SUMX( FILTER(RevertLines, RevertLines[status]=&quot;manual_required&quot;), RevertLines[amountMinorUnits] )</code> — outstanding manual exposure. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Operational KPIs & drillthrough patterns:</strong> <br> 1. <code>AutomationRateByVendor</code> — aggregate <code>Revert_AutomationRate</code> grouped by <code>Vendor</code>: identifies vendors requiring mapping fixes. <br> 2. <code>TopPendingManualByCostCenter</code> — <code>TOPN</code> on sum of pending manual amounts to prioritize GL desk work. <br> 3. <code>SLA_BreachCount</code> — count of run durations exceeding configured SLAs. <br> 4. Provide drillthrough from a <code>Run</code> row to show <code>applyDescriptor</code> metadata, <code>revertDescriptor</code> progress timeline, per-journal breakdown, and links to <code>forensicManifestRef</code> (tokenized). <br> 5. Allow auditors to filter by <code>policyHash</code> to see runs affected by policy migration. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Alerting & thresholds (recommended):</strong> <br> 1. Automation Rate < 80% for high-volume vendors triggers operational review. <br> 2. Pending Manual Amount over threshold for a cost center triggers pager. <br> 3. Idempotency hits > threshold indicates duplicate revert activity requiring ops review. <br> 4. Golden parity failures in CI trigger immediate blocking and require remediation. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Migration & policy governance (detailed rules):</strong> <br> 1. Policy changes that alter mapping/JEs must include <code>migrationManifest</code> with <code>revertImpactAssessment</code>, <code>sampleFixtures</code>, <code>canaryPlan</code>, <code>rollbackPlan</code>, and <code>approvals[]</code>. <br> 2. Do not allow reverts for runs created under prior <code>policyHash</code> without explicit documented approval if <code>migrationManifest</code> indicates behavior change. <br> 3. Canary reverts required for policy-change-run parity: small cohorts used to verify <code>AutomationRate</code>, <code>AvgRevertDuration</code>, and <code>PostRevertDiscrepancyRate</code> before full promotion. <br> 4. Document <code>revertImpactAssessment</code> capturing expected delta in depreciation expense and mappings. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Performance & scale engineering guidance:</strong> <br> 1. <strong>Shard strategy:</strong> shard work by <code>applyId</code> ranges, <code>vendor</code>, or <code>costCenter</code> to parallelize while preserving deterministic ordering within shards. <br> 2. <strong>Worker checkpointing:</strong> persist per-journal progress after each item (or micro-batch) to minimize redo on crash; configurable trade-off between throughput and rework. <br> 3. <strong>Parallelism tuning:</strong> begin conservatively, monitor vendor rate-limit responses and latency, then auto-scale. <br> 4. <strong>Large-run strategies:</strong> support subset partial reverts (cost center, vendor) and operator-driven staged reverts to limit blast radius. <br> 5. <strong>Storage & evidence architecture:</strong> store raw GL responses and large artifacts in object store (cheap) and small manifest indexes in relational DB for fast queries. <br> 6. <strong>Autoscale & SLOs:</strong> scale workers by queue depth; monitor <code>revert.durationMs</code> and <code>revert.pendingManualCount</code> to trigger scale-out. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Operator CLI & admin commands (conceptual):</strong> <br> 1. <code>fa.revert --apply &lt;applyId&gt; --operator &lt;operatorId&gt;</code> → start <code>RevertJEs</code> run and return <code>revertId</code> and <code>revertDescriptorRef</code>. <br> 2. <code>fa.revert.status --revertId &lt;revertId&gt;</code> → show progress snapshot and links to <code>reversalArtifact</code> if manual items exist. <br> 3. <code>fa.revert.forensic --revertId &lt;revertId&gt; --download</code> → prepare zipped <code>forensic_manifest</code> bundle for GL desk (requires approvals). <br> 4. <code>fa.revert.retry --revertId &lt;revertId&gt; --only-failed</code> → retry transient failures with idempotency; obey approvals. <br> 5. <code>fa.revert.cancel --revertId &lt;revertId&gt; --operator &lt;operatorId&gt;</code> → cancel in-progress revert if policy allows; persist <code>status=failed</code> with reason. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Acceptance gating before production release (explicit):</strong> <br> 1. Deterministic <code>revertId</code> and canonical sha256 vector tests passing across runtimes. <br> 2. Full integration tests against GL stubs covering success, partial, failure, idempotency, and concurrency. <br> 3. Golden parity tests for <code>reversalArtifact.csv</code> and <code>forensic_manifest.json</code> across PQ pilot and backend pass in CI. <br> 4. Security verification that ephemeral tokens are not logged or persisted and PII gating enforced. <br> 5. Performance tests for planned data volumes meet SLOs. <br> 6. Runbooks and operator training validated in a dry-run environment, including GL desk manual handoff practice. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Appendices, templates & reference checklists</strong> </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Appendix A — canonical field order for <code>applyDescriptor</code> hashing (authoritative):</strong> <br> 1. <code>applyId</code> <br> 2. <code>runId</code> <br> 3. <code>operatorId</code> <br> 4. <code>mode</code> <br> 5. <code>acceptedJEsHash</code> <br> 6. <code>beforeChecksums</code> canonical sub-order <br> 7. <code>postedJournalIds[]</code> sorted by <code>originalJeId</code> <br> 8. <code>approvalsRef</code> <br> 9. <code>applyTs</code> <br> 10. <code>canonicalVersion</code> <br> Compute sha256 over UTF-8 canonical string with <code>|</code> separators and prefix with <code>sha256:</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Appendix B — canonical error codes (reference):</strong> <br> • <code>fa.revert.noSnapshot</code> — missing applyDescriptor. <br> • <code>fa.revert.missing_approvals</code> — approvals insufficient. <br> • <code>APD_CHECKSUM_MISMATCH</code> — applyDescriptor checksum mismatch. <br> • <code>GL_404_NOT_FOUND</code> — vendor reports postedJournalId not found. <br> • <code>GL_409_ALREADY_REVERSED</code> — vendor reports journal already reversed. <br> • <code>fa.revert.auth_failure</code> — ephemeral token issuance or auth failure. <br> • <code>fa.revert.partial</code> — partial revert with manual items pending. <br> • <code>fa.revert.forensic_staged</code> — forensic artifact staged due to persistence failure. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Appendix C — operator quick-run verification checklist:</strong> <br> 1. Confirm <code>applyDescriptorRef</code> exists and <code>applyChecksum</code> validated. <br> 2. Confirm approvals via <code>ValidateRevertPreconditions</code>. <br> 3. Compute <code>revertId</code> locally and confirm parity with persisted <code>revertDescriptor</code>. <br> 4. Ensure <code>revertDescriptor</code> persisted before any GL calls. <br> 5. Obtain ephemeral token and verify token audit <code>tokenId</code>. <br> 6. Monitor <code>revertDescriptor.perJournalProgress</code> and follow <code>revert</code> playbook for manual fallbacks. <br> 7. Confirm <code>postRevertReport</code> persisted and finalize with <code>CleanupAndFinalize</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Incident runbook excerpt (explicit steps):</strong> <br> 1. Triage: capture <code>correlationId</code>, retrieve <code>applyDescriptor</code>, <code>revertDescriptor</code>, <code>previewManifest</code>, <code>depreciationRunManifest</code>, and <code>policySnapshot</code> via evidenceRefs. <br> 2. Validate: check <code>applyDescriptor</code> checksum and <code>acceptedJEsHash</code>. <br> 3. Contain: pause any propagating automated exports or applies; notify GL ops and compliance. <br> 4. Remediate: if mapping error from policy change, prepare <code>forensic_manifest</code> and coordinate manual postings with GL desk; if storage issue, freeze operations and restore from backup. <br> 5. Post-mortem: produce incident report with <code>correlationId</code>, root cause, artifacts, and recommended prevention steps; attach to <code>migrationManifest</code> if change-related. <br> 6. Regulatory: preserve <code>forensic_manifest</code> and evidence under legal hold if regulated accounts affected. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Extensibility & adapter patterns:</strong> <br> 1. GL Adapter contract: implement <code>buildReversalPayload</code>, <code>parseReversalResponse</code>, <code>mapVendorErrorsToCanonical</code>, <code>respectVendorRateLimit</code>, and <code>idempotencyToken</code> injection. <br> 2. Notification adapter plug-ins: email, ticketing, pager, with PII redaction hooks. <br> 3. Token service integration: token issuance and revocation audited; store only <code>tokenId</code> and <code>expiryTs</code>. <br> 4. Evidence store adapter: support create-if-not-exists, append-versioning, cross-region replication and parity verification job. <br> 5. CLI & admin API: commands for <code>revert.status</code>, <code>revert.forensic</code>, <code>revert.retry</code>, <code>revert.cancel</code>. </td></tr><tr><td data-label="modRevert — Per-function Expert Technical Breakdown"> <strong>Closing operational note & next steps (actionable)</strong> <br> This specification is the authoritative blueprint for implementing, testing, operating, and governing <code>modRevert</code>. It captures artifact-level semantics, deterministic canonicalization, full function contracts, exhaustive examples and edge cases, PQ pilot guidance, DAX reporting concepts, CI/golden parity requirements, runbooks, and governance. <br> If you want the following deliverables produced next (pick one or more): <br> 1. Formal JSON Schema for <code>applyDescriptor</code>, <code>revertDescriptor</code>, <code>reversalArtifact.csv</code> row schema, and <code>forensic_manifest.json</code> with canonical field order and example fixtures. <br> 2. Canonical CSV and JSON golden fixtures with expected <code>sha256:</code> checksums for CI tests. <br> 3. Step-by-step PQ canonicalization recipe (intermediate table shapes and parity checks). <br> 4. Compact operator runbook (PDF-ready checklist and escalation matrix). <br> Request chosen items and they will be produced as precise artifacts aligned to this blueprint. </td></tr></tbody></table></div><div class="row-count">Rows: 66</div></div><div class="table-caption" id="Table3" data-table="Docu_0187_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by modReconcile — Per-function Expert Technical Breakdown"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">modReconcile — Per-function Expert Technical Breakdown</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Preface (concise):</strong> This document expands <code>modReconcile</code> into a full forensic and operational blueprint. It provides exhaustive per-row narratives for reconciliation artefacts, complete function-level contracts (inputs, outputs, responsibilities, invariants, failure modes, observability metrics, CI tests, operator runbooks), worked examples that surface edge cases and procedural nuance, conceptual Power Query pilot guidance with anti-patterns and mitigations (no PQ code), and conceptual DAX reporting patterns optimized for reconciliation and operational observability (no DAX snippets). All numbered lists use <code>&lt;br&gt;</code> line breaks for downstream rendering consistency. This artifact assumes canonical upstream inputs exist (immutable <code>depreciationRunManifest</code>, <code>assetIngestManifest</code>, <code>capexIngestManifest</code>) and that a policy snapshot (<code>policyHash</code>) governs materiality, FX, mapping, and remediation rules. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Scope & goals (concise):</strong> <code>modReconcile</code> reconciles fixed-asset subledger aggregates to GL control balances in a deterministic, auditable, and evidence-first manner: grouping, currency alignment, variance computation, materiality decisioning, evidence sampling, remediation suggestion generation, remediation orchestration, incremental replays, manifest persistence, and audit emission. The module must produce append-only evidence manifests (<code>fa_recon_report_&lt;runId&gt;_&lt;reportHash&gt;.json</code>) with canonical <code>reportHash</code> (sha256) and attach evidenceRefs for forensic replay. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Per-row canonical narratives & forensic handling</strong> <br> <strong>AssetScheduleAggRow (canonical extended narrative):</strong> This row is the canonical aggregation of subledger schedules for a posting key. Canonical fields: <code>aggregationId</code> (sha256 canonicalKey), <code>controlGLAccount</code>, <code>costCenter</code>, <code>currency</code> (ISO4217), <code>period</code> (YYYY-MM or ISO date for period end), <code>subledgerAmountMinorUnits</code> (integer), <code>rowsContributing[]</code> (ordered list of <code>scheduleRowChecksum</code>), <code>aggregationDiagnostics</code> (object: <code>rowsDropped</code>, <code>parseIssues</code>, <code>overflowFlag</code>), <code>evidenceRefs[]</code> (ingest/run manifests). Responsibilities: be the authoritative subledger-side value for reconciliation; preserve contributor row checksums for deterministic chase; expose diagnostics for failed contributors. Invariants: integer summation (minor-units) preserves associativity and prevents floating-point skew; <code>rowsContributing[]</code> sorted lexicographically by <code>scheduleRowChecksum</code> to make <code>aggregationId</code> deterministic across runtimes. Failure modes & remediation: missing contributor checksums → mark <code>aggregationDiagnostics.missingEvidence=true</code>; integer accumulator overflow → enlarge accumulator (128-bit or bignum) and mark <code>aggregationDiagnostics.overflow=true</code> for CI investigation. Observability: <code>aggregation.rowsCount</code>, <code>aggregation.durationMs</code>, <code>aggregation.rowsDropped</code>. CI Tests: contributor-order independence fixtures, large-accumulator overflow regression, aggregationId parity tests across runtimes. Runbook excerpt: on aggregation diagnostics, retrieve contributor <code>scheduleRowChecksum</code> evidenceRef and re-run aggregation for affected partition, escalate if many missing contributors. <br><br> <strong>GLBalanceRow (canonical extended narrative):</strong> Represents canonical GL control balances ingested from ERP extracts. Canonical fields: <code>glRowChecksum</code> (sha256 of canonical representation), <code>controlGLAccount</code>, <code>costCenter</code>, <code>currency</code>, <code>period</code>, <code>glAmountMinorUnits</code> (integer), <code>sourceFingerprint</code>, <code>originalSignRepresentation</code>, <code>signConvention</code> (normalized), <code>ingestMappingRef</code>, <code>rawPayloadRef</code>, <code>ingestDiagnostics</code> (e.g., <code>mappingSuggestions</code>). Responsibilities: record GL-side authoritative balance for a posting key, preserve mapping and sign decisions in manifest for audit. Invariants: sign normalization policy applied deterministically; missing cost center recorded as <code>Unmapped</code> with mapping suggestions persisted. Failure modes & remediation: inconsistent sign conventions across GL extracts → produce signConvention diagnostics and mappingSuggestions for analyst action; unmapped accounts → persist mapping suggestion artifact and continue run if permitted by tolerance. Observability: <code>gl.ingest.rows</code>, <code>unmappedAccountsCount</code>, <code>signConflicts</code>. CI Tests: sign-convention permutations, unmapped account suggestion parity, ingest checksum golden fixtures. Runbook: inspect <code>ingestDiagnostics</code>, accept mapping suggestions where validated, re-ingest or patch mapping and rerun reconciliation for affected partitions. <br><br> <strong>VarianceRow (canonical extended narrative):</strong> A single canonical reconciliation outcome for a posting key. Canonical fields: <code>reconRowChecksum</code>, <code>aggregationId</code>, <code>controlGLAccount</code>, <code>costCenter</code>, <code>currency</code>, <code>period</code>, <code>subledgerMinorUnits</code>, <code>glMinorUnits</code>, <code>varianceMinorUnits</code> (subledger - gl), <code>absVarianceMinorUnits</code>, <code>relativeVariancePct</code> (nullable; use absolute path for GL==0), <code>matchedState</code> (<code>Matched|FAOnly|GLOnly</code>), <code>materialityDecision</code> (<code>BeyondTolerance:true|false</code>), <code>decisionTrace</code> (ordered list capturing thresholds and overrides applied), <code>evidenceSamples[]</code> (seeded selection of evidenceRefs), <code>suggestedRemediationRef</code> optional, <code>diagnostics</code> (e.g., <code>fxFallbackUsed</code>, <code>signNormalizationApplied</code>). Responsibilities: provide deterministic, minimal, auditable data sufficient for analyst triage and automated remediation suggestion. Invariants: arithmetic in integer minor-units; relative pct computed in scaled integer form (e.g., basis points) to avoid floats; <code>decisionTrace</code> captures rationale for audit. Failure modes & remediation: divide-by-zero on relative pct when <code>glMinorUnits == 0</code> → record <code>relativeVariancePct = null</code> and mark for absolute-threshold comparison; evidence sample missing → fall back to ingest manifest references and flag <code>evidenceMissing</code>. Observability: <code>variance.topBuckets</code>, <code>variance.distribution</code>, <code>variance.largeExceptions</code>. CI Tests: parity tests for variance computation under permutations and streaming join fallback equivalence. Runbook: triage by top <code>absVarianceMinorUnits</code>, follow <code>decisionTrace</code> to locate mapping or FX issues, accept remediation suggestions or start manual corrections. <br><br> <strong>ReconManifest (canonical extended narrative):</strong> The canonical manifest <code>fa_recon_report_&lt;runId&gt;_&lt;reportHash&gt;.json</code> contains <code>runId</code>, <code>policyHash</code>, <code>assetIngestChecksum</code>, <code>capexIngestChecksum</code>, <code>depreciationRunHash</code>, <code>paramsHash</code>, <code>period</code>, <code>canonicalVersion</code>, <code>rowsCount</code>, <code>exceptionsCount</code>, <code>beyondToleranceCount</code>, <code>varianceRows[]</code> (canonical ordering), <code>suggestedRemediationIndexRef</code>, <code>evidenceRefs[]</code>, <code>createdTs</code>, <code>operatorId</code>, and <code>reportHash = sha256(canonicalString)</code>. Responsibilities: immutable evidence of reconciliation run; must be sufficient for full forensic replay. Invariants: canonical field ordering specified and stable; canonicalVersion included in hashed canonical string. Failure modes & remediation: manifest write failure → write staging artifact and emit <code>fa.recon.persist.warning</code>; canonicalization parity mismatch across environments → open parity investigation and block promotion. Observability: <code>recon.manifest.persistLatency</code>, <code>reportHash</code>. CI Tests: canonical serialization parity, manifest atomicity, golden <code>reportHash</code> fixtures. Runbook: follow persist failure steps, collect staging artifact, retry, investigate parity failures with engineering. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Function-level breakdown — complete contracts & narratives</strong> <br> <strong>ReconcileFAtoGL (orchestrator) — complete contract:</strong> <br> <strong>Purpose:</strong> End-to-end orchestration: validate inputs, produce <code>assetScheduleAgg</code> (if missing), ingest GL, align currencies, compute variance, decide materiality, attach evidence, suggest remediation, persist canonical manifest, and emit audit events. <br> <strong>Inputs:</strong> <code>depreciationRunManifestRef</code> (evidenceRef), optionally <code>assetScheduleAgg</code> (pre-aggregated), <code>glExtractRef</code> (file/API), <code>policySnapshotRef</code> (fa_policy_<policyHash>.json), <code>tolerances</code> (absoluteMinorUnits default, relativePct default), <code>params</code> (<code>runId</code>, <code>periodStart</code>, <code>periodEnd</code>, <code>operatorId</code>, <code>samplingPolicy</code>), <code>canonicalVersion</code>. <br> <strong>Outputs:</strong> <code>fa_recon_report_&lt;runId&gt;_&lt;reportHash&gt;.json</code> persisted with evidenceRef, <code>suggestedRemediation[]</code> persisted, audit event <code>fa.recon.report.generated</code>. <br> <strong>Responsibilities (detailed stepwise):</strong> <br> 1. <strong>Pre-flight validation:</strong> confirm <code>depreciationRunManifestRef</code> exists and contains <code>assetIngestChecksum</code> and <code>capexIngestChecksum</code>; verify <code>policySnapshotRef</code> integrity and compute <code>paramsHash</code> for the run.<br> 2. <strong>Input normalization:</strong> ensure <code>tolerances</code> and materiality rules are resolved from <code>policySnapshotRef</code> if not provided explicitly; ensure <code>canonicalVersion</code> is set and recorded.<br> 3. <strong>Aggregate subledger:</strong> if <code>assetScheduleAgg</code> not supplied, invoke <code>AggregateSubledger</code> on <code>DepreciationSchedule[]</code> referenced in <code>depreciationRunManifest</code> for the requested period window.<br> 4. <strong>Load GL:</strong> call <code>LoadGLBalances</code> with <code>glExtractRef</code> and <code>exportSpec</code> to produce canonical <code>glBalances[]</code> plus <code>glIngestManifest</code> evidenceRef.<br> 5. <strong>Currency alignment:</strong> call <code>AlignCurrenciesAndFX</code> with <code>assetScheduleAgg</code> and <code>glBalances</code> to obtain currency-aligned minor-units (optionally in a <code>canonicalCurrency</code>) and record <code>appliedFxRefs[]</code>.<br> 6. <strong>Compute variances:</strong> call <code>ComputeVarianceRows</code> to perform deterministic full-outer join and compute variance metrics per posting key.<br> 7. <strong>Materiality decisions:</strong> call <code>DetermineMateriality</code> to annotate <code>varianceRows</code> with <code>BeyondTolerance</code> flags, reason traces, and required approvals if any.<br> 8. <strong>Attach evidence:</strong> call <code>AttachEvidenceSamples</code> for exception rows per <code>samplingPolicy</code> producing <code>sampleManifestRef</code> and attached evidenceRefs for each varianceRow.<br> 9. <strong>Suggest remediation:</strong> call <code>SuggestRemediation</code> to produce ranked remediation items (mappingPatch, re-export suggestion, manual journal templates) persisted as <code>remediationPayloads</code> and an index referenced in the final manifest.<br> 10. <strong>Persist manifest:</strong> call <code>PersistReconManifest</code> to canonicalize and persist <code>fa_recon_report</code> and compute <code>reportHash</code> (sha256 prefix).<br> 11. <strong>Emit audit:</strong> call <code>EmitReconAudit</code> with the manifest evidenceRef, summary metrics, and correlationId. <br> <strong>Invariants:</strong> Deterministic outputs for identical canonical inputs, <code>policyHash</code>, and <code>canonicalVersion</code>. Idempotent for identical <code>runId</code>. All numeric math performed in minor-units. <br> <strong>Failure modes & remediation:</strong> <br> - Missing upstream manifest: abort with <code>fa.recon.missing_input</code>; remediation: fetch and re-run. <br> - GL ingest parse failure: persist partial manifest with <code>issues[]</code> and advise re-extract; remediation: update <code>exportSpec</code> and re-run <code>LoadGLBalances</code>. <br> - Evidence store persist failure at end: write staging artifact, emit <code>fa.recon.persist.warning</code>, attempt retries, and escalate if persistent. <br> <strong>Observability & telemetry:</strong> <code>recon.totalTimeMs</code>, <code>recon.exceptionsCount</code>, <code>recon.beyondToleranceCount</code>, <code>recon.appliedFxCount</code>, <code>recon.sampledEvidenceCount</code>, <code>correlationId</code> tagging. <br> <strong>CI tests:</strong> end-to-end golden fixtures (full-run parity), injection tests for GL ingest failures and evidence persist outage tests, property tests for order invariance. <br> <strong>Operator runbook (concise flow):</strong> <br> 1. On <code>fa.recon.report.generated</code> check <code>reportHash</code> and top exceptions; <br> 2. Use evidenceRefs to open preview artifacts and <code>depreciationRunManifest</code> to trace sources; <br> 3. Accept remediation suggestions or schedule manual corrections; <br> 4. Rerun incremental tasks for corrected partitions or full run if required. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>AggregateSubledger (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Deterministically reduce <code>DepreciationSchedule[]</code> into <code>assetScheduleAgg[]</code> groups keyed for reconciliation. <br> <strong>Inputs:</strong> <code>DepreciationSchedule[]</code> (from <code>depreciationRunManifest</code>), <code>aggregationSpec</code> (ordered keys: controlGLAccount, costCenter, currency, period), <code>params</code> (<code>roundingScale</code>, <code>periodWindow</code>). <br> <strong>Outputs:</strong> <code>assetScheduleAgg[]</code> with <code>subledgerAmountMinorUnits</code>, <code>rowsContributing[]</code>, <code>aggregationId</code>, <code>aggregationManifestRef</code>. <br> <strong>Responsibilities (detailed):</strong> <br> 1. Validate each schedule row for required fields (<code>scheduleRowChecksum</code>, <code>depreciationAmount</code>, posting keys).<br> 2. Normalize mapping keys using <code>policySnapshot.mappingOverrides</code> and fallback mapping tables; record <code>mappingUsed</code> into diagnostics. <br> 3. Convert <code>depreciationAmount</code> to minor-units using canonical rounding policy and integer math. <br> 4. Group rows by canonical key ordering; sum minor-units with a high-precision accumulator; compute <code>aggregationId = sha256(canonicalKey | orderedRowsContributing | policyHash | canonicalVersion)</code>. <br> 5. Persist <code>aggregationManifest</code> including <code>rowsCount</code>, <code>groupsCount</code>, <code>aggregationDiagnostics</code> and <code>sourceEvidenceRefs</code>. <br> <strong>Invariants:</strong> Idempotent grouping given same inputs; grouping accumulator uses integer arithmetic to preserve associativity; <code>rowsContributing[]</code> ordered for deterministic hash. <br> <strong>Failure modes & remediation:</strong> <br> - Missing <code>scheduleRowChecksum</code> → exclude and annotate diagnostics; <br> - Overflow in accumulation → switch to larger integer type and flag for CI review. <br> <strong>Observability:</strong> <code>aggregation.durationMs</code>, <code>groupsCount</code>, <code>rowsExcludedCount</code>. <br> <strong>CI tests:</strong> grouping invariance across input permutations, overflow fixtures, and aggregation manifest golden checks. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>LoadGLBalances (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Parse GL extract into canonical <code>GLBalanceRow[]</code> with ingest manifest. <br> <strong>Inputs:</strong> <code>glExtractRef</code> (file or API payload), <code>exportSpec</code> with column mapping rules and sign conventions, <code>params</code> (<code>period</code>, <code>defaultCurrency</code>). <br> <strong>Outputs:</strong> <code>glBalances[]</code>, <code>glIngestManifest</code> (<code>sourceFingerprint</code>, <code>ingestChecksum</code>, <code>issues[]</code>) persisted to evidence. <br> <strong>Responsibilities:</strong> <br> 1. Normalise raw bytes (canonical newline, BOM handling), compute <code>sourceFingerprint = sha256(normalizedBytes)</code>, and persist original blob as evidence. <br> 2. Map columns deterministically using <code>exportSpec</code>; record <code>headerMap</code> in <code>glIngestManifest</code> and generate <code>mappingSuggestions</code> if required. <br> 3. Normalize sign conventions to canonical policy, recording <code>originalSignRepresentation</code> and <code>signConvention</code> used. <br> 4. Coerce amounts to minor-units deterministically and compute per-row <code>glRowChecksum</code>. <br> 5. Validate account strings against chart-of-accounts mapping; record unmapped accounts. <br> <strong>Invariants:</strong> identical bytes + <code>exportSpec</code> produce identical <code>glIngestManifest</code>. <br> <strong>Failure modes & remediation:</strong> <br> - API timeouts -> exponential backoff and <code>fa.gl.ingest.io_error</code>; <br> - Unmapped accounts -> persist mapping suggestions and continue if allowed by <code>tolerant</code> mode. <br> <strong>Observability:</strong> <code>gl.ingest.latencyMs</code>, <code>unmappedAccountsCount</code>, <code>signConventionConflicts</code>. <br> <strong>CI tests:</strong> sign-convention permutations, mapping suggestion generation, golden ingest checksum parity. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>AlignCurrenciesAndFX (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Convert and align currencies deterministically for fair comparison between subledger and GL groups. <br> <strong>Inputs:</strong> <code>assetScheduleAgg[]</code>, <code>glBalances[]</code>, <code>fxRateTableRef</code>, <code>policySnapshot.fxPolicy</code> containing <code>canonicalCurrency</code>, <code>fxDateRule</code>, <code>allowedFallbackWindow</code>, <code>roundingScale</code>. <br> <strong>Outputs:</strong> <code>currencyAlignedSubledger[]</code>, <code>currencyAlignedGL[]</code>, <code>appliedFxRefs[]</code>, <code>fxDiagnostics</code> persisted. <br> <strong>Responsibilities (detailed):</strong> <br> 1. Resolve the <code>canonicalCurrency</code> for the run (policy override or provided param). <br> 2. For each non-canonical currency, perform deterministic FX lookup using <code>fxDateRule</code> (e.g., period-end spot, monthly average) against <code>fxRateTableRef</code>. <br> 3. Express FX rates as rational numbers (numerator/denominator) where possible; perform integer-safe conversion: <code>convertedMinor = round((amountMinor * fxNumerator) / fxDenominator)</code> with documented rounding mode. <br> 4. Persist <code>fxDiagnostics</code> with applied rate, source date, fallbacks (if used), and any <code>fxPrecisionLoss</code> deltas. <br> <strong>Invariants:</strong> integer arithmetic used for conversions; <code>fxRateRef</code> and <code>canonicalVersion</code> included in conversion hash. <br> <strong>Failure modes & remediation:</strong> <br> - Missing fxRate for requested date -> deterministic fallback to nearest allowed date within <code>allowedFallbackWindow</code> and mark <code>fxDiagnostics.fallbackUsed=true</code>. If no fallback available, mark affected rows as <code>fxMissing</code> and surface to analyst queue. <br> <strong>Observability:</strong> <code>fx.appliedCount</code>, <code>fx.fallbackCount</code>, <code>fx.latitudeMs</code>. <br> <strong>CI tests:</strong> fallback determinism, rational-rate conversion parity, rounding degenerate cases. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>ComputeVarianceRows (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Deterministic full-outer join of currency-aligned subledger and GL groups producing canonical variance rows. <br> <strong>Inputs:</strong> <code>currencyAlignedSubledger[]</code>, <code>currencyAlignedGL[]</code>, <code>params</code> (<code>keyOrder</code>, <code>roundingScale</code>). <br> <strong>Outputs:</strong> <code>varianceRows[]</code> with computed fields including <code>matchedState</code>, <code>varianceMinorUnits</code>, <code>relativeVariancePct</code>, and <code>diagnostics</code>. <br> <strong>Responsibilities (detailed):</strong> <br> 1. Construct canonical composite key <code>controlGLAccount|costCenter|currency|period</code> in exact field order; ensure each key normalized using policy mapping. <br> 2. Perform deterministic full-outer join sorted by composite key. For large data sets use external-merge or streaming join paths while preserving canonical ordering. <br> 3. Compute per-row arithmetic in minor-units: <code>varianceMinorUnits = subledgerMinorUnits - glMinorUnits</code> and <code>absVarianceMinorUnits = abs(varianceMinorUnits)</code>. <br> 4. Compute <code>relativeVariancePct</code> using safe divide: when <code>glMinorUnits == 0</code>, set <code>relativeVariancePct = null</code> and flag <code>divisionFallback=absoluteThreshold</code> for <code>DetermineMateriality</code>. Otherwise compute scaled integer pct (e.g., basis points) to avoid float imprecision. <br> 5. Annotate <code>matchedState</code> (<code>Matched</code> if both present, <code>FAOnly</code> or <code>GLOnly</code> otherwise) and relevant diagnostics. <br> <strong>Invariants:</strong> deterministic join and arithmetic; composite key canonicalization must be identical across runtimes. <br> <strong>Failure modes & remediation:</strong> <br> - Memory/sort blowout -> fallback to streaming join and mark <code>diagnostics.streamingJoin=true</code> so auditors know join was streamed; <br> - Unexpected nulls -> coerce to zero with diagnostic flag. <br> <strong>Observability:</strong> <code>recon.join.durationMs</code>, <code>leftOnlyCount</code>, <code>rightOnlyCount</code>, <code>matchedCount</code>. <br> <strong>CI tests:</strong> join parity across input permutations, streaming vs in-memory equivalence, safe-divide edge cases. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>DetermineMateriality (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Apply deterministic materiality decisioning to varianceRows using policy rules and per-account overrides. <br> <strong>Inputs:</strong> <code>varianceRows[]</code>, <code>policySnapshot.materialityRules</code> (<code>globalAbsoluteMinorUnits</code>, <code>globalRelativePct</code>, <code>perAccountOverrides</code> map), <code>context</code> (<code>period</code>, <code>runId</code>). <br> <strong>Outputs:</strong> <code>varianceRows[]</code> annotated with <code>BeyondTolerance:true|false</code>, <code>MaterialityReason</code>, <code>decisionTrace</code>. <br> <strong>Responsibilities (detailed):</strong> <br> 1. For each variance row: <br> &nbsp;&nbsp;&nbsp;&nbsp;a. If <code>glMinorUnits == 0</code> compare <code>absVarianceMinorUnits</code> to <code>absoluteThreshold</code> (per-account if override exists). <br> &nbsp;&nbsp;&nbsp;&nbsp;b. Else compute <code>relativePct = absVarianceMinorUnits / abs(glMinorUnits)</code> using scaled integer arithmetic and compare to <code>relativeThresholdPct</code>. <br> &nbsp;&nbsp;&nbsp;&nbsp;c. Apply per-account overrides before global rules with deterministic precedence, recording the rule used in <code>decisionTrace</code>. <br> 2. For rows crossing pk-specific rules (e.g., special regulatory accounts), mark <code>requiresApproval</code> and include required roles from <code>policySnapshot.approvalMatrix</code>. <br> <strong>Invariants:</strong> Decisions reproducible when <code>policySnapshot</code> and inputs constant; <code>decisionTrace</code> contains full rationale for audit. <br> <strong>Failure modes & remediation:</strong> <br> - Negative or invalid thresholds -> <code>LoadPolicySnapshot</code> must fail such policies; if discovered runtime, abort and mark <code>policy.load.invalid</code>. <br> - Missing per-account override expected -> fallback to global rule and log <code>decisionTrace.missingOverride=true</code>. <br> <strong>Observability:</strong> <code>materiality.decisionsMs</code>, <code>beyondToleranceCount</code>, <code>overrideHitRate</code>. <br> <strong>CI tests:</strong> threshold boundary tests, per-account override precedence tests, decisionTrace parity tests. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>AttachEvidenceSamples (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Attach deterministic, seeded samples of evidence artifacts to exception <code>varianceRows</code> to enable rapid analyst triage. <br> <strong>Inputs:</strong> <code>varianceRows[]</code> (particularly exceptions), <code>samplingPolicy</code> (<code>sampleSize</code>, <code>stratifyBy</code>, <code>seedComposition</code>), <code>evidenceIndex</code> (index of manifests and payloads), <code>runHash</code>. <br> <strong>Outputs:</strong> <code>varianceRows[]</code> with <code>evidenceSamples[]</code> (ordered), <code>sampleManifestRef</code>. <br> <strong>Responsibilities (detailed):</strong> <br> 1. For each exception, compute deterministic seed = sha256(<code>runHash | canonicalKey</code>) and use it to select representative samples in a reproducible order. <br> 2. Sampling preference order: scheduleRowRefs (preferred), then ingest manifests, then preview artifacts, then raw payloads subject to approval. Where raw PII is needed but approval absent, attach redacted pointers and create an <code>evidenceAccessRequest</code> payload. <br> 3. Persist <code>sampleManifest</code> describing the sampling trace, seed used, and selected evidenceRefs for auditor replay. <br> <strong>Invariants:</strong> Sampling reproducible across runs given same <code>runHash</code> and <code>samplingPolicy</code>; <code>evidenceSamples[]</code> ordered deterministically. <br> <strong>Failure modes & remediation:</strong> <br> - Missing evidence due to retention -> mark evidenceMissing and pick alternates; <br> - PII retrieval without required approvals -> do not attach raw PII; instead attach redacted sample and escalate to approval workflow. <br> <strong>Observability:</strong> <code>evidenceSamplesAttachedCount</code>, <code>evidenceMissingCount</code>, <code>samplingLatencyMs</code>. <br> <strong>CI tests:</strong> seeded sampling parity, PII redaction checks, sampling fallback tests. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>SuggestRemediation (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> For each exception produce ranked remediation suggestions (mapping fix, re-export request, minor reallocation, manual JE payload) with deterministic scoring and persisted payloads for acceptance. <br> <strong>Inputs:</strong> <code>varianceRows[]</code> with evidenceSamples, <code>policySnapshot.remediationRules</code>, <code>historicalMappingIndex</code>, <code>candidateMappingIndex</code>, <code>operatorContext</code>. <br> <strong>Outputs:</strong> <code>suggestedRemediation[]</code> with <code>remediationId</code>, ordered <code>actionItems[]</code>, <code>payloadRefs[]</code> (mappingPatch, exportSpecAdjustment, manualJournalCSV), <code>confidenceScore</code> (0..1), <code>estimatedEffort</code>, <code>remediationManifestRef</code>. <br> <strong>Responsibilities (detailed):</strong> <br> 1. For each exception, run remediation heuristics in deterministic order: mapping correction, dataset re-export request, reallocation suggestions, and manual journal suggestion. <br> 2. Compute <code>confidenceScore</code> using a dot-product of normalized signals (mappingCompleteness, sampleConsistency, historicalStability) weighted by <code>policySnapshot.matchingWeights</code>. Persist the exact weight vector used in the remediation payload for audit. <br> 3. Generate deterministic payload(s): mapping patch JSON (with canonical ordering), re-extract instructions, or manual JE CSV template. Persist these payloads to evidence store and return <code>payloadRef</code>. <br> 4. Rank suggestions by <code>confidenceScore</code> and <code>estimatedImpact</code>; return an index suitable for analyst review with batch-accept actions. <br> <strong>Invariants:</strong> Remediation scoring reproducible given same inputs and weights; payloads deterministic and idempotent where possible. <br> <strong>Failure modes & remediation:</strong> <br> - Low confidence across suggestions -> mark <code>requiresManualReview</code> and route to analyst triage queue; <br> - Conflicting suggestions (mapping vs manual override) -> mark as <code>conflict</code> and set approval requirement per <code>policySnapshot.approvalMatrix</code>. <br> <strong>Observability:</strong> <code>remediation.suggestionsCount</code>, <code>avgConfidenceScore</code>, <code>bulkApplyPotential</code>. <br> <strong>CI tests:</strong> scoring parity with seeded inputs, payload determinism tests, conflict resolution tests. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>PersistReconManifest (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Canonicalize the entire recon result into the manifest and persist to evidence store, computing the canonical <code>reportHash = sha256(canonicalString)</code>. <br> <strong>Inputs:</strong> <code>reconReport</code> structure (canonical fields), <code>runContext</code> (<code>runId</code>, <code>policyHash</code>, <code>ingestChecksums</code>, <code>paramsHash</code>), <code>canonicalVersion</code>. <br> <strong>Outputs:</strong> persisted manifest <code>fa_recon_report_&lt;runId&gt;_&lt;reportHash&gt;.json</code>, <code>manifestEvidenceRef</code>. <br> <strong>Responsibilities (detailed):</strong> <br> 1. Validate manifest schema and canonical field ordering. <br> 2. Serialize canonical string using <code>|</code> separators and JSON-compact strings for arrays as per canonical recipe. Include <code>canonicalVersion</code> in the canonical string. <br> 3. Compute <code>reportHash = sha256(canonicalString)</code> and prefix with <code>sha256:</code> in stored metadata. <br> 4. Persist manifest atomically to evidence store and return evidenceRef. <br> <strong>Invariants:</strong> canonicalVersion included; identical canonical inputs & version produce identical <code>reportHash</code>. <br> <strong>Failure modes & remediation:</strong> evidence store write failure -> write to staging artifact and alert; canonicalization mismatch across environments -> fail deployment gating and open parity investigation. <br> <strong>Observability:</strong> <code>manifestPersistLatency</code>, <code>manifestWriteRetries</code>. <br> <strong>CI tests:</strong> canonicalization parity across runtimes, golden <code>reportHash</code> fixtures, manifest atomicity assertions. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>EmitReconAudit (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Emit <code>fa.recon.report.generated</code> audit event referencing persisted manifest summarizing key metrics without exposing PII. <br> <strong>Inputs:</strong> <code>manifestEvidenceRef</code>, <code>metricsSummary</code> (exceptionsCount, beyondToleranceCount, topVariance), <code>correlationId</code>, <code>operatorId</code>, <code>environment</code>. <br> <strong>Outputs:</strong> audit event appended to audit stream and persisted. <br> <strong>Responsibilities:</strong> Build append-only audit row with required tags (<code>runId</code>, <code>policyHash</code>, <code>reportHash</code>) and telemetry labels; ensure event persisted with retry/backoff and that no raw PII is in the payload. <br> <strong>Invariants:</strong> one audit event per persisted manifest; audit row includes evidenceRefs and correlationId. <br> <strong>Failure modes & remediation:</strong> audit stream outage -> buffer and retry; persistent failure -> persist local forensic audit and escalate. <br> <strong>Observability:</strong> <code>audit.emitLatency</code>, <code>audit.publishFailures</code>. <br> <strong>CI tests:</strong> audit emission idempotency tests, schema validation tests. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>ApplyRemediationPlan (orchestrator) — complete contract:</strong> <br> <strong>Purpose:</strong> When remediation is accepted, orchestrate application (mapping patches, export/regenerate, manual posting), persist execution descriptors with idempotency tokens, enforce approvals, and call downstream exporters or <code>ApplyCorrections</code>. <br> <strong>Inputs:</strong> <code>acceptedRemediationIds[]</code>, <code>approvalsRef</code>, <code>operatorId</code>, <code>policySnapshotRef</code>, optional <code>exportSpec</code> for re-export. <br> <strong>Outputs:</strong> <code>executionDescriptor</code> (persisted), <code>executionResult</code> with per-action statuses, audit events <code>fa.recon.remediation.started/completed/fail</code>. <br> <strong>Responsibilities (detailed):</strong> <br> 1. Validate approvals against <code>policySnapshot.approvalMatrix</code>. <br> 2. Persist <code>executionDescriptor</code> atomically with idempotency tokens for each action. <br> 3. Execute mapping patches via mapping service (safe, audited API). For re-export, call <code>GenerateJEExport</code>; for GL posts, call <code>ApplyCorrections</code> which enforces ephemeral token usage. <br> 4. Collect per-action results and persist <code>executionResult</code>. If any action is mutative to GL, persist <code>revertDescriptor</code> capturing necessary reversal info. <br> <strong>Invariants:</strong> <code>executionDescriptor</code> persisted BEFORE any mutative action; idempotency tokens guarantee safe retries. <br> <strong>Failure modes & remediation:</strong> partial failure -> capture per-action errors and expose for governed retry; if direct GL posts partially succeed, prepare <code>revertDescriptor</code> for reversion and escalate. <br> <strong>Observability:</strong> <code>remediation.exec.latency</code>, <code>partialFailureCount</code>, <code>approvalFailures</code>. <br> <strong>CI tests:</strong> idempotency replay, approval gating, partial failure and revert handling. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>RecomputeAfterCorrection (primitive) — complete contract:</strong> <br> <strong>Purpose:</strong> Incremental recompute for changed partitions after remediation to validate results and produce delta recon reports or trigger full re-run if needed. <br> <strong>Inputs:</strong> <code>changedAssetRevisionIds[]</code>, <code>changedMappings[]</code>, updated <code>glExtractRef</code> (if re-ingested), <code>runContext</code>. <br> <strong>Outputs:</strong> <code>deltaReconReport</code> for changed groups, <code>incrementalReconManifestRef</code>, <code>parityCheckResult</code> (incremental vs full-run equivalence). <br> <strong>Responsibilities (detailed):</strong> <br> 1. Map changed entities deterministically to aggregation keys and shard partitions for parallel recompute. <br> 2. Run aggregation and variance compute only on impacted keys; ensure same canonical pipeline used for full-run. <br> 3. Compare incremental results to stored full-run results for parity; if mismatch beyond tolerance schedule full re-run and escalate. <br> <strong>Invariants:</strong> incremental results equivalent to full-run for affected rows; deterministic shard mapping used for stable hashing. <br> <strong>Failure modes & remediation:</strong> missed dependent groups -> detect parity mismatch and trigger full run; shard imbalance -> rebalance and rerun. <br> <strong>Observability:</strong> <code>incremental.durationMs</code>, <code>changedRowsCount</code>, <code>parityMismatchCount</code>. <br> <strong>CI tests:</strong> incremental vs full-run equivalence, shard-determinism fixtures, parity regression tests. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Extremely detailed worked examples & edge-case narratives</strong> <br> <strong>Example 1 — Cross-currency fallback FX & audit trail (deep narrative):</strong> <br> 1. Scenario: <code>assetScheduleAgg</code> rows in EUR for period 2026-07 with significant balances; GL extract contains USD balances. <code>policySnapshot.fxPolicy</code> mandates canonical currency USD with <code>fxDateRule</code> = period-end spot and <code>allowedFallbackWindow</code> = 2 business days prior. <br> 2. Observed condition: <code>fxRateTableRef</code> lacks a rate for 2026-07-31 due to data feed outage; rates available for 2026-07-30 and 2026-08-01. <br> 3. Deterministic behavior: <code>AlignCurrenciesAndFX</code> uses deterministic fallback policy (prefer nearest prior date within window) and applies rate from 2026-07-30. <code>fxDiagnostics.fallbackUsed=true</code> and <code>appliedFxRef</code> references <code>fxRates_20260730</code>. Conversion used rational representation from the fx table: numerator/denominator to ensure integer math. The convert step recorded <code>fxDeltaMinorUnits</code> for each affected group showing rounding deltas. <br> 4. Consequence: <code>ComputeVarianceRows</code> produces variances that may flip materiality for some rows. <code>DetermineMateriality</code> documents <code>materialityDecision</code> and <code>decisionTrace</code> includes <code>fxFallback</code> reference. <code>AttachEvidenceSamples</code> attaches FX table evidence and <code>fxDiagnostics</code> to each exception for audit. <br> 5. Runbook action: analysts decide whether to accept fallback or obtain official rate for 2026-07-31. If a new canonical fx table is provided, run <code>AlignCurrenciesAndFX</code> and <code>ComputeVarianceRows</code> again for affected partitions, persist a corrected <code>fa_recon_report</code> and include <code>correctionOf</code> link to prior manifest. <br> 6. CI golden test requirement: include missing-rate fixture where fallback selection is validated across runtimes so <code>reportHash</code> parity asserts catch any differences in fallback logic implementation. <br><br> <strong>Example 2 — GL sign convention flip mid-file and mapping remediation (deep narrative):</strong> <br> 1. Scenario: GL extract contains a mixture of negative and positive balances for the same control account due to ERP export misconfiguration. Subledger uses canonical positive convention for control balances. <br> 2. LoadGLBalances identifies mixed <code>originalSignRepresentation</code> and computes <code>signConventionConflicts</code>. It normalizes rows to canonical sign and persists <code>glIngestManifest</code> including a <code>signConvention</code> decision map. <br> 3. ComputeVarianceRows shows large exceptions. SuggestRemediation produces two deterministic suggestions: <br> &nbsp;&nbsp;&nbsp;&nbsp;a. A mapping override at GL ingest to flip sign for a specific export pattern (low effort, quick fix). <br> &nbsp;&nbsp;&nbsp;&nbsp;b. A permanent fix: reconfigure ERP export to consistent conventions and re-extract (higher effort, recommended for long-term parity). <br> 4. Applying mapping override requires approval if the override affects regulated accounts and surpasses thresholds. <code>ApplyRemediationPlan</code> persists <code>executionDescriptor</code> with idempotency token and, if approved, patches mapping service and triggers <code>RecomputeAfterCorrection</code> for affected partitions. <br> 5. Post-apply, reconcile parity validated via parity checks and <code>PersistReconManifest</code> records corrected <code>reportHash</code>. <br> 6. CI tests must include sign-convention permutations and ensure mapping override vs export reconfig produce equivalent final parities when applied deterministically. <br><br> <strong>Example 3 — Batch-level residual absorption policy (enterprise nuance):</strong> <br> 1. Scenario: Floating rounding residuals across many assets in a cost center accumulate to non-zero and enterprise policy mandates batch-level absorption to zero residual at cost-center level. <br> 2. ComputeDepreciation created schedules that individually adhered to round-half-to-even at asset-level, producing micro residuals. <code>AggregateSubledger</code> sums minor-units and <code>ComputeVarianceRows</code> shows small net residual per cost center. <br> 3. SuggestRemediation builds a batch absorption payload that deterministically selects absorption targets using ordered rules: highest absolute preRounded amount, tie-breaker lexicographic <code>assetId</code>, and last-resort seeded runHash fallback. Payload documents adjustments as <code>manualJournal</code> entries and includes <code>approvalRef</code> requirement because the action mutates GL control balances. <br> 4. Approval gating: two-person approval required per <code>policySnapshot.approvalMatrix</code> for batch absorptions over the configured threshold. Once approved, <code>ApplyRemediationPlan</code> persists <code>executionDescriptor</code> and calls <code>ApplyCorrections</code> (post_direct) with ephemeral credentials and idempotency tokens. <code>RecomputeAfterCorrection</code> validates parity. <br> 5. Audit chain: <code>revertDescriptor</code> prepared in case of post failure; <code>PersistReconManifest</code> records the final zeroed residual state. <br> 6. CI coverage: batch residual arbitration fixtures with thousands of assets to ensure deterministic allocation under heavy scale and to validate performance and parity. <br><br> <strong>Example 4 — Units-of-Production method missing usage (operational nuance):</strong> <br> 1. Scenario: Several assets use Units-of-Production (UoP) method but missing <code>usageThisPeriod</code> data. <code>ComputeDepreciation</code> marks corresponding schedule rows with <code>requiresManualInput</code> and lowers <code>confidenceScore</code>. <br> 2. Reconciliation: those schedule rows propagate to <code>assetScheduleAgg</code> but <code>SuggestRemediation</code> marks the varianceRows with <code>requiresManualInput</code> tag and suggests data collection actions (systematic data capture or manual spreadsheet inputs). <br> 3. Operator flow: analyst collects usage metrics, annotates <code>assetRevision</code> with <code>manualInputs</code>, and triggers <code>RecomputeAfterCorrection</code> on changed assets only. <br> 4. Observability: <code>requiresManualInputCount</code> metric surfaced to operations dashboard for prioritization. <br> 5. CI tests: behavior when usage data arrives late, idempotent re-runs for UoP assets and expected schedule recomputation parity checks. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Conceptual Power Query (PQ) pilot guidance — patterns, anti-patterns, parity guardrails (no code)</strong> <br> <strong>When PQ is appropriate (concise):</strong> Use PQ for analyst previews, early parity checks, and small-cohort canonicalization where interactivity and rapid iteration trump scalability. PQ is not a production backend for 10k+ assets or for high-precision internal math required by final canonical outputs. <br> <strong>Parameterized architecture for PQ pilots (conceptual):</strong> <br> 1. Use named parameterized queries: <code>AssetMaster_Staging(headerMapParam, decimalLocaleParam)</code>, <code>Capex_Staging(headerMapParam, decimalLocaleParam)</code>, <code>PolicySnapshotParam(policyJson)</code>. Keep policy constants (<code>canonicalVersion</code>, <code>policyHashConst</code>) exported as parameters so PQ outputs can be parity-checked against backend runs. <br> 2. Implement canonicalization as small, named steps visible to analysts so intermediate outputs can be inspected and <code>issues[]</code> rows surfaced (e.g., <code>NormalizeTextStep</code>, <code>ParseDecimalStep</code>, <code>ComputeAmountMinorUnitsStep</code>). <br> <strong>Canonicalization steps to implement conceptually in PQ:</strong> <br> 1. Text normalization: apply a consistent pipeline — NFKC (or best-effort approximation in PQ), trim, collapse whitespace, casefold, optionally diacritic-stripping via mapping tables; store <code>rawField</code> alongside canonical token fields. <br> 2. Numeric parsing: pre-clean thousand separators using replace rules, unify decimal separator to <code>.</code> then parse <code>Number.FromText</code> with explicit culture; compute <code>amountMinorUnits</code> by rounding to <code>roundingScale</code> then multiply by 10^scale; store parse diagnostics. <br> 3. Date parsing: attempt ISO parse first; on ambiguity preserve <code>rawDateString</code> and add to <code>issues[]</code> for manual correction. <br> <strong>PQ anti-patterns & mitigations (conceptual):</strong> <br> 1. Per-row custom function loops — Anti-pattern: slow and non-scalable; Mitigation: vectorize transformations with table merges and buffering; sample-only for preview when loops unavoidable. <br> 2. High-precision arithmetic in PQ — Anti-pattern: PQ lacks high precision; Mitigation: represent preRounded high-precision intermediate values as strings and offload final high-precision math to backend for canonical runs. <br> 3. Large in-memory joins — Anti-pattern: timeouts and OOM; Mitigation: sample for preview, or chunk joins and persist intermediate artifacts to object store for backend replay. <br> <strong>Parity and validation in PQ (conceptual):</strong> <br> 1. Always compute <code>policyHash</code> locally by canonicalizing the policy table in PQ and hashing deterministically (or relying on a helper service) so PQ preview includes <code>policyHash</code> and <code>canonicalVersion</code> for parity verification. <br> 2. Produce <code>preview_manifest</code> including <code>previewHash</code> and <code>policyHash</code>; queue the artifact for backend parity job which must assert <code>runHash</code> parity; discrepancies result in <code>fa.verify.parity.failed</code> and block promotion. <br> <strong>Operational PQ flows (concise):</strong> <br> 1. Analysts create PQ Preview -> Export <code>fa_preview_&lt;runId&gt;_&lt;previewHash&gt;.zip</code> -> Submit to backend parity job -> On parity success, analysts accept suggestions and generate remediation artifacts for backend apply flows. <br> <strong>Testing PQ parity (conceptual):</strong> <br> 1. Maintain a set of PQ golden fixtures and automate parity runs comparing PQ <code>previewHash</code> and backend <code>runHash</code>; track differences in <code>pqParityReport</code> with suspected causes (locale parsing differences, diacritic mapping mismatches, rounding mode differences). <br> <strong>Governance guidelines for PQ pilots:</strong> <br> 1. Document PQ canonicalization approximations and ensure the backend canonical pipeline is source-of-truth; PQ should never be the only source for an enforced production decision without backend parity. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Conceptual DAX measures & reporting patterns for reconciliation observability (no code)</strong> <br> <strong>Modeling principles (concise):</strong> Use canonical keys (<code>runId</code>, <code>policyHash</code>, <code>assetId</code>, <code>aggregationId</code>) for relationships. Tokenize PII on visuals and allow evidenceRef drillthroughs guarded by <code>approvalRef</code> workflows. Expose <code>policyHash</code> and <code>runId</code> as slicers to switch between snapshots and runs. <br> <strong>Core measures (conceptual):</strong> <br> 1. <code>DepreciationExpense</code> — sum of <code>DepreciationSchedule.depreciationAmount</code> by period (used in trend and by-category visuals). <br> 2. <code>ReconciliationVarianceTotal</code> — aggregate <code>varianceMinorUnits</code> across selected scope; used to show control-level deltas. <br> 3. <code>BeyondToleranceCount</code> — count of <code>varianceRows</code> where <code>BeyondTolerance == true</code>; used as KPI tile. <br> 4. <code>OpenManualActions</code> — count of schedule rows flagged <code>requiresManualInput</code>; used to prioritize data-gathering. <br> <strong>Operational measures & derived indicators (conceptual):</strong> <br> 1. <code>SuggestionAcceptanceRate</code> — ratio of accepted remediation suggestions to suggested items for the selected period or policyHash; indicates model usefulness. <br> 2. <code>RunParityDeltaCount</code> — number of runs where <code>runHash</code> diverged from golden fixtures; used in migration monitoring dashboards. <br> <strong>Drillthrough UX patterns (conceptual):</strong> <br> 1. From matrix cell (ControlGLAccount × CostCenter) drillthrough to page showing <code>varianceRows</code>, attached <code>evidenceSamples</code>, <code>preview_manifest</code> metadata, and CTA to open <code>evidenceAccessRequest</code> for PII retrieval (approval flow). <br> 2. Provide <code>policyHash</code> brush to overlay parity markers on time-series visuals so analysts can see when policy changes affected metrics. <br> <strong>Materiality UI patterns (conceptual):</strong> <br> 1. Parameterized materiality slicer: auditors can switch between <code>Strict</code>, <code>Normal</code>, <code>Lenient</code>; measures recalculate <code>BeyondTolerance</code> on the fly and the page annotates which threshold is active. <br> <strong>KPI & operational dashboard patterns (concise):</strong> <br> 1. Exceptions overview: tiles for <code>TotalExceptions</code>, <code>BeyondToleranceCount</code>, <code>TopVarianceByCostCenter</code>, <code>OpenManualActions</code>. <br> 2. SLO & parity panel: <code>PlanBuildLatencyP50</code>, <code>PreviewLatencyP50</code>, <code>GoldenParityFailureRate</code>, <code>ApplySuccessRate</code> with recent trend and alert thresholds. <br> <strong>Reporting best-practices (conceptual):</strong> <br> 1. Avoid raw PII in report visuals; use tokenized keys and provide direct evidenceRef drillthroughs guarded by approvals. <br> 2. Embed <code>decisionTrace</code> and <code>remediationHistory</code> as exportable CSV for audit trails. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Testing strategy, CI/golden parity, property tests & performance matrix</strong> <br> <strong>Unit tests (must cover):</strong> <br> 1. canonicalization primitives: <code>NormalizeText</code>, <code>CanonicalDecimal</code>, <code>FormatDateISO</code> across locales and extreme unicode cases; <br> 2. arithmetic invariants: integer minor-unit math, overflow handling, safe-divide logic; <br> 3. join invariants: composite key generation and full-outer join determinism; <br> 4. materiality logic including per-account override precedence; <br> 5. seeded sampling parity. <br> <strong>Integration tests (must cover):</strong> <br> 1. ingest→aggregate→alignFX→computeVariance→materiality→persist pipeline for a range of fixtures: single-currency, cross-currency, sign-convention mismatches, missing FX, batch residuals; <br> 2. remediation life-cycle: suggest -> accept -> apply -> incremental recompute -> parity check. <br> <strong>Golden parity tests (must cover):</strong> <br> 1. Maintain canonical fixtures with expected <code>reportHash</code> for representative cases and run across PQ pilot and backend environments; <br> 2. failing golden tests must block merges and require migration manifest if policy-caused. <br> <strong>Property tests:</strong> row-order invariance, header-synonym invariance, idempotency for apply/revert, deterministic tie-breaker checks. <br> <strong>Performance & load tests:</strong> <br> 1. aggregation throughput: 1k / 10k / 100k schedule rows; <br> 2. full-outer join memory & latency tests for 10k/100k/1M groups; <br> 3. incremental recompute latencies for 100/1k/10k changed assets. <br> <strong>Security & privacy tests:</strong> <br> 1. PII leakage scans on artifacts and logs; <br> 2. ephemeral token lifecycle validation; <br> 3. evidence access approval enforcement tests. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Observability, SLOs, audit architecture & incident runbooks</strong> <br> <strong>Mandatory audit events (must emit):</strong> <code>fa.recon.report.generated</code>, <code>fa.recon.remediation.started</code>, <code>fa.recon.remediation.completed</code>, <code>fa.recon.persist.warning</code>, <code>fa.recon.sample.evidence_request</code> (PII access), <code>fa.recon.apply.fail</code>, <code>fa.recon.policy.migration</code>. Each audit entry includes <code>correlationId</code>, <code>runId</code>, <code>policyHash</code>, <code>reportHash</code> or <code>exportChecksum</code>, <code>evidenceRefs</code>, <code>operatorId</code>, and <code>paramsHash</code>. <br> <strong>Evidence store conventions:</strong> append-only, immutable artifacts, <code>createdTs</code>, <code>checksum</code>, <code>retentionPolicy</code>, <code>legalTags</code>; PII retrieval gated by <code>approvalRef</code> and recorded in chain-of-custody audit rows. <br> <strong>Suggested SLO examples (targets are illustrative):</strong> <br> 1. <code>ReconBuildLatencyP50</code> target < 500ms for small close cohorts; <br> 2. <code>EvidenceSampleAttachLatencyP50</code> target < 1s for small sample sizes; <br> 3. <code>GoldenParityFailureRate</code> target 0% in protected branches; <br> 4. <code>ApplySuccessRate</code> target > 99% for <code>create_export</code> flows. <br> <strong>Parity verification job (daily):</strong> recompute <code>reportHash</code> for stored manifests and compare; emit <code>verify.parity.failed</code> on mismatch and open investigation ticket with correlationId. <br> <strong>Incident triage runbook (explicit steps):</strong> <br> 1. Capture <code>correlationId</code> and <code>runId</code> from alert. <br> 2. Retrieve <code>fa_recon_report</code>, <code>depreciationRunManifest</code>, <code>assetIngestManifest</code>, <code>capexIngestManifest</code>, and <code>policySnapshot</code> via their evidenceRefs. <br> 3. Inspect <code>issues[]</code>, <code>ingestDiagnostics</code>, and <code>fxDiagnostics</code> to identify parsing or mapping root-cause. <br> 4. If exports or posts exist, fetch <code>applyDescriptor</code> and attempt <code>RevertJEs</code>. If revert impossible produce <code>forensic_manifest</code> and escalate to GL/compliance for manual remediation. <br> 5. Persist all investigation steps in audit rows and update incident ticket with forensic evidenceRefs. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Failure modes, mitigation & operator runbooks (exhaustive patterns)</strong> <br> <strong>Fault A — Evidence store persist failure:</strong> <br> 1. Symptom: <code>fa.recon.persist.warning</code> and a staging artifact present. <br> 2. Triage: capture <code>correlationId</code>, check evidence store health, and verify staging queue. <br> 3. Remediation: attempt atomic retry, if persistent, move staging artifact to durable archive and open <code>investigationTicket</code> with evidence reference. <br> <strong>Fault B — Unmapped GL account spike:</strong> <br> 1. Symptom: <code>unmappedAccountsCount</code> spike. <br> 2. Triage: run mapping suggestion analytics ranking unmapped accounts by frequency and value. <br> 3. Remediation: present mapping suggestions to business owners with example rows for bulk acceptance; update mapping and re-run GL ingest or reconcile. <br> <strong>Fault C — Golden parity failure after policy migration:</strong> <br> 1. Symptom: <code>verify.parity.failed</code> for golden fixtures. <br> 2. Triage: fetch <code>migrationManifest</code> and canary results; compute <code>DepnExpenseDeltaPct</code>. <br> 3. Remediation: if canary KPIs breached rollback <code>policyHash</code> pointer, re-run parity assertions, and rework migration with updated manifest and approvals. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Operational CLI patterns & explicit examples (concise):</strong> <br> 1. <code>fa.recon.build --run &lt;runId&gt; --policyRef fa_policy_&lt;policyHash&gt; --glExtract &lt;glFileRef&gt; --operator alice</code> → runs <code>ReconcileFAtoGL</code> and returns <code>reconManifestRef</code>.<br> 2. <code>fa.recon.preview --run &lt;runId&gt; --top 100 --operator alice</code> → returns top 100 varianceRows with evidence samples for triage.<br> 3. <code>fa.recon.suggest --run &lt;runId&gt; --operator alice</code> → persists <code>suggestedRemediation</code> and <code>previewRef</code> for analysts.<br> 4. <code>fa.recon.apply --remediation &lt;remediationId&gt; --approvalsRef ap-123 --operator bob</code> → calls <code>ApplyRemediationPlan</code> and returns <code>executionDescriptorRef</code>. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Acceptance criteria & release gates (explicit):</strong> <br> 1. Unit tests confirm deterministic canonicalization and arithmetic parity across locales. <br> 2. Integration tests validate entire pipeline ingest→aggregate→align→variance→materiality→persist flows using canonical fixtures and expected <code>reportHash</code> values. <br> 3. Golden parity tests ensure <code>reportHash</code> parity across PQ pilot and backend runs; failing golden tests block merges. <br> 4. Any policy semantic change must be accompanied by <code>migrationManifest</code> with canary KPIs and approvals before production promotion. <br> 5. All mutative flows that affect GL control ranges require approval gating (two-person) and ephemeral token issuance. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Appendices — canonical templates, runbook snippets & checklists (concise)</strong> <br> <strong>Appendix A — ReconManifest minimal canonical fields:</strong> <code>runId</code>, <code>policyHash</code>, <code>assetIngestChecksum</code>, <code>capexIngestChecksum</code>, <code>depreciationRunHash</code>, <code>paramsHash</code>, <code>period</code>, <code>rowsCount</code>, <code>exceptionsCount</code>, <code>beyondToleranceCount</code>, <code>varianceRows[]</code> (canonical ordering), <code>suggestedRemediationIndexRef</code>, <code>evidenceRefs</code>, <code>createdTs</code>, <code>operatorId</code>, <code>canonicalVersion</code>, <code>reportHash</code>. <br> <strong>Appendix B — Reconciliation verification checklist:</strong> <br> 1. Confirm <code>policyHash</code> equals approved snapshot; <br> 2. Verify <code>assetIngestChecksum</code> and <code>capexIngestChecksum</code> presence; <br> 3. Recompute <code>reportHash</code> locally using canonicalization recipe and compare; <br> 4. Ensure <code>evidenceSamples</code> attached; PII retrieval requires <code>approvalRef</code>; <br> 5. Validate <code>suggestedRemediation</code> includes <code>payloadRef</code> persisted to evidence store. <br> <strong>Appendix C — Security & privacy checklist:</strong> <br> 1. Tokenize PII on analyst surfaces; raw evidence retrieval requires specific <code>approvalRef</code> and generates chain-of-custody audit rows; <br> 2. Use ephemeral credentials for GL posting; never log token material; <br> 3. Static analysis for secrets and PII in repo; <br> 4. Evidence retrieval and remediation actions must be audited and retained per <code>retentionPolicy</code>. </td></tr><tr><td data-label="modReconcile — Per-function Expert Technical Breakdown"> <strong>Closing operational note & follow-ups (concise):</strong> This expanded <code>modReconcile</code> blueprint is designed to be implemented as a deterministic, evidence-first reconciliation module with tightly governed remediation flows and comprehensive telemetry, CI, and governance controls. If you want follow-ups (choose one or more): <br> 1. Formal JSON Schema for <code>assetScheduleAgg</code>, <code>varianceRow</code>, and <code>fa_recon_report</code> with exact field ordering for canonical hashing. <br> 2. A canonical set of CSV test fixtures and expected <code>sha256</code> reportHash for golden tests. <br> 3. A step-by-step Power Query canonicalization recipe for PQ pilots including intermediate outputs (no code blocks). <br> 4. A compact runbook PDF summarizing triage steps, CLI commands, and operator checklists. <br> Specify desired artifact(s) and target runtime(s) (PQ pilot or backend worker) and they will be produced. </td></tr></tbody></table></div><div class="row-count">Rows: 25</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>