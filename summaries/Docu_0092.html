<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1762337895">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      // Delegate addEventListener/removeEventListener to visible button
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      // Delegate onclick assignments
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      // Delegate focus/blur
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
      // If legacy code used direct addEventListener earlier than this script, listeners would already exist
      // on alias element; attempt to re-dispatch those by cloning them to visible button is non-trivial.
      // This approach covers the common case where legacy scripts query the alias and bind after DOM ready.
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0092_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Prioritized File Checks</strong> <br><br><strong>assets/script.table.js</strong> — Handles caption insertion logic, ID assignment, and copy delegation. Critical to ensure that <code>TableN</code> IDs are stable and not overwritten by subsequent renders. Look for functions that apply captions immediately after table creation; confirm they respect existing IDs. <br><br><strong>assets/script.core.js</strong> — Core conversion and render lifecycle. Verify whether <code>convert</code> is invoked with combined marked text, and ensure it triggers caption-applier events after render completion. Check if <code>convert</code> performs destructive DOM operations such as replacing <code>innerHTML</code> on table containers. <br><br><strong>render/core_table.py, render/convert.py, html_renderer.py, server.py</strong> — Server-side rendering of captions and ID generation. Confirm that caption content generated server-side matches expected selectors and that IDs are deterministic. Check for differences in server vs. client output (e.g., h1–h3 vs. caption elements). <br><br><strong>assets/script.toc.js</strong> — Normalizes heading IDs and builds the table of contents. Ensure it does not conflict with caption IDs or alter heading nodes in ways that break applier logic. <br><br><strong>assets/script.save.js</strong> — Handles post-render DOM replacement. Identify any operations that overwrite tables or captions after initial render, such as saving to local cache or performing full container replacements. Consider adding logging here to detect destructive replacements. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Likely Failure Modes</strong> <br><br><strong>1. Client overwrites server captions:</strong> This is a common issue. Client-side code may replace the container’s <code>innerHTML</code> after server captions are inserted. Look for patterns like <code>container.innerHTML = ...</code>. Use logging statements before and after these replacements to trace the behavior. Temporarily comment out destructive re-renders to isolate the issue. <br><br><strong>2. Race condition:</strong> Caption applier might run before DOM nodes exist. Ensure the applier runs only after the renderer has completed. You can dispatch a custom event at the end of the convert lifecycle:<br><code>try { window.dispatchEvent(new CustomEvent(&#x27;ptt:render-complete&#x27;)); } catch(e){}</code><br>Then attach caption-applier logic to this event. Optionally, also listen for <code>ptt:group-loaded</code> if groups of tables are loaded asynchronously. <br><br><strong>3. Selector mismatch:</strong> Renderer may use elements like <code>&lt;caption&gt;</code> or <code>&lt;h3&gt;</code> instead of <code>.table-caption</code>. Standardize selector for caption-applier: <code>.table-caption, caption, h1,h2,h3</code>. This ensures all captions are detected regardless of node type. <br><br><strong>4. Large-scale performance bottlenecks:</strong> For extremely large tables (~290k), synchronous DOM updates can freeze the browser. Use chunked updates or a “visible-first” strategy. For example, combine <code>IntersectionObserver</code> with batched updates so only visible nodes are updated first, followed by deferred updates for off-screen nodes. This prevents UI lock-up. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Quick Diagnostic Snippet</strong> <br><br>Use this snippet in the console to map runtime captions to DOM nodes and identify mismatches. It inspects the first 50 captions and logs any discrepancies between expected captions and actual DOM nodes. <br><br><code>(function(){</code><br><code>var caps = Array.isArray(window.__ptt_runtime_captions)? window.__ptt_runtime_captions.slice(0,200):[];</code><br><code>var nodes = Array.from(document.querySelectorAll(&#x27;.table-caption, caption, h1,h2,h3&#x27;)).slice(0,200);</code><br><code>console.log(&#x27;captions.length&#x27;, caps.length, &#x27;nodes.length&#x27;, nodes.length);</code><br><code>for(var i=0;i&lt;Math.max(caps.length, nodes.length, 50); i++){</code><br><code>console.log(i+1, &#x27;caption-&gt;&#x27;, caps[i], &#x27;&lt;empty&gt;&#x27;, &#x27;node-&gt;&#x27;, nodes[i] ? (nodes[i].tagName + &#x27;:&#x27; + (nodes[i].id || nodes[i].textContent.slice(0,40))) : &#x27;&lt;no-node&gt;&#x27;);</code><br><code>}})();</code><br><br>Paste the output into a document or share it, and it can be used to generate a mapping of captions to nodes, helping to suggest exact fixes. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Immediate Safe Fix Options</strong> <br><br><strong>Option 1: Defensive caption-applier</strong> — Write a small utility that listens for <code>ptt:render-complete</code> and applies captions in batches using a non-blocking approach. Use <code>requestIdleCallback</code> or <code>setTimeout</code> for chunked updates to avoid blocking the main thread. This ensures captions are applied after DOM is stable and prevents overwrites. <br><br><strong>Option 2: Patch destructive renders</strong> — Modify <code>script.core.js</code> or <code>script.table.js</code> to prevent any <code>innerHTML</code> replacements on table containers after captions are inserted. Ensure <code>convert</code> or other lifecycle methods update content safely by targeting only the inner table cells or rows rather than replacing the container. Add logging around every lifecycle method that modifies DOM to detect accidental overwrites. <br><br><strong>Option 3: Logging instrumentation</strong> — Surround critical points (before/after render, before/after <code>innerHTML</code> updates, at caption insertion) with verbose logging. Example:<br><code>console.log(&#x27;Before container update:&#x27;, container.id, container.childElementCount);</code><br><code>console.log(&#x27;After container update:&#x27;, container.id, container.childElementCount);</code><br>This helps detect race conditions or destructive operations. <br><br><strong>Option 4: Selector normalization and fallback</strong> — Ensure caption-applier queries <code>.table-caption, caption, h1,h2,h3</code>. Normalize IDs and text content before applying to avoid mismatch. Optionally, strip HTML noise (e.g., <code>&lt;br&gt;</code>) before comparison. <br><br><strong>Option 5: Performance safeguards</strong> — For very large document loads, update captions in chunks of 50–200 nodes at a time. Use <code>IntersectionObserver</code> to prioritize visible tables. Defer updates for offscreen elements to prevent browser hangs. Combine with the defensive caption-applier from Option 1. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recommended Stepwise Approach</strong> <br><br>1. Add logging around every DOM mutation in core, table, and save scripts. <br>2. Normalize selectors to <code>.table-caption, caption, h1,h2,h3</code>. <br>3. Dispatch <code>ptt:render-complete</code> after convert or post-render operations. <br>4. Attach defensive caption-applier that listens to this event and applies captions in chunks using non-blocking updates. <br>5. Temporarily disable any destructive <code>innerHTML</code> assignments to isolate overwrites. <br>6. Run diagnostic snippet to map captions to DOM nodes and verify correctness. <br>7. Implement chunked or IntersectionObserver-based updates for large tables. <br>8. Monitor performance and iterate. <br>9. Once stable, gradually re-enable save/replace functionality while monitoring for overwrites. <br>10. Confirm consistent behavior across all browsers and table sizes. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Additional Notes & Observations</strong> <br><br>- Server-generated captions are reliable but can be erased by client DOM updates. <br>- Race conditions often happen when render lifecycle is asynchronous or uses Promises; ensure events are fired strictly after all render operations. <br>- Large documents require deferred and batched updates; synchronous brute-force DOM updates will fail. <br>- Selector mismatches are a subtle but common source of errors; normalize both ID and tag selectors. <br>- Logging is your best immediate diagnostic tool; use before/after states to detect destructive updates. <br>- Consider unit-testing the caption-applier in isolation using a small set of tables before applying to full documents. <br>- Keep a defensive mindset: assume any future code may overwrite captions unless explicitly protected. </td></tr></tbody></table></div><div class="row-count">Rows: 6</div></div><div class="table-caption" id="Table2" data-table="Docu_0092_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Prioritized File Checks</strong> <br><br><strong>assets/script.table.js</strong> — Handles caption insertion, ID assignment, copy delegation, and table-specific post-processing. It is critical to ensure that <code>TableN</code> IDs are stable, especially when multiple tables are rendered in succession or when tables are dynamically updated via the <code>convert</code> or <code>paste</code> actions. Confirm that caption insertion functions do not overwrite pre-existing IDs or merge different tables unintentionally. Inspect for patterns like <code>table.id = ...</code> or <code>caption.id = ...</code> that might be invoked after every render cycle. <br><br><strong>assets/script.core.js</strong> — The main conversion and render lifecycle engine. It converts marked-up text to HTML tables, invokes caption insertion routines, and triggers any post-processing events. Check whether <code>convert</code> is invoked with combined marked text from multiple table sources, and confirm that it triggers caption-applier events <strong>after</strong> the DOM is fully rendered. Watch for destructive DOM operations such as replacing <code>container.innerHTML</code>, <code>container.replaceChildren()</code>, or wholesale table removal and re-creation. These can easily erase server-generated captions. Ensure that event hooks exist to notify other modules once conversion is complete. <br><br><strong>render/core_table.py, render/convert.py, html_renderer.py, server.py</strong> — These server-side scripts are responsible for deterministic ID generation, caption rendering, and HTML preparation. Confirm that server-generated captions match the client-side selectors used by the caption-applier. Differences between server and client rendering (e.g., <code>&lt;h1&gt;</code> vs <code>&lt;caption&gt;</code> vs <code>.table-caption</code>) can cause misalignment. Check that Python scripts emit predictable IDs, especially when table order or groupings vary between sessions. Consider adding a checksum or hash per table to verify consistency between server output and client DOM. <br><br><strong>assets/script.toc.js</strong> — Responsible for building the Table of Contents (TOC) based on headings, normalizing IDs, and enabling anchor navigation. Ensure it does not overwrite table or caption IDs, alter heading nodes in ways that break the caption-applier, or introduce race conditions with dynamically loaded tables. Confirm that it listens to lifecycle events like <code>ptt:render-complete</code> to avoid firing too early. <br><br><strong>assets/script.save.js</strong> — Handles post-render DOM operations such as saving table state or updating cache. Identify any operations that replace table containers or captions, especially full DOM replacements triggered by <code>innerHTML</code> assignments. Introduce logging around these operations to detect destructive replacements and verify that the DOM modifications occur <strong>after</strong> all captions are applied. Consider temporarily disabling save logic for diagnostics. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Likely Failure Modes</strong> <br><br><strong>1. Client overwrites server captions:</strong> Client-side code may replace containers (<code>container.innerHTML = ...</code>) after server captions are applied. This is a leading cause of lost captions. Implement logging before and after all DOM replacements to detect this. Temporarily comment out destructive operations to confirm the cause. <br><br><strong>2. Race condition:</strong> Caption-applier may execute before DOM nodes exist. Ensure the applier only runs <strong>after</strong> the renderer has completed. Use a custom event, e.g., <code>ptt:render-complete</code>:<br><code>try { window.dispatchEvent(new CustomEvent(&#x27;ptt:render-complete&#x27;)); } catch(e){}</code><br>Attach caption-applier logic to this event. Additionally, if tables are grouped and loaded asynchronously, listen for <code>ptt:group-loaded</code>. <br><br><strong>3. Selector mismatch:</strong> Renderer may emit <code>&lt;caption&gt;</code> or <code>&lt;h3&gt;</code> elements instead of <code>.table-caption</code>. Standardize selectors for the applier: <code>.table-caption, caption, h1,h2,h3</code>. This ensures all captions are detected. Normalize IDs and strip HTML noise such as <code>&lt;br&gt;</code> or nested tags. <br><br><strong>4. Performance bottlenecks:</strong> Extremely large tables (~290k nodes) can freeze the browser during synchronous DOM updates. Use chunked updates or a "visible-first" strategy, combining <code>IntersectionObserver</code> with batched updates. Only visible rows are updated first, and offscreen rows are updated asynchronously to prevent UI lock-ups. Consider <code>requestIdleCallback</code> for deferred work. <br><br><strong>5. Mixed server-client DOM models:</strong> Differences between server-generated captions and client DOM may lead to mismatches, especially when table groups are dynamically reordered or replaced. Introduce a hash per table and verify the hash on the client-side before applying captions. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Quick Diagnostic Snippet</strong> <br><br>Use this snippet to map runtime captions to DOM nodes, identify mismatches, and generate an audit mapping. Inspect the first 50–200 captions: <br><br><code>(function(){</code><br><code>  var caps = Array.isArray(window.__ptt_runtime_captions)? window.__ptt_runtime_captions.slice(0,200):[];</code><br><code>  var nodes = Array.from(document.querySelectorAll(&#x27;.table-caption, caption, h1,h2,h3&#x27;)).slice(0,200);</code><br><code>  console.log(&#x27;captions.length&#x27;, caps.length, &#x27;nodes.length&#x27;, nodes.length);</code><br><code>  for(var i=0;i&lt;Math.max(caps.length, nodes.length, 50); i++){</code><br><code>    console.log(i+1, &#x27;caption-&gt;&#x27;, caps[i], &#x27;&lt;empty&gt;&#x27;, &#x27;node-&gt;&#x27;, nodes[i] ? (nodes[i].tagName + &#x27;:&#x27; + (nodes[i].id || nodes[i].textContent.slice(0,40))) : &#x27;&lt;no-node&gt;&#x27;);</code><br><code>  }</code><br><code>})();</code><br><br>Paste output into a document to map captions to nodes, identify missing entries, and suggest exact fixes. Use it before and after patching to confirm correctness. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Immediate Safe Fix Options</strong> <br><br><strong>Option 1: Defensive caption-applier</strong> — Create a utility that listens for <code>ptt:render-complete</code> and applies captions in small batches using <code>requestIdleCallback</code> or <code>setTimeout</code> to avoid blocking the main thread. Apply captions in groups of 50–200 nodes. <br><br><strong>Option 2: Patch destructive renders</strong> — Modify <code>script.core.js</code> or <code>script.table.js</code> to prevent full container <code>innerHTML</code> replacements after captions are applied. Target only table rows or cells when updating content. Add logging around every lifecycle method that modifies the DOM to detect accidental overwrites. <br><br><strong>Option 3: Logging instrumentation</strong> — Surround critical points with verbose logging (before/after render, <code>innerHTML</code> updates, caption insertion). Example:<br><code>console.log(&#x27;Before container update:&#x27;, container.id, container.childElementCount);</code><br><code>console.log(&#x27;After container update:&#x27;, container.id, container.childElementCount);</code><br>Detect race conditions or destructive operations. <br><br><strong>Option 4: Selector normalization & fallback</strong> — Ensure applier queries <code>.table-caption, caption, h1,h2,h3</code>. Normalize IDs, strip <code>&lt;br&gt;</code> tags, and clean text content before applying. <br><br><strong>Option 5: Performance safeguards</strong> — For large document loads, update captions in chunks, prioritize visible tables with <code>IntersectionObserver</code>, defer offscreen updates. Combine with defensive applier from Option 1. <br><br><strong>Option 6: Unit test small tables</strong> — Before applying to full documents, verify caption-applier behavior on isolated, small tables to ensure logic is correct. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Recommended Stepwise Approach</strong> <br><br>1. Add logging around every DOM mutation in core, table, and save scripts. <br>2. Normalize selectors to <code>.table-caption, caption, h1,h2,h3</code>. <br>3. Dispatch <code>ptt:render-complete</code> after convert or post-render operations. <br>4. Attach defensive caption-applier that applies captions in chunks using non-blocking updates. <br>5. Temporarily disable destructive <code>innerHTML</code> assignments. <br>6. Run diagnostic snippet to map captions to DOM nodes and verify correctness. <br>7. Implement chunked or <code>IntersectionObserver</code>-based updates for large tables. <br>8. Monitor performance and iterate. <br>9. Gradually re-enable save/replace functionality while monitoring overwrites. <br>10. Confirm consistent behavior across browsers and table sizes. <br>11. Add automated regression tests for tables and captions after core updates. <br>12. Document observed issues and fixes for knowledge sharing. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Additional Notes & Observations</strong> <br><br>- Server-generated captions are reliable but may be erased by client DOM updates. <br>- Race conditions often happen when render lifecycle is asynchronous or uses Promises; ensure events are fired strictly after all render operations. <br>- Large documents require deferred and batched updates; synchronous brute-force DOM operations will fail. <br>- Selector mismatches are subtle but common sources of errors; normalize both ID and tag selectors. <br>- Logging is your best immediate diagnostic tool; use before/after states to detect destructive updates. <br>- Consider unit-testing the caption-applier on small table sets before applying to full documents. <br>- Keep a defensive mindset: assume future code may overwrite captions unless explicitly protected. <br>- Ensure all patches are backward-compatible with older table data. <br>- For extremely large tables, monitor memory usage and browser responsiveness. <br>- Consider using optional web workers or deferred DOM patches for extremely heavy datasets. <br>- Keep a running audit log of caption-applier events for debugging post-deployment. </td></tr></tbody></table></div><div class="row-count">Rows: 6</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>