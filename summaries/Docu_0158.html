<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1759925496">
<link rel="stylesheet" href="assets/overrides.css?v=1766815434">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li>
<li class="toc-item"><a class="toc-link" href="#Table6">Table 6</a></li>
<li class="toc-item"><a class="toc-link" href="#Table7">Table 7</a></li>
<li class="toc-item"><a class="toc-link" href="#Table8">Table 8</a></li>
<li class="toc-item"><a class="toc-link" href="#Table9">Table 9</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0158_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical User Guide"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical User Guide</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical User Guide"> <strong>Document authority & scope</strong><br> This runbook is the single authoritative source for everything operators, developers, auditors, compliance reviewers and incident responders need to operate, maintain, verify, and audit the Excel add-in system. It defines responsibilities and procedures for design, development, deployment, incident response, auditability, and regulatory interactions. When guidance elsewhere conflicts with this document, this document prevails. Language here is prescriptive: follow steps exactly and record deviations in audit. This document is normative for operational work and evidence collection; sections labeled "MUST", "SHOULD", and "MAY" follow the same intent as RFC-style guidance where "MUST" is mandatory, "SHOULD" is recommended and requires justification if not followed, and "MAY" is optional. Any local adaptations require a compliance exception ticket and two-person approval recorded in audit. <br> <strong>Change history:</strong> every edit to this runbook MUST be recorded in the runbook's change log with author, date, rationale, linked PR/issue, and compliance sign-off when relevant. <br> <strong>Scope boundaries:</strong> this runbook governs the add-in codebase, packaged helpers, CI/CD pipeline gates affecting regulatory outputs, release manifests, audit chain design, and operational playbooks. It does not govern unrelated Excel macros, third-party add-ins, or external accounting systems except where direct integration is specified; those are covered by integration contracts described in appendices. </td></tr><tr><td data-label="Technical User Guide"> <strong>Audience</strong><br> This document is written to be usable by non-technical operators following step-by-step runbooks, by developers implementing deterministic calculations and migrations, by IT and release engineers performing upgrades and rollbacks, and by auditors and compliance teams verifying evidence. Each section provides background, commands or exact actions to perform, what to observe, expected outputs, and the evidence to collect for each scenario. Where skill-level matters, a header marks whether steps are Operator-level (no code), Engineer-level (requires credentials and terminal), or Developer-level (requires code-level changes and CI). Use the "Evidence to collect" checklists at the end of each procedural section to ensure artifacts are preserved for compliance. </td></tr><tr><td data-label="Technical User Guide"> <strong>Design principles (non-negotiable)</strong><br> The system is built around a small set of inviolable principles: determinism (same inputs + same config → same outputs), complete auditability (every judgment recorded), recoverability (jobs checkpointed and restorable), explicit failure (no silent corrections), immutable evidence (append-only audit chain), minimal direct Excel COM interactions, side-effect isolation, and strict reproducibility across supported environments. Any design or operational change that weakens these principles is disallowed without explicit compliance sign-off. Design reviews MUST include a determinism impact assessment and an auditability impact assessment. All code that touches regulatory outputs must include a canonical fixture and self-test. Any deviation from these principles requires a written risk assessment and two-person sign-off logged in audit. </td></tr><tr><td data-label="Technical User Guide"> <strong>Golden rule & mental model</strong><br> The guiding operational model is simple and must be repeated in training: Excel hosts the add-in; the add-in orchestrates work; heavy computation executes as jobs outside direct UI work; outputs are written atomically; and the audit is the system of record. If an action or result is not present in audit, it is not authoritative. Treat Excel as a UI and cache, not as the system of record. Users and operators must be trained to never rely on Excel worksheet contents as final evidence without verifying the audit chain and output checksums. The canonical mental model for incident triage:<br> 1) Verify audit entries and correlation id;<br> 2) Confirm job descriptor and job state;<br> 3) Reproduce deterministic compute in isolated runner with identical inputs and config;<br> 4) Validate produced artifact checksums against archived golden hashes. </td></tr><tr><td data-label="Technical User Guide"> <strong>Roles, responsibilities & SLAs</strong><br> Define and publish the primary roles (Product Owner, Release Engineer, Compliance Officer, Security Lead, On-call SRE, Support Engineer, Developer) and the RACI model for changes, incidents, and releases. Establish operational SLAs: production availability objectives, paging windows for critical incidents, response and acknowledgement times for on-call, and defined change-freeze periods (for example during financial close). All role assignments and escalation lists must be maintained in a visible roster and accessible from runbook links. <br> <strong>Minimum SLAs (example):</strong><br> Acknowledge critical page within 15 minutes, begin mitigations within 1 hour, run first forensic export within 3 hours, and produce interim status to stakeholders within 6 hours. SLA exceptions must be pre-authorized and recorded in audit. </td></tr><tr><td data-label="Technical User Guide"> <strong>Quick start & mandatory smoke tests (purpose & checklist)</strong><br> Always begin diagnosis with a short, repeatable smoke test that validates the add-in is fundamentally alive: close Excel completely, confirm no orphan EXCEL.EXE, start Excel as the installing user, open a known-good workbook, confirm ribbon initialization within the expected window, run the smallest built-in action (self-test), validate a progress indicator and the presence of an output or test-result sheet, and confirm an audit row has been appended with the action’s correlation id. If any step fails, stop and escalate following the Common Failures playbook — do not continue deeper troubleshooting without preserving evidence. <br> <strong>Smoke test steps (operator):</strong><br> 1) Close Excel and verify no EXCEL.EXE in Task Manager/ps.<br> 2) Launch Excel and open <code>KnownGoodWorkbook.xslx</code> (provided in artifacts).<br> 3) Wait maximum bootstrap window (configurable, default 12s).<br> 4) Trigger <code>SelfTest -&gt; Run</code>.<br> 5) Observe expected <code>_SelfTest</code> sheet and audit row with correlation id format <code>yyyyMMdd-HHMMSS-&lt;module&gt;-&lt;rand8&gt;</code>.<br> 6) Collect <code>bootstrap.log</code>, <code>ribbon.log</code>, and the generated audit row.<br> <strong>Expected outputs:</strong> ribbon initializes, self-test sheet present, audit row appended within 3 seconds of action, no error codes > WARN. <br> <strong>Evidence to collect:</strong> <code>bootstrap.log</code>, <code>ui.log</code>, <code>audit_tail.csv</code> (last 50 rows), copy of <code>KnownGoodWorkbook</code> with appended <code>_SelfTest</code> sheet. </td></tr><tr><td data-label="Technical User Guide"> <strong>Full lifecycle & control-flow (phases & guarantees)</strong><br> The add-in lifecycle has five phases: lightweight bootstrap (open logs, register shutdown hooks, do not perform heavy IO), deferred initialization (load config, verify dependencies, initialize audit buffers, resolve flags), idle-ready (ribbon handlers live and responsive), job scheduling & execution (jobs persist descriptors, execute with checkpoints, and produce audit rows), and completion/shutdown (atomic commits, audit flushes, and resource release). Each phase has explicit guarantees about what may and may not run there to avoid freezing Excel or losing audit fidelity. Determinism rules — inputs + config + flags + deterministic seed produce identical artifacts — are enforced and verified in CI. <br> <strong>Phase checks:</strong> at bootstrap confirm <code>bootstrap.started</code> log entry; at deferred init confirm <code>config.loaded</code> and <code>deps.reported</code>; at idle-ready confirm <code>ribbon.ready</code>; at scheduling confirm <code>job.persisted:&lt;jobid&gt;</code>; at completion confirm <code>audit.flushed:&lt;jobid&gt;</code> and <code>artifact.checksum:&lt;sha256&gt;</code>. </td></tr><tr><td data-label="Technical User Guide"> <strong>Module architecture and single-responsibility boundaries</strong><br> The add-in is intentionally modular. Each module has a tight single responsibility, explicit public interfaces, and a required audit contract. Modules must never duplicate centralized policies (config loading, audit writing, error mapping). This boundary discipline makes troubleshooting deterministic: when a symptom is observed, follow the ownership map to the responsible module and inspect its logs and audit rows before attempting corrective action. Ownership map is maintained in <code>OWNERS.md</code> and in the release manifest. When modifying or adding modules, include an ownership entry, interface contract (inputs/outputs), and a module-level audit schema. </td></tr><tr><td data-label="Technical User Guide"> <strong>modBootstrap responsibilities and verification</strong><br> modBootstrap brings the system to life safely — it opens structured logs, creates the correlation id generator, schedules deferred initialization on the UI idle loop, and registers process shutdown handlers. It must never perform heavy computation, network calls, or Excel Range access during bootstrap. Verify correct behavior by checking bootstrap logs for expected start and deferred-init scheduling entries. If bootstrap fails or the add-in is auto-disabled by Excel, document bootstrap logs and follow reinstall and permission-fix procedures. <br> <strong>Operator verification steps:</strong> confirm <code>init-scheduled</code> and absence of long-blocking calls in <code>bootstrap.log</code>; collect <code>excel-register-state</code> (COM/VSTO registration keys) and Windows event logs if auto-disable occurred. </td></tr><tr><td data-label="Technical User Guide"> <strong>modRibbonCallbacks responsibilities and verification</strong><br> Ribbon callbacks map each control id to exactly one handler. Handlers perform lightweight validation and either execute trivial actions inline or schedule jobs for heavy work. Every click must produce a structured log entry with control id and correlation id, and an audit UserAction row. If buttons are unresponsive, inspect customUI resources, Ribbon_OnLoad logs, and the click mapping — repair the resource or re-register callbacks rather than modifying behavior ad-hoc. Maintain a canonical <code>ribbon-map.json</code> in the repo documenting control id → handler mapping and required permissions. </td></tr><tr><td data-label="Technical User Guide"> <strong>modConfig responsibilities and governance</strong><br> Config is the single source of runtime truth: load once, validate schema, apply idempotent migrations before use, and treat resolved values as immutable for the running process unless changed through controlled update flows. Missing keys must be replaced by safe defaults; the system must never crash on absent or extra keys. Any change to configuration that impacts regulatory computations must follow the change-control policy (ticketing, two-person approval where required, migration manifest, and audit entries recording operator and rationale). <br> <strong>Config format:</strong> JSON Schema v7 with versioned namespace <code>config.v&lt;major&gt;</code>. Example minimal fragment provided in the Appendices. Include a <code>config.hash</code> in the release manifest and in audit rows that reference the config used for a run. </td></tr><tr><td data-label="Technical User Guide"> <strong>EnsureDeps responsibilities and behavior</strong><br> EnsureDeps validates that required platform runtimes, helper executables, OS features, and permission contexts are present. It distinguishes degradable features (where functionality can be reduced with a graceful message) from critical features (which block execution). EnsureDeps writes a dependency report to structured logs and audit when critical dependencies are missing and prescribes exact remediation steps to operators, avoiding guesswork. <br> <strong>Example outputs:</strong> <code>deps.report.json</code> listing each dependency, status, remediation commands, and whether it is <code>CRITICAL</code> or <code>DEGRADABLE</code>. </td></tr><tr><td data-label="Technical User Guide"> <strong>modUtilities responsibilities</strong><br> All shared low-level behavior is centralized: atomic write semantics, temporary file management, deterministic rounding (SafeRound), date normalization according to canonical calendar policy, progress reporting, and retry/backoff helpers. No other module may implement its own file writing, rounding, or retry logic. Centralization preserves determinism and simplifies cross-language parity testing. Utilities are versioned and their API contract is covered by unit tests and integration fixtures. Utility changes require cross-language parity checks if counterparts exist in other runtimes. </td></tr><tr><td data-label="Technical User Guide"> <strong>modDataInput responsibilities and validation rules</strong><br> modDataInput normalizes messy human inputs (type coercion, date parsing, trimming), enforces schema-level validation, and produces a line-level Validation_Report that includes a stable error code, human-friendly message, and a suggested remediation. Invalid rows must be surfaced explicitly and not silently dropped; operator options to fix or skip must be recorded in audit. Validation error codes are stable and documented for CI and support use. Validation reports are stored in <code>validation/&lt;run-id&gt;/report.csv</code> and persisted in artifact storage for compliance. </td></tr><tr><td data-label="Technical User Guide"> <strong>modCalculations responsibilities and determinism rules</strong><br> All domain calculations are deterministic and executed in-memory without Excel Range calls inside hot loops. Use ordered data structures to avoid non-deterministic iteration ordering. Perform bulk writes to Excel only at defined commit points and ensure calculations are repeatable across supported runtimes and platforms using canonical test vectors. If floating-point behavior could differ between runtimes, apply normalization and SafeRound consistently to ensure byte-for-byte artifact parity. For large jobs, shard deterministically (e.g., by stable hash partition) and document shard boundaries in job descriptors. </td></tr><tr><td data-label="Technical User Guide"> <strong>modExport responsibilities and integrity guarantees</strong><br> Exports must validate destinations (permissions, path existence), use atomic write semantics (write to temp then move/replace), compute and record integrity checksums in audit, retry deterministically on transient failures, and support staged local delivery when network destinations are unavailable. Export fallbacks and final delivery must be audited and operators must be provided explicit remediation steps when manual intervention is needed. Exports include <code>artifact.checksum.sha256</code>, <code>destination.uri</code>, <code>delivery.attempts</code>, and <code>final.status</code> in audit. </td></tr><tr><td data-label="Technical User Guide"> <strong>modStatements / templating responsibilities</strong><br> Presentation templates are separate, versioned assets. Code fills values into templates but must never hardcode layout or formulas. The templating system validates post-generation that all expected fields are present and that formulas are intact. Template versions are recorded in the release manifest so auditors can see which template version produced a given artifact. Keep templates in <code>templates/v&lt;major&gt;.&lt;minor&gt;/</code> and include a test that verifies placeholder coverage and that all required placeholders are replaced. </td></tr><tr><td data-label="Technical User Guide"> <strong>Regulatory core modules (modIFRS15, modIAS36, modIFRS16)</strong><br> Regulatory modules implement accounting standards precisely and deterministically. Every material judgment and parameter (discount rates, variable-consideration estimators, rounding modes) must be auditable and versioned. Each module provides canonical fixtures and self-tests; results must match golden artifacts in CI. Any change to calculation behavior requires compliance review, CI rerun against canonical fixtures, and a migration plan for historical data as necessary. Judgmentable parameters must be surfaced in configuration along with approval records. </td></tr><tr><td data-label="Technical User Guide"> <strong>modIFRS15 — responsibilities and lifecycle</strong><br> The modIFRS15 pipeline is explicit: input normalization, schema validation, variable consideration evaluation, deterministic allocation (including SafeRound and deterministic residual absorption), recognition schedule generation, journal entry mapping, and disclosure artifact production. Each step emits audit entries with correlation ids and a snapshot of redacted inputs, outputs and decisions. Preserve backward-compatible APIs and provide a “forceRecompute=false” path to accept precomputed Analysis where permitted, while still validating and auditing preserved allocations. <br> <strong>Critical audit fields:</strong> <code>ContractID</code>, <code>RunID</code>, <code>ModuleVersion</code>, <code>ParameterSetID</code>, <code>DecisionTrace</code> (redacted), and <code>ArtifactChecksum</code>. </td></tr><tr><td data-label="Technical User Guide"> <strong>modIFRS15 — input shape, validation, and error codes</strong><br> The contract object schema requires ContractID, ContractDate, TransactionPrice, ContractCurrency, Parties and a PerformanceObligations array with required PO fields. Validation returns stable, enumerable error codes (documented in appendices) and a Validation_Report that operators use to remediate input data. Error codes are used in monitoring to create actionable dashboards and in CI to flag regressions. Provide a remediation UI flow that suggests minimal edits, and require operator sign-off for skipped rows. </td></tr><tr><td data-label="Technical User Guide"> <strong>modIFRS15 — allocation, SafeRound, and residual absorption rules</strong><br> Allocation follows a deterministic recipe: canonicalize inputs, optionally preserve precomputed allocation if allowed, compute expected variable consideration per configured strategy, apply the variableConstraintThreshold reserve rules, compute raw proportional allocations to standalone prices, perform SafeRound with configured precision and midpoint-away-from-zero semantics, compute residual and deterministically absorb it into a chosen PO via a deterministic tie-breaker (largest standalone, then stable POID hash). Every micro-decision is recorded in audit to support forensic review and regulator queries. Include a <code>DecisionTrace</code> that lists intermediate numeric values (redacted when containing PII). </td></tr><tr><td data-label="Technical User Guide"> <strong>modIFRS15 — recognition schedule and journal mapping rules</strong><br> Recognition schedules are output as explicit periodized rows (ContractID, POID, PeriodIndex, PeriodStart, PeriodEnd, Amount, RecognitionMethod). Time-based and point-in-time methods are supported with safety clamps for maximum periods and configurable business-day adjustments. Each schedule row deterministically maps to journal lines using configured GL mapping; journal entries are created idempotently using deterministic JournalIDs and recorded with checksums and path metadata. Reconciliation tooling consumes these artifacts to verify accounting ledgers. Provide a standard reconciliation manifest format and automated diff tooling to compare expected vs posted journals. </td></tr><tr><td data-label="Technical User Guide"> <strong>modIFRS15 — disclosures and PII policy</strong><br> Disclosure artifacts summarize unsatisfied performance obligations, significant judgments, and sensitivity analyses while excluding customer-specific PII by default. When regulators require customer-level disclosure, include only redacted or encrypted identifiers under a documented compliance-approved workflow. All disclosure generation actions and resulting artifact checksums are written to audit for evidence and archival. Maintain a <code>de-redaction</code> process that is strictly governed and logged whenever granular identifiers are re-associated. </td></tr><tr><td data-label="Technical User Guide"> <strong>modIFRS15 — self-test harness and CI integration</strong><br> The IFRS self-test suite includes canonical fixtures covering normal and edge cases (zero standalone totals, variable-consideration scenarios, rounding edge cases, and large-PO batches). Self-tests export hidden <code>_IFRS_TestResults</code> sheets with expected vs actual hashes; CI requires byte-for-byte parity with golden files before a change is accepted. Test failures block releases and must be remediated per change-control procedures. Include a checksum verification step in CI that asserts <code>sha256(artifact) == golden_sha256</code>. </td></tr><tr><td data-label="Technical User Guide"> <strong>modIAS36 and modIFRS16 authoritative notes</strong><br> Implemented models must record discount rate sources, model versions, and key sensitivities used in impairment (IAS36) and lease accounting (IFRS16) computations. Reversal logic, remeasurement behavior, treatment of lease incentives and initial direct costs, and modification rules are explicitly documented and audited. Test fixtures exercise typical, modified, terminated and extended lease scenarios. Each calculation run publishes a <code>ModelAudit</code> containing model inputs, version, and sensitivity seeds. </td></tr><tr><td data-label="Technical User Guide"> <strong>modAudit — authoritative system of record and chain verification</strong><br> Audit is append-only and cryptographically chained. Audit rows include timestamps, correlation ids, module names, procedure names, severity, user identifiers and a context payload with redaction applied. Audit buffers improve performance but must flush within configured intervals; rotated audit archives are created and indexed for long-term retention. VerifyAuditChain procedures must be run in CI and as part of monitoring to detect mismatches early; any mismatch triggers the audit-compromise runbook. <br> <strong>Audit row canonical schema (CSV/JSON):</strong> <code>timestamp,correlationId,module,procedure,severity,userId,payloadHash,prevHash,signature</code>. Signatures are produced by the signing key associated with the release manifest. </td></tr><tr><td data-label="Technical User Guide"> <strong>modError — centralized error taxonomy and operator messaging</strong><br> Internal exceptions are classified into stable error codes and mapped to operator-facing remediation guidance. No stack traces or raw automation errors should be exposed to end users; instead every error message includes a correlation id that ties logs and audit to the user-visible message. The mapping table is part of the appendices and used by support staff for quick remediation. Maintain an <code>ErrorCodeCatalog.md</code> and include sample remediation steps per code. </td></tr><tr><td data-label="Technical User Guide"> <strong>Configuration & feature flag governance</strong><br> Feature flags carry metadata (id, default, type, scope, required approvals). Resolution precedence is explicit (runtime admin overrides > server-managed remote flags > registry overrides > local config > code default). Flags that affect financial or regulatory outputs require two-person approval and audit meta entries. Canary enablement and emergency kill-switch changes are audited and replayable. Provide a flag roll history API and a <code>flag.change</code> audit entry for every resolution change. </td></tr><tr><td data-label="Technical User Guide"> <strong>Canary and phased rollout patterns</strong><br> Rollouts use explicit cohort selection (tenant id, allowlist, or user attribute), staged percentage expansion, and automated gating by KPIs (error rate, audit fallback rate, checksum mismatches). At each stage run IFRS self-tests and audit-chain verifications on samples. If thresholds are crossed, automatically revert the flag and enter the incident runbook. Log all observations and roll decisions in audit to support post-mortem compliance evidence. Maintain a rollback window and require sign-off for re-exposure. </td></tr><tr><td data-label="Technical User Guide"> <strong>Config migration policy and offline migration tooling</strong><br> Schema migrations are idempotent and accompanied by a migration manifest that lists transformations and affected counts. Provide an offline migration tool supporting dry-runs and sample transformations for auditor inspection. Migration runs must create audit migration rows summarizing what changed, who ran the migration, and sample before/after records for compliance review. Migration runs include <code>dryRun</code> logs, <code>affectedCount</code>, <code>sampleIds</code>, and <code>backoutPlan</code> in the manifest. </td></tr><tr><td data-label="Technical User Guide"> <strong>Runtime debug and safe-ops mode</strong><br> Provide an admin-only debug panel to toggle verbose logging, force deferred initialization, flush audit buffers, export diagnostics and temporarily toggle transient flags. Every debug action requires permission checks, writes an audit row describing operator, time, and reason, and is recorded for compliance review. Debug mode defaults to off and must be disabled after troubleshooting. Access to the panel requires multi-factor auth and an access ticket and is periodically audited. </td></tr><tr><td data-label="Technical User Guide"> <strong>Security operations & incident response (IR) playbook</strong><br> The IR playbook prescribes triage decision trees, immediate containment steps, and evidence collection procedures tailored for the add-in: isolate suspected PII exfiltration routes, disable network exports, quarantine helper executables, export rotated audit archives to a secure forensic share, and preserve process and environment snapshots. All containment and remediation actions are audited and forensics artifacts preserved with checksums and chain-of-custody metadata. <br> <strong>IR communications:</strong> use pre-approved templates for customer/regulatory notifications and include a list of required attachments. </td></tr><tr><td data-label="Technical User Guide"> <strong>Incident evidence collection requirements</strong><br> When investigating incidents collect rotated audit CSVs, bootstrap and runtime logs covering the timeframe, config snapshots, registry exports, job descriptors from job stores, helper binaries and their signatures, correlation ids associated with the event, and environment metadata (Excel bitness, OS version, add-in version). Store evidence in a secure forensic share and record checksums and transfer logs in audit. Maintain a <code>forensic_evidence_manifest.json</code> listing files, checksums, collection time, collector identity, and destination URI for chain of custody. </td></tr><tr><td data-label="Technical User Guide"> <strong>Containment, remediation and post-incident activities</strong><br> Containment may involve setting audit to read-only, turning off network exports, or disabling helper execution. Remediation typically requires restoring components from signed artifacts, rotating credentials and secrets, re-running critical jobs in an isolated environment and validating outputs against preserved checksums, and if audit corruption occurred restoring from the last verified rotation under compliance supervision. Produce a full post-mortem with timeline, root cause, remediation, and preventive changes, and implement follow-on CI/monitoring checks to prevent recurrence. Post-incident, run full VerifyAuditChain and self-tests before the system returns to normal operation. </td></tr><tr><td data-label="Technical User Guide"> <strong>Deployment, upgrade, migration and rollback runbooks (prescriptive)</strong><br> Pre-deployment checks require signed artifacts, passing CI gates including IFRS self-tests and audit verification, config snapshots and backup of audit rotations, and stakeholder notifications. Canary rollouts advance through explicit cohorts with IFRS self-tests and audit verification performed at each step. Emergency rollback includes triggering the kill-switch, revoking server overrides, reinstalling the previous signed build, restoring config snapshots where needed, running IFRS self-tests and VerifyAuditChain prior to resuming, and recording the rollback event in audit with operator and reason. All deployment steps are executed from the Release Engineer's console using signed credentials and produce a <code>deployment.audit</code> row for each phase. </td></tr><tr><td data-label="Technical User Guide"> <strong>CI/CD gating, automated tests and artifact policy</strong><br> CI pipelines must include lint, unit, integration, IFRS self-tests, audit chain verification, performance microbenchmarks, signing, and publishing artifacts to immutable storage. Release artifacts must be signed, accompanied by a manifest with build hash and signing fingerprints, and only published after all gates pass. Regulated releases also require manual compliance sign-off recorded in the deployment manifest and audit. CI must run VerifyAuditChain for sample runs and fail the pipeline on any mismatch. Artifacts are immutable once published; patch releases follow a formal patch manifest protocol. </td></tr><tr><td data-label="Technical User Guide"> <strong>Performance metrics, thresholds and remediation actions</strong><br> Instrument and collect metrics including add-in startup time, deferred init time, audit flush latency, job queue length, export error rate, and process memory. Document explicit warn and critical thresholds for each metric and prescriptive remediation steps — for example reduce audit batch size or increase flush frequency when audit flush latency rises, throttle new job scheduling or increase worker counts when queue length is excessive, and enable local staging fallback when network export error rates cross thresholds. Provide an operations mapping: metric → detection threshold → immediate action → escalation path. </td></tr><tr><td data-label="Technical User Guide"> <strong>Production monitoring, dashboards and alerting playbook</strong><br> Maintain Support, Ops, and Compliance dashboards that surface real-time health: recent errors, top error codes, audit fallback events, job queue state, resource utilization, and audit chain verification status. Alert payloads must include initial triage steps, logs to collect, runbook links, correlation id, and on-call contact. Critical alerts should auto-page stakeholders and create conference bridges, while less-critical alerts are routed through standard escalation. Dashboards must include visualizations for audit integrity checks and a quick-action panel to trigger a forensic export. </td></tr><tr><td data-label="Technical User Guide"> <strong>High-severity incident runbooks (three canonical examples)</strong><br> Provide fully prescriptive runbooks for audit chain compromise (isolate writes, export rotations, run VerifyAuditChain, and reconstruct or restore under compliance rules), helper executable compromise (quarantine binary, rotate credentials, rebuild signed helper, redeploy after validation), and mass export failures (pause exports, enable local staging fallback, diagnose network/permission issues, replay exports with checksums). Each runbook includes required evidence, notification steps, verification checks, and post-mortem templates. Each high-severity runbook includes a dedicated checklist and owner roster for immediate paging. </td></tr><tr><td data-label="Technical User Guide"> <strong>Appendices and canonical artifacts</strong><br> Maintain appendices with canonical audit CSV row formats, recognition schedule samples, config schema keys and types, IFRS fixture descriptions for CI, diagnostic checklist contents for reproducible bug reports, operator cheat-sheets, and compliance & audit sign-off templates — all versioned and stored in immutable artifact storage for auditor access. Appendices include sample JSON snippets, CSV headers, and golden-file checksums to support automated verification. </td></tr><tr><td data-label="Technical User Guide"> <strong>Reconciliation, correction and migration procedures</strong><br> Provide reconciliation tooling and a controlled process for producing correction journals: run reconciliation in isolated environment against immutable input snapshots, produce reconciliation manifests listing impacted contracts and adjustments, require audit logging of all correction entries with reconciliation ids and rationale, and ensure all corrective actions are reversible and documented for audit. Bulk reruns are permitted only under defined governance and with full evidence capture. Use <code>reconciliation.run</code> in safe mode first (<code>--dry-run</code>) and capture <code>reconciliation.report.json</code> before applying corrections. </td></tr><tr><td data-label="Technical User Guide"> <strong>Data protection, PII handling, encryption and key management</strong><br> Classify PII fields and enforce deterministic redaction in disclosure artifacts; store audit archives and exported artifacts encrypted using envelope encryption with managed keys; enforce key rotation schedules; forbid secrets in files; and restrict access to de-redaction artifacts to auditors with logged access. All key rotation and access events are recorded in audit. Use an HSM-backed key management service for signing audit rotations and require multi-person approval for key material export. </td></tr><tr><td data-label="Technical User Guide"> <strong>Operational procedures and operator commands (conceptual)</strong><br> Provide concise but exact operator checklists for common tasks: verifying add-in registration and COM/VSTO entries, collecting diagnostic bundles (logs, audit rotations, config snapshot, input sample), flushing audit buffers, re-queuing or canceling jobs, toggling safe-ops flags, and performing controlled rollbacks. Every operator action that changes runtime state must append an audit row with operator identity, reason, and correlation ids. <br> <strong>Canonical operator commands (examples):</strong><br> <code>diagnostics collect --run-id &lt;id&gt; --out &lt;path&gt;</code>, <code>audit flush --immediate</code>, <code>jobs requeue --job-id &lt;id&gt;</code>, <code>exports stage-local --artifact &lt;id&gt;</code>. Ensure CLI tools authenticate via operator SSO tokens and produce signed audit events. </td></tr><tr><td data-label="Technical User Guide"> <strong>Testing, fixtures and golden-file governance</strong><br> Golden fixtures are stored in an immutable repository and any change requires a documented PR with rationale and approvals from Development and Compliance. CI compares produced artifacts against golden hashes and blocks changes unless a migration manifest and compliance sign-off are present. The test matrix covers supported OS versions, Excel bitness, locales and runtime combinations to catch environment-dependent regressions. Include locale-based fixtures for date/time and numeric formatting to catch regional differences. </td></tr><tr><td data-label="Technical User Guide"> <strong>Release manifest, artifact signing and verification</strong><br> Each release includes a manifest describing build id, artifact hashes, signer identity, test pass/fail summaries, and compliance approvals. Artifacts are code-signed and verified at deployment time; manifest and signing records are appended to audit and stored in immutable artifact stores for later verification by auditors. Release manifests include <code>buildId</code>, <code>commitHash</code>, <code>artifactList</code>, <code>signingFingerprint</code>, <code>ciSummary</code>, and <code>complianceApproval</code>. Verification is automated in deployment orchestration and fails fast on any mismatch. </td></tr><tr><td data-label="Technical User Guide"> <strong>Housekeeping, retention and scheduled maintenance</strong><br> Define audit rotation retention and archival cadence, scheduled temp cleanup windows when Excel is not running, routine kill-switch tests, dependency verification checks, and the cadence for running self-tests in staging. Retention policies reflect regulatory requirements and are implemented with secure archives and evidence of successful archival operations in audit. <br> <strong>Typical retention schedule:</strong> hot audit rotations (30 days), warm archive (7 years), cold deep archive (as required by regulation). Automate retention verification monthly and log results in <code>housekeeping.audit</code>. </td></tr><tr><td data-label="Technical User Guide"> <strong>Governance, approvals and change control</strong><br> Any change affecting allocation, journal generation, or other regulatory outputs requires two-person approval, documented test evidence, migration manifests, and explicit entries in the deployment manifest and audit. Maintain RACI clarity for owners of fixes and ensure compliance sign-off is mandatory for policy-impacting changes. All approvals must be recorded with operator id, timestamp, scope, and link to evidence artifacts. </td></tr><tr><td data-label="Technical User Guide"> <strong>Operator cheat-sheets and run-to-resolution flows</strong><br> Provide short, copy-ready one-page sequences for common incident types: invoice reconciliation differences, missing dependencies, export failures, audit mismatches. Each cheat-sheet lists required artifacts to collect, immediate verification commands or checks, containment actions, and escalation paths; operators must follow the listed steps and record actions in audit. Cheat-sheets are stored in <code>runbooks/cheatsheets/</code> and must be updated when major process changes occur. </td></tr><tr><td data-label="Technical User Guide"> <strong>Templates for post-mortem, change request and regulatory packages</strong><br> Supply standardized templates capturing incident timeline, detection, root cause, remediation, permanent fixes, preventive controls, owners and deadlines, and evidence attachments. Regulatory packages include release manifest, audit rotations for date ranges, migration audit entries, and anonymized sample inputs and outputs that demonstrate deterministic behavior. Templates include mandatory fields and an evidence checklist to ensure completeness for regulator submission. </td></tr><tr><td data-label="Technical User Guide"> <strong>Final absolute rules and non-negotiables</strong><br> Always begin with smoke tests. Never bypass audit or modify audit rows without documented legal/compliance approval. Never guess — record every deviation and remediation step. Determinism, traceability, and auditable approvals are mandatory. Feature flags that change regulatory outputs require two-person governance and CI enforcement. A tested emergency kill-switch must exist and be exercised periodically. Non-negotiable controls are enforced by CI/CD gates and runtime guards; violations trigger automated audits and may halt releases. </td></tr><tr><td data-label="Technical User Guide"> <strong>Available exports and next steps</strong><br> This runbook can be exported immediately into single consolidated PDF, DOCX, XLSX, CI pipeline YAML, or a Prometheus/Grafana package. If you want an export produced now, specify the exact filename and desired format and the corresponding artifact will be prepared. <br> <strong>Export options and required metadata:</strong> when requesting PDF/DOCX provide <code>title</code>, <code>author</code>, <code>effectiveDate</code>; when requesting XLSX specify whether to include hidden sheets (self-test artifacts) and whether to include appendices. Exports include an appended <code>runbook.audit</code> entry capturing who requested the export and why. </td></tr><tr><td data-label="Technical User Guide"> <strong>Operator quick-reference: Immediate triage checklist (copy-ready)</strong><br> 1) Run smoke test and capture <code>audit_tail.csv</code>.<br> 2) If smoke test fails, collect <code>bootstrap.log</code>, <code>ui.log</code>, <code>deps.report.json</code> and <code>excel.register.state</code>.<br> 3) If audit rows are absent for a known action, stop and preserve evidence; do not run corrective scripts that mutate state.<br> 4) If export failure, set exports to <code>stage-local</code>, capture <code>export.failures</code> and enable retry.<br> 5) If calculation mismatch, re-run canonical fixture in isolated runner with identical <code>config.hash</code> and capture <code>artifact.checksum</code>.<br> 6) Record every operator action with <code>operatorId</code>, <code>reason</code>, and <code>correlationId</code> in audit. </td></tr><tr><td data-label="Technical User Guide"> <strong>Evidence templates & canonical fields (copy-ready)</strong><br> - Audit row CSV header: <code>timestamp,correlationId,module,procedure,severity,userId,payloadHash,prevHash,signature,metadata</code><br> - Job descriptor JSON fields: <code>jobId,createdAt,owner,shard,attempts,state,params,configHash</code><br> - Forensic manifest JSON: <code>manifestId,collector,collectionTime,items:[{path,sha256,size}],destination,notes</code><br> - Release manifest example fields: <code>releaseId,buildId,commit,signer,artifacts:[{path,sha256}]</code> Keep these templates in <code>appendices/templates/</code> and use them unchanged for evidence submissions. </td></tr><tr><td data-label="Technical User Guide"> <strong>Operator command reference (explicit examples)</strong><br> - Collect diagnostics: <code>add-in-cli diagnostics collect --run-id &lt;run&gt; --out ./diag-&lt;run&gt;.tar.gz</code><br> - Flush audit: <code>add-in-cli audit flush --immediate --correlation &lt;id&gt;</code><br> - Re-run job: <code>add-in-cli jobs run --job-id &lt;job&gt; --isolated --config-hash &lt;hash&gt;</code><br> - Toggle flag (requires 2-person approval): <code>add-in-cli flags set --id &lt;flag&gt; --value false --approved-by &lt;uid&gt;</code> Each CLI call MUST produce an audit row; failures of CLI produce a signed local error object which must be attached to troubleshooting artifacts. </td></tr><tr><td data-label="Technical User Guide"> <strong>Sample migration manifest (template, copy-ready)</strong><br> <code>json { &quot;migrationId&quot;:&quot;mig-2025-12-26-001&quot;, &quot;author&quot;:&quot;&lt;uid&gt;&quot;, &quot;description&quot;:&quot;Normalize Contract.Currency codes to ISO4217&quot;, &quot;affectedCount&quot;:12345, &quot;dryRunSummary&quot;:{&quot;sampleAffected&quot;:10,&quot;examples&quot;:[&quot;CUST-001&quot;,&quot;CUST-002&quot;]}, &quot;steps&quot;:[{&quot;stepId&quot;:1,&quot;action&quot;:&quot;transform-currency&quot;,&quot;script&quot;:&quot;scripts/migrate_currency_v2.py&quot;,&quot;backout&quot;:&quot;scripts/backout_currency_v2.py&quot;}], &quot;approval&quot;:[{&quot;approver&quot;:&quot;compliance@company&quot;,&quot;timestamp&quot;:&quot;2025-12-26T20:00:00Z&quot;}], &quot;evidence&quot;:[&quot;before-sample.csv&quot;,&quot;after-sample.csv&quot;], &quot;notes&quot;:&quot;Requires two-person signoff to run in production&quot; } </code> Use this template and attach sample before/after rows for audit. </td></tr><tr><td data-label="Technical User Guide"> <strong>Sample release manifest (template, copy-ready)</strong><br> <code>json { &quot;releaseId&quot;:&quot;rel-2025-12-26-01&quot;, &quot;buildId&quot;:&quot;build-abc123&quot;, &quot;commitHash&quot;:&quot;abcdef0123456789&quot;, &quot;artifacts&quot;:[{&quot;path&quot;:&quot;add-in-v2.3.0.zip&quot;,&quot;sha256&quot;:&quot;...&quot;}], &quot;signingKey&quot;:&quot;sig-key-01&quot;,&quot;ciSummary&quot;:{&quot;status&quot;:&quot;passed&quot;,&quot;runId&quot;:&quot;ci-9876&quot;}, &quot;complianceApproval&quot;:[{&quot;approver&quot;:&quot;compliance@company&quot;,&quot;timestamp&quot;:&quot;2025-12-26T19:30:00Z&quot;,&quot;notes&quot;:&quot;Approved IFRS self-tests&quot;}] } </code> Append manifest to audit prior to deployment; ensure <code>signingKey</code> fingerprint present. </td></tr><tr><td data-label="Technical User Guide"> <strong>Post-mortem template (required fields)</strong><br> 1) Incident ID<br> 2) Severity<br> 3) Detection time<br> 4) Containment time<br> 5) Resolution time<br> 6) Summary (1 paragraph)<br> 7) Full timeline with correlation ids<br> 8) Root cause analysis<br> 9) Corrective actions with owners and deadlines<br> 10) Evidence attached (audit rotations, logs, manifests)<br> 11) Preventive measures and tests to add to CI<br> 12) Compliance impact and regulator notification plan<br> 13) Lessons learned. Post-mortem is due within 72 hours of incident resolution and must be approved by Compliance. </td></tr><tr><td data-label="Technical User Guide"> <strong>Regulatory package checklist (copy-ready)</strong><br> - Release manifest (signed)<br> - Audit rotations for affected date range<br> - Migration manifests (if any)<br> - Redacted sample inputs and outputs demonstrating deterministic behavior<br> - Test fixtures and CI run logs proving parity<br> - Compliance sign-offs and reviewer comments<br> - De-redaction requests (if applicable)<br> - Post-mortem (if incident-related) Deliver in an immutable archive and append <code>submission.audit</code> entry. </td></tr><tr><td data-label="Technical User Guide"> <strong>Verification & acceptance tests (developer checklist)</strong><br> - Unit tests cover edge cases and negative paths<br> - Integration tests exercise module interfaces<br> - IFRS self-tests match golden artifacts byte-for-byte<br> - Audit chain verified in CI for sample runs<br> - Performance benchmarks within thresholds<br> - Signed artifacts and manifests present<br> - Compliance approvals recorded If any item fails, the release is blocked until remediated and evidence attached to the blocking ticket. </td></tr><tr><td data-label="Technical User Guide"> <strong>Common failures playbook (operator-ready)</strong><br> <em>Failure: Add-in not loading.</em> Steps:<br> 1) Confirm Excel COM registration; collect <code>excel.register.state</code>.<br> 2) Check <code>bootstrap.log</code> for <code>autoload-disabled</code> messages.<br> 3) Reinstall signed add-in package and re-register; collect <code>install.log</code>.<br> 4) If auto-disabled persists, escalate to Release Engineer with logs and <code>audit_tail.csv</code>.<br> <em>Failure: Exports failing.</em> Steps:<br> 1) Set exports to <code>stage-local</code> and capture <code>export.failures</code>.<br> 2) Restart export daemon.<br> 3) Replay exports with <code>exports replay --from &lt;timestamp&gt;</code>.<br> 4) If network auth error, rotate creds and record <code>key.rotate</code> audit row.<br> <em>Failure: Calculation mismatch vs golden.</em> Steps:<br> 1) Re-run canonical fixture in isolated runner with identical <code>config.hash</code>.<br> 2) Diff intermediate values.<br> 3) If mismatch unexplained, block release and open an incident. Always collect evidence described in the relevant section. </td></tr><tr><td data-label="Technical User Guide"> <strong>Audit compromise runbook (summary)</strong><br> 1) Isolate writes (set audit to read-only).<br> 2) Export current rotations and preserve copies with checksums to secure forensic share.<br> 3) Run <code>VerifyAuditChain</code> on prior rotations to identify first mismatch.<br> 4) Reconstruct or restore from last verified rotation under compliance supervision.<br> 5) Alert regulators as required.<br> 6) Perform kill-switch test and update post-mortem. Each step must be logged and evidence stored in <code>forensic</code> store. </td></tr><tr><td data-label="Technical User Guide"> <strong>Operator training & periodic drills</strong><br> Operators must complete annual training including smoke tests, common failures, and evidence collection. Perform a quarterly tabletop run of at least one high-severity runbook and an annual full drill including forensic export and VerifyAuditChain. Retain drill artifacts and approvals in audit. </td></tr><tr><td data-label="Technical User Guide"> <strong>Appendix A — audit row example (canonical JSON)</strong><br> <code>json { &quot;timestamp&quot;:&quot;2025-12-26T20:00:00Z&quot;, &quot;correlationId&quot;:&quot;20251226-200000-modIFRS15-1a2b3c4d&quot;, &quot;module&quot;:&quot;modIFRS15&quot;, &quot;procedure&quot;:&quot;allocate&quot;, &quot;severity&quot;:&quot;INFO&quot;, &quot;userId&quot;:&quot;system&quot;, &quot;payloadHash&quot;:&quot;sha256:abcd...&quot;, &quot;prevHash&quot;:&quot;sha256:0000...&quot;, &quot;signature&quot;:&quot;sig:abcd...&quot;, &quot;metadata&quot;:{&quot;runId&quot;:&quot;run-2025-12-26-0001&quot;,&quot;configHash&quot;:&quot;cfg-1234&quot;} } </code> Sign each rotation and archive rotated packages according to retention policy. </td></tr><tr><td data-label="Technical User Guide"> <strong>Appendix B — glossary of key terms</strong><br> - Audit chain: append-only sequence of signed audit rows<br> - Correlation id: unique id that ties logs, audit, and artifacts<br> - SafeRound: deterministic rounding algorithm with configured midpoint rule<br> - Golden file: canonical artifact used for CI parity<br> - Job descriptor: persisted metadata describing an execution unit<br> - Forensic share: secure archive for incident evidence<br> - Kill-switch: mechanism to disable unsafe features or exports </td></tr><tr><td data-label="Technical User Guide"> <strong>Appendix C — monitoring thresholds (recommended defaults)</strong><br> - Startup time (WARN > 12s, CRIT > 30s)<br> - Audit flush latency (WARN > 5s, CRIT > 30s)<br> - Job queue length (WARN > 100, CRIT > 1000)<br> - Export error rate (WARN > 0.5%, CRIT > 2%)<br> - Memory usage (WARN > 75%, CRIT > 90%) Adjust thresholds per environment and justify deviations in <code>thresholds.audit</code>. </td></tr><tr><td data-label="Technical User Guide"> <strong>Appendix D — change-control checklist (must-complete before production change)</strong><br> 1) Create change ticket with scope and rollback plan.<br> 2) Run IFRS self-tests and attach results.<br> 3) Attach migration manifest (if applicable).<br> 4) Obtain two-person approval for regulatory-impacting changes.<br> 5) Sign artifacts and create release manifest.<br> 6) Schedule deployment outside freeze windows or get override approvals.<br> 7) Run deployment in canary cohorts with automated gates.<br> 8) After rollout, run VerifyAuditChain and record results in audit. </td></tr><tr><td data-label="Technical User Guide"> <strong>Appendix E — contact & escalation matrix (copy-ready)</strong><br> Maintain an up-to-date roster with direct paging numbers and SSO ids for Product Owner, Release Engineer, Compliance Officer, Security Lead, On-call SRE, and Support Engineer. The matrix must be publicly accessible to authorized personnel and updated on role change. Paging policies define business hours, off-hours, and holiday rotations. </td></tr><tr><td data-label="Technical User Guide"> <strong>Document distribution & access controls</strong><br> Store the canonical runbook in immutable artifact storage and present a read-only rendered copy in the internal docs portal. Edits go through PRs targeting <code>runbook/master</code>; each PR must include test evidence and, for regulatory-impacting changes, compliance sign-off. Access to edit rights is limited to the Runbook Owners group and requires two-person approvals for publishing. </td></tr><tr><td data-label="Technical User Guide"> <strong>Next steps for consumers of this runbook</strong><br> If you are an operator, familiarize yourself with the smoke tests and common failures cheat-sheets in the next 48 hours. If you are a developer, ensure your next PR touching regulatory modules includes a canonical fixture and updated golden file checksums. If you are Compliance, schedule a monthly review of migration manifests and a quarterly audit of release manifests. For any export request of this runbook, specify format and filename and include the intended use and recipient to ensure appropriate audit tracking. </td></tr></tbody></table></div><div class="row-count">Rows: 69</div></div><div class="table-caption" id="Table2" data-table="Docu_0158_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modAudit)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modAudit)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modAudit)"> <strong>Overview:</strong> Production-ready, append-only audit module for an Excel Add-in implemented in VBA. Goals: tamper-evident chain of rows, UTC ISO8601 timestamps, deterministic bulk/batched writes, pluggable hash provider (macro / certutil SHA256 / CRC32 fallback), buffered writes with atomic Range assignment, safe rotation/export, PII-light redaction, meta-sheet observability, and a backwards-compatible public API. Row schema (cols 1..12): <code>TimestampUTC | CorrelationID | Module | Procedure | Severity | ErrNum | WindowsUser | ExcelUser | Action | ContextJSON | PrevHash | Hash</code>. Canonical payload for hashing: <code>PrevHash | TimestampUTC | CorrelationID | Module | Procedure | Severity | ErrNum | WindowsUser | ExcelUser | Action | ContextJSON</code> (UTF-8). Public API (stable signatures): <code>InitAuditModule</code>, <code>ShutdownAuditModule</code>, <code>LogAudit</code>, <code>AppendAuditEntry</code>, <code>AppendAuditBuffered</code>, <code>FlushAuditBuffer</code>, <code>RotateAuditNow</code>, <code>ExportAuditToCSV</code>, <code>ExportAuditToJSON</code>, <code>VerifyAuditChain</code>, <code>GenerateAuditDiagnosticReport</code>, <code>FindAuditByCorrelationID</code>, <code>ReadAuditRow</code>, <code>CreateAuditSheetIfMissing</code>, <code>SetAuditFeatureFlag</code>, <code>GetAuditFeatureFlag</code>, plus <code>HashProviderMacroName</code> injection point. Use this table as authoritative inline documentation; tests and invariants are listed per-function. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>InitAuditModule</strong> — <em>initialize runtime state and meta-sheet</em><br><strong>Purpose:</strong> Initialize module-level state (buffer, locks, flags), ensure meta-sheet if enabled, record an init observation in the buffer. Designed to be idempotent and safe to call multiple times.<br><strong>Signature:</strong> <code>Public Sub InitAuditModule()</code><br><strong>Behavior:</strong> If already initialized, exits. Allocates <code>g_auditBuffer</code> (Collection), sets <code>g_batchWriteLock=False</code>, records <code>g_lastHashProviderUsed = &quot;&quot;</code>, sets <code>g_auditInitialized=True</code>. Calls <code>CreateAuditMetaSheetIfMissing</code> if <code>g_enableMetaSheet</code>. Appends an <code>AuditInit</code> buffered entry with a newly-created correlation id via <code>AppendAuditBuffered Entry_Row(...)</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Creates meta-sheet (very-hidden) if enabled; adds one buffered entry; may set workbook state (hidden worksheet).<br><strong>Invariants:</strong> After return, <code>g_auditInitialized=True</code> and <code>g_auditBuffer</code> is non-Null. Idempotent: multiple calls harmless.<br><strong>Failure modes:</strong> Errors suppressed with <code>On Error Resume Next</code>; failure to create sheets means module still marks initialized and may log fallback entries. Caller should check <code>CreateAuditSheetIfMissing</code> returns a worksheet if they need it.<br><strong>Security/Privacy:</strong> None beyond existing module behaviors. Initialization entry contains no sensitive payload.<br><strong>Recommended tests:</strong> Call twice to verify idempotence; validate meta-sheet created when flag enabled; ensure a buffered <code>AuditInit</code> row is produced on flush. <br><strong>Notes:</strong> Must be called before any buffered append; public API methods auto-call if not initialized. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ShutdownAuditModule</strong> — <em>flush and clean shutdown</em><br><strong>Purpose:</strong> Gracefully flush buffer, append shutdown observability, clear resources and update meta-sheet.<br><strong>Signature:</strong> <code>Public Sub ShutdownAuditModule()</code><br><strong>Behavior:</strong> Appends <code>AuditShutdown</code> buffered row, calls <code>FlushAuditBuffer</code>, sets <code>g_auditBuffer = Nothing</code>, resets locks and flags, writes final meta-sheet state with <code>UpdateAuditMetaSheet</code> if enabled.<br><strong>Complexity:</strong> O(n) where n is buffered entries (due to <code>FlushAuditBuffer</code>).<br><strong>Side-effects:</strong> Persists buffered entries to worksheet; updates meta sheet; may perform per-row writes in fallback. <br><strong>Invariants:</strong> After call, <code>g_auditInitialized=False</code>, buffer cleared or persisted. <br><strong>Failure modes:</strong> If <code>FlushAuditBuffer</code> fails, <code>ShutdownAuditModule</code> will attempt per-row fallback (see <code>FlushAuditBuffer</code> behavior). Errors are swallowed with best-effort persistence logged. <br><strong>Recommended tests:</strong> Ensure buffered entries are persisted after shutdown; simulate bulk write failure (force by mocking Range assignment) and verify fallback per-row writes recorded. <br><strong>Notes:</strong> Safe to call during application closing; caller should not assume synchronous disk visibility beyond workbook state. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>SetAuditFeatureFlag / GetAuditFeatureFlag</strong> — <em>runtime feature flags</em><br><strong>Purpose:</strong> Toggle runtime flags <code>EnableMetaSheet</code> and <code>AggressiveRedaction</code> and persist unknown flags to meta-sheet for visibility. Provide read access to flags.<br><strong>Signature:</strong> <code>Public Sub SetAuditFeatureFlag(ByVal flagName As String, ByVal flagValue As Boolean)</code> / <code>Public Function GetAuditFeatureFlag(ByVal flagName As String) As Variant</code><br><strong>Behavior:</strong> Recognizes <code>&quot;EnableMetaSheet&quot;</code> and <code>&quot;AggressiveRedaction&quot;</code> (case-insensitive). When enabling meta-sheet, creates meta sheet. Unknown flags are appended to the meta-sheet (if enabled) as rows for auditing. <code>GetAuditFeatureFlag</code> returns current in-memory value or <code>Empty</code> for unknown flags.<br><strong>Complexity:</strong> O(1) (except writing a row to meta-sheet O(1) per append).<br><strong>Side-effects:</strong> May create/update meta sheet and write a new row for unknown flags. Updates in-memory flag values only; not persisted elsewhere unless consumer writes meta-sheet to file or inspects it.<br><strong>Invariants:</strong> Flags live in module-level variables; meta-sheet mirrors them when enabled. <br><strong>Failure modes:</strong> IO errors when writing meta-sheet are swallowed; unknown-flag persistence may fail silently. <br><strong>Recommended tests:</strong> Toggle both supported flags, verify <code>GetAuditFeatureFlag</code> returns expected values, and that meta-sheet entries appear for unknown flags. <br><strong>Notes:</strong> Feature flags are intentionally only runtime; persistent feature storage not implemented by default. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>LogAudit</strong> — <em>compatibility logger (simple API)</em><br><strong>Purpose:</strong> Backwards-compatible convenience wrapper that generates a correlation id and appends a buffered entry (preserves older call-sites). Provides synchronous fallback on error.<br><strong>Signature:</strong> <code>Public Sub LogAudit(ByVal action As String, ByVal details As String)</code><br><strong>Behavior:</strong> Ensures module initialized; creates a correlation id; calls <code>AppendAuditBuffered Entry_Row(action, details, corr)</code>. On error, falls back to synchronous <code>AppendAuditEntry</code> to avoid data loss (keeps backwards-compatibility with callers expecting immediate logging).<br><strong>Complexity:</strong> O(1) amortized. <br><strong>Side-effects:</strong> Adds buffered entry. On severe errors, writes a synchronous fallback row. <br><strong>Invariants:</strong> Does not throw; always best-effort logs. <br><strong>Failure modes:</strong> If initialization or buffer creation fails, fallback may still write minimal failure row. <br><strong>Tests:</strong> Call with normal inputs; simulate <code>g_auditInitialized=False</code>; simulate error inside <code>AppendAuditBuffered</code> to validate fallback synchronous write. <br><strong>Notes:</strong> Signature intentionally minimal to preserve old integrations. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>CreateAuditSheetIfMissing</strong> — <em>create stable audit worksheet</em><br><strong>Purpose:</strong> Ensure <code>_IFRS_Audit</code> worksheet exists and has canonical header row. Returns the worksheet object or <code>Nothing</code> on failure.<br><strong>Signature:</strong> <code>Public Function CreateAuditSheetIfMissing() As Worksheet</code><br><strong>Behavior:</strong> Searches workbook sheets by name (case-insensitive). If not found, adds a new worksheet at the end, names it <code>_IFRS_Audit</code> (best-effort), writes header columns 1..12 (TimestampUTC ... Hash), bolds header, sets sheet to <code>xlSheetVeryHidden</code>. Returns the worksheet reference. Catches errors and returns <code>Nothing</code> on failure. <br><strong>Complexity:</strong> O(sheets). <br><strong>Side-effects:</strong> Adds a worksheet and sets visibility. <br><strong>Invariants:</strong> Created sheet contains canonical header row in row 1. <br><strong>Failure modes:</strong> Naming collision, workbook protections, or restricted macro permissions may prevent creation. Returns <code>Nothing</code> to callers, which must handle it. <br><strong>Security:</strong> Being <code>VeryHidden</code> prevents casual user edits but does not prevent malicious tampering. <br><strong>Tests:</strong> Remove <code>_IFRS_Audit</code> and call function; verify header correctness, sheet visibility, and that subsequent calls return same sheet. Test behavior under workbook-protection and when adding sheets is disallowed. <br><strong>Notes:</strong> Keep sheet name stable; changing it breaks external tools and exports. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>AppendAuditEntry</strong> — <em>synchronous single-row append (back-compat)</em><br><strong>Purpose:</strong> Immediate append to audit worksheet for callers that require synchronous persistence. Performs redaction and computes hash for new row, updates PrevHash and Hash columns, and triggers rotation when threshold crossed.<br><strong>Signature:</strong> <code>Public Sub AppendAuditEntry(ByVal action As String, ByVal details As String, Optional ByVal moduleName As String = &quot;&quot;, Optional ByVal procName As String = &quot;&quot;, Optional ByVal severity As String = &quot;Info&quot;, Optional ByVal errNum As Long = 0, Optional ByVal correlationID As String = &quot;&quot;, Optional ByVal contextJson As String = &quot;&quot;)</code><br><strong>Behavior (detailed):</strong> Ensures audit sheet; fills defaults (correlation id, module/proc names). Redacts <code>contextJson</code> via <code>RedactSensitiveData</code>, truncates if over <code>MAX_CONTEXT_LENGTH</code> and emits a <code>ContextTruncated</code> buffered entry. Captures <code>prevHash</code> via <code>GetLastAuditHash(ws)</code>, builds canonical <code>rowData</code> string, calculates <code>entryHash</code> via <code>ComputeEntryHash(prevHash, rowData)</code>. Writes all 12 columns into nextRow using cell-by-cell assignments (synchronous). Sets sheet VeryHidden and calls <code>RotateAuditNow</code> if threshold reached. Updates meta-sheet if enabled. Error handler writes fallback minimal row describing logging failure. <br><strong>Complexity:</strong> O(1) per row write; hash computation cost depends on provider (certutil external process or CRC32 loop). <br><strong>Side-effects:</strong> Immediate worksheet modification; calls external tools for SHA256 (proc execution), modifies meta-sheet. <br><strong>Invariants:</strong> After a successful call, the appended row's PrevHash equals previous last row's Hash; the new row Hash equals <code>ComputeEntryHash(prevHash,rowData)</code>. <br><strong>Failure modes:</strong> File/worksheet locked, workbook protection, or certutil failures. Error handler attempts best-effort minimal failure logging. Race conditions possible if multiple threads/processes write concurrently (VBA single-threaded in-process mitigates some risks but external Excel automation could race). <br><strong>Security:</strong> <code>contextJson</code> is redacted; writes use <code>text</code> cells only. <br><strong>Recommended tests:</strong> Append with large context (>MAX_CONTEXT_LENGTH) and verify truncation and redaction entries; simulate certutil missing to observe CRC32 fallback; verify PrevHash/Hash chain property across multiple appends. <br><strong>Notes:</strong> This function must remain stable for backward compatibility with older callers expecting synchronous persistence. Consider locking at higher level when used concurrently by external automation. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>EnsureBuffer / Entry_Row</strong> — <em>buffer helpers & canonical buffered entry creation</em><br><strong>Purpose:</strong> <code>EnsureBuffer</code> lazily allocates <code>g_auditBuffer</code>. <code>Entry_Row</code> creates a canonical 10-element array representing a buffered row (columns subset) with redaction applied and defensive truncation; used by buffered API.<br><strong>Signatures:</strong> <code>Private Sub EnsureBuffer()</code> / <code>Private Function Entry_Row(ByVal action As String, ByVal details As String, ByVal corrId As String) As Variant</code><br><strong>Behavior:</strong> <code>EnsureBuffer</code> checks <code>g_auditBuffer</code> and instantiates a new <code>Collection</code> if <code>Nothing</code>. <code>Entry_Row</code> fills a 1..10 variant array with timestamp, correlation id, default module/proc/severity, user names, action, and redacted/truncated context. If redaction changed input content, it emits a buffered <code>RedactionApplied</code> entry (recursive but safe because the entry emitted is itself an <code>Entry_Row</code> of a short note). <br><strong>Complexity:</strong> O(len(details)) for redaction regexes. <br><strong>Side-effects:</strong> May recursively append small audit entries describing redaction. <br><strong>Failure modes:</strong> Over-recursion risk if <code>Entry_Row</code> keeps finding differences — mitigated because redaction produces stable shorter strings; but if redaction function misbehaves it could loop. <br><strong>Tests:</strong> Create entries that trigger <code>RedactionApplied</code> and <code>ContextTruncated</code> to ensure recursion depth is limited and the resultant buffer contains both the original event and the redaction notice. <br><strong>Notes:</strong> Keep the array layout stable — buffered code depends on fixed indexes. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>AppendAuditBuffered</strong> — <em>add an entry to in-memory buffer</em><br><strong>Purpose:</strong> Add pre-built entry arrays (from <code>Entry_Row</code>) into <code>g_auditBuffer</code> and trigger <code>FlushAuditBuffer</code> when threshold reached; update meta-sheet observability.<br><strong>Signature:</strong> <code>Public Sub AppendAuditBuffered(entry As Variant)</code><br><strong>Behavior:</strong> Ensures module initialized, ensures buffer exists, adds <code>entry</code> to <code>g_auditBuffer</code>, updates meta-sheet if enabled, and if buffered count >= <code>AUDIT_BATCH_FLUSH_THRESHOLD</code> calls <code>FlushAuditBuffer</code>. Error handler falls back to synchronous <code>AppendAuditEntry</code> for the entry to avoid silent loss.<br><strong>Complexity:</strong> O(1) per append + potential flush cost. <br><strong>Side-effects:</strong> May trigger <code>FlushAuditBuffer</code>. <br><strong>Failure modes:</strong> If buffer allocation fails, fallback per-row append is attempted. <br><strong>Tests:</strong> Append <code>AUDIT_BATCH_FLUSH_THRESHOLD</code> items and verify <code>FlushAuditBuffer</code> runs and buffer cleared. Test fallback by forcing an error (e.g., by making <code>CreateAuditSheetIfMissing</code> return Nothing). <br><strong>Notes:</strong> Buffer contains arrays with positions tied to <code>FlushAuditBuffer</code> ordering. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>FlushAuditBuffer</strong> — <em>deterministic bulk write with fallback per-row</em><br><strong>Purpose:</strong> Atomically persist buffered entries into the audit worksheet with a single <code>Range.Value</code> assignment where possible; compute chained hashes deterministically; preserve buffer on failure via safe per-row fallback; provide observability entries for start/finish/fallback.<br><strong>Signature:</strong> <code>Public Sub FlushAuditBuffer()</code><br><strong>Behavior (detailed):</strong> No-op if buffer empty. Idempotent guard via <code>g_batchWriteLock</code>. Appends a <code>FlushStart</code> buffered observation, obtains worksheet, computes <code>startRow</code>, pre-allocates a 2D <code>outArr(1 To n,1 To 12)</code> and iterates buffered entries computing rowData and each row's hash using <code>ComputeEntryHash(prevHash,rowData)</code>. Writes the whole <code>outArr</code> at once to <code>ws.Cells(startRow,1).Resize(n,12).Value</code>. On success, appends <code>FlushFinish</code> buffered observation, replaces buffer with new Collection, updates meta-sheet and triggers rotation if needed. On error, falls back to iterating buffered entries and calling <code>AppendAuditEntry</code> per entry (idempotent but slower), emits <code>FlushFallback</code> buffered observation and clears buffer. Locks released at end. Error handler also emits <code>FlushFallback</code> detail and clears buffer. <br><strong>Complexity:</strong> O(n + cost of hash per entry). Bulk write reduces round-trips to Excel COM from O(n) to 1. Fallback is O(n * COM writes). <br><strong>Side-effects:</strong> May execute external certutil commands during hash computation when provider is SHA256 (expensive); modifies worksheet and meta-sheet; may write many cells at once. <br><strong>Invariants:</strong> On success, the worksheet rows from <code>startRow..startRow+n-1</code> contain PrevHash/Hash chain consistent with <code>ComputeEntryHash</code>. Buffer cleared only after successful write or after safe per-row fallback. <br><strong>Failure modes:</strong> COM Range.Write failure (e.g., protected workbook) triggers fallback; external certutil may block or fail; long-running certutil calls may cause UI hang (function uses Exec + DoEvents). On fallback, if per-row writes fail, error handler attempts to log the write failure to the sheet. <br><strong>Security:</strong> Uses only text writes; context redaction already applied. <br><strong>Recommended tests:</strong> Stress tests with n >> threshold; simulate Range.Value failure to exercise fallback loop; test concurrent calls (should be serialized by the lock). Also validate correct PrevHash chaining for batch writes and after fallback. <br><strong>Notes:</strong> Bulk Range assignment is crucial for performance; keep <code>AUDIT_BATCH_FLUSH_THRESHOLD</code> tuned. Consider additional locking across processes if external automation might write concurrently. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>RotateAuditNow</strong> — <em>archive then truncate primary audit sheet</em><br><strong>Purpose:</strong> Archive the current <code>_IFRS_Audit</code> content to CSV in a chosen folder (configurable) and delete archived rows from the live sheet to reset the audit ledger; emit rotation observability entries.<br><strong>Signature:</strong> <code>Public Sub RotateAuditNow()</code><br><strong>Behavior:</strong> Computes archive folder using <code>AUDIT_ARCHIVE_FOLDER</code>, <code>TEMP</code>, workbook path, or user profile as fallback. Creates folder if missing (FSO), builds filename <code>IFRS_Audit_Archive_&lt;utcnow&gt;.csv</code>. Creates a temporary workbook, copies <code>ws.UsedRange</code> and pastes values into <code>tmpWB</code>, saves as CSV to <code>fname</code> via <code>tmpWB.SaveAs</code> (csv format). On success, deletes rows 2..lastRow from main sheet (preserving header), appends <code>RotateFinish</code> with archive path and rows archived. On Save failure, attempts fallback save in TEMP and records <code>RotateFallback</code>. Errors emit <code>AuditRotateError</code>. <br><strong>Complexity:</strong> O(#rows archived) for copy & delete. <br><strong>Side-effects:</strong> Writes file to disk, deletes rows from audit sheet (destructive operation), creates tmp workbooks. <br><strong>Invariants:</strong> After successful rotation, live audit sheet contains only header row and new writes start from row 2. <br><strong>Failure modes:</strong> Unable to save CSV due to permissions; <code>SaveAs</code> may fail on non-writable paths. Delete of rows may fail if sheet or workbook protected. Robust error handling attempts fallback and logs. <br><strong>Security:</strong> Archive files contain the full audit contents including redacted contexts; ensure file storage is secure. <br><strong>Recommended tests:</strong> Rotate with small and large row counts; test failure path by pointing archive folder to unwritable location; validate deletion only occurs after successful save. <br><strong>Notes:</strong> Rotation is destructive — keep backups and consider incremental archival (e.g., append-mode) if required. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ExportAuditToCSV / ExportAuditToJSON</strong> — <em>hard exports for off-line analysis</em><br><strong>Purpose:</strong> Export full audit sheet to CSV or JSON at specified path for external analysis or ingestion.<br><strong>Signatures:</strong> <code>Public Function ExportAuditToCSV(ByVal fullPath As String) As Boolean</code> / <code>Public Function ExportAuditToJSON(ByVal fullPath As String) As Boolean</code><br><strong>Behavior (CSV):</strong> Copies <code>ws.UsedRange</code> into a temporary workbook and <code>SaveAs</code> CSV to <code>fullPath</code>. Creates folders if missing using FSO. Returns True on success; logs <code>ExportAuditError</code> on failure. <br><strong>Behavior (JSON):</strong> Reads <code>ws.UsedRange.Value</code> into a variant, iterates rows/cols to build JSON array of objects using header row as keys, writes JSON to <code>fullPath</code> via textual <code>Open For Binary</code> and <code>Put</code>. Returns True on success and logs <code>ExportAuditError</code> on exceptions. <br><strong>Complexity:</strong> O(rows * cols) to read and serialize. <br><strong>Side-effects:</strong> Creates file on disk. <br><strong>Failure modes:</strong> File system permissions, large datasets memory pressure when building JSON; note JSON builder builds a full string in memory. <br><strong>Security:</strong> JSON/CSV export preserves whatever is in the audit sheet (including contexts, albeit already redacted). Protect exported files appropriately. <br><strong>Tests:</strong> Export with no rows, with many rows, with special characters in cells (commas, quotes, newlines). Verify JSON structural correctness and escaping (tested via <code>EscapeJson</code>/<code>EscapeCsv</code>). <br><strong>Notes:</strong> For very large audit tables, consider streaming write rather than building the whole JSON string in memory. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>VerifyAuditChain</strong> — <em>verify PrevHash / Hash chain integrity</em><br><strong>Purpose:</strong> Validate that each row's <code>PrevHash</code> matches the reconstructed chain and that the computed hash equals stored <code>Hash</code>. Returns boolean and optionally reports first bad row and diagnostic code (0 OK, 1 MissingPrevHash, 2 HashMismatch, 3 Malformed/Other).<br><strong>Signature:</strong> <code>Public Function VerifyAuditChain(Optional ByRef firstBadRow As Long, Optional ByRef diagnosticCode As Long) As Boolean</code><br><strong>Behavior:</strong> Loads <code>ws.UsedRange</code> into array <code>data</code>. Iterates rows 2..rows and for each builds canonical <code>rowData</code> from columns 1..10, checks stored PrevHash equals <code>prevHash</code> (empty for first row), computes <code>expectedHash = ComputeEntryHash(prevHash,rowData)</code>, compares <code>expectedHash</code> to stored hash col 12, and updates <code>prevHash = expectedHash</code>. On mismatch sets output params and returns False. Returns True if all rows OK. Errors set diagnosticCode=3 and False. <br><strong>Complexity:</strong> O(rows * hashCost). Hash cost dominated by provider. <br><strong>Side-effects:</strong> None (read-only). <br><strong>Failure modes:</strong> Malformed rows, missing expected columns, or inability to compute hash (hash provider failures will cause mismatch). <br><strong>Security:</strong> Useful for tamper detection. However, verification depends on same <code>ComputeEntryHash</code> implementation — if provider behavior differs (macro provider returns different canonicalization) false positives may occur. <br><strong>Recommended tests:</strong> Tamper a single row PrevHash or Hash and verify the returned firstBadRow and diagnosticCode. Test with different hash providers and ensure consistent canonical payload encoding (UTF-8). <br><strong>Notes:</strong> Consider exposing an option to supply a deterministic hash provider for verification (e.g., an in-module pure-VBA fallback consistent with CRC32 path). </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>GenerateAuditDiagnosticReport</strong> — <em>row-level diagnostic CSV</em><br><strong>Purpose:</strong> Produce a CSV summarising expected vs actual prev/hash for each row offering a forensic export for auditors; suitable for bulk analysis outside Excel.<br><strong>Signature:</strong> <code>Public Function GenerateAuditDiagnosticReport(ByVal outputCsvPath As String, Optional ByVal startRow As Long = 2) As Boolean</code><br><strong>Behavior:</strong> Opens <code>outputCsvPath</code> for binary write, writes header, iterates rows <code>startRow..lastRow</code>, recomputes expected prev/hash via <code>ComputeEntryHash</code>, writes CSV lines <code>Row,ExpectedPrev,ActualPrev,ExpectedHash,ActualHash,Reason</code>. Returns True on success or False and logs an <code>ExportAuditError</code>. <br><strong>Complexity:</strong> O(rows * hashCost). <br><strong>Side-effects:</strong> Writes file to disk. <br><strong>Failure modes:</strong> File I/O errors. <br><strong>Recommended tests:</strong> Generate report on a valid sheet; validate CSV fields contain expected values for both OK and deliberately tampered rows. <br><strong>Notes:</strong> CSV contains full hash values — treat as sensitive output. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>FindAuditByCorrelationID</strong> — <em>lookup helper</em><br><strong>Purpose:</strong> Find the first row where column B (CorrelationID) equals provided id and return row number; returns 0 if not found.<br><strong>Signature:</strong> <code>Public Function FindAuditByCorrelationID(ByVal corrId As String) As Long</code><br><strong>Behavior:</strong> Uses <code>ws.Range(&quot;B:B&quot;).Find(what:=corrId, LookIn:=xlValues, LookAt:=xlWhole)</code>; returns <code>.Row</code> or 0 on not found. Handles errors returning 0. <br><strong>Complexity:</strong> Excel Find is optimized — expected O(1) average but worst-case O(rows). <br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> If sheet missing returns 0. <br><strong>Tests:</strong> Insert a row with known corrId and assert return row; search non-existent id returns 0. <br><strong>Notes:</strong> Find returns first match; if duplicates exist, consumer must handle multiples. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ReadAuditRow</strong> — <em>read-back structured row</em><br><strong>Purpose:</strong> Return a <code>Scripting.Dictionary</code> object mapping column names to values for a requested sheet row. Useful for programmatic inspection or export by other modules.<br><strong>Signature:</strong> <code>Public Function ReadAuditRow(ByVal sheetRow As Long) As Object</code><br><strong>Behavior:</strong> Validates <code>sheetRow</code> in bounds, creates <code>Scripting.Dictionary</code>, populates keys <code>TimestampUTC, CorrelationID, Module, Procedure, Severity, ErrNum, WindowsUser, ExcelUser, Action, ContextJSON, PrevHash, Hash</code> from the row, and returns dictionary. Returns <code>Nothing</code> on invalid input or error. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Read a row and verify dictionary fields equal cells; invalid row returns <code>Nothing</code>. <br><strong>Notes:</strong> Caller must release COM objects if used extensively. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>GetLastAuditHash</strong> — <em>helper to fetch current chain tail</em><br><strong>Purpose:</strong> Return the hash value from the last audit row (col 12) or empty string if none. Used by append functions to compute <code>PrevHash</code> for the next row.<br><strong>Signature:</strong> <code>Private Function GetLastAuditHash(ws As Worksheet) As String</code><br><strong>Behavior:</strong> If ws omitted, resolves by calling <code>CreateAuditSheetIfMissing</code>. Determines <code>lastRow = ws.Cells(ws.Rows.Count,1).End(xlUp).Row</code>. If <code>lastRow &lt; 2</code> returns <code>&quot;&quot;</code> else returns <code>CStr(ws.Cells(lastRow,12).Value)</code>. <br><strong>Complexity:</strong> O(1). <br><strong>Failure modes:</strong> Sheet missing -> returns "". <br><strong>Notes:</strong> Small but central helper — any change to column layout affects this function. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ComputeEntryHash</strong> — <em>hash provider orchestration (pluggable)</em><br><strong>Purpose:</strong> Produce the hash string for a canonical payload; tries injected macro provider first, then <code>certutil</code> SHA256, then CRC32 fallback. Emits <code>HashProviderUsed</code> buffered observation when a provider succeeds.<br><strong>Signature:</strong> <code>Private Function ComputeEntryHash(ByVal prevHash As String, ByVal rowData As String) As String</code><br><strong>Behavior:</strong> Constructs <code>payload = prevHash &amp; &quot;|&quot; &amp; rowData</code>. If <code>HashProviderMacroName</code> set, calls <code>Application.Run(HashProviderMacroName, payload)</code> and if non-empty, returns provider output. Else tries <code>ComputeSHA256_UsingCertUtil(payload)</code>; if returns value, uses it. Otherwise calls <code>ComputeCRC32String(payload)</code> (fast pure-VBA fallback) and returns 8-hex CRC string. Sets <code>g_lastHashProviderUsed</code> accordingly and records an observability buffered entry <code>HashProviderUsed</code> with provider name. <br><strong>Complexity:</strong> CRC32 O(len(bytes)); certutil path involves writing a file and blocking process execution; macro path complexity depends on user-provided macro.<br><strong>Side-effects:</strong> May call external process <code>certutil</code> and create/delete temp files; may call arbitrary public macro via <code>Application.Run</code> which could execute arbitrary workbook code (trust boundary). Appends <code>HashProviderUsed</code> entries to buffer. <br><strong>Invariants:</strong> Returned hash string must be stable for identical <code>payload</code> and provider. <br><strong>Failure modes:</strong> Macro provider may throw or be malicious; certutil may be unavailable (non-Windows or restricted); ADODB Stream may be absent; fallback ensures a non-empty hash is always returned (CRC32). <br><strong>Security:</strong> Macro provider is a trust boundary — if an external macro returns unpredictable values or blocks, the chain's security is reduced. <code>certutil</code> path is only available on Windows environments with certutil in PATH. <br><strong>Recommended tests:</strong> Replace <code>HashProviderMacroName</code> with test double macro to confirm invocation and fallbacks; run on non-Windows machine to enforce CRC32 fallback; test determinism across identical inputs. <br><strong>Notes:</strong> Encourage consumers to provide a cryptographic provider for production (HSM or signed macro) where regulatory compliance requires stronger hashing. The <code>certutil</code> exec uses <code>WScript.Shell.Exec</code> and <code>DoEvents</code> loop — this blocks the thread until completion; beware UI hangs for large payloads. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ComputeSHA256_UsingCertUtil</strong> — <em>Windows certutil-based SHA256</em><br><strong>Purpose:</strong> Compute SHA256 by writing payload to a binary temp file and calling <code>certutil -hashfile &lt;file&gt; SHA256</code>, parsing stdout for the 64-hex digest. Designed as a higher-strength option when available.<br><strong>Signature:</strong> <code>Private Function ComputeSHA256_UsingCertUtil(ByVal s As String) As String</code><br><strong>Behavior:</strong> Determine temp path heuristically (<code>TEMP</code>, workbook path, or userprofile). Compose unique filename, write UTF-8 bytes from <code>StrToUtf8Bytes(s)</code> into file (Binary write). Create <code>WScript.Shell</code> and <code>Exec</code> <code>certutil -hashfile &quot;fname&quot; SHA256</code>. Poll <code>execObj.Status</code> in a <code>DoEvents</code> loop until complete. Read <code>StdOut.ReadAll</code>, kill temp file, parse lines for token with >=64 hex chars, return first 64-char token. On any error returns empty string and deletes tmp file when possible. <br><strong>Complexity:</strong> Dominated by external process runtime and I/O; writing payload to disk is O(len(s)). <br><strong>Side-effects:</strong> Creates temp file; executes external OS command; may block UI until finished. <br><strong>Failure modes:</strong> <code>WScript.Shell</code> unavailable (e.g., in locked-down environments), <code>certutil</code> absent, <code>Exec</code> returns Nothing, or parsing fails. In these cases returns <code>&quot;&quot;</code>. <br><strong>Security/Privacy:</strong> Payload written to disk in cleartext momentarily — treat temp dir carefully and use secure storage when required. Recommend secure temp storage and immediate deletion (module attempts to delete). <br><strong>Tests:</strong> Run on Windows with <code>certutil</code> present; test with varying payload sizes; verify deletion of temp file on normal and exceptional paths. <br><strong>Notes:</strong> Not portable to macOS/Linux. Use only when platform constraints are known. Consider adding an in-memory hashing provider via COM or PowerShell for better portability if required. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>ComputeCRC32String / CRC32Table</strong> — <em>pure-VBA CRC32 fallback</em><br><strong>Purpose:</strong> Deterministic CRC32 hex string fallback when no cryptographic provider is available. Ensures chain can still be computed and verified even in restricted environments.<br><strong>Signatures:</strong> <code>Private Function ComputeCRC32String(ByVal s As String) As String</code> / <code>Private Function CRC32Table() As Long()</code><br><strong>Behavior:</strong> <code>StrToUtf8Bytes</code> converts payload to bytes; CRC computed by standard table-driven algorithm; final value xor'ed and returned as 8-char hex uppercase. <code>CRC32Table</code> builds the 256-entry table. <br><strong>Complexity:</strong> O(len(bytes)). <br><strong>Security:</strong> CRC32 is non-cryptographic; vulnerable to collisions — suitable for tamper-evidence only when combined with environment protections or as last resort. Document this explicitly. <br><strong>Tests:</strong> Validate known vectors, ensure hex formatting <code>Right$(&quot;00000000&quot; &amp; Hex$(crc),8)</code>. <br><strong>Notes:</strong> Keep implementation deterministic across different VBA variants (use Long arithmetic carefully). Consider exposing function for offline verification when cryptographic hashing not required. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>StrToUtf8Bytes</strong> — <em>UTF-8 conversion helper</em><br><strong>Purpose:</strong> Return byte array of UTF-8 encoded string using ADODB.Stream when available; fallback to <code>StrConv</code> when not available.<br><strong>Signature:</strong> <code>Private Function StrToUtf8Bytes(ByVal s As String) As Byte()</code><br><strong>Behavior:</strong> Attempts to create <code>ADODB.Stream</code>, set <code>Type=2</code> (text), <code>Charset=&quot;utf-8&quot;</code>, write text, switch to binary and <code>Read</code> to return bytes. On failure returns <code>StrConv(s, vbFromUnicode)</code> (system code page bytes). <br><strong>Complexity:</strong> O(len(s)). <br><strong>Failure modes:</strong> <code>ADODB.Stream</code> may be unavailable causing fallback to non-UTF8 bytes; this can change hash semantics (UTF-8 vs system code page). <br><strong>Tests:</strong> Test round-trip expected UTF-8 bytes; verify that when ADODB available output length > 0 and matches expected UTF-8 sequences for non-ASCII. <br><strong>Notes:</strong> Hash canonicalization requires consistent UTF-8 encoding; where ADODB not available, document impact on cross-machine verification. Consider packaging a pure-VBA UTF-8 encoder for stricter determinism. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>GetUtcIsoTimestamp / UtcNowForFilename</strong> — <em>UTC timestamp helpers</em><br><strong>Purpose:</strong> Produce consistent ISO8601 UTC timestamps using <code>GetSystemTime</code> Win32 API when available; provide compact filename-safe UTC string too.<br><strong>Signatures:</strong> <code>Private Function GetUtcIsoTimestamp() As String</code> / <code>Private Function UtcNowForFilename() As String</code><br><strong>Behavior:</strong> <code>GetUtcIsoTimestamp</code> calls <code>GetSystemTime</code> (PtrSafe for VBA7) and formats <code>YYYY-MM-DDTHH:MM:SSZ</code>. Fallback uses <code>Now</code> local time formatted and appends <code>Z</code> (less accurate). <code>UtcNowForFilename</code> removes punctuation to create filename-safe string. <br><strong>Complexity:</strong> O(1). <br><strong>Failure modes:</strong> On non-Windows platforms <code>GetSystemTime</code> Windows API may be unavailable; function falls back to <code>Now</code>. <br><strong>Tests:</strong> Verify formatting and that <code>UtcNowForFilename</code> contains no colons or hyphens. <br><strong>Notes:</strong> For strict UTC correctness on non-Windows hosts, consider retrieving UTC via <code>CDate(Format(Now, ...)) - TimeZoneBias</code> if TimeZone known; current fallback is acceptable for many use cases but be explicit in docs. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>RedactSensitiveData</strong> — <em>PII-light redaction engine (regex heuristics)</em><br><strong>Purpose:</strong> Heuristic-based redaction of sensitive tokens (card numbers, SSNs, emails, long tokens, account numbers) from JSON-like text. Designed to be conservative and reduce PII risk before persisting contexts to audit storage or export.<br><strong>Signature:</strong> <code>Private Function RedactSensitiveData(ByVal inputJson As String) As String</code><br><strong>Behavior:</strong> If input empty returns immediately. Uses <code>VBScript.RegExp</code> with a series of global regex replacements: long contiguous digits (13-19) replaced by <code>[REDACTED_NUMBER]</code>, grouped card patterns, SSN patterns, account-number-like patterns, email addresses replaced with <code>[REDACTED_EMAIL]</code>, long token-like base64/hex strings replaced by <code>[REDACTED_TOKEN]</code>. If <code>g_aggressiveRedaction</code> enabled, applies more aggressive patterns for keys like <code>token|apikey|secret|password</code>. Truncates to <code>MAX_CONTEXT_LENGTH</code> if too long. Returns redacted string. <br><strong>Complexity:</strong> O(len(input)) times number of regex passes. <br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Regex false-positives may redact non-sensitive content; false-negatives leave PII in logs. Regex engine variations across hosts may behave differently. <br><strong>Security:</strong> This is heuristic — do not rely on it for compliance-level masking. For highly sensitive environments, require strict schema-based redaction before logging (application-level). <br><strong>Recommended tests:</strong> Provide test corpus with emails, card numbers (with spaces/dashes), SSNs, tokens, account keys, and ensure replacements occur; test <code>g_aggressiveRedaction</code> toggle. <br><strong>Notes:</strong> Keep redaction rules conservative and document limitations to auditors. Consider pluggable redaction function to allow enterprise-specific patterns. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>NewCorrelationId</strong> — <em>GUID/unique id creation</em><br><strong>Purpose:</strong> Create correlation identifiers for events. Uses <code>Scriptlet.TypeLib</code> GUID when available; falls back to pseudo-random timestamp-rand string prefixed <code>IFRS-</code> otherwise.<br><strong>Signature:</strong> <code>Private Function NewCorrelationId() As String</code><br><strong>Behavior:</strong> Attempts to create <code>Scriptlet.TypeLib</code> COM object and uses <code>.Guid</code> with braces stripped. If fails, constructs <code>IFRS-&lt;yyyymmddHHMMSS&gt;-&lt;random&gt;</code> string. <br><strong>Complexity:</strong> O(1). <br><strong>Tests:</strong> Confirm returned string is non-empty and unique across multiple calls; ensure GUID format when <code>Scriptlet.TypeLib</code> available. <br><strong>Notes:</strong> If enterprise requires standard UUID format, prefer to inject a provider macro or use OS-level UUID generator. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>EscapeJson / EscapeCsv / EscapeCsvField / NzValue</strong> — <em>text escaping & defensive helpers</em><br><strong>Purpose:</strong> Helper functions to escape JSON strings, CSV fields, and to coalesce Null/Empty/Errors into safe strings. Used during export and diagnostic report generation. <br><strong>Signatures:</strong> <code>Private Function EscapeJson(ByVal s As String) As String</code> / <code>Private Function EscapeCsv(ByVal s As String) As String</code> / <code>Private Function EscapeCsvField(ByVal s As String) As String</code> / <code>Private Function NzValue(v As Variant) As String</code><br><strong>Behavior:</strong> <code>EscapeJson</code> escapes backslashes, quotes, slashes and normalizes newlines to <code>\n</code>. <code>EscapeCsv</code> doubles internal quotes; <code>EscapeCsvField</code> wraps value in quotes and doubles quotes. <code>NzValue</code> converts Error/Null/Empty to empty string or <code>CStr</code> otherwise. <br><strong>Complexity:</strong> O(len(s)). <br><strong>Tests:</strong> Round-trip tests: ensure CSV fields containing quotes are escaped correctly; JSON escapes correct characters. <br><strong>Notes:</strong> Keep JSON escaping in sync with export and any external consumers. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>CreateAuditMetaSheetIfMissing / UpdateAuditMetaSheet</strong> — <em>observability & small state store</em><br><strong>Purpose:</strong> Provide a <code>VeryHidden</code> meta sheet <code>_IFRS_AuditMeta</code> with small key/value rows (LastFlushUTC, BufferedCount, EnableMetaSheet, AggressiveRedaction) and allow the module to update observability metrics there for administrators.<br><strong>Signatures:</strong> <code>Private Function CreateAuditMetaSheetIfMissing() As Worksheet</code> / <code>Private Sub UpdateAuditMetaSheet()</code><br><strong>Behavior:</strong> Create meta sheet with key/value header and initial rows. <code>UpdateAuditMetaSheet</code> writes <code>LastFlushUTC</code>, <code>BufferedCount</code>, and flag states to rows and keeps sheet <code>VeryHidden</code>. Both functions swallow errors and return <code>Nothing</code>/no-op on failure. <br><strong>Complexity:</strong> O(1). <br><strong>Side-effects:</strong> Adds/updates meta-sheet. <br><strong>Security:</strong> Meta-sheet visibility is <code>VeryHidden</code> but still present in workbook file — treat as sensitive. <br><strong>Tests:</strong> Toggle <code>g_enableMetaSheet</code> and confirm sheet presence and values updated after appends/flush. <br><strong>Notes:</strong> This is purposely minimal; consumers may extend the meta sheet to add additional observability keys. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>Utility time/encoding/diagnostic helpers</strong> — <em>misc helpers used by module</em><br><strong>Purpose:</strong> Misc small helpers: <code>EscapeCsvField</code> used in diagnostics, <code>GetSystemTime</code> declarations for Win32 interop and fallback, <code>UtcNowForFilename</code>. They are implementation primitives used by larger functions.<br><strong>Behavior & Tests:</strong> See calling functions. <br><strong>Notes:</strong> Keep these stable; changes change serialization and thus hash payloads. </td></tr><tr><td data-label="Technical breakdown (modAudit)"> <strong>Maintenance & Integration notes (global)</strong> <br> - <strong>Canonicalization</strong>: Hash correctness depends critically on canonical encoding: order of fields, UTF-8 encoding of payload, and deterministic redaction/truncation. Any change to <code>ComputeEntryHash</code> payload composition, <code>StrToUtf8Bytes</code>, or <code>RedactSensitiveData</code> will break verification across existing audit files. Treat these functions as high-stability APIs and include migration strategy when changing. <br> - <strong>Provider trust boundary</strong>: <code>HashProviderMacroName</code> allows workbook macros to supply hashes. This is a trust boundary — document that external macros may execute arbitrary code; prefer signed macros or a vetted provider. <br> - <strong>Platform portability</strong>: <code>ComputeSHA256_UsingCertUtil</code> requires Windows & <code>certutil</code>; <code>ADODB.Stream</code> may not exist in some hosts leading to <code>StrConv</code> fallback and different byte encodings. If cross-machine verification is required, add a pure-VBA UTF-8 encoder and/or a pure-VBA SHA256 implementation. <br> - <strong>Atomicity & concurrency</strong>: Bulk <code>Range.Value</code> write reduces COM overhead and is atomic from VBA perspective but not atomic across multiple Excel instances. If multiple processes may edit the same workbook concurrently, implement external coordination (file locks) to avoid race conditions. <br> - <strong>Observability</strong>: Module emits small buffered events (<code>FlushStart</code>, <code>FlushFinish</code>, <code>RotateStart</code>, <code>HashProviderUsed</code>, etc.) to aid debugging. These are appended to buffer and flushed like normal entries. <br> - <strong>Security & Compliance</strong>: Redaction is heuristic — should not be relied upon for legal compliance without higher-assurance redaction. Exported CSV/JSON may contain sensitive data and should be protected. <br> - <strong>Performance</strong>: Keep <code>AUDIT_BATCH_FLUSH_THRESHOLD</code> tuned; bulk writes are essential for high-throughput usage. Consider <code>maxParallelFetches</code> equivalent if other modules do heavy IO. <br> - <strong>Testing matrix</strong>: Unit tests should cover: canonicalization and cross-provider hash parity; certutil path; CRC32 fallback; bulk write vs fallback; rotation atomicity; export correctness; VerifyAuditChain detection of tamper; redaction behavior; meta-sheet updates. <br> - <strong>Backwards compatibility</strong>: Public function signatures are intentionally stable. Any breaking changes require bumping integration contracts and migration helpers. </td></tr></tbody></table></div><div class="row-count">Rows: 28</div></div><div class="table-caption" id="Table3" data-table="Docu_0158_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modBootstrap)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modBootstrap)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Overview:</strong> Exhaustive per-function technical breakdown of the <code>modBootstrap</code> VBA module you provided. Each entry documents: purpose, signature, inputs/outputs, internal behaviour, complexity, side-effects, invariants, failure modes, security/privacy considerations, recommended tests, and maintainer notes. Treat this as authoritative inline documentation for reviewers and QA. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_Initialize()</strong> — <em>idempotent entrypoint; schedule deferred init; prepare metadata & feature state</em><br><strong>Purpose:</strong> Called at workbook open to create deterministic bootstrap id, prepare feature dictionaries, ensure metadata persistence sheet, persist initial state, and schedule <code>AddIn_DeferredInit</code> via <code>Application.OnTime</code> in a tolerant, cross-host way.<br><strong>Signature:</strong> <code>Public Sub AddIn_Initialize()</code> — no args, no return.<br><strong>Behavior:</strong> Idempotency check via <code>g_bootstrapInitialized</code>. Records <code>g_bootstrapStartUtc</code> and computes <code>g_bootstrapId</code> using CRC32 of a timestamp + user string. Attempts to create scripting dictionaries for <code>g_disabledFeatures</code> and <code>g_enabledFeatures</code> with <code>CreateObjectSafe</code>. Ensures metadata sheet exists (<code>EnsureMetadataSheetExists</code>) and writes initial meta values. Performs basic environment sanity check (Application.Version) and may disable "core" feature on failure. Schedules deferred init at <code>g_deferredWhen = Now + 1s</code> via <code>Application.OnTime</code>, trying workbook-qualified procedure first (Windows) then unqualified fallback (Mac or when workbook unavailable). Sets <code>g_bootstrapScheduled</code>, <code>g_bootstrapInitialized</code>, and logs via <code>Bootstrap_Audit</code>. Uses structured error-handling and forwards errors to <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(1) runtime; a few COM creations. Scheduling is O(1).<br><strong>Side-effects:</strong> Creates metadata sheet, writes persistent metadata entries, modifies module-level state, schedules OnTime jobs, writes audit rows (local or remote).<br><strong>Invariants:</strong> Sets <code>g_bootstrapInitialized = True</code> on successful call (idempotent). <code>g_bootstrapId</code> persists if non-empty. <code>g_deferredWhen</code> contains scheduled time when scheduling succeeded.<br><strong>Failure modes:</strong> <code>Application.OnTime</code> may fail (workbook unavailable, Mac restrictions); <code>CreateObject</code> may fail (no Scripting.Dictionary); metadata sheet creation can be prevented by protected workbook or insufficient permissions. All failures are handled best-effort and audited. If scheduling fails completely, <code>g_bootstrapScheduled</code> is False and bootstrap is still considered initialized. <br><strong>Security/Privacy:</strong> Does not store secrets here; writes masked markers for sensitive keys later. Computes checksum-based id (not cryptographically secure).<br><strong>Recommended tests:</strong> Run on Windows and Mac host emulators; simulate workbook unavailable; validate bootstrap id written to metadata; assert idempotency by running twice; verify OnTime scheduled (mock or inspect OnTime calls).<br><strong>Notes for maintainers:</strong> Preserve public signature. Avoid changing id format without migration because other modules may read <code>BootstrapId</code>. Keep workbook-qualified scheduling for Windows for determinism. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_DeferredInit()</strong> — <em>deferred startup: capability snapshot, config load/migrate, warm-up services, optional self-test</em><br><strong>Purpose:</strong> Runs after <code>AddIn_Initialize</code> (via OnTime) to probe dependencies, attempt safe config load and migration, warm-up lightweight modules, optionally run startup self-tests, persist final bootstrap state and diagnostics, and audit timings.<br><strong>Signature:</strong> <code>Public Sub AddIn_DeferredInit()</code> — no args, no return.<br><strong>Behavior:</strong> Ensures <code>g_bootstrapInitialized</code> true, calls <code>AddIn_EnsureDependencies()</code> to build capability snapshot and persist it. Uses <code>SafeRun</code> and <code>SafeRunWithResult</code> to call <code>Config_Load</code>, <code>Config_MigrateIfNeeded</code> and other modules (<code>modAudit_Init</code>, <code>modUtilities_Init</code>) in a non-fatal manner. Reads <code>run_selftest_on_start</code> flag from <code>Config_Get</code> and conditionally calls <code>AddIn_SelfTestStartup</code>. On success writes <code>PersistBootstrapState &quot;finished&quot;,&quot;ok&quot;</code>, records <code>DeferredInitDurationSeconds</code> and audit messages. On any error it calls <code>Bootstrap_HandleError</code>, persists <code>&quot;finished&quot;,&quot;partial&quot;</code> and clears scheduled flag. Idempotent-safe (sets <code>g_bootstrapInitialized</code> if not set).<br><strong>Complexity:</strong> O(1) for orchestration; cost depends on invoked SafeRun targets (IO, config parse).<br><strong>Side-effects:</strong> Calls other modules (config, audit, utilities), may alter configuration via migration, writes metadata and audit rows, starts additional module-level initialization side-effects.<br><strong>Invariants:</strong> If successful, final persisted bootstrap state reflects <code>&quot;finished&quot; : &quot;ok&quot;</code>. The <code>DeferredInitDurationSeconds</code> is set to wall-clock seconds of the run. <code>g_bootstrapScheduled</code> should be set to False at end.<br><strong>Failure modes:</strong> <code>SafeRun</code> calls may be unavailable or throw; <code>Config_Get</code> may return Empty and be interpreted as False. Long-running migrations risk blocking UI if host is sensitive. Self-test may return failures — flagged and cause feature disable for <code>selftest</code> if failing. Errors are logged and handled gracefully.<br><strong>Security/Privacy:</strong> Config migration and loads may touch sensitive data — <code>WriteMetaValue</code> redacts sensitive keys. Ensure <code>Config_*</code> implementations also respect redaction.<br><strong>Recommended tests:</strong> Simulate <code>Config_Load</code> present/missing; simulate failing <code>Config_MigrateIfNeeded</code>; verify <code>DeferredInitDurationSeconds</code> written; verify that an unavailable <code>modAudit_Init</code> is tolerated and logged; test self-test true/false paths.<br><strong>Notes for maintainers:</strong> Keep SafeRun usage; avoid turning <code>AddIn_DeferredInit</code> into a heavy synchronous block — if you add heavy tasks, consider splitting into smaller safe-run steps. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_Shutdown()</strong> — <em>idempotent shutdown / cancel scheduled jobs / final persistence</em><br><strong>Purpose:</strong> Clean shutdown entrypoint: cancel OnTime schedule, persist shutdown state, and log audit row.<br><strong>Signature:</strong> <code>Public Sub AddIn_Shutdown()</code> — no args, no return.<br><strong>Behavior:</strong> Calls <code>TryCancelOnTime</code> (which tries both workbook-qualified and unqualified cancellation) to cancel scheduled <code>AddIn_DeferredInit</code> and swallows errors. Sets <code>g_bootstrapScheduled = False</code>, persists <code>PersistBootstrapState &quot;shutdown&quot;,&quot;&quot;</code>, and logs via <code>Bootstrap_Audit</code>. Errors forwarded to <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes to metadata, cancels scheduled OnTime events, writes audit rows.<br><strong>Invariants:</strong> After run <code>g_bootstrapScheduled</code> false and metadata contains <code>&quot;BootstrapLastStatus&quot; = &quot;shutdown&quot;</code>.<br><strong>Failure modes:</strong> OnTime cancel may fail if original time or proc name mismatched; workbook closed; errors are logged but shutdown remains best-effort.<br><strong>Security/Privacy:</strong> No special concerns.<br><strong>Recommended tests:</strong> Schedule AddIn_DeferredInit, call AddIn_Shutdown and assert OnTime is cancelled; call shutdown multiple times to assert idempotency. <br><strong>Notes:</strong> Keep cancellation tolerant to host differences; do not rely solely on <code>g_bootstrapScheduled</code> flag for cancellation. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_IsInitialized()</strong> — <em>query</em><br><strong>Purpose:</strong> Return bootstrap initialization boolean for external callers.<br><strong>Signature:</strong> <code>Public Function AddIn_IsInitialized() As Boolean</code> → returns module-level <code>g_bootstrapInitialized</code>.<br><strong>Behavior:</strong> Simple accessor.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Mirrors internal state. <br><strong>Failure modes:</strong> None.<br><strong>Tests:</strong> Toggle <code>g_bootstrapInitialized</code> and verify return value. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_GetState()</strong> — <em>return bootstrap state snapshot as Scripting.Dictionary</em><br><strong>Purpose:</strong> Provide external callers with a snapshot object containing bootstrapId, startUtc, scheduled flag, enabled/disabled feature lists.<br><strong>Signature:</strong> <code>Public Function AddIn_GetState() As Object</code> → returns <code>Scripting.Dictionary</code> or <code>Nothing</code> on failure.<br><strong>Behavior:</strong> Creates a <code>Scripting.Dictionary</code> via <code>CreateObjectSafe</code> and populates keys: <code>bootstrapId</code>, <code>startUtc</code>, <code>scheduled</code>, <code>enabledFeatures</code> (array from dict safe), <code>disabledFeatures</code> (array with values). If dictionary creation fails returns <code>Nothing</code>. Errors handled via <code>Bootstrap_HandleError</code> and returns <code>Nothing</code> on exceptions.<br><strong>Complexity:</strong> O(Nfeatures) to produce arrays.<br><strong>Side-effects:</strong> None persistent; creates transient COM object.<br><strong>Invariants:</strong> Arrays produced are safe-cloned snapshots (not live refs). If dictionaries are missing returns empty arrays.<br><strong>Failure modes:</strong> COM unavailable → returns <code>Nothing</code>. <br><strong>Tests:</strong> With feature dicts populated, verify structure and content. <br><strong>Notes:</strong> Keep return shape stable for consumers. Consider switching to a VBA <code>Collection</code> only if consumers cannot handle Scripting.Dictionary. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_SelfTestStartup()</strong> — <em>repeated lightweight self-test harness used optionally at start-up</em><br><strong>Purpose:</strong> Run repeated sanity checks (dependency availability and TestRunner) to surface bootstrap-level issues early, but treat many failures as benign. Designed to run in a loop (10 iterations) to detect intermittent issues.<br><strong>Signature:</strong> <code>Public Function AddIn_SelfTestStartup() As Boolean</code> → returns Boolean success summary.<br><strong>Behavior:</strong> Loops 10 iterations; each iteration calls <code>AddIn_EnsureDependencies()</code> and expects <code>coreAvailable</code> true. Also calls <code>TestRunner_SelfTest</code> via <code>SafeRunWithResult</code> if available (otherwise treats missing TestRunner as benign). Uses <code>DoEvents</code> to yield. Collects boolean <code>ok</code> and audits result. On error forwards to <code>Bootstrap_HandleError</code> and returns False.<br><strong>Complexity:</strong> O(iterations * cost of dependency checks). Each iteration is O(1) unless dependencies are heavy.<br><strong>Side-effects:</strong> Calls <code>AddIn_EnsureDependencies</code> which persists capability snapshot; logs audit. May mark <code>ok</code> false on failures.<br><strong>Invariants:</strong> Deterministic: 10 cycles as written. Returns True only if all checks passed deemed essential.<br><strong>Failure modes:</strong> False negatives if TestRunner missing (treated benign); intermittent dependencies may transiently fail. On exception returns False and logs. <br><strong>Security:</strong> None special.<br><strong>Recommended tests:</strong> Force <code>AddIn_EnsureDependencies</code> to return incomplete capabilities; simulate TestRunner returning false; verify function returns false and audit logged. <br><strong>Notes:</strong> Conservative: avoids failing bootstrap on missing TestRunner. If this function becomes heavy, consider reducing iterations or splitting into async checks. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_EnableFeature(featureName As String)</strong> — <em>enable feature (in-memory + persist)</em><br><strong>Purpose:</strong> Mark a feature enabled in <code>g_enabledFeatures</code> and remove from <code>g_disabledFeatures</code>. If dictionaries unavailable, persists a pending marker to metadata for later reconciliation.<br><strong>Signature:</strong> <code>Public Sub AddIn_EnableFeature(ByVal featureName As String)</code> — no return.<br><strong>Behavior:</strong> Ensures dictionaries exist (best-effort via <code>CreateObjectSafe</code>). If dictionaries unavailable writes <code>FeatureEnablePending</code> meta key. Otherwise removes feature from disabled and sets enabled=true in the enabled dictionary. Calls <code>PersistBootstrapState</code> to persist records. Errors forwarded to <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates in-memory dicts and writes metadata. <br><strong>Invariants:</strong> <code>g_enabledFeatures</code> contains featureName with True and <code>g_disabledFeatures</code> does not.<br><strong>Failure modes:</strong> Dictionaries unavailable; metadata write failure. Both are best-effort and recorded. <br><strong>Tests:</strong> Toggle enable/disable sequences; confirm metadata entries and in-memory dictionaries align. <br><strong>Notes:</strong> Keep feature name length bounded (persist uses Left$(…,256)). </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_DisableFeature(featureName As String, reason As String)</strong> — <em>disable feature with reason (in-memory + persist)</em><br><strong>Purpose:</strong> Mark a feature disabled (and store reason string) and remove from enabled dict. If dictionaries missing, persist pending disable marker to metadata.<br><strong>Signature:</strong> <code>Public Sub AddIn_DisableFeature(ByVal featureName As String, ByVal reason As String)</code> — no return.<br><strong>Behavior:</strong> Ensures dictionaries exist via <code>CreateObjectSafe</code>. If unavailable writes <code>FeatureDisablePending</code> meta key combining featureName and reason. Otherwise removes feature from enabledFeatures and writes featureName→reason in disabledFeatures. Persists via <code>PersistBootstrapState</code> with <code>feature_disabled</code> note including reason. Errors handled.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates dicts and metadata.<br><strong>Invariants:</strong> <code>g_disabledFeatures(featureName)</code> exists with truncated reason ≤256 chars. <code>g_enabledFeatures</code> does not contain it.<br><strong>Failure modes:</strong> Missing dictionary; metadata writes fail. <br><strong>Tests:</strong> Disable feature with long reason; assert truncated reason saved and marker present. <br><strong>Notes:</strong> Use this to gate features at runtime; ensure consumers check disabled dict before using optional APIs. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_EnsureDependencies()</strong> — <em>build & persist capability snapshot</em><br><strong>Purpose:</strong> Probe host capabilities and COM availability (FSO, ADODB.Stream, WScript), signature accessibility, host OS, and produce a <code>Scripting.Dictionary</code> snapshot persisted via <code>PersistCapabilitySnapshot</code> and returned to caller.<br><strong>Signature:</strong> <code>Public Function AddIn_EnsureDependencies() As Object</code> → returns <code>Scripting.Dictionary</code> (or Nothing on fatal error).<br><strong>Behavior:</strong> Attempts <code>CreateObjectSafe(&quot;Scripting.FileSystemObject&quot;)</code>, <code>CreateObjectSafe(&quot;ADODB.Stream&quot;)</code>, and <code>CreateObjectSafe(&quot;WScript.Shell&quot;)</code>. Checks <code>ThisWorkbook.Signatures.Count</code> in a guarded <code>On Error</code> block (handles host differences). Sets <code>excelVersion</code>, <code>coreAvailable</code> true, <code>hostOperatingSystem</code>, <code>isMac</code>. Calls <code>PersistCapabilitySnapshot</code> to write a serialized (k=v;) string to metadata. Returns dictionary.<br><strong>Complexity:</strong> O(1) COM creations. <br><strong>Side-effects:</strong> Writes LastCapabilitySnapshot metadata. <br><strong>Invariants:</strong> Returned dictionary contains boolean flags for key capabilities; persisted string limited to 1024 characters. <br><strong>Failure modes:</strong> COM instantiation fails → flags false; workbook unavailability prevents signature checks. Such failures are expected on constrained hosts and are handled gracefully. <br><strong>Security:</strong> None beyond normal. <br><strong>Tests:</strong> Run in environment variations: normal Windows Excel, protected workbook, Mac host, remove ADODB.Stream registration; verify flags reflect environment. <br><strong>Notes:</strong> Keep this function cheap and side-effect-limited. Avoid heavy probing. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>PersistBootstrapState(status As String, note As String)</strong> — <em>write a set of bootstrap metadata keys to metadata sheet</em><br><strong>Purpose:</strong> Centralized metadata persistence for bootstrap lifecycle: id, start time, last status, note, last updated timestamp, and feature list serialization.<br><strong>Signature:</strong> <code>Private Sub PersistBootstrapState(ByVal status As String, ByVal note As String)</code> — no return.<br><strong>Behavior:</strong> Calls <code>EnsureMetadataSheetExists()</code>. Writes <code>BootstrapId</code>, <code>BootstrapStartUtc</code>, <code>BootstrapLastStatus</code>, <code>BootstrapLastNote</code>, <code>BootstrapLastUpdated</code>. Serializes enabled & disabled arrays (via helper functions) and writes <code>EnabledFeatures</code>, <code>DisabledFeatures</code> truncated to 1024 chars. Uses <code>WriteMetaValue</code> for each key. Error handling via <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(Nfeatures).<br><strong>Side-effects:</strong> Mutates metadata worksheet rows, may create sheet. <br><strong>Invariants:</strong> Key names consistent; values truncated to safe sizes. <br><strong>Failure modes:</strong> Worksheet creation or write may fail on protected workbooks or missing permissions. Failures logged via <code>Bootstrap_HandleError</code>. <br><strong>Security:</strong> Uses <code>WriteMetaValue</code> which redacts sensitive keys. <br><strong>Tests:</strong> Populate feature dicts and call persist; verify sheet values and truncation. <br><strong>Notes:</strong> Keep truncation rules aligned with other consumers. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>PersistCapabilitySnapshot(dict As Object)</strong> — <em>write capability serialized string to metadata</em><br><strong>Purpose:</strong> Convert capability dictionary into small serialized string and write <code>LastCapabilitySnapshot</code> and <code>LastCapabilitySnapshotUpdated</code> keys.<br><strong>Signature:</strong> <code>Private Sub PersistCapabilitySnapshot(ByVal dict As Object)</code> — no return.<br><strong>Behavior:</strong> Iterates dict keys building <code>key=value;</code> pairs up to 1024 chars, writes via <code>WriteMetaValue</code>. Errors logged to Debug.Print and swallowed to avoid breaking bootstrap. <br><strong>Complexity:</strong> O(Nkeys).<br><strong>Side-effects:</strong> Writes metadata. <br><strong>Invariants:</strong> Snapshot truncated to 1024 chars. <br><strong>Failure modes:</strong> Write failure is non-fatal and logged. <br><strong>Tests:</strong> Build dict of capabilities and call; inspect metadata. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>WriteMetaValue(key As String, value As String)</strong> — <em>persist a metadata key/value in metadata sheet; redact sensitive keys</em><br><strong>Purpose:</strong> Single place to write metadata with redaction logic, row lookup, create or update semantics, and size truncation. Adds sensitive key markers when necessary.<br><strong>Signature:</strong> <code>Private Sub WriteMetaValue(ByVal key As String, ByVal value As String)</code> — no return.<br><strong>Behavior:</strong> Ensures metadata sheet exists, truncates value to 2048 chars, checks <code>IsSensitiveKey(key)</code> and if sensitive replaces stored value tail with <code>[REDACTED]</code> and records the key via <code>AddSensitiveKeyMarker</code>. Locates key via <code>Find</code> on column 1; if found updates column2; else appends a new row (never overwrites header row). Uses On Error guards and logs to audit on failure. <br><strong>Complexity:</strong> O(number of rows) due to <code>.Find</code> usage (fast in Excel). <br><strong>Side-effects:</strong> Mutates metadata sheet rows, may create rows and change visible properties. <br><strong>Invariants:</strong> Sensitive keys not written raw in full; <code>SensitiveKeys</code> list contains the key summary. <br><strong>Failure modes:</strong> <code>.Find</code> may throw on unusual worksheets; write operations may be blocked by protection; function logs failures to audit. <br><strong>Security/Privacy:</strong> Central redaction strategy; ensure <code>IsSensitiveKey</code> covers all secret patterns. <br><strong>Recommended tests:</strong> Test key insertion/update for normal key and sensitive key; verify <code>SensitiveKeys</code> list and redaction text. <br><strong>Notes:</strong> This is critical for PII/secret safety. Keep size truncation conservative. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ReadMetaValue(key As String) As String</strong> — <em>read persisted value from metadata sheet</em><br><strong>Purpose:</strong> Safely read a meta key from metadata sheet and return its string value (or empty string when missing or on error).<br><strong>Signature:</strong> <code>Private Function ReadMetaValue(ByVal key As String) As String</code> → string.<br><strong>Behavior:</strong> Calls <code>EnsureMetadataSheetExists()</code>, uses <code>.Find</code> in column 1 and returns column2 value if found. Errors return empty string. Uses <code>On Error</code> guards.<br><strong>Complexity:</strong> O(1) average (Find).<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Sheet missing → returns empty string; <code>.Find</code> errors swallowed. <br><strong>Tests:</strong> Write keys and read them back; test missing key returns empty. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>EnsureMetadataSheetExists() As Worksheet</strong> — <em>create or return the metadata worksheet; hide it</em><br><strong>Purpose:</strong> Guarantee the presence of a hidden metadata worksheet with header row and safe name; create with robust fallback name strategy and mark as VeryHidden when possible.<br><strong>Signature:</strong> <code>Private Function EnsureMetadataSheetExists() As Worksheet</code> → Worksheet or Nothing on failure.<br><strong>Behavior:</strong> Attempts to access <code>ThisWorkbook.Worksheets(&quot;_IFRS_Metadata&quot;)</code> (guarded for workbook-unavailable). If not present and workbook available it adds a new worksheet at end, attempts to name it <code>_IFRS_Metadata</code> and, if that fails, append a timestamp suffix. Attempts to set <code>Visible = xlSheetVeryHidden</code> with fallback numeric constant <code>2</code> if constant unsupported. Ensures header cells "Key" and "Value" are in row 1. Returns Worksheet object. Errors write Debug.Print and return Nothing if workbook unavailable.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May add worksheet and set visibility.<br><strong>Invariants:</strong> Returned sheet has headers in row 1. <br><strong>Failure modes:</strong> Workbook unavailable or protected workbook preventing sheet creation. Function returns Nothing in that case. <br><strong>Security:</strong> Sheet is made VeryHidden to reduce user tampering. <br><strong>Tests:</strong> Call from workbook with and without existing metadata sheet; simulate inability to rename; check visibility flags. <br><strong>Notes:</strong> Keep name constant in source; if you change <code>METADATA_SHEET_NAME</code>, update consumers. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ArrayFromDictSafe(dict As Object) As Variant</strong> — <em>convert dictionary keys → array safely</em><br><strong>Purpose:</strong> Produce array of keys from a Scripting.Dictionary, defensively handling Nothing and exceptions.<br><strong>Signature:</strong> <code>Private Function ArrayFromDictSafe(ByVal dict As Object) As Variant</code> → Variant array (or empty Array on failure).<br><strong>Behavior:</strong> If <code>dict</code> is Nothing or <code>dict.Count=0</code> returns empty array. Otherwise ReDims string array of size dict.Count and iterates keys into array. Errors return empty array.<br><strong>Complexity:</strong> O(N).<br><strong>Side-effects:</strong> None.<br><strong>Failure modes:</strong> COM exceptions → returns empty. <br><strong>Tests:</strong> Pass non-empty dict, empty, and Nothing and assert outputs. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ArrayFromDictWithValuesSafe(dict As Object) As Variant</strong> — <em>convert dictionary key/value → "k=v" array safely</em><br><strong>Purpose:</strong> Like previous, but returns <code>key=value</code> strings for each entry.<br><strong>Signature:</strong> <code>Private Function ArrayFromDictWithValuesSafe(ByVal dict As Object) As Variant</code> → Variant array.<br><strong>Behavior:</strong> Similar guard logic; builds arr(i) = key & "=" & dict(key). Uses On Error guards. <br><strong>Complexity:</strong> O(N).<br><strong>Tests:</strong> Verify for typical dictionary. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeJoinArray(arr As Variant, sep As String) As String</strong> — <em>join array defensively</em><br><strong>Purpose:</strong> Safe wrapper around <code>Join</code> that checks for array-ness and bounds to avoid runtime errors on empty arrays.<br><strong>Signature:</strong> <code>Private Function SafeJoinArray(ByVal arr As Variant, ByVal sep As String) As String</code> → string.<br><strong>Behavior:</strong> If <code>IsArray(arr)</code> and length >0 returns <code>Join(arr, sep)</code> else returns empty string. Exceptions return empty string. <br><strong>Complexity:</strong> O(N total string length).<br><strong>Tests:</strong> array, empty array, non-array inputs. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeString(v As Variant) As String</strong> — <em>defensive variant→string normalization</em><br><strong>Purpose:</strong> Convert variant to string safely: treat Error/Null/Empty as empty string; otherwise CStr.<br><strong>Signature:</strong> <code>Private Function SafeString(ByVal v As Variant) As String</code> → string.<br><strong>Behavior:</strong> On Error Resume Next, checks <code>IsError</code>, <code>IsNull</code>, <code>IsEmpty</code> and returns <code>&quot;&quot;</code> for those; else <code>CStr</code>. Clears Err afterwards. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Provide Error, Null, Empty, numeric, string. <br><strong>Notes:</strong> Use widely to avoid propagation of variant errors to callers. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>IsThisWorkbookUnavailable() As Boolean</strong> — <em>safe check whether ThisWorkbook is accessible</em><br><strong>Purpose:</strong> Detect hosts or contexts where <code>ThisWorkbook</code> throws when accessed (protected host, VSTO edge cases), returning True if unavailable.<br><strong>Signature:</strong> <code>Private Function IsThisWorkbookUnavailable() As Boolean</code> → Boolean.<br><strong>Behavior:</strong> Tries <code>Set tmp = ThisWorkbook</code> under On Error; if Err.Number<>0 or tmp is Nothing returns True; else False. Clears Err and releases tmp. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Run in contexts where ThisWorkbook accessible and in Office host tests where it deliberately throws. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>TruncateForAudit(s As String, Optional maxLen As Long = 512) As String</strong> — <em>truncate long messages for audit storage</em><br><strong>Purpose:</strong> Truncate strings for audit/logging to prevent runaway cells and keep logs readable.<br><strong>Signature:</strong> <code>Private Function TruncateForAudit(ByVal s As String, Optional ByVal maxLen As Long = 512) As String</code> → string.<br><strong>Behavior:</strong> If length <= maxLen returns s; else returns Left$(s, maxLen-3) & "...". Uses SafeString wrapper. <br><strong>Complexity:</strong> O(len(s)).<br><strong>Tests:</strong> Strings around the boundary. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CRC32_String(s As String) As Long</strong> — <em>CRC32 checksum helper (byte-wise over UTF-8 bytes)</em><br><strong>Purpose:</strong> Compute a CRC32-style checksum from a string for deterministic id creation (non-crypto). Uses lazy-initialized CRC table (<code>EnsureCRC32Table</code>).<br><strong>Signature:</strong> <code>Private Function CRC32_String(ByVal s As String) As Long</code> → Long (32-bit masked).<br><strong>Behavior:</strong> If input empty returns 0. Calls <code>EnsureCRC32Table</code> to initialize <code>CRC_TABLE</code> lazily. Converts <code>s</code> to bytes via <code>StrConv(..., vbFromUnicode)</code> (UTF-16→byte sequence in host code page), iterates bytes and updates <code>crc</code> using lookup. Returns final CRC masked as 32-bit unsigned integer. <br><strong>Complexity:</strong> O(len(bytes)).<br><strong>Side-effects:</strong> Initializes CRC_TABLE on first call. <br><strong>Failure modes:</strong> Very long strings may loop long but expected safe. Behavior depends on <code>StrConv</code> encoding specifics per host. <br><strong>Security:</strong> Not cryptographic; do not use for secrets hashing. <br><strong>Tests:</strong> Validate known vector and internal table initialization. Example test: <code>CRC32_String(&quot;The quick brown fox&quot;)</code> non-zero. <br><strong>Notes:</strong> Keep table consistent if migrating to other languages; small endian/byte mapping details matter when comparing cross-platform. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>EnsureCRC32Table()</strong> — <em>initialize CRC_TABLE once</em><br><strong>Purpose:</strong> Populate <code>CRC_TABLE(0..255)</code> with polynomial <code>0xEDB88320</code> algorithm and set <code>CRC_TABLE_INIT = True</code>.<br><strong>Signature:</strong> <code>Private Sub EnsureCRC32Table()</code> — no return.<br><strong>Behavior:</strong> ReDim CRC_TABLE and compute values; sets <code>CRC_TABLE_INIT</code> to True. Idempotent-check at top. <br><strong>Complexity:</strong> O(256 * 8) = O(1).<br><strong>Notes:</strong> Keep as private to avoid external dependency. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>HexFromLong(l As Long) As String</strong> — <em>format helper to 8-digit hex string</em><br><strong>Purpose:</strong> Return 8-character zero-padded uppercase hex string for a 32-bit Long value.<br><strong>Signature:</strong> <code>Private Function HexFromLong(ByVal l As Long) As String</code> → string.<br><strong>Behavior:</strong> Masks with <code>&amp;HFFFFFFFF</code> and formats with <code>Hex$</code>, pads to 8 characters rightmost. <code>On Error Resume Next</code> guard. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Border cases for negative/large Longs. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Bootstrap_Audit(action As String, message As String)</strong> — <em>audit dispatcher: Try remote AUDIT_PROC_NAME via SafeRun, fallback to local audit sheet</em><br><strong>Purpose:</strong> Central audit call for bootstrap actions. Attempts to call remote audit procedure (<code>LogAudit</code>) via <code>SafeRunWithResult</code>; if remote call returns non-empty then treat as handled. Else append to local audit sheet via <code>AppendLocalAudit</code>.<br><strong>Signature:</strong> <code>Private Sub Bootstrap_Audit(ByVal action As String, ByVal message As String)</code> — no return.<br><strong>Behavior:</strong> Composes string <code>bootstrapId | action | truncated message</code>. Calls <code>SafeRunWithResult(AUDIT_PROC_NAME, action, composed)</code> and if non-empty returns. Otherwise appends to local audit sheet via <code>AppendLocalAudit</code>. Errors printed to Debug.Print. <br><strong>Complexity:</strong> O(1) plus cost of <code>SafeRunWithResult</code>. <br><strong>Side-effects:</strong> May call external module or mutate audit sheet. <br><strong>Invariants:</strong> If remote audit handler exists and returns non-empty, local append is skipped. <br><strong>Failure modes:</strong> Remote audit may be absent; local audit sheet may be uncreatable — errors logged to Immediate window. <br><strong>Security:</strong> Audit messages are truncated and should avoid storing PII. <br><strong>Tests:</strong> Mock remote audit procedure to return non-empty and verify no local append; remove remote procedure and verify local audit appended. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CallSafeRunAudit(action, message)</strong> — <em>best-effort non-blocking fire of audit via SafeRun</em><br><strong>Purpose:</strong> Convenience wrapper calling <code>SafeRun AUDIT_PROC_NAME</code> and ignoring errors. Used when audit should not block bootstrap.<br><strong>Signature:</strong> <code>Private Sub CallSafeRunAudit(ByVal action As String, ByVal message As String)</code> — no return.<br><strong>Behavior:</strong> <code>On Error Resume Next</code> then <code>SafeRun AUDIT_PROC_NAME, action, truncated message</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Use when audit failure is non-critical. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AppendLocalAudit(message As String)</strong> — <em>append an audit row to local <code>_IFRS_Audit</code> sheet</em><br><strong>Purpose:</strong> Fallback audit target when remote audit not available. Ensures sheet exists (creates hidden sheet if needed) and appends timestamp, user, message, bootstrapId with headers.<br><strong>Signature:</strong> <code>Private Sub AppendLocalAudit(ByVal message As String)</code> — no return.<br><strong>Behavior:</strong> Creates/gets <code>_IFRS_Audit</code> worksheet, ensures headers for Timestamp, User, Message, bootstrapId, appends new row with current timestamp, Application.UserName, truncated message, and current <code>g_bootstrapId</code>. Uses On Error guards; if sheet creation fails silently exits. <br><strong>Complexity:</strong> O(1) row append. <br><strong>Side-effects:</strong> Creates/updates audit worksheet. <br><strong>Failure modes:</strong> Sheet creation may fail; function exits silently in that case. <br><strong>Security/Privacy:</strong> Audit sheet may contain PII (UserName); store only what's necessary; ensure workbook-level protections if required. <br><strong>Tests:</strong> Validate header creation and row append; test behavior when workbook unavailable. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Bootstrap_HandleError(procName As String, errNum As Long, errDesc As String)</strong> — <em>centralized error forwarding with SafeRun forwarding and fallback to local audit</em><br><strong>Purpose:</strong> Centralize error handling: attempt to forward errors to a centralized error handler (<code>HandleError</code>) via <code>SafeRunWithResult</code>; if error handler handled it (non-empty result) then return; else append a local audit entry and Debug.Print the error.<br><strong>Signature:</strong> <code>Private Sub Bootstrap_HandleError(ByVal procName As String, ByVal errNum As Long, ByVal errDesc As String)</code> — no return.<br><strong>Behavior:</strong> Composes <code>proc=.. | err=.. | msg=..</code> payload. Calls <code>SafeRunWithResult(ERROR_PROC_NAME, procName, errNum, truncated errDesc)</code> and if not Empty returns. Else falls back to Debug.Print and <code>AppendLocalAudit &quot;Error|proc:err|desc&quot;</code>. <code>On Error</code> guards ensure this function never raises further exceptions. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call external error handler or write local audit row. <br><strong>Invariants:</strong> Does not throw. <br><strong>Failure modes:</strong> Remote error handler may be absent; fallback must succeed. <br><strong>Tests:</strong> Simulate remote <code>HandleError</code> presence and absence and ensure fallback. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeRun(procName As String, ParamArray args() As Variant) As Boolean</strong> — <em>robust Application.Run wrapper (no result expected)</em><br><strong>Purpose:</strong> Safely call an external procedure by attempting workbook-qualified first (on Windows) and falling back to unqualified procedure. Handles up to 9 args. Returns True if call succeeded (no error), otherwise False. Non-fatal design for optional handlers.<br><strong>Signature:</strong> <code>Private Function SafeRun(ByVal procName As String, ParamArray args() As Variant) As Boolean</code> → Boolean.<br><strong>Behavior:</strong> If <code>procName</code> empty returns False. If not <code>IsMac</code> and <code>ThisWorkbook</code> available attempts <code>CallRunWithArgs</code> with <code>&quot;&#x27;ThisWorkbookName&#x27;!proc&quot;</code>. If that fails tries unqualified <code>procName</code>. Uses <code>On Error</code> to detect success. Returns boolean success. <br><strong>Complexity:</strong> O(1) plus cost of invoked proc. <br><strong>Side-effects:</strong> May execute arbitrary public procedures in workbook (side-effects depend on those procs). <br><strong>Invariants:</strong> Returns true only when a call completes without error. <br><strong>Failure modes:</strong> Application.Run can error when proc missing or has different signature; SafeRun catches and returns False. <br><strong>Security:</strong> Calling arbitrary code—callers must trust invoked procedure. Avoid using with user-controlled proc names. <br><strong>Tests:</strong> Call existing and non-existing procedure; verify behavior on Mac/Windows. <br><strong>Notes:</strong> Supports up to the first 9 params explicitly. If you expect more args, extend the dispatcher. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>SafeRunWithResult(procName As String, ParamArray args() As Variant) As Variant</strong> — <em>Application.Run wrapper returning result or Empty</em><br><strong>Purpose:</strong> Like <code>SafeRun</code> but expects and returns a result from <code>Application.Run</code> or <code>Empty</code> on failure. Tries workbook-qualified first (not on Mac) then unqualified. Handles errors and returns <code>Empty</code> on failure.<br><strong>Signature:</strong> <code>Private Function SafeRunWithResult(ByVal procName As String, ParamArray args() As Variant) As Variant</code> → Variant or Empty.<br><strong>Behavior:</strong> Attempts qualified/unqualified <code>CallRunWithArgsWithResult</code>. On error returns Empty. <br><strong>Complexity:</strong> O(1) plus cost of invoked proc. <br><strong>Side-effects:</strong> Executes remote procedure. <br><strong>Tests:</strong> Call known function returning value; call missing proc -> returns Empty. <br><strong>Notes:</strong> Use when remote API may return information; always check <code>IsEmpty</code> before CBool conversions. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CallRunWithArgs(proc As String, args() As Variant)</strong> — <em>explicit Application.Run arg dispatcher (no result)</em><br><strong>Purpose:</strong> Dispatch <code>Application.Run</code> calls with explicit cases for 0..9 arguments to avoid runtime argument array issues and limit risk of late-binding errors.<br><strong>Signature:</strong> <code>Private Sub CallRunWithArgs(ByVal proc As String, ByVal args() As Variant)</code> — no return.<br><strong>Behavior:</strong> Counts args using <code>ParamCount</code> and uses <code>Select Case</code> to call <code>Application.Run proc[,args...]</code> with appropriate explicit parameter count. For >9 args passes first 9 only (documented). Uses <code>On Error Resume Next</code> in the dispatch. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> This dispatcher intentionally caps at 9 args to remain simple and predictable. If you rely on vararg > 9, update carefully and test. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CallRunWithArgsWithResult(proc As String, args() As Variant) As Variant</strong> — <em>explicit Application.Run dispatcher returning result</em><br><strong>Purpose:</strong> Same as <code>CallRunWithArgs</code> but returns value from <code>Application.Run</code>, with guard for Err.Number to return Empty on error.<br><strong>Signature:</strong> <code>Private Function CallRunWithArgsWithResult(ByVal proc As String, ByVal args() As Variant) As Variant</code> → Variant.<br><strong>Behavior:</strong> Dispatches <code>Application.Run</code> per <code>ParamCount</code> and sets <code>CallRunWithArgsWithResult = Application.Run(...)</code>. If <code>Err.Number &lt;&gt; 0</code> sets result Empty and clears error. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Verify with procs that return primitives and objects. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>ParamCount(args() As Variant) As Long</strong> — <em>safe ParamArray length helper</em><br><strong>Purpose:</strong> Return number of elements passed in a ParamArray while guarding against Empty/UBound errors.<br><strong>Signature:</strong> <code>Private Function ParamCount(ByVal args() As Variant) As Long</code> → Long.<br><strong>Behavior:</strong> If <code>Not IsEmpty(args)</code> attempts <code>UBound-LBound+1</code> under On Error. Returns 0 on any error or when empty. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Call with 0..n args and ensure result correct. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>CreateObjectSafe(progId As String) As Object</strong> — <em>defensive CreateObject wrapper</em><br><strong>Purpose:</strong> Try <code>CreateObject(progId)</code> and return object or Nothing on failure, swallowing errors. Simplifies optional COM creation logic across module.<br><strong>Signature:</strong> <code>Private Function CreateObjectSafe(ByVal progId As String) As Object</code> → Object or Nothing.<br><strong>Behavior:</strong> <code>On Error GoTo ErrHandler</code> attempts CreateObject, returns object; on error clears Err and returns Nothing. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Test with known registered COM progId and an invalid string. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>IsMac() As Boolean</strong> — <em>OS hint helper</em><br><strong>Purpose:</strong> Return True when <code>Application.OperatingSystem</code> appears to contain "Mac" to help branch host-specific code paths (OnTime scheduling, qualified proc names).<br><strong>Signature:</strong> <code>Private Function IsMac() As Boolean</code> → Boolean.<br><strong>Behavior:</strong> Calls <code>SafeString(Application.OperatingSystem)</code> and <code>InStr(...,&quot;Mac&quot;,vbTextCompare)&gt;0</code>. Errors are cleared. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Mock Application.OperatingSystem containing "Mac" and other strings. <br><strong>Notes:</strong> OS string parsing is heuristic; keep central for consistent behavior. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>TryCancelOnTime(whenTime As Date, procName As String)</strong> — <em>idempotent OnTime cancellation helper</em><br><strong>Purpose:</strong> Cancel <code>Application.OnTime</code> scheduled calls; attempt workbook-qualified cancellation first (Windows) then unqualified; tolerant to errors and multiple calls.<br><strong>Signature:</strong> <code>Private Sub TryCancelOnTime(ByVal whenTime As Date, ByVal procName As String)</code> — no return.<br><strong>Behavior:</strong> If <code>procName</code> empty returns. If not IsMac and <code>ThisWorkbook</code> accessible tries qualified cancellation: <code>Application.OnTime EarliestTime:=whenTime, Procedure:=&quot;&#x27;ThisWorkbook.Name&#x27;!procName&quot;, Schedule:=False</code>. Always attempts unqualified cancellation afterwards. Swallows errors. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Cancels scheduled OnTime if matching parameters found. <br><strong>Tests:</strong> Schedule and then cancel; call twice to validate idempotency. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>IsSensitiveKey(key As String) As Boolean</strong> — <em>heuristic sensitive key detector</em><br><strong>Purpose:</strong> Detect keys that likely contain secrets (password, token, api key, pwd) to trigger redaction in <code>WriteMetaValue</code>.<br><strong>Signature:</strong> <code>Private Function IsSensitiveKey(ByVal key As String) As Boolean</code> → Boolean.<br><strong>Behavior:</strong> Lowercases key and tests <code>InStr</code> for patterns <code>&quot;pass&quot;</code>, <code>&quot;secret&quot;</code>, <code>&quot;token&quot;</code>, <code>&quot;api&quot; &amp; &quot;key&quot;</code>, <code>&quot;pwd&quot;</code>. Returns True if any matched. <br><strong>Complexity:</strong> O(len(key)).<br><strong>Failure modes:</strong> Heuristic may miss or false-positive some keys; maintain carefully. <br><strong>Tests:</strong> Provide keys like <code>&quot;ApiKey&quot;</code>, <code>&quot;password&quot;</code>, <code>&quot;user_token&quot;</code> and confirm detection. <br><strong>Notes:</strong> If adding other secret patterns add here and include test coverage. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddSensitiveKeyMarker(key As String)</strong> — <em>record sensitive key name in <code>SensitiveKeys</code> meta value</em><br><strong>Purpose:</strong> Maintain an index of sensitive keys stored in metadata (not raw value) so operators can review masked entries.<br><strong>Signature:</strong> <code>Private Sub AddSensitiveKeyMarker(ByVal key As String)</code> — no return.<br><strong>Behavior:</strong> Reads existing <code>SensitiveKeys</code> meta via <code>ReadMetaValue</code>, performs case-insensitive containment check, appends the key if not present, and writes back via <code>WriteMetaValue</code>. <code>On Error Resume Next</code> guards. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Writes metadata. <br><strong>Tests:</strong> Add multiple keys and confirm non-duplication and presence. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AddIn_RunInternalTests()</strong> — <em>developer/internal CI-style lightweight tests runner</em><br><strong>Purpose:</strong> Run small built-in tests for CRC table, metadata read/write, SafeRun behaviour and write results to <code>_IFRS_TestResults</code> sheet. Designed for manual or CI invocation.<br><strong>Signature:</strong> <code>Public Sub AddIn_RunInternalTests()</code> — no return.<br><strong>Behavior:</strong> Builds <code>results()</code> array with tests: CRC basic vector non-zero, Metadata R/W test (<code>WriteMetaValue</code> + <code>ReadMetaValue</code>), SafeRun non-existent proc check expected False. Appends results via <code>AppendTestResult</code> and audits completion. Handles errors via <code>Bootstrap_HandleError</code>.<br><strong>Complexity:</strong> O(1) plus I/O to metadata/test sheet. <br><strong>Side-effects:</strong> Writes to <code>_IFRS_TestResults</code> sheet and metadata. <br><strong>Failure modes:</strong> Sheet creation may fail, tests might assume environment features; handle gracefully. <br><strong>Recommended tests:</strong> Already built-in; maintain expected pass/fail semantics. <br><strong>Notes:</strong> Keep tests stable and non-destructive; avoid tests that mutate production data. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>AppendTestResult(text As String)</strong> — <em>append a result row into <code>_IFRS_TestResults</code> sheet</em><br><strong>Purpose:</strong> Helper to persist test run rows with timestamp and result text (used by <code>AddIn_RunInternalTests</code>).<br><strong>Signature:</strong> <code>Private Sub AppendTestResult(ByVal text As String)</code> — no return.<br><strong>Behavior:</strong> Ensures <code>_IFRS_TestResults</code> exists, sets it VeryHidden if possible, ensures headers, and appends <code>Timestamp</code> and <code>Result</code> rows. Errors printed to Debug.Print. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Run <code>AddIn_RunInternalTests</code> and verify appended rows. </td></tr><tr><td data-label="Technical breakdown (modBootstrap)"> <strong>Misc notes: cross-cutting behaviors & maintainers checklist</strong><br>- <strong>Idempotency:</strong> Public lifecycle entrypoints (<code>AddIn_Initialize</code>, <code>AddIn_DeferredInit</code>, <code>AddIn_Shutdown</code>) are defensive and idempotent; maintain that property when changing behaviour.<br>- <strong>SafeRun contract:</strong> <code>SafeRun</code> and <code>SafeRunWithResult</code> are canonical external-call gates — use them for all optional cross-module calls to avoid hard dependencies. Maintain the workbook-qualified-first strategy for deterministic resolution on Windows.<br>- <strong>Metadata safety:</strong> <code>WriteMetaValue</code> performs size truncation and redaction for sensitive keys. Keep <code>IsSensitiveKey</code> heuristics up-to-date if new secret patterns appear.<br>- <strong>Audit / Error forwarding:</strong> Audit attempts remote <code>LogAudit</code> and <code>HandleError</code> via <code>SafeRun</code> and falls back to local worksheets. This dual-path design ensures offline safety but requires operators to inspect <code>_IFRS_Audit</code> when remote logging fails.<br>- <strong>COM & host differences:</strong> All COM calls are guarded via <code>CreateObjectSafe</code> and <code>On Error</code> to tolerate limited hosts (e.g., Excel for Mac, protected workbooks, or constrained runtime). Do not add unguarded COM calls.<br>- <strong>Worker expectations & public API stability:</strong> Public functions and their signatures (listed near top) must not be renamed without updating callers. In particular <code>AddIn_Initialize</code>, <code>AddIn_DeferredInit</code>, <code>AddIn_Shutdown</code>, <code>AddIn_GetState</code>, <code>AddIn_RunInternalTests</code> are part of the public surface.<br>- <strong>Telemetry & PII:</strong> Audit logs include <code>Application.UserName</code>; decide whether to redact or avoid depending on privacy policy. Metadata may contain masked sensitive keys but indices to them (<code>SensitiveKeys</code>) are preserved for operator visibility.<br>- <strong>Testing matrix:</strong> Unit tests should verify all host branches: typical Excel desktop Windows, Excel for Mac, protected workbook (simulate permission failure), and COM absence (e.g., ADODB unregistered). Also add CI check that runs <code>AddIn_RunInternalTests</code> in a sandboxed environment.<br>- <strong>Migration caution:</strong> CRC-derived <code>g_bootstrapId</code> is used in many persisted audit rows and metadata; changing id composition will break historical correlation. Document any change and add migration mapping if necessary. </td></tr></tbody></table></div><div class="row-count">Rows: 41</div></div><div class="table-caption" id="Table4" data-table="Docu_0158_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modCalculations)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modCalculations)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Overview:</strong> This table documents <code>modCalculations</code> (VBA) at a per-function level. Each entry records: purpose, signature, inputs/outputs, internal behaviour, complexity, side-effects, invariants, failure modes, recommended tests, and maintainer notes. The implementation preserves public signatures, centralizes rounding/error routing, defers to <code>modConfig</code>/<code>modUtilities</code> when present, and prefers safe conversions and best-effort central logging. Use this as authoritative inline technical documentation for reviewers, auditors, and QA. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Constants & Enums</strong> — <em>module metadata & domain primitives</em><br><strong>Purpose:</strong> Central constants and enums define versioning, feature defaults, numeric limits and business enums used across functions.<br><strong>Members:</strong> <code>MODCALC_VERSION</code>, <code>DEFAULT_*</code>, <code>PV_MAX_NPER</code>, <code>TINY_RESIDUAL_THRESHOLD</code>, <code>RATE_NEAR_ZERO</code>, <code>DepMethod</code> enum, <code>RoundingPolicy</code> enum.<br><strong>Behavior:</strong> Read-only; used to guard numeric edge-cases and to drive rounding/feature behaviour.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Values are treated as stable constants; changing them is breaking for behaviour and tests (especially <code>RATE_NEAR_ZERO</code> and <code>PV_MAX_NPER</code>).<br><strong>Failure modes:</strong> None by themselves but improper values (e.g., extremely small <code>RATE_NEAR_ZERO</code>) can change numeric branching. <br><strong>Tests:</strong> Ensure <code>MODCALC_VERSION</code> increments on behaviour changes; edge-case tests for thresholds. <br><strong>Notes:</strong> Keep version string and numeric guards in sync with tests and CI. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcDepreciation(cost As Double, usefulLife As Double) As Double</strong> — <em>simple SL façade</em><br><strong>Purpose:</strong> Backwards-compatible convenience for straight-line depreciation using default rounding policy.<br><strong>Signature:</strong> <code>CalcDepreciation(Double, Double) -&gt; Double</code> (returns 0 on error).<br><strong>Behavior:</strong> Calls <code>CalcDepreciationEx</code> with <code>depStraightLine</code> and default rounding policy. Error routed to <code>HandleCalcError</code> and returns 0 on failure.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Possible audit/log via error handler on failure.<br><strong>Invariants:</strong> Preserves public signature and behaviour expected by callers. <br><strong>Failure modes:</strong> Invalid numerics or exceptions inside underlying call -> returns 0 and logs. <br><strong>Tests:</strong> SL on typical costs (e.g., 1000,5 ->200), salvage-clamping via underlying. <br><strong>Notes:</strong> Lightweight wrapper; maintain if <code>CalcDepreciationEx</code> signature changes. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcEBITDA(revenue As Double, expenses As Double) As Double</strong> — <em>direct arithmetic</em><br><strong>Purpose:</strong> Compute EBITDA-like simple subtraction (no adjustments).<br><strong>Signature:</strong> <code>CalcEBITDA(Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Returns <code>revenue - expenses</code>. Errors handled centrally.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None (except error audit on exceptions).<br><strong>Invariants:</strong> Pure arithmetic. <br><strong>Failure modes:</strong> Non-numeric inputs produce routed error and 0. <br><strong>Tests:</strong> Positive/negative/zero inputs, very large numbers. <br><strong>Notes:</strong> If future adjustments (e.g., addbacks) required, convert to more explicit API. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalcDepreciationEx(cost, usefulLife, method, Optional salvage, Optional unitsProduced, Optional unitsTotal, Optional rounding) As Double</strong> — <em>general depreciation engine</em><br><strong>Purpose:</strong> Compute depreciation per several methods (straight-line, declining balance, sum-of-years, units-of-production) with sanitization and central rounding.<br><strong>Signature:</strong> <code>CalcDepreciationEx(Double, Double, DepMethod, Optional Double, Optional Double, Optional Double, Optional RoundingPolicy) -&gt; Double</code>.<br><strong>Behavior (high level):</strong> Validates numeric inputs; clamps salvage to [0,cost]; enforces <code>usefulLife&gt;0</code> except for units-of-production; implements algorithms:<br>- <strong>Straight-line:</strong> <code>(cost - salvage) / usefulLife</code>.<br>- <strong>Declining balance:</strong> <code>rate = 2/usefulLife</code>, <code>result = cost * rate</code>, clamped ≤ <code>(cost - salvage)</code> and ≥ 0.<br>- <strong>Sum-of-years:</strong> uses integer <code>n = Fix(usefulLife)</code> and <code>sumYears = n*(n+1)/2</code>, <code>result = (cost - salvage) * (n / sumYears)</code> (caller should interpret position/year externally).<br>- <strong>Units-of-production:</strong> requires <code>unitsTotal&gt;0</code>, <code>result = (cost - salvage) * (unitsProduced / unitsTotal)</code>.<br>Finally applies <code>ApplyRounding(result, policy)</code> and returns result. All errors go to <code>HandleCalcError</code> and function returns 0 on error.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error/audit calls on invalid inputs; may call central rounding helpers if configured.<br><strong>Invariants:</strong> <code>0 &lt;= salvage &lt;= cost</code>; returned value >= 0; uses consistent rounding policy. <br><strong>Failure modes:</strong> Invalid numerics, zero/negative usefulLife for non-UoP methods, unitsTotal<=0 for UoP -> logged and returns 0. Rounding policy conversion errors default to module policy. <br><strong>Security:</strong> No I/O; no sensitive data handling. <br><strong>Recommended tests:</strong> Per-method correctness (including boundary cases: salvage>cost, usefulLife fractional, n=0, very large numbers), rounding policy variants, units-production edge cases, and error routing integration (mock <code>modError</code>/<code>modAudit</code>).<br><strong>Notes for maintainers:</strong> Keep tokenization of usefulLife for Sum-of-Years explicit — changing integer truncation breaks outputs; adding new methods must preserve existing signatures and rounding behaviour. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>LeaseAmortizationSchedule(pmt As Double, ratePerPeriod As Double, periods As Long, Optional startDate As Date) As Variant</strong> — <em>period-by-period amortization generator</em><br><strong>Purpose:</strong> Build a 1-based 2D array amortization schedule (Period, OpeningBalance, Payment, Interest, Principal, ClosingBalance). Designed for leases/loan style schedules where payment is known.<br><strong>Signature:</strong> <code>LeaseAmortizationSchedule(Double pmt, Double ratePerPeriod, Long periods, Optional Date) -&gt; Variant (1..n,1..6) or Empty on error</code>.<br><strong>Behavior (detailed):</strong><br>- Validates <code>periods&gt;0</code>.<br>- Computes opening balance via <code>PvFromPmt(pmt, ratePerPeriod, n)</code> and uses absolute value to avoid sign confusion.<br>- Iterative loop for each period computes <code>interest = bal * ratePerPeriod</code> (zeroed for near-zero rates), <code>principal = payment - interest</code> then guards <code>principal</code> between 0 and balance. All numeric outputs go through <code>ApplyRounding</code> at relevant points (payment, interest, principal, balances). Tiny residuals are zeroed using <code>TINY_RESIDUAL_THRESHOLD</code>.<br>- After loop verifies sum(principal) ≈ opening and adjusts last principal/closing if discrepancy beyond tolerance. Returns populated 2D array. Errors routed to <code>HandleCalcError</code> and returns <code>Empty</code> on failure.<br><strong>Complexity:</strong> O(nPeriods).<br><strong>Side-effects:</strong> None besides error/audit on failure; may read rounding/config via <code>ApplyRounding</code> helper.<br><strong>Invariants:</strong> Output array dimensions = <code>n×6</code>; sum of principals ≈ opening (within tolerance). Outstanding balance never negative. Rounding consistent across rows.<br><strong>Failure modes:</strong> Invalid <code>periods</code>, extremely large <code>periods</code> may stress memory; <code>PvFromPmt</code> returning 0 leads to zero opening; potential tiny floating residuals corrected at end. <br><strong>Recommended tests:</strong> Zero rate vs very small rate, large <code>periods</code> near PV cap, sum-principal adjustment correctness, final residual zeroing. <br><strong>Notes:</strong> Payment is expected positive; if callers supply negative semantics, document behavior. Consider adding <code>maxPeriods</code> guard if module runs on low-memory hosts. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>PvFromPmt(pmt As Double, rate As Double, nper As Long) As Double</strong> — <em>robust present value from payment</em> (private)<br><strong>Purpose:</strong> Compute PV for known payment across <code>nper</code> periods; handles near-zero rate and clamps large <code>nper</code> for safety.<br><strong>Signature:</strong> <code>PvFromPmt(Double, Double, Long) -&gt; Double</code>.<br><strong>Behavior:</strong> If <code>nper &lt;= 0</code> returns 0. Clamps <code>nper</code> to <code>PV_MAX_NPER</code>. For <code>Abs(rate) &lt; RATE_NEAR_ZERO</code> uses <code>pmt * n</code>, else computes <code>pmt / rate * (1 - (1+rate)^(-n))</code>. If denom too small the function falls back to <code>pmt * n</code>. Returns absolute value to standardize sign for asset balances. Errors return 0.<br><strong>Complexity:</strong> O(1) (power calculation cost).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Returns non-negative PV value for positive pmt. <br><strong>Failure modes:</strong> Overflow/power extremes mitigated by clamping and fallbacks. <br><strong>Tests:</strong> Zero/near-zero rate, negative rate boundary <code>&gt;-1</code>, large <code>nper</code> behavior, sign normalization. <br><strong>Notes:</strong> Keep <code>PV_MAX_NPER</code> tuned; if financial precision required, consider using higher precision math or spreadsheet functions. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>RecognizeRevenue(transactionPrice As Double, progress As Double) As Double</strong> — <em>simple progress-based revenue recognition</em><br><strong>Purpose:</strong> Return revenue recognized as <code>transactionPrice * progress</code> with validations and rounding.<br><strong>Signature:</strong> <code>RecognizeRevenue(Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates <code>progress</code> numeric and in [0,1]; returns <code>ApplyRounding(transactionPrice * progress)</code>. On invalid input logs error and returns 0. Errors routed centrally.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error audit on invalid input. <br><strong>Invariants:</strong> <code>0 &lt;= progress &lt;= 1</code>; result rounded as configured. <br><strong>Failure modes:</strong> Out-of-range <code>progress</code>, non-numeric inputs. <br><strong>Tests:</strong> Values at 0,1, fractional, invalid, and rounding policy effects. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ImpairmentLoss(carryingAmount As Double, recoverableAmount As Double) As Double</strong> — <em>simple impairment comparator</em><br><strong>Purpose:</strong> Compute impairment loss when <code>recoverableAmount &lt; carryingAmount</code> as rounded difference.<br><strong>Signature:</strong> <code>ImpairmentLoss(Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates numerics; if <code>recoverableAmount &lt; carryingAmount</code> returns <code>ApplyRounding(carryingAmount - recoverableAmount)</code> else 0. Errors go to handler and return 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error/audit on invalid input. <br><strong>Invariants:</strong> Returns non-negative number. <br><strong>Failure modes:</strong> Non-numeric inputs. <br><strong>Tests:</strong> boundary where equal, recoverable bigger, invalid types. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ImpairmentLossByNPV(carryingAmount As Double, cashflows As Variant, discountRate As Double) As Double</strong> — <em>impairment via discounted cash flows</em><br><strong>Purpose:</strong> Compute impairment comparing carrying amount vs NPV of future cashflows; if NPV < carrying => loss = carrying - NPV (rounded).<br><strong>Signature:</strong> <code>ImpairmentLossByNPV(Double, Variant, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Calls <code>NPVFromArray</code> to compute npv. If <code>npv &lt;= 0</code> treats as potential full impairment check; otherwise compares and returns <code>ApplyRounding(carrying - npv)</code> if positive; 0 otherwise. Errors routed centrally. <br><strong>Complexity:</strong> O(N) where N = number of cashflow periods.<br><strong>Side-effects:</strong> May call error logger from <code>NPVFromArray</code> when discount invalid. <br><strong>Invariants:</strong> Numeric conversions via safe helpers. <br><strong>Failure modes:</strong> Bad discount rate, malformed cashflows; NPV false negatives due to numeric issues. <br><strong>Tests:</strong> Scalar and array cashflows, negative/zero NPV behavior, discountRate boundaries (> -1). </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>NPVFromArray(cashflows As Variant, discountRate As Double) As Double</strong> — <em>NPV evaluator with flexible input</em> (private)<br><strong>Purpose:</strong> Compute NPV for scalar or array cashflows; supports arbitrary LBound/UBound arrays and returns 0 on invalid discount rates.<br><strong>Signature:</strong> <code>NPVFromArray(Variant, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates <code>discountRate</code> numeric and <code>&gt; -1</code>. Iterates array from LBound to UBound (or handles scalar as single-period) applying <code>cf / ((1+discountRate)^periodIndex)</code> where <code>periodIndex</code> is 1-based relative to LBound. Uses <code>ToDoubleSafe</code> to coerce CFs. Errors are logged and function returns 0 on failure.<br><strong>Complexity:</strong> O(N) per cashflow count.<br><strong>Side-effects:</strong> None aside from error routing. <br><strong>Invariants:</strong> Deterministic mapping of array bounds to periods. <br><strong>Failure modes:</strong> <code>discountRate &lt;= -1</code>, malformed arrays, non-numeric cashflow entries. <br><strong>Tests:</strong> Arrays with non-zero LBound, scalar path, discount edge values, known sample NPV calculations. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ExpectedCreditLoss(exposure As Double, pd As Double, lgd As Double) As Double</strong> — <em>ECL single-case formula</em><br><strong>Purpose:</strong> Return ECL = exposure × PD × LGD with validation for PD/LGD in [0,1] and rounding.<br><strong>Signature:</strong> <code>ExpectedCreditLoss(Double, Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates numerics and ranges; computes <code>ApplyRounding(exposure * pd * lgd)</code>. On invalid inputs logs and returns 0.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error/audit on invalid inputs. <br><strong>Invariants:</strong> <code>0 &lt;= pd, lgd &lt;= 1</code>. <br><strong>Failure modes:</strong> Out-of-range parameters, NaN. <br><strong>Tests:</strong> Boundaries (0,1), random combinations, rounding check. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ExpectedCreditLossBatch(exposures As Variant, pds As Variant, lgds As Variant) As Variant</strong> — <em>vectorized ECL over input arrays</em><br><strong>Purpose:</strong> Accept scalar or array inputs for exposures/pds/lgds and return a 1-based array of ECL results; normalizes inputs to common length and applies <code>ExpectedCreditLoss</code> per index.<br><strong>Signature:</strong> <code>ExpectedCreditLossBatch(Variant, Variant, Variant) -&gt; Variant (1..n) or Empty on error</code>.<br><strong>Behavior:</strong> Uses <code>NormalizeArrayInput</code> to produce 1-based arrays; determines <code>n = Max(UBoundSafe(exArr), UBoundSafe(pdArr), UBoundSafe(lgArr))</code>. Iterates 1..n and uses <code>ToDoubleSafeIndex</code> to fetch indexed values and calls <code>ExpectedCreditLoss</code> for each element; returns an array of doubles. Errors logged and returns <code>Empty</code> on top-level exception.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> Error routing on top-level problems. <br><strong>Invariants:</strong> Output length equals computed n; missing elements treated as 0. <br><strong>Failure modes:</strong> Empty inputs produce <code>Array()</code> early; improper array shapes handled defensively. <br><strong>Tests:</strong> Mixed scalar/arrays, unequal lengths, invalid items. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GenerateDepreciationSchedule(cost As Double, usefulLife As Double, Optional method As DepMethod, Optional salvage As Double, Optional startYear As Long, Optional rounding As RoundingPolicy) As Variant</strong> — <em>periodic schedule generator</em><br><strong>Purpose:</strong> Produce a 0-based table (header row at index 0) containing rows for each period with columns: Period, DepreciationExpense, AccumulatedDepreciation, CarryingAmount.<br><strong>Signature:</strong> <code>GenerateDepreciationSchedule(Double, Double, Optional DepMethod, Optional Double, Optional Long, Optional RoundingPolicy) -&gt; Variant (0..periods,1..4) or Empty</code>.<br><strong>Behavior:</strong> Validates <code>usefulLife&gt;0</code>; computes <code>periods = Fix(usefulLife)</code>; iterates 1..periods and computes expense according to method (implementations: SL, declining balance, sum-of-years, units-of-production fallbacks). Expenses are rounded via <code>ApplyRounding(expense, rpolicy)</code> and accumulated. Header row inserted at index 0. Returns <code>out</code> 2D variant. Errors logged and returns <code>Empty</code>.<br><strong>Complexity:</strong> O(periods).<br><strong>Side-effects:</strong> None aside from rounding/config access. <br><strong>Invariants:</strong> Sum of expenses + salvage = cost (subject to rounding); carrying amount never negative. <br><strong>Failure modes:</strong> <code>usefulLife</code> not numeric or ≤0, extremely large periods; rounding aggregate drift — expected and accepted but maintainers should monitor. <br><strong>Tests:</strong> Method-specific sequences, rounding policy checks, startYear mapping. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>DeferredTax(tempDifference As Double, taxRate As Double) As Double</strong> — <em>deferred tax simple product</em><br><strong>Purpose:</strong> Compute deferred tax as <code>tempDifference * taxRate</code> with validation for taxRate in [0,1] and rounding.<br><strong>Signature:</strong> <code>DeferredTax(Double, Double) -&gt; Double</code>.<br><strong>Behavior:</strong> Validates taxRate numeric and between 0 and 1; returns <code>ApplyRounding(tempDifference * taxRate)</code>. Logs and returns 0 on invalid inputs.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Error/audit on invalid input. <br><strong>Invariants:</strong> <code>0 &lt;= taxRate &lt;= 1</code>. <br><strong>Failure modes:</strong> Out-of-range taxRate, non-numeric inputs. <br><strong>Tests:</strong> Boundaries and rounding. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GetRoundPolicy() As Long</strong> — <em>config-driven rounding policy resolver</em> (private)<br><strong>Purpose:</strong> Read configured rounding policy via <code>GetConfigValue</code> and fall back to <code>DEFAULT_ROUNDING_POLICY</code> if missing or invalid.<br><strong>Signature:</strong> <code>GetRoundPolicy() -&gt; Long</code>.<br><strong>Behavior:</strong> Calls <code>GetConfigValue(&quot;modCalculations.RoundPolicy&quot;, DEFAULT_ROUNDING_POLICY)</code> then normalizes numeric/variant types to <code>Long</code>. Errors return default.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Attempts <code>GetConfigValue</code> which calls <code>SafeCallCentral</code> to consult <code>modConfig</code> or global <code>GetConfigValue</code>.<br><strong>Invariants:</strong> Return one of <code>RoundingPolicy</code> values. <br><strong>Failure modes:</strong> Central config missing -> uses default. <br><strong>Tests:</strong> Mock <code>GetConfigValue</code> returns (vbBoolean, vbLong, numeric string) and ensure conversion. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ShouldUseCentralRounding() As Boolean</strong> — <em>config boolean resolver</em> (private)<br><strong>Purpose:</strong> Decide whether to route rounding to centralized helper (e.g., <code>modUtilities</code>) based on config key <code>modCalculations.UseCentralRounding</code>.<br><strong>Signature:</strong> <code>ShouldUseCentralRounding() -&gt; Boolean</code>.<br><strong>Behavior:</strong> Calls <code>GetConfigValue</code> with default; converts variant to boolean by VarType/IsNumeric. Errors → default. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls <code>GetConfigValue</code> (safe-run).<br><strong>Tests:</strong> Ensure true/false numeric/string conversion. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ApplyRounding(value As Double, Optional policy As Variant) As Double</strong> — <em>central rounding entry</em><br><strong>Purpose:</strong> Apply module rounding policy, optionally delegating to centralized rounding helpers if <code>ShouldUseCentralRounding()</code> is true. Provides safe fallbacks to <code>WorksheetRound</code> if central helper absent.<br><strong>Signature:</strong> <code>ApplyRounding(Double, Optional Variant) -&gt; Double</code>.<br><strong>Behavior:</strong> Determines <code>pol</code> via explicit <code>policy</code> or <code>GetRoundPolicy()</code>. If <code>ShouldUseCentralRounding()</code> attempts <code>SafeCallCentral(&quot;modUtilities.ApplyRounding&quot;, r, value, pol)</code> then tries <code>modUtilities.Round</code> variant; if those succeed uses returned value (converted via <code>ToDoubleSafe</code>). Otherwise falls back to internal <code>WorksheetRound</code> implementation for <code>roundNone</code>, <code>roundFinancial</code> (2 decimals), <code>roundInteger</code> (0 decimals). Errors return original <code>value</code> (safe non-destructive fallback).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May call external modules via <code>Application.Run</code> (<code>SafeCallCentral</code>) which can produce exceptions that are swallowed and routed to fallback. <br><strong>Invariants:</strong> If central rounding used, result should match central semantics; otherwise deterministic local rounding used. <br><strong>Failure modes:</strong> Central helper present but throws — fallback to local rounding; failure to convert returned type uses <code>ToDoubleSafe</code>. <br><strong>Recommended tests:</strong> Behavior when <code>ShouldUseCentralRounding</code> true/false, central helper returns numeric/non-numeric, policy variations, and rounding edge cases (.5 rounding semantics). <br><strong>Notes:</strong> Keep consistent rounding semantics documented; unit tests must assert parity between central and local rounding in environments where central is enabled. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>WorksheetRound(value As Double, digits As Long) As Double</strong> — <em>worksheet rounding wrapper</em> (private)<br><strong>Purpose:</strong> Use <code>Application.WorksheetFunction.Round</code> but degrade gracefully if unavailable.<br><strong>Signature:</strong> <code>WorksheetRound(Double, Long) -&gt; Double</code>.<br><strong>Behavior:</strong> Calls the worksheet function, returns <code>value</code> on error.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Worksheet Round missing or error -> returns unrounded input; callers must accept this fallback. <br><strong>Tests:</strong> Compare to known rounding for positive and negative values, digits=0 and 2. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ValidateNumeric(v As Variant) As Boolean</strong> — <em>defensive numeric checker</em> (private)<br><strong>Purpose:</strong> Centralize numeric detection and error-resilience when validating inputs.<br><strong>Signature:</strong> <code>ValidateNumeric(Variant) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Returns False for <code>IsError(v)</code> or non-numeric; True if <code>IsNumeric</code>. Uses <code>On Error Resume Next</code> defensively. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Numeric strings, Empty, Null, Error CVErr values. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>NormalizeArrayInput(v As Variant) As Variant</strong> — <em>normalize scalar/array → 1-based array</em> (private)<br><strong>Purpose:</strong> Convert scalar or VB array (any LBound) into a predictable 1-based contiguous 1-D array for batch functions.<br><strong>Signature:</strong> <code>NormalizeArrayInput(Variant) -&gt; Variant (1..n) array</code>.<br><strong>Behavior:</strong> If <code>IsArray(v)</code> copies elements from <code>LBound..UBound</code> into <code>out(1..n)</code>; if scalar returns <code>out(1)=v</code>. Returns zero-length <code>1 To 0</code> when n<=0 or on error. Errors handled and zero-length fallback returned. <br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Output always 1-based if non-empty. <br><strong>Failure modes:</strong> Jagged/bad arrays preserved as values; callers should use <code>SafeArrayLength</code> if uncertain. <br><strong>Tests:</strong> LBound != 0 arrays, scalar input, empty-array input. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ToDoubleSafe(v As Variant, Optional defaultValue As Double = 0#) As Double</strong> — <em>safe numeric coercion</em> (private)<br><strong>Purpose:</strong> Convert variant to Double when numeric; otherwise return default safely without throwing.<br><strong>Signature:</strong> <code>ToDoubleSafe(Variant, Optional Double) -&gt; Double</code>.<br><strong>Behavior:</strong> If <code>IsNumeric(v)</code> returns <code>CDbl(v)</code>, else <code>defaultValue</code>. Errors return default. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Numeric strings, Null, Empty, Error values. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ToDoubleSafeIndex(arr As Variant, idx As Long) As Double</strong> — <em>safe indexed conversion</em> (private)<br><strong>Purpose:</strong> Return <code>ToDoubleSafe</code> for element at <code>idx</code> in array normalized to the calling module's indexed convention; supports scalar fallback when <code>idx=1</code>.<br><strong>Signature:</strong> <code>ToDoubleSafeIndex(Variant, Long) -&gt; Double</code>.<br><strong>Behavior:</strong> If arr is array, computes <code>pos = LBound + idx -1</code> and returns element safely; otherwise if <code>idx=1</code> returns scalar. Returns 0 on out-of-range or errors. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> LBound/UBound boundary, scalar path. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>UBoundSafe(arr As Variant) As Long</strong> — <em>defensive UBound</em> (private)<br><strong>Purpose:</strong> Return <code>UBound(arr)</code> or 0 for non-arrays or errors, swallowing errors.<br><strong>Signature:</strong> <code>UBoundSafe(Variant) -&gt; Long</code>.<br><strong>Behavior:</strong> <code>On Error Resume Next</code> and returns 0 on error. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Non-array, array with invalid bounds. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>SafeArrayLength(arr As Variant) As Long</strong> — <em>array length helper</em> (private)<br><strong>Purpose:</strong> Return number of elements for scalar/array with defensive checks (0 for Empty/Null).<br><strong>Signature:</strong> <code>SafeArrayLength(Variant) -&gt; Long</code>.<br><strong>Behavior:</strong> If <code>IsArray</code> returns <code>UBound-LBound+1</code> else 1 for scalar (unless Empty/Null). <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Empty, Null, scalar, array. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>SafeCallCentral(procName As String, ByRef outResult As Variant, ParamArray args() As Variant) As Boolean</strong> — <em>defensive external-run wrapper</em> (private)<br><strong>Purpose:</strong> Safely call external procedures via <code>Application.Run</code> with up to 9 parameters, swallow errors and return success boolean; used to integrate with <code>modConfig</code>, <code>modUtilities</code>, <code>modError</code>, <code>modAudit</code> if present.<br><strong>Signature:</strong> <code>SafeCallCentral(String procName, ByRef Variant outResult, ParamArray args() ) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Detects <code>UBound(args)</code> defensively and invokes <code>Application.Run</code> with explicit arity cases (cases -1..8 enumerated). If <code>Err.Number=0</code> returns True and <code>outResult</code> populated; otherwise clears error and returns False. Errors inside <code>Application.Run</code> are swallowed. <br><strong>Complexity:</strong> O(1) but uses <code>Application.Run</code> which can invoke arbitrary user code (cost variable).<br><strong>Side-effects:</strong> Executes external macros; those macros may have side-effects. <br><strong>Invariants:</strong> Caller must not assume side-effects are absent; use only for non-critical best-effort calls. <br><strong>Failure modes / Security:</strong> Calling arbitrary macro names has security implications (macro code executes). This wrapper avoids throwing but does not sandbox the code — maintain strict naming and review of any central procs. <br><strong>Tests:</strong> Mock <code>Application.Run</code> via test harness or run against known safe procs to ensure success/failure branches behave as expected. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>GetConfigValue(key As String, Optional defaultValue As Variant = Empty) As Variant</strong> — <em>config fetch with fallbacks</em> (private)<br><strong>Purpose:</strong> Read configuration keys by attempting <code>GetConfigValue</code> globally then <code>modConfig.GetConfigValue</code> via <code>SafeCallCentral</code>; falls back to <code>defaultValue</code> on failure.<br><strong>Signature:</strong> <code>GetConfigValue(String, Optional Variant) -&gt; Variant</code>.<br><strong>Behavior:</strong> Attempts <code>SafeCallCentral(&quot;GetConfigValue&quot;, r, key)</code> then <code>SafeCallCentral(&quot;modConfig.GetConfigValue&quot;, r, key)</code> and returns defaultValue if both fail. <br><strong>Complexity:</strong> O(1) but external calls possible. <br><strong>Side-effects:</strong> Calls external code that can have side-effects. <br><strong>Tests:</strong> Provide fake central implementation or ensure fallback triggers. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>ShouldRaiseErrors() As Boolean</strong> — <em>config-driven error policy resolver</em> (private)<br><strong>Purpose:</strong> Determine whether to re-raise or only log errors based on config <code>modCalculations.RaiseErrors</code> (default <code>DEFAULT_RAISE_ERRORS</code>).<br><strong>Signature:</strong> <code>ShouldRaiseErrors() -&gt; Boolean</code>.<br><strong>Behavior:</strong> Reads config key, coerces to Boolean, returns default on error. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Use with care — enabling will change control flow and may throw to callers unexpectedly; tests must toggle this config. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>HandleCalcError(procName As String, Optional errNum As Long = 0, Optional errMsg As String = "")</strong> — <em>central error/audit routing</em> (private)<br><strong>Purpose:</strong> Structured error routing: attempt <code>modError.HandleError</code> or global <code>HandleError</code>, or <code>modAudit.Log</code> / <code>LogAudit</code>, else append to local <code>_IFRS_Audit</code> worksheet. Optionally re-raises error if <code>ShouldRaiseErrors()</code> true.<br><strong>Signature:</strong> <code>HandleCalcError(String, Optional Long, Optional String)</code>.<br><strong>Behavior (detailed):</strong><br>- Build <code>payload</code> string for local fallback.<br>- Try <code>SafeCallCentral(&quot;modError.HandleError&quot;, ...)</code> and <code>SafeCallCentral(&quot;HandleError&quot;, ...)</code>. If those succeed exit.<br>- Try <code>modAudit.Log</code> or <code>LogAudit</code> via <code>SafeCallCentral</code>. If none available append local audit row in hidden sheet <code>_IFRS_Audit</code> via <code>AppendLocalAudit</code> (creates sheet if absent and hides it <code>xlSheetVeryHidden</code>).<br>- Finally, if <code>ShouldRaiseErrors()</code> true calls <code>Err.Raise</code> to escalate. The function swallows errors during logging. <br><strong>Complexity:</strong> O(1) but may call several external procs and perform worksheet modifications. <br><strong>Side-effects:</strong> May create or write to <code>_IFRS_Audit</code> sheet; may execute external audit/error handlers. <br><strong>Invariants:</strong> Local audit sheet header created first time. <br><strong>Failure modes / Security:</strong> External <code>Application.Run</code> executes arbitrary code; creating sheets may fail in restricted contexts -> fallback guarded. <br><strong>Recommended tests:</strong> Simulate presence/absence of <code>modError</code>/<code>modAudit</code>, ensure local audit created and rows appended; verify <code>ShouldRaiseErrors</code> toggle causes <code>Err.Raise</code>. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>AppendLocalAudit(message As String)</strong> — <em>local-sheet audit appender</em> (private)<br><strong>Purpose:</strong> Append a timestamped audit message to hidden worksheet <code>_IFRS_Audit</code> as a last-resort logger.<br><strong>Signature:</strong> <code>AppendLocalAudit(String)</code>.<br><strong>Behavior:</strong> Gets <code>ThisWorkbook</code>, finds or creates <code>_IFRS_Audit</code> sheet, ensures headers then appends a row with timestamp,user,message trimmed to 2000 chars. Uses <code>xlSheetVeryHidden</code>. Errors swallowed silently. <br><strong>Complexity:</strong> O(1) per append but uses worksheet I/O. <br><strong>Side-effects:</strong> Creates/edits workbook sheets (persistence). <br><strong>Failure modes:</strong> Workbook protected, user with no permission, or environments where <code>ThisWorkbook</code> not set -> function exits early. <br><strong>Tests:</strong> Run in workbook with and without sheet, locked workbook, and with limited permissions. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>SafeLog(moduleName As String, proc As String, details As String)</strong> — <em>best-effort log helper</em> (private)<br><strong>Purpose:</strong> Convenience wrapper to try <code>modAudit.Log</code>/<code>LogAudit</code> and fallback to <code>AppendLocalAudit</code> for structured logging.<br><strong>Signature:</strong> <code>SafeLog(String, String, String)</code>.<br><strong>Behavior:</strong> Attempts central logging via <code>SafeCallCentral</code> and falls back to <code>AppendLocalAudit</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Ensure messages end up in central log when present else local sheet. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>CalculationsSelfTest() As Boolean</strong> — <em>module self-test runner & CI hook</em><br><strong>Purpose:</strong> Execute a battery of smoke and edge-case tests for key functions, record PASS/FAIL in <code>_IFRS_TestResults</code> sheet, and attempt to register the self-test with central test harness (<code>modTests.RegisterSelfTest</code>) if present.<br><strong>Signature:</strong> <code>CalculationsSelfTest() -&gt; Boolean</code>.<br><strong>Behavior (detailed):</strong><br>- Runs repeated checks (3x loop) for <code>CalcDepreciationEx</code>, <code>CalcEBITDA</code>, <code>RecognizeRevenue</code>, <code>ExpectedCreditLoss</code>, <code>DeferredTax</code>, <code>LeaseAmortizationSchedule</code>, <code>PvFromPmt</code>, <code>NPVFromArray</code>, and edge cases (salvage>cost, units-of-production). Accumulates boolean <code>ok</code> and writes PASS/FAIL with timestamp and <code>MODCALC_VERSION</code> to <code>_IFRS_TestResults</code> sheet (created hidden if absent). Attempts to register self-test with <code>modTests.RegisterSelfTest</code> or global <code>RegisterSelfTest</code>. Logs result via <code>SafeLog</code>. Returns boolean <code>ok</code>. On exception logs and returns False.<br><strong>Complexity:</strong> O(testWork) with loops, array allocations and schedule generation; depends on number of test iterations. <br><strong>Side-effects:</strong> Creates <code>_IFRS_TestResults</code> and writes rows; calls <code>SafeCallCentral</code> to register test; writes audit. <br><strong>Invariants:</strong> Should be idempotent — repeated runs append new timestamped rows. <br><strong>Failure modes:</strong> Environment lacking <code>ThisWorkbook</code> or write permissions cause partial failure (function still returns False). <br><strong>Recommended tests:</strong> Validate this self-test in CI, ensure it reliably returns True on known-good builds and False on intentionally broken builds. <br><strong>Notes:</strong> Keep tests small and deterministic; avoid network or external dependencies in CI. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Maintenance & Security Summary (module-level)</strong><br>- <strong>Error handling:</strong> All public functions catch errors and route through <code>HandleCalcError</code>; by default they return 0/Empty and not crash host. Test <code>ShouldRaiseErrors</code> toggles to verify raising behaviour.<br>- <strong>Rounding:</strong> Centralized via <code>ApplyRounding</code>, optionally delegating to <code>modUtilities</code>. Maintain consistent policy and document rounding semantics (bankers vs away-from-zero).<br>- <strong>External calls risk:</strong> <code>SafeCallCentral</code> uses <code>Application.Run</code> and will execute arbitrary macro code—audit any central routines exposed to this module. Keep call list minimal and well-reviewed. <br>- <strong>Numeric safety:</strong> Constants (<code>RATE_NEAR_ZERO</code>, <code>PV_MAX_NPER</code>, <code>TINY_RESIDUAL_THRESHOLD</code>) mitigate numeric edge cases. Changing these impacts behaviour; add tests before modification. <br>- <strong>I/O & Persistence:</strong> Local fallback audit/test sheets persisted to <code>ThisWorkbook</code>; this can create hidden sheets that should be documented in install/uninstall procedures. Consider allowing opt-out or centralizing audit to <code>modAudit</code> only. <br>- <strong>Recommended CI & tests:</strong> Unit tests for each public function (including invalid input, boundaries, rounding permutations), integration tests for error/ audit pathways (mock central modules), and repeated-run lifecycle tests for schedule generation. Add checks that rely on exact rounding semantics to detect regressions. </td></tr><tr><td data-label="Technical breakdown (modCalculations)"> <strong>Quick recommended checklist before modifying code</strong><br>1. Run <code>CalculationsSelfTest()</code> and confirm PASS in <code>_IFRS_TestResults</code>.<br>2. If changing rounding semantics, run a dedicated rounding parity suite comparing <code>ApplyRounding</code> local vs central when enabled.<br>3. If adding external calls, register them in a restricted allow-list and review code signing and macro security contexts.<br>4. Ensure new public functions preserve existing signatures and return types for COM/Excel callers. </td></tr></tbody></table></div><div class="row-count">Rows: 34</div></div><div class="table-caption" id="Table5" data-table="Docu_0158_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical breakdown (modConfig)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical breakdown (modConfig)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modConfig)"> <strong>Module overview</strong><br><strong>Purpose:</strong> Centralized configuration storage, deterministic schema migration, atomic commit/verify for <code>IFRS_Reporting_AddIn.xlam</code>. Provides stable public API surface for load/save/export/import, migration orchestration, checksum-backed integrity, platform fallbacks (Windows/macOS), defensive error handling and self-tests. Implements pure migration routines (no side-effects) and an atomic writer that uses CustomXMLParts plus checksum verification and restore/backup strategies.<br><strong>Public API (stable names):</strong> <code>LoadConfigXML</code>, <code>LoadConfig</code>, <code>SaveConfigXML</code>, <code>SaveConfig</code>, <code>EnsureConfigSchema</code>, <code>ExportConfigToFile</code>, <code>ExportConfigFile</code>, <code>ImportConfigFromFile</code>, <code>ImportConfigFile</code>, <code>RegisterMigration</code>, <code>RunConfigSelfTests</code>.<br><strong>Key invariants:</strong> CustomXMLParts containing <code>&lt;IFRSConfig&gt;</code> are canonicalized and represented by a single verified part after successful <code>SaveConfigXML</code>. Schema property <code>IFRS_Config_SchemaVersion</code> is written only after a verified commit. Checksum property <code>IFRS_Config_Checksum</code> holds the normalized (lowercase) checksum of the canonical XML. Migration routines are pure (input XML -> output XML) and must not perform external side effects. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Module-level constants & state</strong><br><strong>CFG_ROOT_NAME, CFG_PART_KEY, CFG_SCHEMA_PROP, CFG_CHECKSUM_PROP</strong> — stable external names consumed by other modules; changing these is breaking. <br><strong>MigrationRegistry (Scripting.Dictionary)</strong> — used when available to store registered migration steps. <br><strong>Flags:</strong> <code>MigrationRegistryInitialized</code>, <code>ScriptingAvailable</code>, <code>ADODBAvailable</code>, <code>ModuleInitialized</code>. <br><strong>Notes:</strong> Initialization uses runtime feature detection; code tolerates missing <code>Scripting.Dictionary</code> or <code>ADODB.Stream</code>, logging degradations. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>LoadConfigXML()</strong> — <em>load & verify canonical config XML</em><br><strong>Purpose:</strong> Return canonical config XML if present and checksum-verified. If checksum mismatch or error, backup and return empty string so caller can create defaults or handle migration deterministically.<br><strong>Signature:</strong> <code>LoadConfigXML() -&gt; String</code> (empty string on missing/invalid).<br><strong>Behavior:</strong> Finds candidate CustomXMLPart via <code>FindConfigPart</code>. If none → <code>&quot;&quot;</code>. Computes checksum of chosen part (<code>ComputeChecksumForCustomXMLPart</code>). If <code>CFG_CHECKSUM_PROP</code> exists read stored checksum. If stored checksum present and mismatches computed checksum -> <code>BackupConfigXML(part.xml)</code>, log audit, return <code>&quot;&quot;</code>. If no stored checksum -> log audit and return part.xml (no silent property update). On successful match return part.xml.<br><strong>Complexity:</strong> O(N) over number of CustomXMLParts (checksum computation dominated by string processing/writes).<br><strong>Side-effects:</strong> Only logging/audit and backup on mismatch. Does not modify document properties or parts except via <code>BackupConfigXML</code> when mismatch occurs.<br><strong>Invariants:</strong> Returns verified XML only when checksum present and matches. Caller receives empty string to signal recoverable corruption.<br><strong>Failure modes:</strong> IO/COM errors when reading parts, checksum compute failures — catches and returns empty string while logging audit.<br><strong>Recommended tests:</strong> No-part case, valid checksum case, stored-checksum-mismatch path (ensure backup created), property-missing path (returns XML and logs).<br><strong>Notes:</strong> Intentionally conservative — prefers safe failure+backup over silent overwrites. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>LoadConfig()</strong> — <em>compat shim</em><br><strong>Purpose:</strong> Back-compat alias returning same as <code>LoadConfigXML</code>.<br><strong>Signature:</strong> <code>LoadConfig() -&gt; String</code>.<br><strong>Behavior:</strong> Delegates to <code>LoadConfigXML</code>. No side-effects. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SaveConfigXML(ByVal configXml As String)</strong> — <em>atomic write + verify</em><br><strong>Purpose:</strong> Atomically persist <code>configXml</code> into the workbook CustomXMLParts with checksum verification and safe restore on failure. Updates CustomDocumentProperties only after successful verify. Returns boolean success.<br><strong>Signature:</strong> <code>SaveConfigXML(configXml As String) -&gt; Boolean</code>.<br><strong>High-level behavior (ordered):</strong><br>1. Ensure module initialized.<br>2. Capture existing matching parts and their XML into in-memory <code>origXmls</code> for attempted restore.<br>3. Create temporary CustomXMLPart <code>tmpPart</code> from <code>configXml</code> and compute <code>computedChecksum</code> via <code>ComputeChecksumForCustomXMLPart(tmpPart)</code>.<br>4. If checksum empty → delete tmpPart, audit, fail.<br>5. Add canonical <code>newPart = CustomXMLParts.Add(tmpPart.xml)</code> then delete tmpPart.<br>6. Recompute checksum on <code>newPart</code> (<code>verifyChecksum</code>) and compare to <code>computedChecksum</code>. If mismatch -> delete newPart, attempt to restore <code>origXmls</code> into CustomXMLParts, backup attempted config via <code>BackupConfigXML</code>, audit, fail.<br>7. On success: delete other parts containing <code>&lt;IFRSConfig&gt;</code> (keep <code>newPart</code>), set <code>CFG_CHECKSUM_PROP</code> (lowercase), set <code>CFG_SCHEMA_PROP</code> from extracted schema version, audit success, return True.<br><strong>Complexity:</strong> O(P) over number of CustomXMLParts; checksum compute and reads of part.xml dominate costs (linear in XML size).<br><strong>Side-effects:</strong> Adds and deletes CustomXMLParts, updates CustomDocumentProperties, creates backups on failure, logs audits.<br><strong>Invariants:</strong> If function returns True, workbook contains exactly one verified CustomXMLPart with <code>&lt;IFRSConfig&gt;</code> and props updated. If function fails, previous parts are attempted to be restored from <code>origXmls</code> and a backup file is created on disk.<br><strong>Failure modes & resilience:</strong> - Checksum compute failure; - exec/env constraints preventing certutil; - partial workbook state if COM errors; code attempts best-effort restore and writes a backup file. All fatal errors are logged and bubbled as False return.<br><strong>Security:</strong> Beware of writing arbitrary XML into workbook; callers must sanitize inputs if they originate from untrusted sources. Checksum prevents silent tamper but not maliciously-intentional accepted writes.<br><strong>Recommended tests:</strong> Successful atomic save; simulated verify-failure by corrupting part between tmp/new write; failure path creates backup and restores originals; property update correctness; concurrency/robustness under repeated saves.<br><strong>Notes:</strong> The algorithm intentionally writes then verifies the written part (double-write) to work around COM implementation differences and to ensure the workbook actually stores canonical contents. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SaveConfig(ByVal configXml As String)</strong> — <em>alias</em><br><strong>Purpose:</strong> Back-compat alias to <code>SaveConfigXML</code>.<br><strong>Signature:</strong> <code>SaveConfig(configXml) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Delegates to <code>SaveConfigXML</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>EnsureConfigSchema(Optional targetSCHEMA As String = "")</strong> — <em>ensures config exists & migrates deterministically</em><br><strong>Purpose:</strong> Guarantee a valid config exists in workbook with target schema; perform deterministic migrations when needed; create default config if missing or malformed.<br><strong>Signature:</strong> <code>EnsureConfigSchema(Optional targetSCHEMA As String) -&gt; Void</code>.<br><strong>Behavior:</strong><br>- Determine <code>targetSCHEMA</code> defaulting to <code>GetThisAddinSchemaVersion()</code>.<br>- Ensure migrations registered (<code>RegisterBuiltInMigrations</code>).<br>- Load xml via <code>LoadConfigXML</code>. If empty -> create default via <code>CreateDefaultConfigXML</code> and attempt <code>SaveConfigXML</code>; on failure call <code>HandleConfigError</code>.<br>- Extract current schema via <code>ExtractSchemaVersionFromXML</code>. If missing -> backup, replace with default, save, audit.<br>- If <code>currentVer &lt;&gt; targetSCHEMA</code> -> run migrations via <code>RunMigrations(currentVer, targetSCHEMA)</code>. On migration failure -> <code>HandleConfigError</code> and audit.<br><strong>Complexity:</strong> Dependent on <code>RunMigrations</code> cost; generally dominated by I/O and <code>SaveConfigXML</code> operations.<br><strong>Side-effects:</strong> May create/overwrite config parts, write properties, run migration routines (pure) and commit via <code>SaveConfigXML</code> (side-effect).<br><strong>Invariants:</strong> After successful return, workbook should contain a config with <code>SchemaVersion == targetSCHEMA</code> unless migration failed and error raised.<br><strong>Failure modes:</strong> Migration path cannot be built; migration routine failure; save fail. Errors handled via <code>HandleConfigError</code> which logs and raises vbObjectError +9000.<br><strong>Tests:</strong> Missing-config flow, malformed-config flow, migration-success flow, migration-failure path. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExportConfigToFile(ByVal fullPath As String)</strong> — <em>export current config to filesystem</em><br><strong>Purpose:</strong> Writes current verified config XML to <code>fullPath</code> (binary write). Returns boolean.<br><strong>Signature:</strong> <code>ExportConfigToFile(fullPath As String) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Loads config via <code>LoadConfigXML</code>. If empty -> return False. Else open file (Binary Access Write) and <code>Put</code> xml, return True. Exceptions logged and return False.<br><strong>Complexity:</strong> O(file size).<br><strong>Side-effects:</strong> Writes a file on disk. Should respect file system permissions and antivirus locks.<br><strong>Failure modes:</strong> IO errors, path missing, permission denied; audits error. Tests: write to temp path, verify contents match <code>LoadConfigXML</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExportConfigFile(ByVal fullPath As String)</strong> — <em>alias</em><br><strong>Purpose:</strong> Back-compat alias. Delegates to <code>ExportConfigToFile</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ImportConfigFromFile(ByVal fullPath As String)</strong> — <em>import config from file and save atomically</em><br><strong>Purpose:</strong> Read file contents and invoke <code>SaveConfigXML</code> to atomically persist into workbook. Returns boolean success.<br><strong>Signature:</strong> <code>ImportConfigFromFile(fullPath As String) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Opens file binary, reads bytes/contents into string, verifies string contains <code>&lt;IFRSConfig&gt;</code> root; if not present -> return False. Else calls <code>SaveConfigXML(xml)</code> and returns its result. Exceptions handled and logged.<br><strong>Complexity:</strong> O(file size + <code>SaveConfigXML</code> cost).<br><strong>Side-effects:</strong> Invokes atomic save which may modify workbook parts and properties.<br><strong>Failure modes:</strong> IO failure, malformed file, <code>SaveConfigXML</code> failure. Tests: round-trip export->import. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ImportConfigFile(ByVal fullPath As String)</strong> — <em>alias</em><br><strong>Purpose:</strong> Back-compat alias to <code>ImportConfigFromFile</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>FindConfigPart()</strong> — <em>deterministic selection of canonical config CustomXMLPart</em><br><strong>Purpose:</strong> Find a matching CustomXMLPart containing <code>&lt;IFRSConfig&gt;</code> with deterministic preference for the one matching stored checksum (if <code>CFG_CHECKSUM_PROP</code> exists). Returns <code>CustomXMLPart</code> or <code>Nothing</code>.<br><strong>Signature:</strong> <code>FindConfigPart() -&gt; CustomXMLPart | Nothing</code>.<br><strong>Behavior:</strong> Reads stored checksum from <code>ThisWorkbook.CustomDocumentProperties</code> if available. If present, walk all <code>CustomXMLParts</code> and compute checksum for those that contain <code>&lt;IFRSConfig&gt;</code>; if a computed checksum matches stored checksum (case-insensitive) return that part. If none match — log audit and return Nothing. If no stored checksum, return the first CustomXMLPart containing <code>&lt;IFRSConfig&gt;</code> found (deterministic by iteration order).<br><strong>Complexity:</strong> O(P) parts with per-part checksum computation dependent on XML size.<br><strong>Side-effects:</strong> Logs audit when no match. No writes. <br><strong>Failure modes:</strong> COM errors; ComputeChecksum failures — caught and return Nothing. Tests: multiple parts with one matching checksum; stored checksum absent -> first-match; stored checksum present but no matching part -> returns Nothing and logs. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>CreateDefaultConfigXML(ByVal schemaVersion As String)</strong> — <em>create minimal canonical config XML</em><br><strong>Purpose:</strong> Produce a deterministic default XML with <code>&lt;SchemaVersion&gt;</code>, <code>&lt;COAMappings&gt;</code>, <code>&lt;Templates&gt;</code> sections. Used when missing or malformed config detected.<br><strong>Signature:</strong> <code>CreateDefaultConfigXML(schemaVersion As String) -&gt; String</code>.<br><strong>Behavior:</strong> Constructs XML string using <code>EscapeXml</code> for schemaVersion and returns it. No side-effects. <br><strong>Complexity:</strong> O(len(schemaVersion)).<br><strong>Tests:</strong> Returns well-formed XML containing provided schemaVersion. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ExtractSchemaVersionFromXML(ByVal xml As String)</strong> — <em>extract schema value</em><br><strong>Purpose:</strong> Return value inside <code>&lt;SchemaVersion&gt;</code> tag or empty string if not found. Minimal parser using <code>InStr</code> and <code>Mid$</code>.<br><strong>Signature:</strong> <code>ExtractSchemaVersionFromXML(xml As String) -&gt; String</code>.<br><strong>Behavior:</strong> Locates start & end tags; returns substring. Not XML-namespace-aware; expects well-formedness. <br><strong>Complexity:</strong> O(len(xml)).<br><strong>Failure modes:</strong> Malformed XML -> returns empty string. Tests: various XMLs, missing tag, extra whitespace. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>BackupConfigXML(ByVal xml As String)</strong> — <em>safe disk backup</em><br><strong>Purpose:</strong> Write <code>xml</code> to a timestamped file in a safe temp folder (tries several fallbacks) for triage. Audit logged on success or error.<br><strong>Signature:</strong> <code>BackupConfigXML(xml As String) -&gt; Void</code>.<br><strong>Behavior:</strong> Resolves folder via <code>GetSafeTempFolder</code> (ENV TEMP/TMP → workbook.Path → Application.DefaultFilePath → macOS path). Forms filename <code>IFRS_Config_Backup_YYYYMMDD_HHNNSS_random.xml</code>. Writes binary, logs audit. Swallows exceptions and logs errors.<br><strong>Complexity:</strong> O(file size).<br><strong>Side-effects:</strong> Writes filesystem artifact. <br><strong>Security/privacy:</strong> Backups may contain sensitive secrets — ensure folder access policies or alert users before telemetry. <br><strong>Tests:</strong> Verify file written in candidate temp folder and timestamped format; verify audit entry. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>HandleConfigError(ByVal proc As String, ByVal msg As String)</strong> — <em>centralized error handler for config</em><br><strong>Purpose:</strong> Log audit entry, call <code>modError</code> handler if available, then raise a controlled runtime error (vbObjectError +9000) with correlation id appended.<br><strong>Signature:</strong> <code>HandleConfigError(proc As String, msg As String) -&gt; Void</code> (raises error).<br><strong>Behavior:</strong> Builds correlation ID via <code>GetCorrelationId</code>, calls <code>LogAudit(&quot;ConfigError&quot;, ...)</code>, attempts <code>SafeCallModErrorHandle</code> if error handler available, raises <code>Err.Raise vbObjectError + 9000, proc, msg | correlation</code>. Uses <code>On Error Resume Next</code> to avoid cascading exceptions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Logs, possibly calls external error module, raises a runtime error. <br><strong>Tests:</strong> Simulate when <code>modError</code> present/absent; verify audit message and raised error includes correlation id. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsErrorHandlerAvailable()</strong> — <em>probe for modError presence</em><br><strong>Purpose:</strong> Lightweight probe using <code>Application.Run &quot;modError_Probe_HandleError&quot;</code> to determine whether <code>modError</code> provides the probe entrypoint. Returns Boolean.<br><strong>Signature:</strong> <code>IsErrorHandlerAvailable() -&gt; Boolean</code>.<br><strong>Behavior:</strong> Attempts <code>Application.Run</code> and checks <code>Err.Number</code>. Uses <code>On Error Resume Next</code>. Returns True only if probe call succeeded (no Err). Does not otherwise call <code>modError.HandleError</code> to avoid side-effects.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Conservative probe; if <code>modError</code> exists but uses different naming the result is False; HandleConfigError falls back with <code>SafeCallModErrorHandle</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>SafeCallModErrorHandle(proc,msg)</strong> — <em>best-effort invocation of modError handler</em><br><strong>Purpose:</strong> Try <code>Application.Run &quot;modError.HandleError&quot;</code> then fallback probe-style names; swallow exceptions.<br><strong>Signature:</strong> <code>SafeCallModErrorHandle(proc As String, msg As String) -&gt; Void</code>.<br><strong>Behavior:</strong> Attempts <code>Application.Run &quot;modError.HandleError&quot;, proc, msg</code>, then on error tries <code>Application.Run &quot;modError_HandleError&quot;, proc &amp; &quot; | &quot; &amp; msg</code>. Uses <code>On Error Resume Next</code> and clears errors. No exception raised to caller. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Designed to avoid having modConfig depend directly on modError compile-time binding. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RegisterMigration(fromVersion,toVersion,routineName)</strong> — <em>register programmatic migrations</em><br><strong>Purpose:</strong> Expose programmatic registration of migration steps into <code>MigrationRegistry</code> for later deterministic chaining.<br><strong>Signature:</strong> <code>RegisterMigration(fromVersion As String, toVersion As String, routineName As String) -&gt; Void</code>.<br><strong>Behavior:</strong> Ensures module initialized and built-in migrations registered. Adds key <code>from|to</code> => <code>routineName</code> into <code>MigrationRegistry</code> only if not already present. Logs and ignores duplicates. Errors audited.<br><strong>Complexity:</strong> O(1) for dictionary operations (if <code>Scripting.Dictionary</code> available).<br><strong>Failure modes:</strong> <code>Scripting.Dictionary</code> unavailable -> function logs and returns; registration disabled. Tests: register new key, attempt duplicate registration. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RegisterBuiltInMigrations()</strong> — <em>initialize migration registry & runtime detection</em><br><strong>Purpose:</strong> Create <code>Scripting.Dictionary</code>, add built-in migration mappings (example <code>1.0.0|1.1.0</code>), detect <code>ADODB.Stream</code> availability, set <code>ModuleInitialized</code> and <code>Randomize</code> seed.<br><strong>Signature:</strong> <code>RegisterBuiltInMigrations() -&gt; Void</code>.<br><strong>Behavior:</strong> Attempts <code>CreateObject(&quot;Scripting.Dictionary&quot;)</code>. On failure logs and disables migrations. Adds example migration <code>Migrate_v1_0_0_to_v1_1_0</code>. Detects ADODB.Stream availability and logs fallback for UTF-8 conversion. Sets <code>ModuleInitialized = True</code> and <code>MigrationRegistryInitialized = True</code> when successful.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates module state and logs. <br><strong>Tests:</strong> Environments with/without Scripting.Dic and ADODB.Stream. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>BuildMigrationPath(currentVersion,targetVersion)</strong> — <em>deterministic path builder with loop protection</em><br><strong>Purpose:</strong> Build ordered collection of migration routine names to go from <code>currentVersion</code> to <code>targetVersion</code> using <code>MigrationRegistry</code>. Deterministic tie-breaker uses lexicographic smallest <code>toVersion</code>. Safety loop limit prevents infinite loops.<br><strong>Signature:</strong> <code>BuildMigrationPath(currentVersion As String, targetVersion As String) -&gt; Collection | Nothing</code>.<br><strong>Behavior:</strong> If <code>MigrationRegistry</code> not initialized return Nothing. Iterative loop: if direct <code>cur|target</code> key exists add its routine and finish. Else, scan all registry keys where left side equals <code>cur|*</code>, pick candidate with lexicographically smallest <code>toVersion</code>. Add its routine and set <code>cur = candidateTo</code>. Repeat until <code>cur == targetVersion</code> or safety limit (100) reached. If path empty or fails return Nothing. <br><strong>Complexity:</strong> O(E * K) where E = registry entries, K = length of path (E small).<br><strong>Failure modes:</strong> No path found, cycles prevented by safety limit. Tests: Build chain across multiple hops; tie-breaker determinism test when multiple next-hops exist. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RunMigrations(currentVersion,targetVersion)</strong> — <em>orchestrate pure migration steps and commit</em><br><strong>Purpose:</strong> Construct migration path and execute each pure migration routine; each returned XML must be saved via <code>SaveConfigXML</code> (atomic commit). Returns Boolean success.<br><strong>Signature:</strong> <code>RunMigrations(currentVersion As String, targetVersion As String) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Ensures module init; calls <code>BuildMigrationPath</code> to get ordered routines. For each routine name: uses <code>Select Case</code> to call the corresponding pure function with <code>LoadConfigXML()</code> (current config) and receives <code>newXml</code>. If <code>newXml</code> is empty -> fail. Calls <code>SaveConfigXML(newXml)</code> to commit. If any Save fails -> fail. If all succeed return True. Logs progress and errors. <br><strong>Complexity:</strong> Sum of migration routine costs + <code>SaveConfigXML</code> I/O. <br><strong>Side-effects:</strong> Commits new config parts via <code>SaveConfigXML</code>. <br><strong>Failure modes:</strong> Unknown routine name, migration returns empty, <code>SaveConfigXML</code> failure. Tests: path with single builtin migration; unsuccessful migration where Save fails; unknown routine name logged as error. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Migrate_v1_0_0_to_v1_1_0(currentXml)</strong> — <em>pure migration example</em><br><strong>Purpose:</strong> Example pure migration routine transforming SchemaVersion and template tag attributes without side-effects. Input: <code>currentXml</code> string. Output: transformed XML string or empty on error.<br><strong>Signature:</strong> <code>Migrate_v1_0_0_to_v1_1_0(currentXml As String) -&gt; String</code>.<br><strong>Behavior:</strong> Reads existing SchemaVersion via <code>ExtractSchemaVersionFromXML</code>. If present replaces with <code>1.1.0</code>. If not present inserts <code>&lt;SchemaVersion&gt;1.1.0&lt;/SchemaVersion&gt;</code> after XML declaration. Updates <code>&lt;Templates&gt;</code> to <code>&lt;Templates version=&quot;1.1.0&quot;&gt;</code> if tag found. Returns new XML. Pure function: must not call Save/Backup or other side-effects. <br><strong>Complexity:</strong> O(len(xml)).<br><strong>Failure modes:</strong> Malformed XML — routine returns empty and logs via <code>Call LogAudit</code>. Tests: fixture migration checks (present in <code>RunConfigSelfTests</code>).<br><strong>Notes:</strong> Migration routines are critical to remain pure and deterministic to allow easy testing and reliable rollbacks. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ComputeChecksumForCustomXMLPart(part As CustomXMLPart)</strong> — <em>compute canonical checksum (SHA256 → CRC32 fallback)</em><br><strong>Purpose:</strong> Compute a deterministic checksum string for a CustomXMLPart; prefer SHA256 via certutil (Windows) and fall back to CRC32 (UTF-8 bytes) when SHA not available. Normalizes to lowercase.<br><strong>Signature:</strong> <code>ComputeChecksumForCustomXMLPart(part) -&gt; String</code> (lowercase hex; CRC32 8-hex when fallback).<br><strong>Behavior:</strong> Calls <code>ComputeSHA256_UsingCertUtil(part.xml)</code> and if empty calls <code>ComputeCRC32String(part.xml)</code> with audit log that SHA unavailable. Ensures lowercase returned. On unexpected errors returns CRC32 of <code>part.xml</code> in <code>ErrHandler</code> fallback.<br><strong>Complexity:</strong> SHA path involves writing temp file & invoking external <code>certutil</code> → O(n) file write + external process latency. CRC32 uses <code>StrToUtf8Bytes</code> conversion and byte loop O(n).<br><strong>Side-effects:</strong> May create temp file and spawn <code>certutil</code> (external process) on Windows. <br><strong>Failure modes:</strong> certutil missing or blocked; ADODB unavailable affecting UTF-8 conversion (Code falls back to ANSI StrConv). Tests: path where certutil available; path where certutil fails -> CRC32 returned and audit logged. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ComputeSHA256_UsingCertUtil(ByVal s As String)</strong> — <em>Windows certutil-based SHA256</em><br><strong>Purpose:</strong> Compute SHA256 by writing <code>s</code> to temp file then running <code>certutil -hashfile &lt;file&gt; SHA256</code> and parsing StdOut for 64 hex characters. Returns 64-hex lowercase string or empty on failure/timeouts.<br><strong>Signature:</strong> <code>ComputeSHA256_UsingCertUtil(s As String) -&gt; String</code>.<br><strong>Behavior & robustness details:</strong><br>- Determine safe temp folder via <code>GetSafeTempFolder</code> with fallbacks.<br>- Create unique temp filename with timestamp+random suffix.<br>- Write <code>s</code> to file Binary Access Write.<br>- Use <code>WScript.Shell.Exec(&quot;cmd /c certutil -hashfile &quot;&quot;fname&quot;&quot; SHA256&quot;)</code> and wait with timeout guard (~10s), using <code>DoEvents</code> loop. If timeout -> attempt <code>execObj.Terminate</code> and continue graceful failure path.<br>- Read <code>StdOut.ReadAll</code>, <code>KillSafe</code> the temp file, parse lines for a 64-hex substring; if found return lowercased 64-hex; else attempt to strip non-hex characters to extract 64 hex. If not found return empty string.<br><strong>Complexity:</strong> IO + external process; network independent. <br><strong>Side-effects / security:</strong> Spawns <code>certutil</code> process and writes a temp file which is removed. Ensure antivirus does not block <code>certutil</code> execution. <br><strong>Failure modes:</strong> <code>WScript.Shell</code> unavailable (server/maclient), <code>certutil</code> missing (non-Windows), cmd launch blocked, execution times out, output unparseable. In each case function returns <code>&quot;&quot;</code> and caller falls back to CRC32.<br><strong>Tests:</strong> Windows environment with certutil; environment without certutil or blocked process; output parsing robustness (simulate noisy STDOUT).<br><strong>Notes:</strong> Use of external CLI introduces OS-dependency; code already falls back safely. Consider future replacement with AVAPI/Win32 crypto calls exposed via COM for less process overhead. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>ComputeCRC32String(ByVal s As String)</strong> — <em>deterministic CRC32 fallback</em><br><strong>Purpose:</strong> Compute CRC32 hex string (8 hex lowercase) over UTF-8 encoded bytes of <code>s</code> (attempt ADODB.Stream; fallback to ANSI bytes). Deterministic and fast compared to external SHA path.<br><strong>Signature:</strong> <code>ComputeCRC32String(s As String) -&gt; String</code>.<br><strong>Behavior:</strong> Build CRC table <code>CRC32Table()</code>, get byte array via <code>StrToUtf8Bytes(s)</code>; iterate bytes performing CRC algorithm, produce 8-hex zero-padded lowercase string. Logs nothing on success. <br><strong>Complexity:</strong> O(n) bytes processed. <br><strong>Notes:</strong> Not cryptographically secure but used as robust fallback to detect accidental equality/tamper. Tests: known CRC values for test strings; Unicode inputs (UTF-8 path vs ANSI fallback). </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>CRC32Table()</strong> — <em>table generator for CRC32</em><br><strong>Purpose:</strong> Build 256-entry CRC32 lookup table used by <code>ComputeCRC32String</code>.<br><strong>Signature:</strong> <code>CRC32Table() -&gt; Long()</code>.<br><strong>Behavior:</strong> Standard polynomial 0xEDB88320 generation. Returns array(1 to 256) of Long values. Deterministic and pure. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>StrToUtf8Bytes(s As String)</strong> — <em>string → UTF-8 bytes with ADODB fallback</em><br><strong>Purpose:</strong> Convert VBA <code>String</code> to byte() representing UTF-8 encoding if <code>ADODB.Stream</code> available; else fallback deterministically to ANSI <code>StrConv(..., vbFromUnicode)</code>.<br><strong>Signature:</strong> <code>StrToUtf8Bytes(s As String) -&gt; Byte()</code>.<br><strong>Behavior:</strong> If <code>ADODBAvailable</code> then <code>CreateObject(&quot;ADODB.Stream&quot;)</code>, set <code>.Type=2</code>, <code>.Charset=&quot;utf-8&quot;</code>, <code>.WriteText s</code>, set <code>.Position=0</code>, <code>.Type=1</code> and <code>Read</code> bytes into result. Else <code>tmp = StrConv(s, vbFromUnicode)</code>. On errors cleans up and returns ANSI bytes. <br><strong>Complexity:</strong> O(n).<br><strong>Failure modes:</strong> ADODB not present -> falls back; ADODB present but fails -> fallback to ANSI with audit earlier in <code>RegisterBuiltInMigrations</code>. Tests: UTF-8 result expected when ADODB available (e.g., emoji/diacritics preserved). <br><strong>Notes:</strong> ADODB Stream usage is standard in VBA for UTF-8; fallback provides determinism for environments lacking ADODB. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>EscapeXml(s As String)</strong> — <em>simple XML escaping</em><br><strong>Purpose:</strong> Replace <code>&amp; &lt; &gt; &quot; &#x27;</code> with XML entities for safe insertion into constructed XML strings.<br><strong>Signature:</strong> <code>EscapeXml(s) -&gt; String</code>.<br><strong>Behavior:</strong> <code>Replace</code> calls for <code>&amp;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&quot;</code> and <code>&#x27;</code>. Deterministic and pure. <br><strong>Tests:</strong> Strings with <code>&lt;&gt;&amp;&quot;&#x27;</code> produce correct entities. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>PropExists(propName As String)</strong> — <em>safe document property probe</em><br><strong>Purpose:</strong> Return True if <code>ThisWorkbook.CustomDocumentProperties(propName)</code> exists. Uses <code>On Error Resume Next</code> to avoid exceptions from missing prop access.<br><strong>Signature:</strong> <code>PropExists(propName) -&gt; Boolean</code>.<br><strong>Behavior:</strong> Try to <code>Set p = ThisWorkbook.CustomDocumentProperties(propName)</code> and inspect <code>Err.Number</code>. Returns boolean accordingly. <br><strong>Notes:</strong> Minimal function used by several file paths to avoid exceptions. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetThisAddinSchemaVersion()</strong> — <em>single-source schema version</em><br><strong>Purpose:</strong> Return the add-in schema version string <code>&quot;1.1.0&quot;</code> (single source-of-truth used by <code>EnsureConfigSchema</code>).<br><strong>Signature:</strong> <code>GetThisAddinSchemaVersion() -&gt; String</code>.<br><strong>Notes:</strong> Bump this when releasing schema changes; migration registry must be updated to cover upgrades. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetSafeTempFolder()</strong> — <em>resolve safe temp folder w/ mac fallback</em><br><strong>Purpose:</strong> Determine a writable temporary folder using fallback order: environment TEMP/TMP -> <code>ThisWorkbook.Path</code> -> <code>Application.DefaultFilePath</code> -> macOS <code>MacScript(&quot;return POSIX path of (path to temporary items)&quot;)</code> fallback. Returns folder path string or empty string if none found.<br><strong>Signature:</strong> <code>GetSafeTempFolder() -&gt; String</code>.<br><strong>Behavior:</strong> Iterates candidate sources, returns first non-empty. On macOS trims trailing slash. Uses <code>On Error Resume Next</code> liberally. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Uses <code>MacScript</code> on macOS which may be blocked in some environments. <br><strong>Tests:</strong> Windows with ENV set; workbook path only; macOS detection returns POSIX path. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>GetCorrelationId()</strong> — <em>small operational id generator</em><br><strong>Purpose:</strong> Return deterministic-ish correlation id <code>YYYYMMDD_HHNNSS_random6</code> for audits/backups.<br><strong>Signature:</strong> <code>GetCorrelationId() -&gt; String</code>.<br><strong>Behavior:</strong> Uses <code>Now</code> with <code>Format</code> and <code>Rnd()</code> seeded by <code>Randomize</code>. Not cryptographically random. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>EnsureModuleInitialized()</strong> — <em>module init guard & runtime probes</em><br><strong>Purpose:</strong> Idempotent initialization: calls <code>RegisterBuiltInMigrations</code> and probes <code>Scripting.Dictionary</code> and <code>ADODB.Stream</code> if not yet initialized. Sets <code>ModuleInitialized</code> true and logs degradations.<br><strong>Signature:</strong> <code>EnsureModuleInitialized() -&gt; Void</code>.<br><strong>Behavior:</strong> If <code>ModuleInitialized</code> True → return. Else try to create <code>Scripting.Dictionary</code> and <code>ADODB.Stream</code> and set flags. Calls <code>Randomize</code>. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Called by many public functions to lazily initialize. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>RunConfigSelfTests()</strong> — <em>in-module self-test harness for CI/manual verification</em><br><strong>Purpose:</strong> Execute a curated set of deterministic tests exercising migrations, atomic save, checksum fallback, export/import roundtrip, and write results to worksheet <code>_IFRS_TestResults</code>. Also logs an audit entry. Useful for CI/QA manual verification on developer machines.<br><strong>Signature:</strong> <code>RunConfigSelfTests() -&gt; Sub</code> (writes tests and may modify workbook by creating <code>_IFRS_TestResults</code> worksheet, and calls <code>SaveConfigXML</code> as part of tests).<br><strong>Behavior & tests included:</strong><br>- Migration fixture v1.0.0→v1.1.0.<br>- Atomic save + checksum normal flow (calls <code>SaveConfigXML</code>).<br>- Simulated checksum mismatch restore (corrupting a part in-memory and calling <code>SaveConfigXML</code>).<br>- Certutil absent → CRC32 fallback detection (<code>ComputeSHA256_UsingCertUtil</code> + <code>ComputeCRC32String</code>).<br>- Export/import roundtrip (writes and reads a temp file using <code>GetSafeTempFolder</code>).<br>Writes results table to worksheet <code>_IFRS_TestResults</code> with PASS/FAIL notes and logs final audit. Gracefully logs on error. <br><strong>Complexity:</strong> Dependent on invoked Save/IO operations. <br><strong>Side-effects:</strong> Creates or writes <code>_IFRS_TestResults</code> worksheet, creates temp files, modifies CustomXMLParts during test. Should not be run in production without consent. <br><strong>Tests:</strong> The function itself is a test suite; run in a disposable workbook or CI sandbox. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>KillSafe(fname As String)</strong> — <em>safe file delete</em><br><strong>Purpose:</strong> Attempt to <code>Kill</code> (delete) file, swallow errors. Utility used by file-cleanup flows. <br><strong>Signature:</strong> <code>KillSafe(fname) -&gt; Void</code>.<br><strong>Behavior:</strong> <code>On Error Resume Next</code> then <code>Kill fname</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsHexString(s, expectedLen)</strong> — <em>validate hex string</em><br><strong>Purpose:</strong> Return True if <code>s</code> contains at least <code>expectedLen</code> hex characters <code>[0-9a-fA-F]</code>. Used to validate parsed certutil output.<br><strong>Signature:</strong> <code>IsHexString(s As String, expectedLen As Long) -&gt; Boolean</code>.<br><strong>Complexity:</strong> O(expectedLen).<br><strong>Notes:</strong> Conservative check used in <code>ComputeSHA256_UsingCertUtil</code>. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>IsArrayAllocatedByte(arr() As Byte)</strong> — <em>VBA array allocation probe</em><br><strong>Purpose:</strong> Safely detect whether a <code>Byte()</code> array is allocated without triggering errors. Uses <code>LBound(arr)</code> in protected <code>On Error</code> block.<br><strong>Signature:</strong> <code>IsArrayAllocatedByte(arr() As Byte) -&gt; Boolean</code>.<br><strong>Notes:</strong> Helper used by CRC32 implementation to avoid runtime errors when <code>StrToUtf8Bytes</code> returns an empty/unallocated array. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Developer & security notes (summary)</strong><br>- <strong>Checksum-first policy:</strong> The module prefers stored checksum verification before declaring a canonical part. If mismatch -> backup + audit + empty return so caller handles replace; this minimizes silent corruption.<br>- <strong>Atomic write semantics:</strong> Two-stage write (tmpPart -> canonical newPart) followed by verify then prune ensures atomicity despite COM idiosyncrasies. <br>- <strong>Platform fallbacks:</strong> <code>ComputeSHA256_UsingCertUtil</code> is Windows-specific; CRC32 fallback + ADODB fallback to ANSI ensures the functions operate cross-platform albeit with different guarantees. <br>- <strong>Migrations:</strong> Routines are intentionally pure and must remain side-effect free; <code>RunMigrations</code> performs commits. Adding migrations requires <code>RegisterMigration</code> or editing <code>RegisterBuiltInMigrations</code> and adding <code>Select Case</code> branches. <br>- <strong>Telemetry & PII:</strong> Backups and exported XML may contain sensitive data; treat backups carefully and avoid automated telemetry with raw backups. <br>- <strong>Tests & CI:</strong> <code>RunConfigSelfTests</code> mutates workbook; run in isolated/CI contexts. Add unit tests around <code>tokenizer</code>-style functions if extended. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Recommended tests / QA checklist (concise)</strong><br>1. Save->Load roundtrip with SHA available and absent (force CRC fallback).<br>2. Corrupt-after-write scenario: ensure <code>SaveConfigXML</code> fails verify and original parts restored / backup created.<br>3. Migration happy path and failure path (unknown migration routine).<br>4. Export/import roundtrip to temp file. <br>5. <code>FindConfigPart</code> with multiple parts and stored-checksum present/absent.<br>6. <code>StrToUtf8Bytes</code> producing UTF-8 when ADODB present (emoji test).<br>7. <code>ComputeSHA256_UsingCertUtil</code> parsing various <code>certutil</code> outputs (noisy STDOUT).<br>8. <code>RunConfigSelfTests</code> runs without uncaught errors in a disposable workbook. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Maintenance & upgrade guidance (concise)</strong><br>- Do not change tokenizer/serialization of config XML without migration routine. Schema bumps must be accompanied by pure migration functions and added to <code>RegisterBuiltInMigrations</code> and <code>RunMigrations</code> <code>Select Case</code>.<br>- If moving away from <code>certutil</code>, replace with native crypto COM or a signed binary to avoid cmd/exec issues.<br>- When adding new public functions, preserve aliases (<code>LoadConfig</code>/<code>SaveConfig</code>) for backward compatibility or increment API major version.<br>- Consider adding <code>maxRetries</code>/lock/backoff if concurrent add-in instances might race on CustomXMLPart writes. </td></tr><tr><td data-label="Technical breakdown (modConfig)"> <strong>Final summary (one paragraph)</strong><br>This <code>modConfig</code> implements robust, defensive configuration management for an Excel Add-in: checksum-first load, atomic write/verify semantics, deterministic migration registry with lexicographic tie-breaking, and pragmatic platform fallbacks for SHA and UTF-8 encoding. The module favors safety (backup + audit on mismatch), deterministic behavior (pure migration functions, single canonical part after success) and diagnostics (self-tests, correlation ids). Key operational risks are reliance on <code>certutil</code> on Windows and possible ADODB absence — both handled by fallbacks but worth addressing for production hardening. </td></tr></tbody></table></div><div class="row-count">Rows: 42</div></div><div class="table-caption" id="Table6" data-table="Docu_0158_06" style="margin-top:2mm;margin-left:3mm;"><strong>Table 6</strong></div>
<div class="table-wrapper" data-table-id="table-6"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Technical breakdown (modDataInput)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Technical breakdown (modDataInput)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Overview:</strong> Exhaustive per-function technical breakdown for the <code>modDataInput</code> VBA module supplied. Each entry documents: purpose, signature (inputs/outputs), internal behaviour, complexity, side-effects, invariants, failure modes, security/path considerations, recommended tests, and maintainer notes. Use as authoritative inline documentation for reviewers, auditors and QA. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ImportTrialBalance</strong> — <em>back-compat shim entrypoint</em><br><strong>Purpose:</strong> Public, backward-compatible basic entry to the import pipeline; delegates to <code>ImportTrialBalanceAdvanced</code> with default args and centralized error handling.<br><strong>Signature:</strong> <code>Public Sub ImportTrialBalance()</code> — no return.<br><strong>Behavior:</strong> Calls <code>ImportTrialBalanceAdvanced(&quot;sheet&quot;, &quot;&quot;, Nothing, &quot;&quot;, False)</code> inside <code>On Error GoTo ErrHandler</code>. On error calls external <code>HandleError</code> with module and runtime error.<br><strong>Complexity:</strong> O(1) (delegator).<br><strong>Side-effects:</strong> Triggers full import pipeline when <code>ImportTrialBalanceAdvanced</code> runs.<br><strong>Invariants:</strong> Preserves existing public API surface; must remain stable.<br><strong>Failure modes:</strong> Any failure is caught and reported using <code>HandleError</code>.<br><strong>Tests:</strong> Call when no workbook active, when workbook active; confirm <code>HandleError</code> invoked on simulated error (mock).<br><strong>Notes:</strong> Keep signature stable for external calls; do not add optional parameters. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ValidateCOA</strong> — <em>COA quick validator (stub)</em><br><strong>Purpose:</strong> Lightweight check to ensure an account code string is non-empty (placeholder for real COA validation).<br><strong>Signature:</strong> <code>Public Function ValidateCOA(accountCode As String) As Boolean</code><br><strong>Behavior:</strong> Returns <code>True</code> if trimmed <code>accountCode</code> length > 0; on error returns <code>False</code> and calls <code>HandleError</code>.<br><strong>Complexity:</strong> O(len(accountCode)).<br><strong>Side-effects:</strong> None (pure).<br><strong>Invariants:</strong> Returns False for empty/whitespace input.<br><strong>Failure modes:</strong> None aside from unexpected runtime error (reported).<br><strong>Tests:</strong> Empty, whitespace-only, valid string. Replaceable by pluggable rule validation. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ImportTrialBalanceAdvanced</strong> — <em>full hardened import pipeline</em><br><strong>Purpose:</strong> Single authoritative import pipeline handling multiple source types (sheet/csv/workbook/json/powerquery), staging, validation, preview, commit, audit, and locking. Backwards-compatible public API used by UI and scheduled jobs.<br><strong>Signature:</strong> <code>Public Sub ImportTrialBalanceAdvanced(Optional sourceType As String = &quot;sheet&quot;, Optional sourcePath As String = &quot;&quot;, Optional targetWb As Workbook = Nothing, Optional profileName As String = &quot;&quot;, Optional dryRun As Boolean = False, Optional allowOverwrite As Boolean = False)</code><br><strong>Behavior (high-level):</strong><br>- Generate correlation id, resolve target workbook.<br>- Acquire import lock (workbook-level) with <code>AcquireImportLock</code> (best-effort fail if busy).<br>- Read source according to <code>sourceType</code> (delegates to <code>ReadFromActiveSheetToArray</code>, <code>ReadCsvToArray</code>, <code>ReadWorkbookRangeToArray</code>, <code>ReadJsonToArray</code>, <code>ReadFromPowerQueryStub</code>). Path inputs policy-checked with <code>IsAllowedPath</code> before file access.<br>- Create/ensure staging sheet (<code>CreateOrEnsureStagingSheet</code>), write array atomically (<code>WriteArrayToSheetAtomic</code>). Ensure staging schema token (<code>EnsureStagingSchema</code>) and assign stable row IDs (<code>AssignStableRowIDs</code>).<br>- Produce preview (<code>PreviewImport</code>) and run schema-driven validations (<code>ValidateStagingSheetSchemaDriven</code>). If validation errors present, write errors (<code>WriteErrorsToSheet</code>), audit, and abort unless <code>dryRun</code> true.<br>- If <code>dryRun</code> true, audit and exit; otherwise <code>CommitStagingToDestination</code> with optional <code>allowOverwrite</code> and audit commit.<br>- Always attempt to release lock in <code>CleanExit</code> and on error path.<br><strong>Complexity:</strong> Dominated by read operation (I/O, CSV parsing) and <code>WriteArrayToSheetAtomic</code> O(rows*cols).<br><strong>Side-effects:</strong> Reads external files, modifies workbook (staging, preview, destination), creates backup sheets, writes audit via <code>LogAudit</code>, creates/deletes very-hidden sheets for locks and backups.<br><strong>Invariants:</strong> After successful commit, staging renamed to committed token; backups created for overwritten destinations. CorrelationID propagated to audit calls.<br><strong>Failure modes:</strong> File not found or inaccessible, path not allowed, CSV/JSON parse failures, validation errors, workbook lock present, inability to manipulate worksheets (protected/workbook read-only), errors in helper functions. Pipeline uses <code>HandleError</code> to report and best-effort lock release.<br><strong>Security:</strong> Uses <code>IsAllowedPath</code> to block privileged system paths; however filepath policy is coarse — requires review for environment-specific constraints. Avoid running with elevated privileges.<br><strong>Recommended tests:</strong> All <code>sourceType</code> variants (sheet/csv/xlsx/json/powerquery), large file streaming path (>STREAMING_THRESHOLD_BYTES), invalid paths, validation error injection, dryRun vs commit, overwrite toggles, concurrent import lock scenario, failure during commit to verify lock release and backups.<br><strong>Notes:</strong> Critical function—changes require staged rollouts and heavy regression tests. Ensure <code>HandleError</code> and <code>LogAudit</code> are robust. Consider improving <code>IsAllowedPath</code> to use whitelist and canonical path resolution. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadFromActiveSheetToArray</strong> — <em>read a named sheet into Variant array</em><br><strong>Purpose:</strong> Read used range from named sheet in given workbook and return as variant array (or Empty on failure).<br><strong>Signature:</strong> <code>Private Function ReadFromActiveSheetToArray(ByVal wb As Workbook, ByVal sheetName As String) As Variant</code><br><strong>Behavior:</strong> Safely get worksheet via <code>SafeGetWorksheet</code>. Read <code>UsedRange</code> and return <code>.Value</code>. Uses <code>On Error GoTo ErrHandler</code> and returns <code>Empty</code> if missing or error.<br><strong>Complexity:</strong> O(#cells returned).<br><strong>Side-effects:</strong> None (reads only).<br><strong>Invariants:</strong> Returns <code>Empty</code> for empty sheet or inaccessible sheet.<br><strong>Failure modes:</strong> Protected sheet but accessible via <code>SafeGetWorksheet</code>? If <code>UsedRange</code> fails, returns <code>Empty</code>.<br><strong>Tests:</strong> Existing named sheet with data, missing sheet, sheet with 0 used cells. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadCsvToArray</strong> — <em>robust CSV file reader with streaming</em><br><strong>Purpose:</strong> Read CSV from filesystem, handle BOMs, large files (streaming), quoted fields with embedded newlines and return 2D Variant array (rows×cols) or <code>Empty</code> on failure.<br><strong>Signature:</strong> <code>Public Function ReadCsvToArray(ByVal fullPath As String) As Variant</code><br><strong>Behavior (detailed):</strong><br>- Validate <code>fullPath</code>; open file in Binary mode; determine <code>LOF</code>; read as whole or via <code>ReadBinaryStreamAsString</code> when size > <code>STREAMING_THRESHOLD_BYTES</code>.<br>- Normalize line endings/BOM via <code>NormalizeTextNewlinesAndBOM</code>.<br>- Build logical records using <code>BuildCsvLogicalRecords</code> (state machine that respects quoted newlines and doubled quotes).<br>- Determine maximum columns by splitting each record with <code>SplitCsvLine_Strict</code>, allocate <code>out(1..rCount,1..cMax)</code> and fill row/col values; returns 1-based 2D array.<br>- Always closes file and handles errors with <code>HandleError</code> and returns <code>Empty</code> on error.<br><strong>Complexity:</strong> O(file size + total parsed cells). Memory bound by <code>out</code> array; streaming threshold reduces memory pressure for reading raw string but full <code>out</code> still kept in memory.<br><strong>Side-effects:</strong> Reads disk; none to workbook.<br><strong>Invariants:</strong> Each returned row has <code>cMax</code> columns (empty strings where missing). Field trimming applies to unquoted fields (see <code>SplitCsvLine_Strict</code>).<br><strong>Failure modes:</strong> Malformed CSV that breaks parser (should be robust), binary files incorrectly decoded as VBA String, BOM handling errors, memory exhaustion for extremely large files. File locked/inaccessible produces <code>Empty</code> and <code>HandleError</code> call.<br><strong>Security:</strong> Uses <code>IsAllowedPath</code> upstream; ensure path canonicalization before call in public API.<br><strong>Tests:</strong> Simple CSV, quoted fields with embedded newlines, escaped double quotes, trailing commas, empty fields, very large file > STREAMING_THRESHOLD_BYTES, BOM variants (UTF-8, UTF-16 LE/BE). Validate column alignment. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadBinaryStreamAsString</strong> — <em>chunked binary reader</em><br><strong>Purpose:</strong> Read a large binary file in blocks and concatenate into a VBA String to reduce single-call memory overhead.<br><strong>Signature:</strong> <code>Private Function ReadBinaryStreamAsString(ByVal fnum As Long, ByVal totalBytes As Long) As String</code><br><strong>Behavior:</strong> Loops reading <code>blockSize</code> (65536) blocks via <code>Get #fnum, , buffer</code>, concatenates into <code>result</code>, returns string. Handles errors and returns <code>&quot;&quot;</code> on error.<br><strong>Complexity:</strong> O(totalBytes).<br><strong>Side-effects:</strong> Advances file read pointer; caller must close file.<br><strong>Failure modes:</strong> Memory growth when <code>result</code> becomes large; VBA string concatenation can be inefficient for extremely large files (consider using ADODB.Stream in environments that support it).<br><strong>Tests:</strong> Read file sized exactly blockSize, non-multiple sizes, very large file. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>NormalizeTextNewlinesAndBOM</strong> — <em>clean line endings and strip BOMs</em><br><strong>Purpose:</strong> Convert CRLF/CR to LF and remove common BOMs (UTF-8 EF BB BF, UTF-16 LE/BE) and null bytes produced from UTF-16 read as binary.<br><strong>Signature:</strong> <code>Private Function NormalizeTextNewlinesAndBOM(ByVal txt As String) As String</code><br><strong>Behavior:</strong> Detects leading BOM byte sequences by <code>Asc(Mid$(...))</code> checks; strips BOM and null characters for UTF-16; replaces <code>vbCrLf</code> and <code>vbCr</code> with <code>vbLf</code>.<br><strong>Complexity:</strong> O(len(txt)).<br><strong>Side-effects:</strong> None external.<br><strong>Invariants:</strong> Output uses <code>vbLf</code> only for line separators and contains no leading BOMs or <code>vbNullChar</code> when strip logic applies.<br><strong>Failure modes:</strong> Non-text binary files—function still returns processed string possibly corrupted; callers should validate file type. UTF-16 detection depends on reading raw bytes into a VBA String—this can mis-detect in some hosts.<br><strong>Tests:</strong> Strings with CRLF, CR-only, UTF-8 BOM, UTF-16 LE/BE BOM with nulls. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>BuildCsvLogicalRecords</strong> — <em>state-machine to assemble CSV records</em><br><strong>Purpose:</strong> Convert normalized CSV text into logical record strings where record boundaries ignore LFs inside quoted fields.<br><strong>Signature:</strong> <code>Private Function BuildCsvLogicalRecords(ByVal raw As String) As Collection</code><br><strong>Behavior:</strong> Iterates characters, toggles <code>inQuotes</code> on un-escaped quotes, treats doubled <code>&quot;&quot;</code> as escaped quote, accumulates <code>sb</code>, and when encountering <code>vbLf</code> outside quotes commits record (<code>sb</code> without trailing LF). Returns <code>Collection</code> of record strings. Adds final partial record if non-empty.<br><strong>Complexity:</strong> O(len(raw)).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Each collection item corresponds to a CSV logical row; embedded newlines remain inside record strings.<br><strong>Failure modes:</strong> Extremely large raw strings may exhaust memory. Resilient to malformed quotes (will toggle inQuotes which could produce unexpected grouping).<br><strong>Tests:</strong> Lines with embedded newlines inside quoted fields, doubled quotes, last record without trailing LF. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SplitCsvLine_Strict</strong> — <em>RFC-like CSV field splitter</em><br><strong>Purpose:</strong> Strict per-line CSV splitter that handles quoted fields, doubled quotes, trailing commas and trims unquoted fields.<br><strong>Signature:</strong> <code>Private Function SplitCsvLine_Strict(ByVal line As String) As String()</code><br><strong>Behavior:</strong> Character-by-character FSM: starts/ends quoted fields, treats <code>&quot;&quot;</code> as escaped quote inside quoted field, splits on commas outside quotes. If field was quoted, value preserved (including internal whitespace); otherwise <code>Trim$</code> applied. Returns zero-based string array of fields. On error returns single empty string array.<br><strong>Complexity:</strong> O(len(line)).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Quoted field preserves inner spaces; unquoted trimmed. Escaped quotes become single <code>&quot;</code>.<br><strong>Failure modes:</strong> Non-standard CSV flavours (multichar separators) unsupported; malformed quotes might be handled best-effort.<br><strong>Tests:</strong> Quoted fields with commas/newlines/double quotes, trailing commas producing empty fields, unquoted fields with spaces trimmed. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadWorkbookRangeToArray</strong> — <em>open workbook and read first worksheet used range</em><br><strong>Purpose:</strong> Open external workbook (if not already open), read <code>Worksheets(1).UsedRange</code> into a Variant array, and close workbook if opened by this function. Implements retry for transient file open failures.<br><strong>Signature:</strong> <code>Public Function ReadWorkbookRangeToArray(ByVal workbookPath As String) As Variant</code><br><strong>Behavior:</strong> Validates path, attempts to locate workbook in <code>Workbooks</code> collection by name, otherwise opens with <code>Workbooks.Open(..., ReadOnly:=True)</code> with retry loop up to <code>MAX_OPEN_RETRIES</code> with waits <code>SleepMs</code>. Returns used range <code>.Value</code> or <code>Empty</code>. Ensures opened workbook closed if function opened it.<br><strong>Complexity:</strong> O(size of used range + costs to open workbook).<br><strong>Side-effects:</strong> May open external workbook and close it; does not alter source workbook.<br><strong>Invariants:</strong> If <code>opened</code> flag set, will close with <code>SaveChanges:=False</code> on exit/exception.<br><strong>Failure modes:</strong> File locked/inaccessible, long open times, workbook without worksheets or empty sheet returns <code>Empty</code>.<br><strong>Tests:</strong> File already open, file closed, transient lock simulated forcing retry, workbook with empty sheet, workbook with large used range. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>FilenameOnly</strong> — <em>extract filename from path</em><br><strong>Purpose:</strong> Return filename from full path using <code>Application.PathSeparator</code>.<br><strong>Signature:</strong> <code>Private Function FilenameOnly(ByVal path As String) As String</code><br><strong>Behavior:</strong> Returns substring after last path separator using <code>InStrRev</code>. Returns empty string for empty path. Uses <code>On Error Resume Next</code> defensively.<br><strong>Complexity:</strong> O(len(path)).<br><strong>Tests:</strong> Paths with <code>\</code> or <code>/</code> (host dependent), empty string. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadJsonToArray</strong> — <em>best-effort JSON to 2D array parser</em><br><strong>Purpose:</strong> Parse JSON files that are either array-of-objects or array-of-arrays into an Excel-compatible 2D Variant array. Uses RegExp where available to extract key/value pairs for simple object shapes. Falls back to naive parsing if RegExp not available.<br><strong>Signature:</strong> <code>Public Function ReadJsonToArray(ByVal fullPath As String) As Variant</code><br><strong>Behavior (detailed):</strong><br>- Reads file into <code>txt</code> string; replace newlines/tabs with spaces; quick check for top-level <code>[</code> and <code>]</code> for parsability; if JSON contains objects (<code>{</code>) iterates characters to extract top-level <code>{...}</code> objects by brace counting.<br>- If <code>VBScript.RegExp</code> available, uses a tolerant pattern to extract <code>&quot;key&quot;:value</code> pairs; builds <code>Scripting.Dictionary</code> per object and collects headers (unique keys order-of-first-seen). Otherwise falls back to naive split by commas inside the object body (best-effort).<br>- If input is an array-of-arrays, calls <code>JsonArrayToVBAArray</code> to return a 2D array.<br>- Constructs <code>rows(1..n,1..colCount)</code> with headers in row 1 and object values in subsequent rows; returns <code>Empty</code> on errors.<br><strong>Complexity:</strong> O(len(txt) + #objects * #keys) — parser is not fully JSON-compliant and will fail for complex nested or escaped structures.<br><strong>Side-effects:</strong> None to workbook.<br><strong>Invariants:</strong> Works only for flat objects and simple arrays; outputs header row followed by row values matching header ordering discovered during parsing.<br><strong>Failure modes:</strong> Complex JSON (nested arrays/objects, strings with embedded <code>}</code> or <code>,</code> sequences), strings with escaped quotes or unicode escapes, arrays-of-objects with inconsistent keys — parser may produce incomplete or incorrect results. Reliance on RegExp pattern is brittle. Caller should prefer canonical JSON parser or pre-convert JSON to CSV.<br><strong>Security:</strong> Parsing using regex is fragile and may be exploited with specially crafted input; ensure files are trusted or validated. Do not evaluate any code from file.<br><strong>Tests:</strong> Small arrays-of-objects, arrays-of-arrays, objects with missing keys, large JSON, malformed JSON to verify <code>Empty</code> return. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>JsonArrayToVBAArray</strong> — <em>simple array-of-arrays extractor</em><br><strong>Purpose:</strong> Convert top-level JSON array-of-arrays string into 2D Variant array (best-effort).<br><strong>Signature:</strong> <code>Private Function JsonArrayToVBAArray(ByVal txt As String) As Variant</code><br><strong>Behavior:</strong> Strips outer <code>[]</code>, iterates to find subarray <code>[...]</code> blocks by depth counting, splits each interior by commas (naive), trims quotes, builds 1-based 2D Variant. Not a full JSON parser; intended for simple numeric/string arrays.<br><strong>Complexity:</strong> O(len(txt)).<br><strong>Failure modes:</strong> Fails for nested arrays, commas inside quoted strings; returns <code>Empty</code> on parse failure.<br><strong>Tests:</strong> <code>[[1,2],[3,4]]</code>, <code>[[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]]</code>. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReadFromPowerQueryStub</strong> — <em>placeholder for Power Query integration</em><br><strong>Purpose:</strong> Stub function returning <code>Empty</code>—placeholder to integrate Power Query data extraction per profileName in future.<br><strong>Signature:</strong> <code>Private Function ReadFromPowerQueryStub(ByVal profileName As String) As Variant</code><br><strong>Behavior:</strong> Immediately returns <code>Empty</code>.<br><strong>Notes:</strong> Implementers should replace with actual Power Query connector or OLE/COM bridge. Tests: none. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SafeGetWorksheet</strong> — <em>defensive worksheet getter</em><br><strong>Purpose:</strong> Return Worksheet object for <code>sheetName</code> or <code>Nothing</code> if inaccessible (handles protected/very-hidden by returning object - operations later must handle visibility/unprotect if needed).<br><strong>Signature:</strong> <code>Public Function SafeGetWorksheet(ByVal wb As Workbook, ByVal sheetName As String) As Worksheet</code><br><strong>Behavior:</strong> Defensive <code>On Error</code> attempts to access <code>wb.Worksheets(sheetName)</code> and returns <code>Nothing</code> on error.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> If sheet exists and accessible object returned; does not change visibility. Consumers must treat <code>Nothing</code> as missing. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>CreateOrEnsureStagingSheet</strong> — <em>staging sheet lifecycle manager & migration shim</em><br><strong>Purpose:</strong> Ensure staging worksheet <code>_IFRS_Staging</code> exists; reuse existing, migrate very-hidden backups that contain <code>STAGING_SCHEMA_TOKEN</code>, or create a new very-hidden sheet. On existing sheet, clears contents but preserves A1 schema token if present and keeps original visibility/position.<br><strong>Signature:</strong> <code>Private Function CreateOrEnsureStagingSheet(ByVal wb As Workbook) As Worksheet</code><br><strong>Behavior:</strong><br>- If <code>STAGING_SHEET_NAME</code> exists: read cell A1 token, clear contents while preserving token, restore visibility.<br>- Otherwise iterate <code>wb.Worksheets</code> for <code>xlSheetVeryHidden</code> sheets whose A1 contains <code>STAGING_SCHEMA_TOKEN</code> and re-name to staging (as migration shim).<br>- Else add new worksheet at end and mark <code>xlSheetVeryHidden</code> and name it.<br><strong>Complexity:</strong> O(#sheets) scanning for migration shim.<br><strong>Side-effects:</strong> May change visibility briefly; creates new very-hidden sheets; clears existing staging content (but preserves token cell as implemented).<br><strong>Invariants:</strong> After call, a worksheet reference to staging is returned; when reusing existing sheet the token in A1 may be preserved.<br><strong>Failure modes:</strong> Naming conflicts, protected workbook preventing sheet creation, permission errors; code uses error suppression for name/visibility ops.<br><strong>Tests:</strong> Existing visible staging, existing very-hidden backup with token, no staging present, failure to add sheet (protected workbook). </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>EnsureStagingSchema</strong> — <em>place schema token and canonical header mechanics</em><br><strong>Purpose:</strong> Place the <code>STAGING_SCHEMA_TOKEN</code> in A1, ensure a canonical header row at row 2, and migrate data down if needed (if row 1 contains data after adding token).<br><strong>Signature:</strong> <code>Private Sub EnsureStagingSchema(ByVal stagingWs As Worksheet)</code><br><strong>Behavior:</strong> Sets A1 token; computes <code>lastCol</code>; if top-left region appears to be data (row 1 has other values), shifts used range down by 1 row, clearing old area. Temporarily disables screen updating and events.<br><strong>Complexity:</strong> O(size of used range) when shifting data.<br><strong>Side-effects:</strong> Moves sheet data one row down when needed; may change sheet contents. Uses <code>Application.ScreenUpdating</code> and <code>EnableEvents</code> toggles.<br><strong>Failure modes:</strong> Shifting may be lossy if used range calculation incorrect; concurrency if other code expects data in same positions. Tests: staging sheet with data in row1 becomes header at row2; empty sheet unaffected. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>WriteArrayToSheetAtomic</strong> — <em>fast atomic write with event suppression</em><br><strong>Purpose:</strong> Write a (possibly non 1-based) variant array into <code>ws</code> cells quickly while suppressing screen updates and events to avoid flicker and event recursion.<br><strong>Signature:</strong> <code>Private Sub WriteArrayToSheetAtomic(ByVal ws As Worksheet, ByVal arr As Variant, Optional ByVal trimEmptyCols As Boolean = False)</code><br><strong>Behavior:</strong> If <code>arr</code> not an array, writes single cell. Else normalizes with <code>Normalize2DArrayTo1Based_Flexible</code>, determines <code>rCount</code>/<code>cCount</code>, disables <code>ScreenUpdating</code> and <code>EnableEvents</code>, and writes <code>ws.Range(...).Value = a1</code>. Restores previous <code>Application</code> flags even on error. Uses <code>On Error GoTo ErrHandler</code> for robust restore.<br><strong>Complexity:</strong> O(rows*cols) memory and runtime. Fastest available method in VBA for block writes.<br><strong>Side-effects:</strong> Overwrites target range content; may trigger recalculation on re-enabled events.<br><strong>Invariants:</strong> <code>Application</code> flags are restored on exit/exception.<br><strong>Failure modes:</strong> arr shape mismatches will raise errors; large arrays may exceed worksheet limits (max rows/columns) leading to error. Tests: 1D/2D arrays with different base indices, non-array scalar write. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Normalize2DArrayTo1Based_Flexible</strong> — <em>array shape normalizer</em><br><strong>Purpose:</strong> Take varied array shapes (scalars, 1D 0-based/1-based arrays, or 2D arrays with arbitrary bounds) and return a 1-based 2D Variant array suitable for direct Range writes.<br><strong>Signature:</strong> <code>Private Function Normalize2DArrayTo1Based_Flexible(ByVal arr As Variant) As Variant</code><br><strong>Behavior:</strong> Detects <code>IsArray</code>; if not array, returns 1×1 with <code>Nz(arr,&quot;&quot;)</code>; if 1D builds 1×N array; if 2D copies elements into new 1-based 2D <code>out</code>; raises error for dims >2.<br><strong>Complexity:</strong> O(total elements).<br><strong>Invariants:</strong> Output always 1-based 2D array. Preserves string/numeric values via <code>Nz</code>.<br><strong>Failure modes:</strong> Multi-dimensional arrays >2 dims cause raised error. Tests: 0-based/1-based 1D arrays, 2D arrays with non-1 lower bounds. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>GetArrayDimensions</strong> — <em>detect 1D vs 2D arrays</em><br><strong>Purpose:</strong> Return 1 or 2 for array dimensionality (1 or 2).<br><strong>Signature:</strong> <code>Private Function GetArrayDimensions(ByVal arr As Variant) As Long</code><br><strong>Behavior:</strong> Attempts <code>LBound(arr,1)</code> and <code>LBound(arr,2)</code> using <code>On Error</code> to infer dims. Returns 0 if not array.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> 1D and 2D arrays. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>AssignStableRowIDs</strong> — <em>deterministic stable RowID assignment</em><br><strong>Purpose:</strong> Ensure each data row in staging has a stable unique <code>IFRS_RowID</code> column without overwriting existing IDs. Format: <code>RB-{UTCstamp}-{RowIndex}-{Rand6}</code>.<br><strong>Signature:</strong> <code>Private Sub AssignStableRowIDs(ByVal stagingWs As Worksheet, ByVal correlationID As String)</code><br><strong>Behavior:</strong> Find existing <code>ROWID_HEADER</code> column; if missing, add it to end. Determine <code>lastRow</code>, build <code>existingIds</code> dictionary scanning existing values, then for each data row without ID generate <code>utcStamp = GetUtcStampForId()</code>, generate 6-digit random part, ensure uniqueness against <code>existingIds</code>, write to cell. Logs audit with count assigned.<br><strong>Complexity:</strong> O(rows).<br><strong>Side-effects:</strong> Writes identifiers into staging sheet; uses <code>Randomize</code> then <code>Rnd()</code>; writes log audit.<br><strong>Invariants:</strong> Does not overwrite existing IDs; IDs deterministic format with timestamp and row index; uniqueness ensured by per-run dictionary check and randomized 6-digit suffix.<br><strong>Failure modes:</strong> If multiple processes run simultaneously in same workbook, risk of collision only if rows processed concurrently—lock mechanism should prevent this. <code>GetUtcStampForId</code> may fallback to local time when timezone not available — acceptable but note for cross-host determinism.<br><strong>Tests:</strong> Staging with prepopulated IDs, staging with none, ensure no duplicates and consistent format. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>GetUtcStampForId</strong> — <em>UTC timestamp helper with fallback</em><br><strong>Purpose:</strong> Compute UTC-based timestamp string <code>yyyymmddHHMMSS</code> for row IDs; falls back to local time if <code>Application.TimeZone</code> not present.<br><strong>Signature:</strong> <code>Private Function GetUtcStampForId() As String</code><br><strong>Behavior:</strong> Attempts to read <code>Application.TimeZone</code> (minutes offset) and subtracts offset from <code>Now</code>; formats using <code>Format(ts,&quot;yyyymmddHHMMSS&quot;)</code>. On error returns local formatted <code>Now</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Host may not expose <code>Application.TimeZone</code> consistently; document that timestamp may be local fallback. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>PreviewImport</strong> — <em>create/refresh visible preview sheet</em><br><strong>Purpose:</strong> Copy first N rows from staging into a visible preview sheet <code>_IFRS_Preview</code> for user inspection and auditing.<br><strong>Signature:</strong> <code>Private Sub PreviewImport(ByVal stagingWs As Worksheet, Optional ByVal rowsToShow As Long = 50, Optional ByVal correlationID As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Ensures preview worksheet exists (creates if missing), clears prior content, copies used range subset to preview using array copy for speed, sets preview visible and activates it. Logs audit with row count.<br><strong>Complexity:</strong> O(rowsToShow * cols).<br><strong>Side-effects:</strong> Creates/modifies visible worksheet; may change active sheet. Temporarily toggles Application settings. <br><strong>Invariants:</strong> Preview contains a top portion of staging data. <br><strong>Failure modes:</strong> Protected workbook preventing sheet creation, large <code>rowsToShow</code> exceeding memory. Tests: preview created, preview updated, preview visible. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>CommitStagingToDestination</strong> — <em>atomic commit with backup & audit</em><br><strong>Purpose:</strong> Commit staging contents into destination sheet named <code>destSheetName</code> with optional overwrite safeguard and backup copy creation (very-hidden). Uses array transfer for atomic operation and renames staging to committed token on success.<br><strong>Signature:</strong> <code>Private Sub CommitStagingToDestination(ByVal wb As Workbook, ByVal stagingWs As Worksheet, ByVal destSheetName As String, ByVal allowOverwrite As Boolean, ByVal correlationID As String)</code><br><strong>Behavior:</strong> If destination exists and <code>allowOverwrite</code> false → error. If destination exists and overwriting allowed → copy existing destination to a new sheet named with <code>IMPORT_BACKUP_PREFIX + dest</code> + timestamp and mark <code>xlSheetVeryHidden</code>. If dest missing create new sheet. Copy staging <code>UsedRange.Value</code> into destination via arrays. Rename staging to <code>STAGING_SHEET_NAME &amp; &quot;_COMMITTED_&quot; &amp; timestamp</code>. Log audit.<br><strong>Complexity:</strong> O(rows*cols) for array copy.<br><strong>Side-effects:</strong> Creates very-hidden backup sheet, modifies workbook (dest sheet), renames staging sheet. May delete/rename sheets. Writes audit entries.<br><strong>Failure modes:</strong> Protected workbook preventing copy/delete, naming conflicts when setting backup name, insufficient workbook space, Excel sheet name length limits, failure to create backup leaves risk. Tests: Overwrite allowed/forbidden flows, backup creation and visibility, checksum/round-trip verification. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>UndoLastImport</strong> — <em>restore latest import backup</em><br><strong>Purpose:</strong> Locate latest import backup sheet (by <code>IMPORT_BACKUP_PREFIX</code> timestamp suffix), copy it as visible sheet restoring destination, and perform checksum verification between backup and restored copy; logs audit.</br><strong>Signature:</strong> <code>Public Sub UndoLastImport(Optional ByVal targetWb As Workbook = Nothing)</code><br><strong>Behavior:</strong> Resolves target workbook, scans worksheets for names starting with <code>IMPORT_BACKUP_PREFIX</code>, parses timestamps from name parts into Date via <code>ParseBackupTimestamp</code>, selects latest, determine original destination name from backup name, delete existing destination if present, copy latest backup to end of workbook, rename to original name and make visible. Compute checksum for restored and source backup with <code>ComputeWorksheetChecksum</code> and log mismatch or success. Errors reported via <code>HandleError</code>.<br><strong>Complexity:</strong> O(#sheets + sheet size for checksum).<br><strong>Side-effects:</strong> Deletes existing destination sheet (with <code>Application.DisplayAlerts=False</code>), adds new visible sheet, logs audit.<br><strong>Failure modes:</strong> No backup found, name parsing failures, checksum mismatch, permission errors while deleting destination.<br><strong>Tests:</strong> Single backup, multiple backups with different timestamps, missing backups, corrupted sheets producing checksum mismatch. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ComputeWorksheetChecksum</strong> — <em>deterministic simple checksum</em><br><strong>Purpose:</strong> Compute a reproducible checksum of a worksheet by summing lengths of all cell textual content modulo 2^31-1. Used for round-trip verification on undo/restore.<br><strong>Signature:</strong> <code>Private Function ComputeWorksheetChecksum(ByVal ws As Worksheet) As Long</code><br><strong>Behavior:</strong> Reads <code>UsedRange</code> into array, iterates cells accumulating <code>Len(CStr(Nz(...,&quot;&quot;)))</code>, returns <code>CLng(sum Mod 2147483647)</code>; returns 0 on empty or error.<br><strong>Complexity:</strong> O(#cells).<br><strong>Limitations:</strong> Not cryptographic; collisions possible; sensitive to whitespace and formatting changes; serves as a fast sanity check only.<br><strong>Tests:</strong> Round-trip identical content produces same checksum; changed cell alters checksum. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ValidateStagingSheetSchemaDriven</strong> — <em>row-by-row schema validator</em><br><strong>Purpose:</strong> Validate staging rows against a schema-driven rule set (required, numeric, date, regex optional) and COA validation; returns <code>Scripting.Dictionary</code> of row errors keyed by row number or <code>Nothing</code> on error.<br><strong>Signature:</strong> <code>Private Function ValidateStagingSheetSchemaDriven(ByVal stagingWs As Worksheet, ByVal correlationID As String) As Object</code><br><strong>Behavior:</strong> Builds <code>headers</code> map from row1, constructs <code>rules</code> dictionary (<code>account: required</code>, <code>balance: required,numeric</code>), iterates rows 2..lastRow, applies rules (presence, numeric check), performs <code>ValidateCOA</code> on <code>account</code> values, aggregates <code>rowErrors</code> and adds to returned dictionary with <code>rowIdx</code> as key. If no errors returns empty dictionary. On error returns <code>Nothing</code>.<br><strong>Complexity:</strong> O(rows * rules).<br><strong>Side-effects:</strong> None (reads only).<br><strong>Invariants:</strong> Row numbers in returned dictionary correspond to staging sheet rows. Rule set is in-module and must be updated when schema changes.<br><strong>Failure modes:</strong> Missing header columns cause <code>Header missing</code> errors logged to each row; complex validation requirements require enhancement of <code>rules</code> expression parsing. Tests: missing headers, non-numeric balance, empty account, COA invalid. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>WriteErrorsToSheet</strong> — <em>emit import validation errors to sheet</em><br><strong>Purpose:</strong> Create or clear <code>_IFRS_ImportErrors</code> sheet and write a table of row number, error text, and IFRS_RowID for errors found during validation.<br><strong>Signature:</strong> <code>Private Sub WriteErrorsToSheet(ByVal wb As Workbook, ByVal errorsDict As Object, Optional ByVal correlationID As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Creates <code>IMPORT_ERRORS_SHEET</code> if missing, clears content if exists, writes headers <code>Row</code>, <code>Error</code>, <code>IFRS_RowID</code>, iterates <code>errorsDict</code> and writes rows, makes sheet visible, logs audit with count. Uses <code>SafeGetWorksheet</code> for retrieval.<br><strong>Complexity:</strong> O(#errors).<br><strong>Side-effects:</strong> Modifies/creates visible sheet. <br><strong>Tests:</strong> errorsDict empty; errorsDict with several rows; ensure visibility and content correctness. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>DetectDuplicatesInStaging</strong> — <em>group by key columns to detect duplicates</em><br><strong>Purpose:</strong> Detect duplicate rows by concatenating values from <code>keyColumns</code> (default <code>[&quot;account&quot;,&quot;balance&quot;]</code>) and return <code>Scripting.Dictionary</code> mapping keyVal -> Collection of row indexes where that key occurs.<br><strong>Signature:</strong> <code>Public Function DetectDuplicatesInStaging(ByVal stagingWs As Worksheet, Optional ByVal keyColumns As Variant) As Object</code><br><strong>Behavior:</strong> Build header map, iterate rows 2..lastRow building <code>keyVal</code> by concatenating keys; uses <code>Scripting.Dictionary</code> to collect <code>Collection</code> of row numbers per key. Returns empty dictionary if none.<br><strong>Complexity:</strong> O(rows * #keyColumns).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Key construction depends on header existence and exact header lowercasing — header name mismatch results in empty column values used in key.<br><strong>Tests:</strong> Duplicate rows for default keys, custom keyColumns array, missing header handling. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>AcquireImportLock</strong> — <em>workbook-level import lock using very-hidden sheet</em><br><strong>Purpose:</strong> Provide a simple workbook-scope mutual exclusion for import operations by creating a very-hidden sheet named <code>_IFRS_ImportLock</code> containing timestamp and correlationID. Detects stale locks older than 60 minutes and breaks them.<br><strong>Signature:</strong> <code>Private Function AcquireImportLock(ByVal wb As Workbook, ByVal correlationID As String) As Boolean</code><br><strong>Behavior:</strong> If lock sheet exists, read <code>ts</code> and <code>ownerId</code>; compute age via <code>DateDiff(&quot;n&quot;, CDate(ts), Now)</code>; if age > 60 minutes delete stale lock sheet and proceed; otherwise return False. If no lock present, add new very-hidden sheet named <code>IMPORT_LOCK_SHEET</code>, write Now and correlationID to cells (1,1) and (1,2). Returns True on successful acquisition, False otherwise. Error-return False and <code>HandleError</code> on exception.<br><strong>Complexity:</strong> O(#sheets) for lookup is O(1) when using <code>Workbooks(...).Worksheets(name)</code> direct call.<br><strong>Side-effects:</strong> Creates or deletes a very-hidden worksheet. Uses <code>Application.DisplayAlerts</code> when deleting.<br><strong>Failure modes:</strong> Race condition where two processes call <code>AcquireImportLock</code> at same time (possible in multi-process hosts); reliance on time-based stale threshold could delete a legitimately long-running import. Tests: concurrent acquisition attempts (simulate by creating lock sheet), stale lock deletion by manipulating timestamp, ownership enforcement. Consider using file/OS-level locking for robust multi-process scenarios. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ReleaseImportLock</strong> — <em>release lock if owner matches</em><br><strong>Purpose:</strong> Remove <code>_IFRS_ImportLock</code> very-hidden sheet if owner matches <code>correlationID</code> or if forced (blank correlationID), log audit.<br><strong>Signature:</strong> <code>Private Sub ReleaseImportLock(ByVal wb As Workbook, ByVal correlationID As String)</code><br><strong>Behavior:</strong> Fetch lock sheet, read ownerId from cell (1,2); if <code>correlationID</code> blank or owner matches, delete sheet with <code>DisplayAlerts=False</code> and log audit. Errors routed to <code>HandleError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Deletes lock sheet; writes audit. <br><strong>Failure modes:</strong> If owner mismatch, lock not removed; ensure callers always pass correlationID. Tests: release by owner, release by blank forced, attempt to release by wrong owner. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>IsAllowedPath</strong> — <em>coarse path policy predicate</em><br><strong>Purpose:</strong> Block obvious sensitive paths (Windows system, <code>/etc</code>) and allow others. Policy gate before file I/O in public import paths.<br><strong>Signature:</strong> <code>Private Function IsAllowedPath(ByVal path As String) As Boolean</code><br><strong>Behavior:</strong> Lowercases path and rejects when it contains <code>&quot;c:\windows&quot;</code> or <code>&quot;/etc&quot;</code>; otherwise returns True. On error returns False and calls <code>HandleError</code>.<br><strong>Complexity:</strong> O(len(path)).<br><strong>Security:</strong> Very coarse — easily bypassable; MUST be hardened for production with canonical path normalization (resolve symlinks), OS-specific checks, whitelist-based directories, and runtime-configurable allowed roots. Document this as high priority to tighten.<br><strong>Tests:</strong> Paths containing <code>C:\Windows</code>, <code>/etc/passwd</code>, valid data path, empty path. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ResolveTargetWorkbook</strong> — <em>resolve workbook target defaulting to ActiveWorkbook / ThisWorkbook</em><br><strong>Purpose:</strong> Determine the workbook to operate upon: prefer explicit <code>targetWb</code>, fallback to <code>Application.ActiveWorkbook</code>, then <code>ThisWorkbook</code>.<br><strong>Signature:</strong> <code>Private Function ResolveTargetWorkbook(Optional ByVal targetWb As Workbook) As Workbook</code><br><strong>Behavior:</strong> Returns the first non-Nothing workbook found in that order. Uses <code>On Error Resume Next</code> defensively.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Pass explicit workbook, with ActiveWorkbook set/unset. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Nz</strong> — <em>null/empty helper</em><br><strong>Purpose:</strong> VBA utility to normalize common empty/Null/Error/Empty-string cases to alt default. Mirrors VB6/Access <code>Nz</code> semantics used widely in module.<br><strong>Signature:</strong> <code>Private Function Nz(v As Variant, Optional ByVal alt As Variant = &quot;&quot;) As Variant</code><br><strong>Behavior:</strong> If <code>v</code> is Error/Null/Empty or string that trims to empty returns <code>alt</code>, else returns <code>v</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> <code>Null</code>, <code>Empty</code>, <code>Err.Value</code>, <code>&quot;&quot;</code> and non-empty strings. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SleepMs</strong> — <em>millisecond sleep via Timer or DateAdd fallback</em><br><strong>Purpose:</strong> Busy-wait with <code>DoEvents</code> for the specified milliseconds; uses <code>Timer</code> on <code>VBA7</code>, otherwise <code>DateAdd</code> fallback. Used by <code>ReadWorkbookRangeToArray</code> retry logic.<br><strong>Signature:</strong> <code>Private Sub SleepMs(ms As Long)</code><br><strong>Behavior:</strong> Computes target time and loops <code>DoEvents</code> until reached. Non-blocking to UI (calls <code>DoEvents</code>) but still CPU busy loop. Use sparingly.<br><strong>Complexity:</strong> O(ms) wall time. <br><strong>Failure modes:</strong> <code>Timer</code> wraps at midnight; loop may be inaccurate across day boundaries. Alternative: <code>Application.Wait</code> could be used but is coarser. Tests: 50ms/500ms sleeps approximate timings. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>GenerateCorrelationID</strong> — <em>human-readable correlation id generator</em><br><strong>Purpose:</strong> Generate <code>CID-yyyymmddHHMMSS-rand6</code> string used across pipeline for audit and lock ownership.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Combines formatted <code>Now</code> and RNG <code>Int((Rnd()*900000)+100000)</code> to produce identifier. No guarantees of global uniqueness beyond timestamp+random suffix.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Repeated calls in same second produce different IDs usually due to random suffix—verify uniqueness for small sample sizes. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>ParseBackupTimestamp</strong> — <em>parse backup timestamp suffix into Date</em><br><strong>Purpose:</strong> Parse timestamp encoded in backup sheet names either <code>yyyymmdd_HHNNSS</code> or <code>yyyymmddHHNNSS</code> into a <code>Date</code> value for ordering backups.<br><strong>Signature:</strong> <code>Private Function ParseBackupTimestamp(ByVal part As String) As Date</code><br><strong>Behavior:</strong> Splits on <code>_</code> if present and uses <code>DateSerial</code> and <code>TimeSerial</code> with substrings to build <code>Date</code>. On error returns <code>0</code> (Date 0).<br><strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Malformed timestamp string returns <code>0</code> — code must handle these cases (it does by fallback). Tests: pass both formats and malformed values. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>SimpleRangeChecksum</strong> — <em>checksum helper for ranges</em><br><strong>Purpose:</strong> Sum lengths of each cell text in a <code>Range</code> for quick integrity checks similar to <code>ComputeWorksheetChecksum</code> but limited to a specific range.<br><strong>Signature:</strong> <code>Private Function SimpleRangeChecksum(ByVal rng As Range) As Long</code><br><strong>Behavior:</strong> Reads <code>rng.Value</code> into array, sums <code>Len(CStr(Nz(...)))</code>, returns modulo constant. Returns 0 on failure or empty range.<br><strong>Complexity:</strong> O(#cells).<br><strong>Tests:</strong> Two identical ranges produce equal checksums. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>DataInputSelfTests</strong> — <em>module-level smoke tests</em><br><strong>Purpose:</strong> Perform a small set of self-tests to verify core CSV parsing, staging sheet creation/writes, and JSON parsing capabilities to detect environmental regressions.<br><strong>Signature:</strong> <code>Public Function DataInputSelfTests() As Boolean</code><br><strong>Behavior:</strong> Tests <code>SplitCsvLine_Strict</code> with sample line, ensures <code>CreateOrEnsureStagingSheet</code> returns a sheet, round-trip write/read small array with <code>WriteArrayToSheetAtomic</code>, creates temporary JSON file and runs <code>ReadJsonToArray</code>, returns boolean success and logs audit <code>&quot;SelfTest&quot;</code>. Uses filesystem (ThisWorkbook.Path) to write a temp file.<br><strong>Complexity:</strong> Small O(n) tests; may fail on locked or protected paths.<br><strong>Side-effects:</strong> Creates preview staging sheet, writes temp test file in workbook path and removes it. Logs audit.<br><strong>Failure modes:</strong> Environments that forbid file writes or sheet creation will fail test; tests rely on production helper behaviour.<br><strong>Tests:</strong> Self-test result True expected in normal environment. Use in CI to catch regressions. </td></tr><tr><td data-label="Technical breakdown (modDataInput)"> <strong>Module-level remarks / cross-cutting concerns</strong><br>- <strong>External dependencies:</strong> Module uses <code>HandleError(module, code, desc)</code> and <code>LogAudit(event,message,Optional metadata)</code> which must exist and be robust; missing implementations will break error/audit flows. Ensure these helpers are unit-tested and non-blocking (avoid raising errors themselves).<br>- <strong>Error handling style:</strong> Heavy use of <code>On Error GoTo ErrHandler</code> and <code>On Error Resume Next</code>. <code>ErrHandler</code> flows usually call <code>HandleError</code> and attempt best-effort cleanup (lock release). Maintainers must ensure <code>HandleError</code> is safe during error contexts.<br>- <strong>Locking model:</strong> Workbook-level lock implemented via very-hidden sheet is simple but not atomic across Excel instances/processes — evaluate OS-level file locking or external semaphore for environments where the same file may be opened by multiple Excel processes. The lock uses a 60-minute stale cutoff — configurable constant would be better.<br>- <strong>Path policy:</strong> <code>IsAllowedPath</code> is intentionally conservative but weak; for production environments implement canonical path normalization, restrict to configured allowed directories, disallow UNC paths if not permitted, and handle Windows vs Unix path semantics.<br>- <strong>CSV/JSON parsing:</strong> CSV logic is robust for RFC-style CSV with quoted fields and embedded newlines. JSON parsing is best-effort and brittle — for production use prefer a real JSON parser (e.g., scripting runtime or MSXML/ScriptControl) if available.<br>- <strong>Large-file handling:</strong> Reading large files into VBA strings and arrays risks memory pressure; <code>STREAMING_THRESHOLD_BYTES</code> attempts to chunk raw read but final array still constructed fully in memory. Consider streaming processing or chunked conversion for very large imports. Document threshold tunable.<br>- <strong>Audit & observability:</strong> Module writes audit entries at key points (<code>AssignRowIDs</code>, <code>ImportPreview</code>, <code>ImportBackup</code>, <code>Commit</code>, <code>UndoImport</code>, <code>SelfTest</code>) — ensure <code>LogAudit</code> attaches correlationID for traceability.<br>- <strong>Determinism & IDs:</strong> <code>AssignStableRowIDs</code> uses random suffix and local timestamp; for deterministic testability consider using a cryptographic RNG source or monotonic sequence persisted to workbook metadata.<br>- <strong>Unit/integration test matrix (recommended shortlist):</strong> CSV parsing edge cases, BOMs, UTF-16 handling, large-file streaming path, staging schema migration from very-hidden legacy sheets, preview generation, validation rules (missing headers / numeric failures), duplicate detection, lock acquire/release concurrency scenarios, commit/backup/undo flows including checksum verification, DataInputSelfTests in CI, and <code>IsAllowedPath</code> policy enforcement tests.<br>- <strong>Security & safety:</strong> Avoid allowing import from system paths or arbitrary UNC shares. Sanitize filenames used for sheet names (Excel sheet name length/illegal characters). Do not evaluate any code from files. Carefully review <code>ReadJsonToArray</code> regex-based parsing for injection vectors.<br><strong>Maintenance notes (concise):</strong><br>- Keep public API stable: <code>ImportTrialBalance</code>, <code>ImportTrialBalanceAdvanced</code>, <code>ValidateCOA</code>, <code>DetectDuplicatesInStaging</code>, <code>ReadCsvToArray</code>, <code>ReadJsonToArray</code>, <code>ReadWorkbookRangeToArray</code>.<br>- Replace regex JSON parsing with robust JSON parser where available; make <code>IsAllowedPath</code> policy-driven; convert lock to more robust mechanism if multi-process concurrency required; add configurable constants for stale-lock timeout and streaming threshold; add comprehensive tests and CI gating. </td></tr></tbody></table></div><div class="row-count">Rows: 41</div></div><div class="table-caption" id="Table7" data-table="Docu_0158_07" style="margin-top:2mm;margin-left:3mm;"><strong>Table 7</strong></div>
<div class="table-wrapper" data-table-id="table-7"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown (modError.bas)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown (modError.bas)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Module Name</strong><br>modError.bas </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Overview:</strong><br>Deterministic, backward-compatible centralized error handling and lightweight structured logging for the IFRS Excel Add-in. Exposes a compact public API that preserves legacy behavior (raises original Err.Number after logging and user notification) while adding structured audit entries, a seeded error catalog, stable correlation IDs, and defensive fallbacks for locked-down environments (no Dictionary, no Scriptlet GUID, no native Sleep). Designed to be robust in the face of missing host services (LogAudit, NewCorrelationID) and to never allow logging to raise to callers. Intended invariants: public signatures remain stable; numeric error codes keep meaning across releases; logging must be best-effort and non-throwing. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>IFRS_ErrorSeverity (Enum)</strong> — <em>error severity levels</em><br><strong>Purpose:</strong> Provide a compact severity scale used across the module and by callers for branching (UI, audit, automation).<br><strong>Definition:</strong> <code>sevInfo = 1, sevWarning = 2, sevError = 3, sevCritical = 4</code><br><strong>Signature/Usage:</strong> used as parameter & stored in <code>IFRS_Error.severity</code>.<br><strong>Behavior:</strong> Simple numeric enum for comparisons (e.g., <code>If e.severity &gt;= sevCritical Then ...</code>).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Values must remain stable across builds (used for telemetry / audit filters).<br><strong>Failure modes:</strong> None intrinsic; mis-mapping on upgrades will change behavior of critical handlers.<br><strong>Tests:</strong> Assert comparison semantics and that severity constants are expected integers. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>IFRS_Error (Type)</strong> — <em>structured error record</em><br><strong>Purpose:</strong> Encapsulate error metadata for logging and downstream consumption (audit, telemetry, UI).<br><strong>Fields:</strong> <code>procName As String, errNum As Long, internalMsg As String, userMsg As String, severity As IFRS_ErrorSeverity, correlationID As String, contextJson As String, TimeStamp As Date</code><br><strong>Behavior:</strong> Populated by <code>HandleError</code> (or helpers) then forwarded to <code>SafeLogStructuredError</code> and to the legacy <code>Err.Raise</code>. Not marshalled beyond strings/dates inside module. Timestamp set to Now at creation.<br><strong>Complexity:</strong> O(1) allocation/copy. <br><strong>Side-effects:</strong> None by itself; used to produce audit entry and UI reaction.<br><strong>Invariants:</strong> <code>TimeStamp</code> must reflect time of error capture; <code>correlationID</code> must be non-empty after <code>HandleError</code> returns.<br><strong>Tests:</strong> Create sample IFRS_Error and assert fields set and truncated/escaped by logger as expected. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Module-level state / constants</strong> — <em>g_errorCatalog, flags, truncation constants</em><br><strong>Purpose:</strong> Persistent helpers to seed and query a message catalog and to control truncation of logged fields.<br><strong>Elements:</strong> <code>g_errorCatalog As Object</code> (Scripting.Dictionary when available), <code>g_catalogInitialized As Boolean</code>, <code>g_catalogAvailable As Boolean</code>, <code>g_randomized As Boolean</code>; constants <code>MAX_LOG_INTERNAL=800</code>, <code>MAX_LOG_USER=400</code>, <code>MAX_LOG_CONTEXT=800</code>.<br><strong>Behavior:</strong> Catalog initialization is attempted once per process; availability flag guides no-op behaviour when Dictionary unavailable. Truncation constants ensure predictable audit payload sizes. <code>g_randomized</code> guarantees <code>Randomize</code> is invoked once per session for fallback correlation ID suffix variation.<br><strong>Complexity:</strong> initialization O(N seeded items) when available; subsequent lookups O(1).<br><strong>Side-effects:</strong> Uses CreateObject which can fail in restricted hosts; code defensively sets <code>g_catalogAvailable=False</code> when that happens.<br><strong>Invariants:</strong> After first call to <code>EnsureCatalogInitialized</code>, <code>g_catalogInitialized=True</code> even if catalog unavailable (prevents repeated heavy attempts).<br><strong>Tests:</strong> Run initialization in environment with/without Scripting.Dictionary; confirm flags and counts behave. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>EnsureCatalogInitialized()</strong> — <em>one-shot catalog setup with graceful fallback</em><br><strong>Purpose:</strong> Create and populate the error catalog (Scripting.Dictionary) if available; ensure <code>Randomize</code> called once; mark initialization completed even on failure (deterministic behaviour across re-loads).<br><strong>Signature:</strong> <code>Private Sub EnsureCatalogInitialized()</code><br><strong>Behavior:</strong><br>- If already initialized, exit early.<br>- Attempt <code>CreateObject(&quot;Scripting.Dictionary&quot;)</code> under <code>On Error Resume Next</code>.<br>- If created, set <code>g_catalogAvailable = True</code>, remove any previous items, and call <code>addCatalogItem</code> repeatedly to seed codes and messages.<br>- If not available, set <code>g_catalogAvailable = False</code> and keep <code>g_errorCatalog = Nothing</code> (catalog lookup functions then return empty strings).<br>- Call <code>Randomize</code> once (guarded by <code>g_randomized</code>).<br><strong>Complexity:</strong> O(M) where M is number of seeded items (constant here).<br><strong>Side-effects:</strong> May call COM; may run with Err.Number non-zero which is cleared; safe for restricted hosts.<br><strong>Invariants:</strong> After first call, <code>g_catalogInitialized=True</code> always; consistent seeded content when dictionary exists.<br><strong>Failure modes:</strong> COM creation failure (handled), partial population (if an error occurs mid-seed) — module clears and proceeds defensively.<br><strong>Security:</strong> No external input used. <br><strong>Tests:</strong> Simulate success/failure paths; assert Idempotency and that post-initialization flags reflect environment. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>addCatalogItem(code, userMsg, remediation, Optional severity)</strong> — <em>safe catalog insertion</em><br><strong>Purpose:</strong> Insert a catalog entry into <code>g_errorCatalog</code> only when dictionary is available; no-op otherwise so missing Scripting runtime doesn't break callers.<br><strong>Signature:</strong> <code>Private Sub addCatalogItem(code As Long, userMsg As String, remediation As String, Optional severity As IFRS_ErrorSeverity)</code><br><strong>Behavior:</strong> Creates a small Scripting.Dictionary object <code>item</code> with keys <code>UserMessage</code>, <code>Remediation</code>, <code>DefaultSeverity</code> and stores it at <code>g_errorCatalog(CStr(code))</code>. Wrapped in <code>On Error Resume Next</code> and returns silently on any failure.<br><strong>Complexity:</strong> O(1) per item. <br><strong>Side-effects:</strong> Allocates COM objects (dictionary) when available; safe no-op otherwise.<br><strong>Invariants:</strong> Only invoked from initialization; duplicate keys are replaced (dictionary semantics).<br><strong>Failure modes:</strong> COM failure → no-op. <br><strong>Tests:</strong> With Scripting.Dictionary present, confirm retrieval by <code>GetUserMessageFromCatalog</code>. With dictionary absent, ensure no exception. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>HandleError(procName, errNum, Optional errMsg, Optional severity, Optional userMsg, Optional contextJson)</strong> — <em>core public handler preserving legacy flow</em><br><strong>Purpose:</strong> Centralized error capture: build structured <code>IFRS_Error</code>, choose user message (catalog override or param), ensure correlation ID, write structured audit log, show critical MsgBox when needed, then re-raise the original error (legacy behavior). Backwards-compatible signature: callers using <code>HandleError(procName, errNum, errMsg)</code> remain valid.<br><strong>Signature:</strong> <code>Public Sub HandleError(procName As String, errNum As Long, Optional errMsg As String = &quot;&quot;, Optional severity As IFRS_ErrorSeverity = sevError, Optional userMsg As String = &quot;&quot;, Optional contextJson As String = &quot;&quot;)</code><br><strong>Behavior (step-by-step):</strong><br>1. Call <code>EnsureCatalogInitialized</code> (one-shot) to enable catalog lookups.<br>2. Populate <code>IFRS_Error e</code> fields: <code>procName</code> defaulting to "Unknown", <code>errNum</code>, <code>internalMsg</code> chosen from <code>errMsg</code> or <code>GetInternalFallbackMessage(errNum)</code>, <code>severity</code> assigned from param and potentially elevated by catalog default severity if catalog has stronger severity.<br>3. Choose <code>userMsg</code>: prefer explicit <code>userMsg</code> param; else <code>GetUserMessageFromCatalog(errNum)</code>; fallback to generic message when none exists.<br>4. Generate <code>correlationID</code>: first attempt <code>Application.Run(&quot;NewCorrelationID&quot;)</code> safely (guarded with <code>On Error Resume Next</code>); if that fails or returns empty, call <code>GenerateCorrelationID()</code>.<br>5. Call <code>SafeLogStructuredError e</code> to produce compact escaped JSON string and pass to <code>LogAudit(&quot;Error&quot;, details)</code> in a best-effort fashion (must not raise).<br>6. If severity >= <code>sevCritical</code> show a <code>MsgBox</code> (guarded by error handlers so it cannot raise outward).<br>7. Finally, <code>Err.Raise errNum, procName, e.userMsg</code> to preserve legacy exception flow for callers/tests.<br><strong>Complexity:</strong> O(1) CPU per invocation; catalog lookup O(1) if available. Logging cost proportional to truncated string lengths (constant bounded by MAX_LOG_* constants).<br><strong>Side-effects:</strong> Calls Application.Run (external macro), COM (dictionary), LogAudit (external), and may show UI message box. Alters global <code>Err</code> state by <code>Err.Raise</code> (legacy behavior).<br><strong>Invariants:</strong> After return (or raising), a structured audit attempt was made and correlationID is non-empty. <code>Err.Raise</code> ensures calling code sees an error with original <code>errNum</code> and <code>userMsg</code> as Description.<br><strong>Failure modes:</strong><br>- Application.Run may throw (handled).<br>- LogAudit missing or failing — SafeLogStructuredError guards against exceptions so no propagation occurs.<br>- If <code>Err.Raise</code> itself fails unusually, host behavior follows VBA semantics; module does not suppress final raise.<br><strong>Security:</strong> <code>contextJson</code> and messages are trimmed and escaped before logging to prevent log injection. Avoid including PII in <code>contextJson</code> per privacy policies.<br><strong>Recommended tests:</strong> Simulate cases: (a) catalog present/absent; (b) <code>NewCorrelationID</code> present/absent; (c) severity levels including critical to assert MsgBox executed (can be tested with a headless hook stub); (d) confirm <code>Err.Number</code> equals provided <code>errNum</code> after call; (e) audit string format validated (escaped JSON).<br><strong>Notes for maintainers:</strong> Keep signature stable. Do not change final <code>Err.Raise</code> behavior since external code depends on legacy Err.Number/Description semantics. Ensure <code>LogAudit</code> contract exists and is non-blocking. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>RaiseIFRSError(procName, errNum, Optional internalMsg, Optional contextJson)</strong> — <em>shorthand wrapper</em><br><strong>Purpose:</strong> Convenience wrapper preserving older API shape that calls <code>HandleError</code> with <code>sevError</code> and empty user message (catalog will supply if present).<br><strong>Signature:</strong> <code>Public Sub RaiseIFRSError(procName As String, errNum As Long, Optional internalMsg As String = &quot;&quot;, Optional contextJson As String = &quot;&quot;)</code><br><strong>Behavior:</strong> Delegates to <code>HandleError</code> with <code>sevError</code> and blank <code>userMsg</code> so catalog mapping is used. Maintains legacy call sites. <br><strong>Complexity/side-effects/failure modes:</strong> Same as <code>HandleError</code>.<br><strong>Tests:</strong> Call wrapper and assert same raise and audit outcomes as direct <code>HandleError</code>. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>GetUserMessageFromCatalog(errNum)</strong> — <em>defensive catalog read for user-facing message</em><br><strong>Purpose:</strong> Return catalog UserMessage or empty string if unavailable. Strictly defensive (no exceptions to caller).<br><strong>Signature:</strong> <code>Private Function GetUserMessageFromCatalog(errNum As Long) As String</code><br><strong>Behavior:</strong> Calls <code>EnsureCatalogInitialized</code>. If dictionary available and <code>g_errorCatalog.Exists(CStr(errNum))</code> returns stored <code>&quot;UserMessage&quot;</code>. Else returns empty string. Wrapped in <code>On Error Resume Next</code> to swallow COM errors.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Never raises; returns "" when no mapping. <br><strong>Tests:</strong> With seeded catalog verify known code returns correct message; absent catalog returns "". </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>GetRemediationFromCatalog(errNum)</strong> — <em>defensive catalog read for remediation text</em><br><strong>Purpose:</strong> Return remediation guidance string from catalog; defensive no-exception contract identical to <code>GetUserMessageFromCatalog</code> but returns <code>&quot;Remediation&quot;</code>.<br><strong>Signature:</strong> <code>Private Function GetRemediationFromCatalog(errNum As Long) As String</code><br><strong>Complexity/Testing/Notes:</strong> Same as <code>GetUserMessageFromCatalog</code>. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>GetInternalFallbackMessage(errNum)</strong> — <em>fallback internal message</em><br><strong>Purpose:</strong> Provide a minimal internal message if no <code>errMsg</code> passed to <code>HandleError</code> (keeps internalMsg non-empty).<br><strong>Signature:</strong> <code>Private Function GetInternalFallbackMessage(errNum As Long) As String</code><br><strong>Behavior:</strong> Returns <code>&quot;Error code &quot; &amp; CStr(errNum)</code> — deterministic and safe.<br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Ensure simple formatting. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>SafeLogStructuredError(e As IFRS_Error)</strong> — <em>build escaped compact JSON and call LogAudit</em><br><strong>Purpose:</strong> Centralized serialization of <code>IFRS_Error</code> into a compact JSON-like escaped payload (bounded by truncation constants) and best-effort call to <code>LogAudit(&quot;Error&quot;, details)</code> without propagating exceptions.<br><strong>Signature:</strong> <code>Private Sub SafeLogStructuredError(e As IFRS_Error)</code><br><strong>Behavior (detailed):</strong><br>- Use <code>TruncateString</code> to limit fields: CorrelationID(120), Proc(200), Internal(MAX_LOG_INTERNAL), User(MAX_LOG_USER), Context(MAX_LOG_CONTEXT). Truncation is performed BEFORE escaping to guarantee payload size limits.<br>- Use <code>EscapeForJson</code> to remove/escape control characters, backslashes, quotes, normalize newlines & tabs, and strip non-printables.<br>- Build a compact JSON-like string (all values double-quoted and escaped); timestamp formatted <code>&quot;yyyy-mm-dd HH:nn:ss&quot;</code> via <code>Format$</code>.<br>- Call <code>On Error Resume Next</code> then <code>LogAudit(&quot;Error&quot;, details)</code> (LogAudit is an external function expected to exist in project); swallow errors and <code>Err.Clear</code> afterwards. No throw to caller.<br><strong>Complexity:</strong> O(L) where L is bounded by constants; effectively constant-time.<br><strong>Side-effects:</strong> Calls external <code>LogAudit</code>. May allocate temporary strings sized by truncation constants.<br><strong>Invariants:</strong> Output not larger than truncation limits + JSON punctuation. Must not raise under any circumstances.<br><strong>Failure modes:</strong> If <code>LogAudit</code> not present or raises, errors are swallowed — but audit is then lost; consider instrumenting an alternate persistent fallback if needed.<br><strong>Security:</strong> Fields are escaped to avoid log injection; still avoid logging PII in <code>contextJson</code>.<br><strong>Tests:</strong> Provide <code>IFRS_Error</code> with suspicious characters and assert output contains escaped characters, respects truncation, and that <code>LogAudit</code> was invoked (mock). </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>CTypeOrDefault(v, Optional defaultVal)</strong> — <em>safe numeric cast to severity</em><br><strong>Purpose:</strong> Defensive cast of potentially-variant <code>DefaultSeverity</code> retrieved from catalog item to <code>IFRS_ErrorSeverity</code>, with bounds checking and fallback default.<br><strong>Signature:</strong> <code>Private Function CTypeOrDefault(v As Variant, Optional defaultVal As IFRS_ErrorSeverity = sevError) As IFRS_ErrorSeverity</code><br><strong>Behavior:</strong> Uses <code>IsNumeric</code>, <code>CLng</code> in <code>On Error Resume Next</code> and validates numeric range between <code>sevInfo</code> and <code>sevCritical</code>. Returns <code>defaultVal</code> on failure. Clears <code>Err</code> before exit.<br><strong>Complexity:</strong> O(1).<br><strong>Invariants:</strong> Always returns a valid severity constant. <br><strong>Tests:</strong> Pass numeric, string numeric, invalid string, missing key. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>TruncateString(s, maxLen)</strong> — <em>defensive truncation with ellipsis</em><br><strong>Purpose:</strong> Truncate long strings to <code>maxLen</code> (preserve small tail) and append "..." when <code>maxLen&gt;3</code> to indicate truncation. Used prior to escaping to keep payload predictable.<br><strong>Signature:</strong> <code>Private Function TruncateString(ByVal s As String, ByVal maxLen As Long) As String</code><br><strong>Behavior:</strong> If <code>Len(s) &lt;= maxLen</code> return s. Else return <code>Left$(s, maxLen-3) &amp; &quot;...&quot;</code> when <code>maxLen&gt;3</code>, else <code>Left$(s,maxLen)</code>.<br><strong>Complexity:</strong> O(maxLen).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Edge cases: maxLen <=3; maxLen longer than s; multibyte characters (VBA deals with character counts). </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>EscapeForJson(s)</strong> — <em>safe JSON-ish escaping + control filtering</em><br><strong>Purpose:</strong> Escape user/internal strings for safe inclusion inside the compact JSON-like payload: escape backslashes and double quotes, convert CR/LF to <code>\n</code>, replace tabs with a space, and remove non-printable characters (preserve LF). Also normalizes characters via <code>AscW</code> check to replace control codes with space.<br><strong>Signature:</strong> <code>Private Function EscapeForJson(ByVal s As String) As String</code><br><strong>Behavior (detailed):</strong><br>- <code>Replace(s, &quot;\&quot;, &quot;\\&quot;)</code> then <code>Replace(Chr(34), &quot;\&quot; &amp; Chr(34))</code>.<br>- Normalize newlines: <code>vbCrLf</code>, <code>vbCr</code>, <code>vbLf</code> to <code>\n</code>; tabs replaced with single space.<br>- Iterate characters and preserve only LF or characters with <code>AscW &gt;= 32</code>; others replaced with space. This prevents binary/control bytes from corrupting JSON payload.<br><strong>Complexity:</strong> O(len(s)).<br><strong>Side-effects:</strong> None. <br><strong>Security:</strong> Prevents log injection and unstable JSON chars. Does not perform Unicode \uXXXX escapes; keeps printable Unicode characters intact (suitable for audit).<br><strong>Failure modes:</strong> Very long strings handled because truncation done prior to escaping; if <code>AscW</code> fails on surrogate pairs, behavior depends on host; tests recommended.<br><strong>Tests:</strong> Strings with quotes, backslashes, CR/LF, tabs, and control chars should be escaped/normalized; non-ASCII chars should be preserved if printable. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>GenerateCorrelationID()</strong> — <em>project override -> Scriptlet GUID -> timestamp+random fallback</em><br><strong>Purpose:</strong> Produce a reasonably-unique correlation identifier for logs so multi-step flows can be grouped. Prefer platform GUID, but provide deterministic fallback when unavailable (useful on locked-down Excel runtimes).<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong><br>- Try <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code> and remove <code>{}</code> if successful, prefix with <code>IFRS-&lt;yyyymmddHHMMSS&gt;-&lt;guid&gt;</code>.<br>- If Scriptlet fails, ensure <code>Randomize</code> called and produce <code>&quot;IFRS-&lt;yyyymmddHHMMSS&gt;-&lt;randomSuffix&gt;&quot;</code> where suffix is <code>CLng(Abs(Rnd * 1000000#))</code>—ensures variation across runs. Uses <code>Now</code> formatted to year-month-day/time components.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> COM create attempt; <code>Randomize</code> call modifies global RNG state once only (guarded by <code>g_randomized</code>).<br><strong>Security/privacy:</strong> Correlation ID contains timestamp and GUID/random; avoid embedding user-identifiable information in correlation ID. <br><strong>Failure modes:</strong> CreateObject may fail (handled). Random fallback ok for correlation needs but not cryptographically secure. <br><strong>Tests:</strong> Verify GUID path returns GUID pattern; fallback path returns timestamp-suffix and uniqueness across successive calls. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>RetryOperationByName(functionName, attempts, delayMs, Optional lastErrNum)</strong> — <em>best-effort retry wrapper for named public routines</em><br><strong>Purpose:</strong> Generic retry helper that invokes a function by name via <code>Application.Run</code> up to <code>attempts</code> times with <code>delayMs</code> between attempts. Accepts heterogeneous return types: vbBoolean true, numeric non-zero, non-empty string, or non-Nothing object all treated as success. Returns Boolean indicating success and optionally last error number via <code>ByRef lastErrNum</code>.<br><strong>Signature:</strong> <code>Public Function RetryOperationByName(ByVal functionName As String, ByVal attempts As Long, ByVal delayMs As Long, Optional ByRef lastErrNum As Long) As Boolean</code><br><strong>Behavior:</strong><br>- Input validation: at least one attempt.<br>- Loop: <code>Application.Run(functionName)</code> under <code>On Error Resume Next</code>; examine <code>Err.Number</code> and <code>result</code>'s <code>VarType</code> to decide success. On success exit with True. On failure wait <code>SleepMs(delayMs)</code> and retry. Returns final boolean and last error number seen when calls fail.<br><strong>Complexity:</strong> O(attempts) * cost of invoked function. <br><strong>Side-effects:</strong> Calls external macro(s) and uses SleepMs which may DoEvents (reentrant host code).<br><strong>Invariants:</strong> Does not throw; returns False on persistent failure. <code>lastErrNum</code> is 0 when success or populated with last <code>Err.Number</code> when failure.<br><strong>Failure modes / gotchas:</strong><br>- <code>Application.Run</code> can call arbitrary user code which may be long-running, modal, or may change application state; retried calls may have side-effects.<br>- Delay uses <code>SleepMs</code> which may pump messages (DoEvents), enabling reentrancy; callers should ensure this is acceptable.<br><strong>Tests:</strong> Create sample macro that toggles success after N invocations and assert RetryOperationByName behavior. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Sleep declaration (conditional) & SleepMs(ms)</strong> — <em>host-safe sleep with native attempt</em><br><strong>Purpose:</strong> Provide a short blocking sleep utility that prefers native <code>Sleep</code> when available (declared via conditional compile for VBA7/Win64) and otherwise falls back to a <code>DoEvents</code> loop using <code>DateAdd</code> to avoid busy-waiting. This is used by retry helper to avoid tight loops while remaining host-safe.<br><strong>Signature:</strong> <code>Private Sub SleepMs(ByVal ms As Long)</code> (uses <code>SleepWin</code> declare when available).<br><strong>Behavior:</strong><br>- If <code>ms &lt;= 0</code> exit.<br>- Try calling <code>SleepWin ms</code> (declared in conditional compilation). If it errors (not present), fallback to computing <code>endTime = DateAdd(&quot;s&quot;, ms / 1000#, Now)</code> and loop <code>Do While Now &lt; endTime: DoEvents: Loop</code>.<br><strong>Complexity:</strong> Time-blocking for ms duration; CPU usage minimal because DoEvents yields. <br><strong>Side-effects:</strong> <code>DoEvents</code> permits other events/macros to run — may enable reentrancy; <code>SleepWin</code> does not pump messages. <br><strong>Safety/Failure modes:</strong> On UI-less automation or protected hosts, DoEvents may be restricted or slow — the function guards with <code>On Error Resume Next</code>. <br><strong>Tests:</strong> Sleep short durations and measure wall-clock; test native and fallback path via conditional compilation or by forcing native declare to be missing. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Test_Injection_RaiseSampleError()</strong> — <em>test/fault injection helper</em><br><strong>Purpose:</strong> Developer test hook that creates a structured error and raises it so unit tests or integration tests can validate audit/logging and legacy raise behavior. Useful for CI and diagnostics.<br><strong>Signature:</strong> <code>Public Sub Test_Injection_RaiseSampleError()</code><br><strong>Behavior:</strong> Calls <code>HandleError &quot;modError._Test_Injection_RaiseSampleError&quot;, 9999, &quot;Injected test error&quot;, sevError, &quot;Test error (injection)&quot;, &quot;{&quot;&quot;test&quot;&quot;:true}&quot;</code>. Because <code>HandleError</code> raises, callers will see Err.Number 9999; audit entry should be written.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Produces audit entry via <code>LogAudit</code> and raises Err.Number 9999. <br><strong>Tests:</strong> Called by automated tests to validate logging and raise semantics. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Public accessors for tests / read-only information</strong> — <em>GetUserFacingMessage, GetRemediationSteps, IsErrorCatalogInitialized, IsErrorCatalogAvailable, GetCatalogItemCount</em><br><strong>Purpose:</strong> Provide safe, read-only access to catalog state for unit tests and diagnostics without exposing mutable internals. Keep deterministic behavior across restricted hosts.<br><strong>Signatures:</strong><br>- <code>Public Function GetUserFacingMessage(errNum As Long) As String</code><br>- <code>Public Function GetRemediationSteps(errNum As Long) As String</code><br>- <code>Public Function IsErrorCatalogInitialized() As Boolean</code><br>- <code>Public Function IsErrorCatalogAvailable() As Boolean</code><br>- <code>Public Function GetCatalogItemCount() As Long</code><br><strong>Behavior:</strong> Thin wrappers around the internal lookup functions and state variables, defensively returning defaults when catalog absent. <code>GetUserFacingMessage</code> returns fallback <code>&quot;An error occurred. See audit log.&quot;</code> when empty.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Tests:</strong> Unit tests should assert correct returns when catalog seeded vs when unavailable. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Maintenance & compatibility notes (module-level)</strong><br><strong>Purpose:</strong> Guidance and constraints for maintainers to preserve deterministic behavior and avoid regressions.<br><strong>Key points:</strong><br>- <strong>API stability:</strong> Do not change <code>HandleError</code> signature or <code>RaiseIFRSError</code> semantics; callers expect <code>Err.Raise errNum, procName, userMsg</code> at the end.<br>- <strong>Error numbers:</strong> Preserve existing error code meanings (numeric constants) — changing codes breaks telemetry and documentation.<br>- <strong>Catalog availability:</strong> <code>EnsureCatalogInitialized</code> intentionally sets <code>g_catalogInitialized = True</code> even if dictionary is unavailable — preserve this one-shot behavior to avoid repeated COM attempts on constrained hosts.<br>- <strong>External hooks:</strong> <code>LogAudit</code> and optional <code>NewCorrelationID</code> are external contract points. Changes to their expected behavior must be coordinated across project. Implement a test stub for <code>LogAudit</code> in CI to validate logging path. <br>- <strong>DoEvents reentrancy:</strong> SleepMs fallback uses <code>DoEvents</code> and can permit reentrant code; avoid calling high-risk host operations from within RetryOperationByName unless reentrancy is acceptable.<br>- <strong>Truncation & escaping:</strong> Truncate BEFORE escaping — rely on <code>MAX_LOG_*</code> constants for predictable audit payload sizing. If fields need to be larger in telemetry later, increase constants and coordinate with server-side schema.<br>- <strong>Security / privacy:</strong> Avoid logging PII into <code>contextJson</code>; ensure downstream audit pipelines treat <code>contextJson</code> as untrusted. Use <code>EscapeForJson</code> to avoid injection into the stored audit payload. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Failure & recovery scenarios (recommended operational behavior)</strong><br><strong>Typical failure cases & module behavior:</strong><br>- Scripting.Dictionary missing → catalog lookups return empty strings; HandleError still performs logging and raises the original Err.Number. No failure escapes module.<br>- Scriptlet.TypeLib GUID unavailable → timestamp+random fallback used for correlation ID (non-crypto).<br>- <code>LogAudit</code> missing or throwing → swallowed by <code>SafeLogStructuredError</code> and no exception propagates; audit lost but application flow preserved.<br>- <code>Application.Run(&quot;NewCorrelationID&quot;)</code> errors → silently ignored and fallback used.<br><strong>Recommendation:</strong> Monitor for missing audit entries in telemetry and provide admin guidance to ensure LogAudit deployed. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Recommended test matrix (concise prioritized list)</strong><br>1. <strong>Catalog presence matrix</strong>: run with Scripting.Dictionary available and unavailable; assert <code>GetCatalogItemCount</code> and <code>GetUserFacingMessage</code> behavior.<br>2. <strong>HandleError end-to-end</strong>: Call with explicit userMsg vs without; assert audit content (escaped/truncated), correlation ID format, and final <code>Err.Number</code> matches input.<br>3. <strong>Critical severity flow</strong>: use sevCritical and assert <code>MsgBox</code> invocation path (mock or intercept).<br>4. <strong>Correlation ID paths</strong>: with <code>NewCorrelationID</code> defined (Application.Run returns a value), with Scriptlet.TypeLib available, and with neither to validate all branches.<br>5. <strong>SleepMs & RetryOperationByName</strong>: stub a function that fails N-1 times then succeeds; assert retry respects attempts and sleep behavior (use mocking to avoid long sleeps).<br>6. <strong>Escape & truncation</strong>: pass long strings and control characters as <code>contextJson</code> and verify audit payload size and escaping correctness.<br>7. <strong>Audit resilience</strong>: make <code>LogAudit</code> throw and assert <code>HandleError</code> does not propagate error and still raises original <code>Err.Number</code> afterwards. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Security, privacy & compliance notes</strong><br>- All logged fields are escaped via <code>EscapeForJson</code> and truncated to defend against log injection and excessive payloads. Nevertheless: do not place sensitive personal data (PII) in <code>contextJson</code> — redact before calling <code>HandleError</code> or implement a centralized sanitizer.<br>- Correlation IDs are non-secret; do not treat as authentication tokens. If stronger entropy is required, integrate secure GUIDs from a trusted cryptographic library or server-side issued IDs.<br>- Ensure <code>LogAudit</code> destination is secure and that logs are access-controlled and retained according to your compliance requirements. </td></tr><tr><td data-label="Technical Breakdown (modError.bas)"> <strong>Final maintainer checklist / recommended improvements</strong><br>- Add optional pluggable <code>ILogAudit</code> interface (project-level public method) so tests can inject a mock audit sink instead of depending on a global <code>LogAudit</code> name and allow async-safe queuing.<br>- If audit volume grows, consider switching <code>LogAudit</code> to an append-queue model and ensure it never blocks main thread (log queue + background flush).<br>- Document the canonical list of error codes in a single external CSV for cross-team reference. Keep <code>MAX_LOG_*</code> constants in sync with server-side ingestion limits.<br>- Add unit test harness that stubs <code>Application.Run</code> and <code>LogAudit</code> to validate all branches and ensure <code>HandleError</code> is covered by automated tests. </td></tr></tbody></table></div><div class="row-count">Rows: 26</div></div><div class="table-caption" id="Table8" data-table="Docu_0158_08" style="margin-top:2mm;margin-left:3mm;"><strong>Table 8</strong></div>
<div class="table-wrapper" data-table-id="table-8"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical breakdown (modExport)**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical breakdown (modExport)</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical breakdown (modExport)"> <strong>Overview:</strong><br>This module implements robust export utilities for the IFRS Excel add-in: PDF, CSV, XLSX, CustomXML, ZIP packaging and a high-level package flow. It emphasizes atomic I/O (prefer modUtilities helpers when present), predictable boolean public APIs (except legacy <code>ExportToPDF</code>), centralized audit integration, conservative security/policy checks for sensitive exports, retry/backoff for flaky network/locked files, and clear error-code space. Use this file as the authoritative spec for maintenance, tests and refactors. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Constants & Error Codes</strong> — <em>module configuration and reserved error space</em><br><strong>Purpose:</strong> Define error numeric base, legacy raise offset and named module errors used by <code>LocalHandleError</code> and public APIs.<br><strong>Details:</strong> <code>EXPORT_ERR_BASE = 2100</code> reserved; specific errors (2100..2399) mapped to names (NO_WORKBOOK, DEST_NOT_WRITABLE, etc.). <code>EXPORT_ERR_LEGACY_RAISE = 21000</code> used when raising to preserve legacy behavior. <code>EXPORT_ERR_MAX_RETRIES = 4</code> controls retry loops.<br><strong>Notes:</strong> Keep mapping stable — external code/tests may depend on numeric values. Add new errors only inside reserved block and document. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportToPDF</strong> — <em>legacy Sub kept for backward compatibility (raise-on-failure)</em><br><strong>Purpose:</strong> Preserve historical <code>Sub ExportToPDF(fileName, targetWb)</code> behavior that raises on failure for callers relying on Err.Raise semantics.<br><strong>Signature:</strong> <code>Public Sub ExportToPDF(Optional ByVal fileName As String = &quot;&quot;, Optional ByVal targetWb As Workbook = Nothing)</code><br><strong>Behavior:</strong> Calls <code>ExportToPDFEx</code>; if it returns False, raises <code>vbObjectError + EXPORT_ERR_LEGACY_RAISE</code>. Errors forwarded to <code>LocalHandleError</code> in ErrHandler.<br><strong>Complexity:</strong> O(1) wrapper.<br><strong>Side-effects:</strong> May raise runtime error; logs via <code>LocalHandleError</code> on exceptions.<br><strong>Invariants:</strong> Does not change export behavior; must keep raise semantics.<br><strong>Failure modes:</strong> Wrapped function returning False leads to Err.Raise; ensure callers expecting raise still function. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportToPDFEx</strong> — <em>safe boolean PDF export with atomic move & retries</em><br><strong>Purpose:</strong> Export workbook to PDF with temporary file strategy, exponential backoff retries, atomic move (Name preferred, Copy fallback), and audit logging. Returns True/False rather than raising to enable programmatic handling.<br><strong>Signature:</strong> <code>Public Function ExportToPDFEx(Optional fileName As String = &quot;&quot;, Optional targetWb As Workbook = Nothing) As Boolean</code><br><strong>Behavior (detailed):</strong><br>- Resolve workbook via <code>ResolveWorkbookSafe</code>.<br>- Compute destination path (provided or derived from workbook name + folder fallback).<br>- Verify destination writable via <code>EnsureFolderWritableForFile</code>.<br>- Build a unique temp filename in same folder <code>ifrs_pdf_temp_yyyymmdd_HHNNSS_&lt;cid&gt;.pdf</code>.<br>- Loop up to <code>maxAttempts=3</code>: delete any leftover temp, call <code>wb.ExportAsFixedFormat Type:=xlTypePDF</code> to write temp file, verify via <code>FileExistsAndNonEmpty</code>, then attempt atomic move: <code>Name</code> (fast same-volume) else <code>FileSystemObject.CopyFile</code> and delete temp. If final file valid -> success; otherwise log and backoff (SleepMs with exponential wait).<br>- Always attempt to cleanup temp file.<br>- On success, <code>SafeLogAuditWithMeta</code> invoked with duration and attemptCount.<br><strong>Complexity:</strong> Network/disk bound — cost proportional to PDF generation time and move operations. Loops up to 3 retries; overall O(retries * exportTime).<br><strong>Side-effects:</strong> Creates temporary files, final PDF; calls <code>SafeLogAuditWithMeta</code> and <code>LocalHandleError</code> on failure.<br><strong>Invariants:</strong> If returns True, export file exists and non-empty at <code>exportName</code> (verified before returning).<br><strong>Failure modes:</strong> <code>ExportAsFixedFormat</code> can fail silently or throw (printer drivers, invalid print areas); Name may fail across volumes; access denied on destination; transient network/locked files cause retries.<br><strong>Security:</strong> None specific to PDF content, but audit/logs may include path names — redaction via <code>SafeLogAuditWithMeta</code> respects modSecurity/modConfig hooks.<br><strong>Tests:</strong> Export small workbook -> file exists; simulate locked destination (open by other process) -> function returns False and logs; temp leftover cleaned; attemptCount recorded; race when destination exists overwritten. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportWorksheetToCsv</strong> — <em>export specified worksheet to CSV (UTF-8 default)</em><br><strong>Purpose:</strong> Export a worksheet's UsedRange to CSV with quoting rules and UTF-8 encoding where possible. Backwards-compatible signature (optional wb, sheetName, fullPath) and boolean return.<br><strong>Signature:</strong> <code>Public Function ExportWorksheetToCsv(Optional targetWb As Workbook = Nothing, Optional sheetName As String = &quot;&quot;, Optional fullPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook and sheet (active sheet if sheetName omitted) via <code>SafeGetWorksheet</code> and <code>ResolveWorkbookSafe</code>.<br>- Compute default path if <code>fullPath</code> omitted (wb.path or Application.DefaultFilePath or USERPROFILE).<br>- Ensure destination writable via <code>EnsureFolderWritableForFile</code>.<br>- Retrieve <code>ws.UsedRange</code> and fail with <code>EXPORT_ERR_SHEET_NO_USED_RANGE</code> if empty.<br>- Call <code>TryExportRangeToCsvWithOptions(rng, fullPath, True)</code> which prefers centralized <code>ExportRangeToCsv</code> if present or falls back to <code>WriteRangeToCsvFallbackWithEncoding</code>.<br>- On success, write audit entry via <code>SafeLogAuditWithMeta</code> including sheet name.<br><strong>Complexity:</strong> O(rows * cols) to serialize cells. Memory usage proportional to CSV string size (module builds full string in sb variable).<br><strong>Side-effects:</strong> May create file at <code>fullPath</code>; logs audit.<br><strong>Invariants:</strong> CSV uses CRLF line endings, CSV quoting for fields containing commas, quotes and embedded newlines; internal newlines normalized to LF inside fields before wrapping.<br><strong>Failure modes:</strong> Large sheets may produce huge memory usage; cell types (objects, errors) converted to empty strings; ADODB fallback used for UTF-8 may not exist on stripped-down hosts.<br><strong>Security:</strong> Use <code>TryAtomicWriteFileWithEncoding</code> to avoid partial writes exposing sensitive data. Audit redaction applies.<br><strong>Tests:</strong> 1) small table export; 2) cells with embedded quotes/newlines; 3) very large sheet memory behavior; 4) missing UsedRange path returns False and logs. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportWorkbookAsXlsx</strong> — <em>atomic save of workbook as .xlsx with verification</em><br><strong>Purpose:</strong> Save a live workbook as a flattened .xlsx file using atomic-save helpers; verify existence and size, and log audit; returns True/False.<br><strong>Signature:</strong> <code>Public Function ExportWorkbookAsXlsx(Optional targetWb As Workbook = Nothing, Optional fullPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve workbook; determine default target path if none provided.<br>- Ensure destination folder writable.<br>- Call <code>TryAtomicSaveWorkbookAsWithVerification(wb, fullPath)</code> which attempts <code>AtomicSaveWorkbookAs</code> via <code>Application.Run</code> or fallback to <code>SaveCopyAs</code> then copy; includes retry/backoff up to <code>EXPORT_ERR_MAX_RETRIES</code>.<br>- On success log <code>SafeLogAuditWithMeta</code> with duration and attempt count; return True.<br><strong>Complexity:</strong> Save cost dominated by Excel SaveCopyAs; retries increase time. Disk I/O bound.<br><strong>Side-effects:</strong> Creates .xlsx file; may create temp SaveCopyAs file and remove it.<br><strong>Invariants:</strong> On success file exists and non-empty; workbook not modified by function (uses SaveCopyAs).<br><strong>Failure modes:</strong> SaveCopyAs can fail for network paths, locked files, or insufficient disk; atomic helper absent on older deployments -> fallbacks invoked. Permission errors surfaced via <code>LocalHandleError</code>.<br><strong>Tests:</strong> Simple workbook save; test on network share and simulate locked destination; verify temp cleanup and attempts count in audit. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportCustomXMLPart</strong> — <em>export named CustomXMLPart with policy checks and UTF-8 write</em><br><strong>Purpose:</strong> Extract a CustomXMLPart identified by a root element and write it to disk with optional schema/version comment; deny exports if policy indicates secrets.<br><strong>Signature:</strong> <code>Public Function ExportCustomXMLPart(ByVal rootElement As String, ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Validate args non-empty.<br>- Read XML via <code>TryReadCustomXMLPart(rootElement)</code> which calls centralized <code>ReadCustomXMLPart</code> if present or fallback iterating <code>ThisWorkbook.CustomXMLParts</code>.<br>- If XML empty -> <code>EXPORT_ERR_CUSTOMXML_NOENT</code>.<br>- If content contains tokens like <code>&quot;password&quot;</code> or <code>&quot;secret&quot;</code> then call <code>CheckCustomXmlPolicy(rootElement, xml)</code> which queries <code>modSecurity_CheckCustomXmlExport</code> via <code>Application.Run</code> or uses conservative default (deny when suspicious tokens present). If denied -> error <code>EXPORT_ERR_CUSTOMXML_POLICY_DENY</code>.<br>- Prepend a small header comment (cid + timestamp) after XML declaration when present, not changing XML structure otherwise.<br>- Ensure folder writable and call <code>TryAtomicWriteFileWithEncoding(fullPath, xml, True)</code> (UTF-8 preferred). On success log audit.<br><strong>Complexity:</strong> O(size of XML) I/O bound.<br><strong>Side-effects:</strong> Writes file; logs audit; invokes security hooks.<br><strong>Invariants:</strong> Exported XML includes a non-invasive header comment; secrets are not exported by default.<br><strong>Failure modes:</strong> Policy function absent -> conservative default; ADODB writing may fail. Caller must handle False. <br><strong>Security:</strong> Highest sensitivity — uses <code>modSecurity</code> hook. Tests must include PII/secret detection and ensure denial path works. Recommended to add unit test that attempts to export known secret patterns. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CreateZipFromFiles</strong> — <em>create cross-platform zip package from list of files</em><br><strong>Purpose:</strong> Create a ZIP archive containing provided full paths, with bootstrap empty zip, platform-specific shells used for adding files, and integrity heuristics. Overwrites existing zipPath if present.<br><strong>Signature:</strong> <code>Public Function CreateZipFromFiles(ByVal files As Collection, ByVal zipPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Validate inputs: non-empty collection and zipPath.<br>- Ensure destination folder writable and create folder.<br>- Remove existing zip if present; create minimal empty zip bootstrap (write PKZIP EOCD with zeros) so Shell.Namespace recognizes container.<br>- Branch: <code>IsMacOS</code> -> call <code>ExecShellZipOnMac(files, zipPath)</code> which shells out to <code>zip -j -q</code>; else <code>ExecShellZipOnWindows(files, zipPath)</code> which uses <code>Shell.Application</code> <code>Namespace.CopyHere</code> to add files and monitors size stabilization via <code>WaitForZipStable</code>.<br>- If creation fails, return <code>EXPORT_ERR_ZIP_CREATE_FAIL</code>. Validate final zip non-empty; audit log.<br><strong>Complexity:</strong> O(#files) per addition plus platform zip command costs; Windows Shell copy is asynchronous and requires Wait loops.<br><strong>Side-effects:</strong> Writes zip file; may call external shell (security considerations for file paths).<br><strong>Invariants:</strong> Resulting zip contains added files when function returns True; bootstrap coding required for Windows Shell API.<br><strong>Failure modes:</strong> Shell utilities missing on Mac/Windows, long waits for <code>CopyHere</code> completion, permission issues, files that do not exist skipped silently. If no files added -> <code>EXPORT_ERR_ZIP_EMPTY</code>.<br><strong>Security:</strong> Paths quoted via <code>QuotePathForShell</code> on Mac; on Windows <code>Shell.Namespace.CopyHere</code> performs background operations — avoid passing untrusted shell metacharacters. Tests: small set of files, many files, missing files, file names with quotes/spaces/unicode, ensure zip valid. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportPackage</strong> — <em>high level package: PDF + XLSX + Audit + optional files -> ZIP</em><br><strong>Purpose:</strong> Convenience function to assemble common exports (PDF, XLSX, Audit CSV) plus caller-supplied files into a ZIP package. Returns boolean success.<br><strong>Signature:</strong> <code>Public Function ExportPackage(Optional ByVal filesToInclude As Collection = Nothing, Optional ByVal zipPath As String = &quot;&quot;) As Boolean</code><br><strong>Behavior:</strong><br>- Resolve active workbook; compute default zipPath if omitted.<br>- Produce PDF via legacy <code>ExportToPDF</code> (preserved raise semantics — wrapped in <code>On Error Resume Next</code>). Add to tmpFiles collection if created.<br>- Export XLSX via <code>ExportWorkbookAsXlsx</code> and audit CSV via <code>ExportAuditToCSV</code> adding created files to collection when present and non-empty.<br>- Append any caller-supplied files after verifying existence and non-empty.<br>- If no files collected -> <code>EXPORT_ERR_ZIP_NO_FILES</code> error.<br>- Create ZIP via <code>CreateZipFromFiles(tmpFiles, zipPath)</code> and log audit on success.<br><strong>Complexity:</strong> Sum of constituent operations (PDF/XLSX/CSV + zip). Risk of partial success scenarios.<br><strong>Side-effects:</strong> Creates multiple files, possibly leaves temporary artifacts if intermediate exports fail. Audit logged.<br><strong>Invariants:</strong> On True return, <code>zipPath</code> exists and contains at least one file. Caller should clean temporary files if desired.<br><strong>Failure modes:</strong> Any constituent export failing leaves package incomplete — callers should inspect audit logs. Tests: end-to-end package creation; missing optional files; verify zip contains expected members. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportAuditToCSV</strong> — <em>export audit trail to CSV with central hook fallback</em><br><strong>Purpose:</strong> Attempt to call centralized <code>ExportAuditToCSV_Central</code> via <code>Application.Run</code>; fallback to scanning workbook for audit sheets and export them as CSV using <code>ExportWorksheetToCsv</code>.<br><strong>Signature:</strong> <code>Public Function ExportAuditToCSV(ByVal fullPath As String) As Boolean</code><br><strong>Behavior:</strong><br>- Default <code>fullPath</code> to TEMP if omitted.<br>- Try <code>Application.Run(&quot;ExportAuditToCSV_Central&quot;, fullPath)</code>; if returns boolean, use it and log audit.<br>- Else scan <code>ThisWorkbook</code> for known audit sheet names (various casings) via <code>SafeGetWorksheet</code>. If none found, search any sheet where name contains <code>&quot;audit&quot;</code> case-insensitively.<br>- If found, call <code>ExportWorksheetToCsv(wb, nameFound, fullPath)</code> and log audit on success.<br><strong>Complexity:</strong> O(#sheets) for search; CSV export complexity as previously.<br><strong>Side-effects:</strong> Writes audit CSV; may call external central routine. <br><strong>Invariants:</strong> Exports the first suitable audit sheet. <br><strong>Failure modes:</strong> Central routine may throw; fallback may not find audit sheet -> returns False with <code>2400</code> error. Tests: central hook present/absent; sheet detection casing; exports file content correctness. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ExportSelfTest</strong> — <em>module self-test orchestration</em><br><strong>Purpose:</strong> Perform deterministic smoke tests: export test CSV, export XLSX, create package zip; used for CI/manual verification. Returns Boolean overall result.<br><strong>Signature:</strong> <code>Public Function ExportSelfTest() As Boolean</code><br><strong>Behavior:</strong><br>- Build <code>_IFRS_TestResults</code> folder under workbook path or TEMP. Ensure folder exists.<br>- Ensure a <code>TST_Export_Sheet</code> exists (create if missing) with deterministic sample values.<br>- Call <code>ExportWorksheetToCsv</code>, <code>ExportWorkbookAsXlsx</code>, and <code>CreateZipFromFiles</code> on the produced artifacts. Aggregate boolean results; log via <code>SafeLogAuditWithMeta</code>.<br><strong>Complexity:</strong> Same as composed operations.<br><strong>Side-effects:</strong> Creates sample files and zip; logs audit.<br><strong>Invariants:</strong> No external state consistent changes (only files).<br><strong>Tests:</strong> This function itself is test harness; run on varied environments including network drives. Clean-up not provided — tests should clean artifacts where appropriate. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ResolveWorkbookSafe</strong> — <em>workbook resolver with fallbacks</em><br><strong>Purpose:</strong> Return supplied workbook, else ActiveWorkbook, else ThisWorkbook; safe against errors.<br><strong>Signature:</strong> <code>Private Function ResolveWorkbookSafe(Optional ByVal suppliedWb As Workbook = Nothing) As Workbook</code><br><strong>Behavior:</strong> Uses <code>On Error Resume Next</code> to avoid runtime errors, returns first valid workbook. <br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None. <br><strong>Notes:</strong> Keep minimal; used by all public export entrypoints to standardize workbook selection. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>LocalHandleError</strong> — <em>centralized error invocation with graceful fallback</em><br><strong>Purpose:</strong> Invoke centralized <code>HandleError</code> if present; otherwise write local audit and raise module-specific error preserving legacy raise semantics. Central point for error mapping and audit fallback.<br><strong>Signature:</strong> <code>Private Sub LocalHandleError(ByVal proc As String, ByVal errNum As Long, ByVal errDesc As String)</code><br><strong>Behavior:</strong><br>- Attempt <code>Application.Run(&quot;HandleError&quot;, proc, errNum, errDesc)</code> and consider error handled if it returns without Err.Number.<br>- If no central handler, call <code>SafeLogAudit &quot;Error&quot;, proc &amp; &quot; | &quot; &amp; CStr(errNum) &amp; &quot; | &quot; &amp; errDesc</code> then raise <code>vbObjectError + EXPORT_ERR_LEGACY_RAISE + (Abs(errNum) Mod 1000)</code> to preserve legacy numeric space. Err.Raise wrapped in <code>On Error Resume Next</code> to avoid secondary unhandled exceptions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls audit and possibly raises an error. <br><strong>Notes:</strong> Do not change numeric mapping logic without considering external callers. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>SafeLogAudit</strong> — <em>best-effort audit writer with fallback to local temp log</em><br><strong>Purpose:</strong> Attempt <code>Application.Run &quot;LogAudit&quot;, category, message</code>. If that fails, append to a local <code>ifrs_local_audit.log</code> in TEMP. Non-blocking best-effort telemetry.<br><strong>Signature:</strong> <code>Private Sub SafeLogAudit(ByVal category As String, ByVal message As String)</code><br><strong>Behavior:</strong> Try central audit hook; if error, write timestamped line to temp file via VB file I/O. <br><strong>Complexity:</strong> O(1) file append. <br><strong>Side-effects:</strong> Writes to disk. <br><strong>Notes:</strong> Keep minimal and robust; do not let logging throw. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>SafeLogAuditWithMeta</strong> — <em>audit writer with metadata and redaction hooks</em><br><strong>Purpose:</strong> Emit richer audit entries (path, workbook name, extra info, duration, retries, correlation id) and request redaction decision from modSecurity/modConfig. Use <code>LogAudit</code> central hook when available and fallback to <code>SafeLogAudit</code> otherwise.<br><strong>Signature:</strong> <code>Private Sub SafeLogAuditWithMeta(ByVal category As String, ByVal message As String, ByVal targetPath As String, Optional ByVal wb As Workbook = Nothing, Optional ByVal extra As String = &quot;&quot;, Optional ByVal durationMs As Long = -1, Optional ByVal retries As Long = -1)</code><br><strong>Behavior:</strong> Build <code>metaMsg</code> concatenating fields, call <code>modSecurity_ShouldRedactAudit(metaMsg)</code> via <code>Application.Run</code> and if boolean true perform simple redaction heuristics (mask userprofile, replace slashes etc.). Then call <code>Application.Run &quot;LogAudit&quot;, category, metaMsg, cid</code> and fallback to <code>SafeLogAudit</code> on error.<br><strong>Complexity:</strong> O(1) string ops and a best-effort call.<br><strong>Side-effects:</strong> May mutate message (redaction) and call central services. <br><strong>Security:</strong> Critical for PII protection; maintain conservative default. Unit tests should assert redaction behavior when the hook returns True. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>GenerateCorrelationID</strong> — <em>correlation ID generator with GUID fallback</em><br><strong>Purpose:</strong> Create a correlation id using <code>Scriptlet.TypeLib</code> GUID when available; fallback to deterministic pseudo-id based on timestamp + random number.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Uses <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code> if available else <code>&quot;CID-&quot; &amp; Format(Now, ...) &amp; &quot;-&quot; &amp; random</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Correlation ID used in audits for traceability; prefer GUID path when available. Keep stable format. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>ChooseFolderFallback</strong> — <em>determine default folder for exports</em><br><strong>Purpose:</strong> Pick export folder from workbook path > Application.DefaultFilePath > USERPROFILE > TEMP in that order.<br><strong>Signature:</strong> <code>Private Function ChooseFolderFallback(ByVal wb As Workbook) As String</code><br><strong>Behavior:</strong> Return first non-empty candidate. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> Centralizes fallback logic for consistent behavior across export functions. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>EnsureFolderWritableForFile / IsFolderWritable / SafeFolderCreate</strong> — <em>folder writability checks & safe create</em><br><strong>Purpose:</strong> Provide robust checks that the folder exists and is writable (create if missing) by attempting a small binary write test file and deleting it. <code>EnsureFolderWritableForFile</code> extracts folder path from full file path and calls <code>IsFolderWritable</code>.<br><strong>Signatures:</strong> <code>Private Function EnsureFolderWritableForFile(ByVal filepath As String) As Boolean</code>, <code>Private Function IsFolderWritable(ByVal folderPath As String) As Boolean</code>, <code>Private Sub SafeFolderCreate(ByVal folderPath As String)</code><br><strong>Behavior:</strong><code>IsFolderWritable</code> creates folder if not exists, writes temporary <code>&quot;IFRS&quot;</code> test file then deletes; returns success boolean. <code>SafeFolderCreate</code> wraps FSO <code>CreateFolder</code> with <code>On Error Resume Next</code>.<br><strong>Complexity:</strong> O(1) I/O. <br><strong>Failure modes:</strong> On network shares write test may pass but subsequent writes may fail; this is best-effort. Tests should run on network path, restricted folder, and local folder. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Atomic write & save helper wrappers</strong> — <em>TryAtomicWriteFile / TryAtomicWriteFileWithEncoding / TryAtomicWriteFileWithVerification</em><br><strong>Purpose:</strong> Prefer centralized <code>AtomicWriteFile</code> from <code>modUtilities</code> when present; otherwise use local fallbacks that write to a temp file and move or use ADODB.Stream for UTF-8. Verification wrapper checks file non-zero size.<br><strong>Signatures:</strong> <code>Private Function TryAtomicWriteFile(fullPath, contents) As Boolean</code>, <code>TryAtomicWriteFileWithEncoding(fullPath, contents, useUtf8)</code>, <code>TryAtomicWriteFileWithVerification(fullPath, contents)</code><br><strong>Behavior:</strong> Attempt <code>Application.Run(&quot;AtomicWriteFile&quot;, ...)</code>. If not available, call <code>WriteTextFileAtomicFallback</code> or <code>WriteUtf8FileAtomicFallback</code>. Verification checks FSO file size > 0. Errors caught and converted to False. <br><strong>Complexity:</strong> O(file_size) I/O. <br><strong>Side-effects:</strong> Creates temp files and moves them into place. <br><strong>Invariants:</strong> On True return, final file exists and non-empty. <br><strong>Tests:</strong> Absence/presence of <code>AtomicWriteFile</code> hook; simulate ADODB absent; verify atomic move semantics across volumes (Name fails, Copy fallback). </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>WriteTextFileAtomicFallback</strong> — <em>binary write temp -> move fallback (not strict UTF-8)</em><br><strong>Purpose:</strong> Generic fallback writing raw bytes to temp file then Name/Copy to destination. Useful when ADODB not present and UTF-8 not strictly required.<br><strong>Signature:</strong> <code>Private Function WriteTextFileAtomicFallback(fullPath, contents) As Boolean</code><br><strong>Behavior:</strong> Create tmp file with timestamp+cid; Open For Binary Access Write; Put contents; Close; attempt Name fullPath else CopyFile; return FileExistsAndNonEmpty(fullPath).<br><strong>Complexity:</strong> O(file_size).<br><strong>Failure modes:</strong> Unicode conversion not handled; binary blob may mis-encode; prefer UTF-8 helper when required. Tests: simple ASCII content success; Unicode content may show BOM issues. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>WriteUtf8FileAtomicFallback</strong> — <em>ADODB.Stream UTF-8 writer fallback with BOM fallback</em><br><strong>Purpose:</strong> Write UTF-8 reliably using <code>ADODB.Stream</code> when available; else write BOM + contents as fallback and move atomically.<br><strong>Signature:</strong> <code>Private Function WriteUtf8FileAtomicFallback(fullPath, contents, useUtf8) As Boolean</code><br><strong>Behavior:</strong> Attempt <code>CreateObject(&quot;ADODB.Stream&quot;)</code>, set <code>.Type=2</code>, <code>.Charset=&quot;utf-8&quot;</code>, <code>.WriteText contents</code>, <code>.SaveToFile tmpPath</code>. If ADODB unavailable, write BOM + contents to tmpPath using Binary I/O. Then move/Name to fullPath (Copy fallback). Clean tmp on errors. Return True if file exists and non-empty.<br><strong>Complexity:</strong> O(file_size).<br><strong>Failure modes:</strong> ADODB absent or restricted; fallback adds BOM which some consumers may not expect. Tests: UTF-8 content roundtrip; verify BOM presence when ADODB absent. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>TryAtomicSaveWorkbookAs / TryAtomicSaveWorkbookAsWithVerification</strong> — <em>atomic SaveCopyAs fallback with retries</em><br><strong>Purpose:</strong> Prefer <code>AtomicSaveWorkbookAs</code> via modUtilities; fallback to <code>Workbook.SaveCopyAs tmp</code> then copy to destination. Verification wrapper retries with exponential backoff to handle locked/network paths.<br><strong>Signature:</strong> <code>Private Function TryAtomicSaveWorkbookAs(wb, fullPath) As Boolean</code>, <code>TryAtomicSaveWorkbookAsWithVerification(wb, fullPath) As Boolean</code><br><strong>Behavior:</strong> Attempt centralized helper; else <code>wb.SaveCopyAs tmp</code> then FSO <code>CopyFile tmp -&gt; fullPath</code>. Verification checks final file exists and non-zero size. Retries up to <code>EXPORT_ERR_MAX_RETRIES</code>.<br><strong>Complexity:</strong> SaveCopyAs cost + copy; retries multiply cost. <br><strong>Failure modes:</strong> SaveCopyAs can fail for unsaved workbook, or if workbook is too large. Tests: saved/unsaved workbooks, network destinations, locked destinations. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CSV fallback writer: TryExportRangeToCsvWithOptions / WriteRangeToCsvFallbackWithEncoding</strong> — <em>serialize Range to CSV and write atomically</em><br><strong>Purpose:</strong> Use centralized <code>ExportRangeToCsv</code> when present; otherwise iterate cells, escape quotes, normalize newlines inside cells to LF, quote fields with commas/newlines/quotes, join rows with CRLF and write via <code>TryAtomicWriteFileWithEncoding</code> (UTF-8 preferred).<br><strong>Signature:</strong> <code>Private Function TryExportRangeToCsvWithOptions(rng, fullPath, useUtf8) As Boolean</code>, <code>Private Function WriteRangeToCsvFallbackWithEncoding(rng, fullPath, useUtf8) As Boolean</code><br><strong>Behavior:</strong> Build full CSV string in-memory (sb), then call atomic writer. Properly handles errors with <code>On Error</code> pattern. <br><strong>Complexity:</strong> O(rows*cols + total_chars). Memory heavy for large ranges; consider streaming when necessary.<br><strong>Failure modes:</strong> Very large ranges may exhaust memory; ADODB may not be present. Tests: fields with quotes/newlines/commas; empty/errored cells; very large sheet performance. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>CustomXML helpers: TryReadCustomXMLPart / ReadCustomXMLPartFallback / CheckCustomXmlPolicy</strong> — <em>read & policy-check XML parts</em><br><strong>Purpose:</strong> Read CustomXMLPart via centralized <code>ReadCustomXMLPart</code> hook if present; fallback by scanning <code>ThisWorkbook.CustomXMLParts</code>. <code>CheckCustomXmlPolicy</code> calls <code>modSecurity_CheckCustomXmlExport</code> to allow/deny export or falls back to conservative deny if suspicious tokens found.<br><strong>Signatures:</strong> <code>Private Function TryReadCustomXMLPart(rootElement) As String</code>, <code>Private Function ReadCustomXMLPartFallback(rootElement) As String</code>, <code>Private Function CheckCustomXmlPolicy(rootElement, xml) As Boolean</code><br><strong>Behavior:</strong> Fallback scans <code>ThisWorkbook.CustomXMLParts</code> searching <code>InStr(cxp.xml, &quot;&lt;&quot; &amp; rootElement) &gt; 0</code>. Policy function invoked via <code>Application.Run</code> when available; defaults to deny on presence of <code>&quot;password&quot;</code> or <code>&quot;secret&quot;</code> tokens. <br><strong>Complexity:</strong> O(#customParts * size). <br><strong>Security:</strong> Conservative default denies export of suspicious content. Unit tests must verify both hook present and absent behaviors, and matching substring search correctness. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Platform & ZIP helpers: IsMacOS / ExecShellZipOnMac / ExecShellZipOnWindows / QuotePathForShell / WaitForZipStable</strong><br><strong>Purpose:</strong> Abstract platform details for zipping files: Mac uses <code>MacScript(&quot;do shell script ...&quot;)</code> with <code>zip -j -q</code>, Windows uses <code>Shell.Application</code> COM to <code>CopyHere</code> into zip container and <code>WaitForZipStable</code> to observe size stalls.<br><strong>Signatures:</strong> <code>Private Function IsMacOS() As Boolean</code>, <code>Private Function ExecShellZipOnMac(files, zipPath) As Boolean</code>, <code>Private Function ExecShellZipOnWindows(files, zipPath) As Boolean</code>, <code>Private Function QuotePathForShell(p) As String</code>, <code>Private Function WaitForZipStable(zipPath, timeoutMs) As Boolean</code><br><strong>Behavior highlights:</strong><br>- <code>IsMacOS</code> checks <code>Application.OperatingSystem</code> string.<br>- <code>ExecShellZipOnMac</code> builds shell command quoting paths via <code>QuotePathForShell</code> and invokes via <code>MacScript</code> (returns False on error).<br>- <code>ExecShellZipOnWindows</code> uses <code>Shell.Namespace(zipPath).CopyHere filepath</code> for each file and polls <code>WaitForZipStable</code> (checks file size changes and a <code>stableCounter</code> threshold) to heuristically wait until the copy completes. Returns whether final zip exists and non-empty.<br><strong>Complexity:</strong> Copy operations are asynchronous on Windows; <code>WaitForZipStable</code> loops <code>DoEvents</code> and checks file size until stable or timeout. <br><strong>Failure modes & Security:</strong> Shell command injection risk for Mac if quoting not correct — <code>QuotePathForShell</code> replaces <code>&quot;</code> with <code>\&quot;</code> and wraps with quotes. On Windows, <code>Shell.Namespace</code> may be unavailable for some zipped formats or if zip is blocked by ACLs. Tests: filenames with spaces/quotes/unicode; long lists; network paths; zip stability timeouts. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Utility helpers: SafeFileName / FileExistsAndNonEmpty / SafeGetWorksheet / SleepMs</strong><br><strong>Purpose & signatures:</strong><br>- <code>SafeFileName(s) -&gt; String</code>: sanitize invalid filename characters by replacing with <code>_</code>.<br>- <code>FileExistsAndNonEmpty(path) -&gt; Boolean</code>: FSO existence and size > 0 check.<br>- <code>SafeGetWorksheet(wb,sheetName) -&gt; Worksheet</code>: case-insensitive search for worksheet by name.<br>- <code>SleepMs(ms)</code>: busy wait using <code>Timer</code> + <code>DoEvents</code> for cross-platform short waits.<br><strong>Behavior:</strong> Small helpers used pervasively. <br><strong>Complexity:</strong> O(1) for string ops, O(1) for FSO checks. <br><strong>Notes:</strong> <code>SleepMs</code> processes events (DoEvents) — be cautious when called inside tight UI contexts. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Design & maintenance notes (module-level)</strong><br>- <strong>Public surface:</strong> stable boolean-returning functions (<code>ExportToPDFEx</code>, <code>ExportWorksheetToCsv</code>, <code>ExportWorkbookAsXlsx</code>, <code>ExportCustomXMLPart</code>, <code>CreateZipFromFiles</code>, <code>ExportPackage</code>, <code>ExportAuditToCSV</code>, <code>ExportSelfTest</code>) plus legacy <code>ExportToPDF</code> (raise). Maintain signatures for backward compatibility.<br>- <strong>Use central hooks when available:</strong> <code>AtomicWriteFile</code>, <code>AtomicSaveWorkbookAs</code>, <code>ExportRangeToCsv</code>, <code>ReadCustomXMLPart</code>, <code>HandleError</code>, <code>LogAudit</code>, <code>modSecurity_*</code> and <code>modConfig_Get</code>. All <code>Application.Run</code> calls are best-effort — fallbacks exist to remain self-contained.<br>- <strong>Error handling:</strong> All public functions catch errors and call <code>LocalHandleError</code>. <code>LocalHandleError</code> prefers central <code>HandleError</code> and otherwise logs and raises within module error space. Keep error numbers stable to avoid breaking external error handling. <br>- <strong>Security:</strong> CustomXML exports are policy-checked; audit redaction hook used; avoid writing secrets. Ensure <code>SafeLogAuditWithMeta</code> redaction heuristics are updated if new PII patterns emerge.<br>- <strong>Atomicity & correctness:</strong> Prefer atomic helpers; fallback strategies use temp file -> Name / Copy pattern. Ensure temp files created in same target folder when possible to avoid cross-volume <code>Name</code> failure. Revoke or cleanup temp artifacts on error paths. <br>- <strong>Platform differences:</strong> Windows zip via Shell.Application is asynchronous; Mac uses CLI zip. Test both platforms. ADODB availability affects UTF-8 writing. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Recommended tests (condensed)</strong><br>1. PDF export: success path; locked destination -> retry/backoff and logged failure; temp file cleanup. 2. CSV export: embedded quotes/newlines/commas; large ranges for memory. 3. XLSX export: atomic save verification on local and network drives; SaveCopyAs fallback. 4. CustomXML: export allowed/denied by <code>modSecurity</code> hook and fallback; header injection correctness. 5. ZIP creation: files with special chars, many files, Windows Shell asynchronous behavior and <code>WaitForZipStable</code> timing edge cases. 6. Audit: central <code>LogAudit</code> present and absent; <code>SafeLogAuditWithMeta</code> redaction test. 7. Atomic write helpers: ADODB present/absent, cross-volume move (Name vs Copy). 8. SelfTest: run in CI on clean VM and assert deterministic outputs. 9. Error mapping: intentional faults produce expected <code>EXPORT_ERR_*</code> codes and <code>LocalHandleError</code> raise semantics. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Maintenance notes for engineers</strong><br>- Do not change exported function signatures; provide new overloads as <code>*Ex</code> functions. <br>- When altering token strings used for secret detection (<code>&quot;password&quot;</code>, <code>&quot;secret&quot;</code>), update tests and document policy implications. <br>- Prefer adding centralized helpers in <code>modUtilities</code> rather than changing fallbacks here; keep <code>Application.Run</code> hooks thin and tolerant. <br>- When adjusting worker/async behavior (e.g., better Windows zip integration), preserve current fallback behavior for older deployments. <br>- Add CI checks to run <code>ExportSelfTest</code> on supported platforms periodically. </td></tr><tr><td data-label="Technical breakdown (modExport)"> <strong>Final summary (one paragraph)</strong><br><code>modExport</code> is a defensive, production-oriented export module built for reliability and compatibility: it prioritizes atomic writes, centralized hook usage, policy-guided CustomXML exports, cross-platform ZIP creation, and exhaustive fallbacks. Public functions return booleans except the preserved legacy sub that raises; all failures funnel through <code>LocalHandleError</code> and <code>SafeLogAuditWithMeta</code>, which attempt centralized handling and otherwise perform local audit + conservative raises. Key maintenance areas: keep error codes stable, test ADODB/ADP/COM availability paths, and strengthen CustomXML policy hooks to avoid accidental secrets exfiltration. </td></tr></tbody></table></div><div class="row-count">Rows: 30</div></div><div class="table-caption" id="Table9" data-table="Docu_0158_09" style="margin-top:2mm;margin-left:3mm;"><strong>Table 9</strong></div>
<div class="table-wrapper" data-table-id="table-9"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module Name</strong><br>modIAS36.bas<br><strong>Module Version</strong>2025.12.25-Rev3<br><strong>Purpose (module level):</strong> Hardened IAS 36 impairment framework: recoverable amount (VIU & FVLCOD), CGU grouping, deterministic DCF/NPV builder with pluggable daycount conventions, deterministic allocation & journal generator, disclosure summary builder, defensive validation, structured audit logging and predictable error handling. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Module_Initialize()</strong> — <em>module defaults initializer</em><br><strong>Purpose:</strong> Ensure module-level defaults (g_IAS36_Daycount) are set before any operation.<br><strong>Signature:</strong> <code>Private Sub Module_Initialize()</code><br><strong>Behavior:</strong> Idempotent micro-error-block: sets <code>g_IAS36_Daycount</code> to <code>IAS36_DAYCOUNT_DEFAULT</code> if unset. Swallows transient errors, clears Err. Designed to be cheap and safe to call at start of public functions.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Mutates module-level variable <code>g_IAS36_Daycount</code> if previously empty.<br><strong>Invariants:</strong> After successful call <code>g_IAS36_Daycount</code> != vbNullString.<br><strong>Failure modes:</strong> If Application environment prevents assignment (unlikely), it silently leaves existing value; errors cleared. Host should catch only systemic failures.<br><strong>Tests:</strong> Ensure repeated calls preserve same default; set g_IAS36_Daycount externally and call — value should remain. </td></tr><tr><td data-label="Technical Breakdown"> <strong>SetIAS36DefaultDaycount(convention As String)</strong> — <em>change module default daycount</em><br><strong>Purpose:</strong> Allow host to change default daycount ("ACT/365", "ACT/360", "30/360") with validation and audit logging.<br><strong>Signature:</strong> <code>Public Sub SetIAS36DefaultDaycount(ByVal convention As String)</code><br><strong>Behavior:</strong> Calls <code>Module_Initialize</code>, validates input (case-insensitive); if valid sets <code>g_IAS36_Daycount</code> to canonical upper-case; if invalid logs via <code>SafeLog</code> and retains previous default. Errors routed to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Updates <code>g_IAS36_Daycount</code> and writes audit on invalid values.<br><strong>Invariants:</strong> Only allowed values stored; invalid input does not change default.<br><strong>Failure modes:</strong> Passing empty string does nothing. Host errors in <code>SafeLog</code> are safe (fallback to Debug.Print).<br><strong>Recommended tests:</strong> Valid/invalid values; repeated set; ensure <code>GetIAS36DefaultDaycount</code> returns expected value. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetIAS36DefaultDaycount() As String</strong> — <em>read module default</em><br><strong>Purpose:</strong> Return currently configured default daycount (ensures initialization).<br><strong>Signature:</strong> <code>Public Function GetIAS36DefaultDaycount() As String</code><br><strong>Behavior:</strong> Calls <code>Module_Initialize</code> then returns <code>g_IAS36_Daycount</code> (falls back to <code>IAS36_DAYCOUNT_DEFAULT</code>).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None beyond possible module init assignment.<br><strong>Tests:</strong> When module default changed via <code>SetIAS36DefaultDaycount</code>, <code>Get...</code> returns that value. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_CalculateRecoverableByVIU(cashflows, discountRate, Optional asOfDate, Optional daycount) As Double</strong> — <em>VIU NPV calculator</em><br><strong>Purpose:</strong> Compute recoverable amount via Value in Use: present value of forecast cashflows using <code>NPVFromDcfEx</code> and module daycount fallback.<br><strong>Signature:</strong> <code>Public Function IAS36_CalculateRecoverableByVIU(ByVal cashflows As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> Ensures defaults (asOfDate -> Date; daycount fallback). Calls <code>NPVFromDcfEx</code> to compute PV. On errors calls <code>HandleInternalError</code> and returns 0#.<br><strong>Complexity:</strong> Dominated by <code>NPVFromDcfEx</code> (O(n) where n = number of forecast rows).<br><strong>Side-effects:</strong> None (pure calculation).<br><strong>Invariants:</strong> Returns 0 for empty forecasts or on error; deterministic given same inputs.<br><strong>Failure modes:</strong> Non-date entries handled by <code>NormalizeForecastToArray</code>; if <code>NPVFromDcfEx</code> errors, returns 0 and logs. <br><strong>Tests:</strong> Zero flows → 0; positive cashflows with known discount → match manual calculation; negative/complex inputs handled gracefully. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_CalculateRecoverableByFVLCOD(fairValue, costsToSell) As Double</strong> — <em>FVLCOD calculator</em><br><strong>Purpose:</strong> Compute fair value less costs of disposal (simple subtraction, defensive numeric coercion).<br><strong>Signature:</strong> <code>Public Function IAS36_CalculateRecoverableByFVLCOD(ByVal fairValue As Double, ByVal costsToSell As Double) As Double</code><br><strong>Behavior:</strong> Uses <code>NZDouble</code> to coerce inputs, returns <code>fairValue - costsToSell</code>. On error returns 0 and logs via <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> If inputs non-numeric, treated as 0. <br><strong>Tests:</strong> normal numeric cases, non-numeric inputs, negative costs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_RecoverableAmount(carryingAmount, Optional cashflows, Optional discountRate, Optional fairValue, Optional costsToSell, Optional asOfDate, Optional daycount) As Object</strong> — <em>recoverable aggregator (legacy signature preserved)</em><br><strong>Purpose:</strong> Compute both VIU and FVLCOD, choose higher as recoverable, compute impairment relative to carrying amount, return Scripting.Dictionary with standardized keys used elsewhere (RecoverableAmount, VIU, FVLCOD, MethodUsed, CarryingAmount, ImpairmentLoss).<br><strong>Signature:</strong> <code>Public Function IAS36_RecoverableAmount(ByVal carryingAmount As Double, Optional ByVal cashflows As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValue As Double = 0#, Optional ByVal costsToSell As Double = 0#, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Initializes module, sets defaults, computes <code>viu</code> via <code>NPVFromDcfEx</code> when forecast present, computes <code>fvlcod</code>, selects method ("VIU" vs "FVLCOD"), sets out dictionary values, calculates impairment (rounded via <code>Round2</code>) if recoverable < carryingAmount, logs audit entry, returns dictionary. On error returns Nothing after bubbling to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> Dominated by NPV computation O(n).<br><strong>Side-effects:</strong> Calls <code>SafeLog</code> to append audit.<br><strong>Invariants:</strong> Returns numeric zeros instead of Empty where appropriate to preserve downstream expectations; legacy behavior preserved (functions that historically returned Empty should still do so — here returns Nothing on error).<br><strong>Failure modes:</strong> Missing/invalid forecasts produce VIU=0; errors set to Nothing. <br><strong>Recommended tests:</strong> Compare against manual VIU/FVLCOD selection; carry amounts equal to recoverable produce zero impairment; rounding behavior check. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_GroupAssetsIntoCGUs(assets, Optional groupingKey = "CGU") As Object</strong> — <em>grouping helper</em><br><strong>Purpose:</strong> Group asset records into CGUs by specified groupingKey; returns Dictionary of Collections keyed by group value. Preserves older behavior and supports arrays/collections/dict-like objects.<br><strong>Signature:</strong> <code>Public Function IAS36_GroupAssetsIntoCGUs(ByVal assets As Variant, Optional ByVal groupingKey As String = &quot;CGU&quot;) As Object</code><br><strong>Behavior:</strong> Defensive: returns empty Dictionary if no assets. Supports arrays (any lower bound) and collection-like objects; for each item extracts groupingKey if present else uses default "CGU_1". Builds deterministic Collections inserted in order of iteration. Uses local <code>On Error Resume Next</code> micro-blocks when probing objects.<br><strong>Complexity:</strong> O(n) where n = number of assets.<br><strong>Side-effects:</strong> None beyond returned structure.<br><strong>Invariants:</strong> Keys are strings; each value is a <code>Collection</code> whose items are the original asset objects (not copies).<br><strong>Failure modes:</strong> Non-collection inputs → returns empty dictionary. <br><strong>Tests:</strong> Arrays with different LBound values; object collections; missing groupingKey cases. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_GenerateDCF(forecast, discountRate, Optional asOfDate, Optional daycount) As Variant</strong> — <em>return DCF table array with header</em><br><strong>Purpose:</strong> Build deterministic, sorted DCF table (Date, Cashflow, DiscountFactor, PV) from various forecast shapes; useful for inspection and disclosures.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateDCF(ByVal forecast As Variant, ByVal discountRate As Double, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Variant</code><br><strong>Behavior:</strong> Validates inputs, normalizes forecast via <code>NormalizeForecastToArray</code>, computes year fractions via <code>YearFractionEx</code>, discount factors and PV per row, accumulates running PV. Returns a 2D variant array with first row headers and subsequent rows for each forecast row. Returns Empty for invalid/empty forecast. Errors routed to <code>HandleInternalError</code> and returns Empty.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Rows sorted by date ascending (via <code>NormalizeForecastToArray</code> sorting). Non-dates appear as Empty in Date column. Discount factor = 1 when discountRate <= 0.<br><strong>Failure modes:</strong> Non-date/invalid rows placed last by normalization; zero/negative rates handled. <br><strong>Tests:</strong> Known cashflow example with manual PV check; negative rates; zero discount; non-date rows. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_RunImpairmentTest(cgu, Optional discountRate=0#, Optional fairValue=0#, Optional costsToSell=0#, Optional asOfDate, Optional daycount) As Object</strong> — <em>single-CGU impairment test</em><br><strong>Purpose:</strong> Execute full impairment test for one CGU: compute total carrying, recoverable amount (VIU/FVLCOD), impairment, deterministic allocation (if impairment > 0), attach CorrelationID and return result dictionary containing core fields and Allocation dictionary.<br><strong>Signature:</strong> <code>Public Function IAS36_RunImpairmentTest(ByVal cgu As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValue As Double = 0#, Optional ByVal costsToSell As Double = 0#, Optional ByVal asOfDate As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Defensive validation of <code>cgu</code>; extracts <code>Assets</code> and <code>Forecast</code>; sums carrying amounts (using <code>GetDictValueIndexed</code> and <code>NZDouble</code>); computes VIU and FVLCOD; determines recoverable and impairment (rounded); builds result dictionary with CGUID (fallback "CGU_UNKNOWN"), TotalCarrying (rounded), RecoverableAmount, MethodUsed, Impairment, VIU, FVLCOD, AsOfDate, DiscountRate, Daycount, CorrelationID via <code>GenerateCorrelationID</code>. If impairment > 0 and assets present, calls <code>AllocateImpairment</code> (PRORATA default), attaches Allocation and verifies invariant via <code>VerifyAllocationInvariant</code>. Logs via <code>SafeLog</code>. On failure returns Nothing and routes to <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(n + m) where n = assets, m = forecast rows (NPV).<br><strong>Side-effects:</strong> Calls <code>AllocateImpairment</code> which mutates/creates allocation Dictionary and triggers <code>SafeLog</code> via verification. Adds CorrelationID. <br><strong>Invariants:</strong> If Allocation present, its rounded sum equals impairment (verified, fixed deterministically if not).<br><strong>Failure modes:</strong> Bad cgu input returns Nothing; per-field non-numeric values handled defensively. <br><strong>Recommended tests:</strong> Full flow with positive impairment verifying allocation sums to impairment; CGU w/o assets → no allocation; missing forecast → FVLCOD path tested. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_GenerateImpairmentJournals(testResult, impairmentAccount, assetAccountPrefix) As Variant</strong> — <em>journal generator</em><br><strong>Purpose:</strong> Convert test result Allocation into posting-ready 2D array rows [Date, DrAccount, DrAmount, CrAccount, CrAmount, Narrative]. Preserves deterministic ordering by allocation keys enumeration order (VBScript Dictionary order) which is stable in practice but not guaranteed by spec — code relies on existing Dictionary ordering.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateImpairmentJournals(ByVal testResult As Object, ByVal impairmentAccount As String, ByVal assetAccountPrefix As String) As Variant</code><br><strong>Behavior:</strong> Validates testResult and allocation presence; returns Empty if no impairment. Builds 1..n variant 2D array where each line uses <code>testResult(&quot;AsOfDate&quot;)</code>, impairmentAccount (debit), allocation amount, assetAccountPrefix & "_" & AssetID (credit), narrative includes CorrelationID. Amounts numeric via <code>NZDouble</code>. Errors routed to Handler and return Empty.<br><strong>Complexity:</strong> O(k) where k = number of allocation entries.<br><strong>Side-effects:</strong> None. <br><strong>Failure modes:</strong> Missing Allocation → Empty. AssetAccountPrefix concatenation may produce unexpected account names if AssetID contains invalid chars — callers should validate AssetID. <br><strong>Tests:</strong> Multi-asset allocation -> n rows; correlation included in narratives. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_RunBatchImpairmentTests(cguList, Optional discountRate=0#, Optional fairValueMap, Optional daycount) As Object</strong> — <em>batch runner with per-CGU resilience</em><br><strong>Purpose:</strong> Run <code>IAS36_RunImpairmentTest</code> for a collection/array of CGUs, capture per-CGU successes and per-CGU errors without aborting whole batch, attach BatchCorrelationID and return Dictionary keyed by CGUID -> result or error record.<br><strong>Signature:</strong> <code>Public Function IAS36_RunBatchImpairmentTests(ByVal cguList As Variant, Optional ByVal discountRate As Double = 0#, Optional ByVal fairValueMap As Variant, Optional ByVal daycount As String) As Object</code><br><strong>Behavior:</strong> Creates batchCorrelation via <code>GenerateCorrelationID</code>, logs start, iterates array or object collection; for each CGU extracts optional fairValueMap entries defensively, runs <code>IAS36_RunImpairmentTest</code> inside a per-CGU error handling block (labeled PerCGUErr / PerCGUErr2). On success attaches batchCorrelation fields; on exception captures Err.Number and description into an issue record dictionary and continues. Logs finish. Returns results Dictionary. On global error calls <code>HandleInternalError</code> and returns Nothing.<br><strong>Complexity:</strong> O(B*(asset+forecast)) where B = number of CGUs. Overhead of per-CGU error handling minimal.<br><strong>Side-effects:</strong> Multiple <code>SafeLog</code> entries; no external writes. <br><strong>Invariants:</strong> Returned Dictionary contains an entry for every input CGU index/key; each entry either full result dictionary or an issue dictionary with ErrorNumber/Description. BatchCorrelation is consistent across entries.<br><strong>Failure modes:</strong> Malformed <code>fairValueMap</code> handled defensively; catastrophic error returns Nothing. <br><strong>Tests:</strong> Batch with mixed valid & invalid CGUs → successful entries and per-CGU error entries present; ensure BatchCorrelation in all entries. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_GenerateDisclosureSummary(testResult) As Object</strong> — <em>disclosure-friendly summary builder</em><br><strong>Purpose:</strong> Produce a compact dictionary with CGUID, TotalCarrying, Impairment, ImpairmentPercent, KeyAssumptions (MethodUsed, DiscountRate, Daycount), Sensitivities placeholder — intended for modStatements consumption.<br><strong>Signature:</strong> <code>Public Function IAS36_GenerateDisclosureSummary(ByVal testResult As Object) As Object</code><br><strong>Behavior:</strong> Defensive: if testResult Nothing returns dictionary with Message. Otherwise extracts values using <code>NZDoubleObjKey</code>/<code>NZStringObj</code>, computes ImpairmentPercent safely (0 if TotalCarrying=0), constructs assumptions and sensitivities dictionaries, returns out. Optionally can be persisted by modUtilities if available (comment indicates optional persistence).<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None (pure transform).<br><strong>Tests:</strong> Valid testResult produces expected percentage and assumptions. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_ValidateInputPackage(pkg) As Object</strong> — <em>input package validator, non-fatal issue collector</em><br><strong>Purpose:</strong> Validate structure & minimal shape of input package (CGUID, Assets, Forecast), return Dictionary of issues where empty dictionary = OK. Caller decides fatal vs non-fatal.<br><strong>Signature:</strong> <code>Public Function IAS36_ValidateInputPackage(ByVal pkg As Object) As Object</code><br><strong>Behavior:</strong> Defensive: if pkg Nothing add PackageMissing. Checks CGUID presence, Assets presence and non-empty; iterates assets to ensure AssetID present and CarryingAmount numeric & non-negative; if Forecast present validates via <code>NormalizeForecastToArray</code>. Uses descriptive keys like <code>Asset_1_ID</code> and messages. Returns issues Dictionary. Errors route to Handler and return Nothing.<br><strong>Complexity:</strong> O(n) assets + O(m) forecast normalization.<br><strong>Side-effects:</strong> None. <br><strong>Recommended tests:</strong> Missing CGUID/Assets; assets with missing IDs; negative carrying amounts; invalid forecasts. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36SelfTest() As Boolean</strong> — <em>self-test harness</em><br><strong>Purpose:</strong> Run deterministic smoke tests covering RunImpairmentTest, allocation invariant, VIU calculation, and validation function; log results and optionally write to test results sheet if host integrates test collection.<br><strong>Signature:</strong> <code>Public Function IAS36SelfTest() As Boolean</code><br><strong>Behavior:</strong> Builds fixtures (two assets, 3-year cashflows, etc.), runs <code>IAS36_RunImpairmentTest</code>, verifies result is object, if impairment>0 verifies allocation sums to impairment, runs zero-flow case, runs <code>IAS36_ValidateInputPackage</code> negative case, logs start/finish, returns boolean <code>ok</code>. On exception returns False and calls <code>HandleInternalError</code>.<br><strong>Complexity:</strong> Moderate (runs a small batch of calculations); deterministic RNG usage minimal (<code>Rnd</code> used elsewhere in correlation fallback).<br><strong>Side-effects:</strong> Calls <code>SafeLog</code>; may create test artifacts if host integration present. <br><strong>Tests:</strong> Self-test should return True in a correctly functioning environment; intentionally break parts to ensure SelfTest catches failures. </td></tr><tr><td data-label="Technical Breakdown"> <strong>NPVFromDcfEx(dcf, discountRate, asOfDate, daycount) As Double</strong> — <em>robust NPV from normalized DCF</em><br><strong>Purpose:</strong> Sum PV of cashflows (normalized) using <code>YearFractionEx</code> to compute time fractions; used by VIU computations and tests.<br><strong>Signature:</strong> <code>Private Function NPVFromDcfEx(ByVal dcf As Variant, ByVal discountRate As Double, ByVal asOfDate As Variant, ByVal daycount As String) As Double</code><br><strong>Behavior:</strong> If forecast empty returns 0. Normalizes via <code>NormalizeForecastToArray</code>. For each row compute year fraction <code>yf</code> and PV = cf / (1+discountRate)^yf (or cf when discountRate <= 0). Accumulate and return. Errors routed to <code>HandleInternalError</code> and return 0.<br><strong>Complexity:</strong> O(n).<br><strong>Side-effects:</strong> None. <br><strong>Invariants:</strong> Deterministic given same inputs and daycount function. <br><strong>Failure modes:</strong> Bad date rows handled by normalization; extremely large exponents may risk floating precision but typical accounting ranges safe. <br><strong>Tests:</strong> Known cashflow manual PV comparison; discountRate=0 returns sum of cashflows. </td></tr><tr><td data-label="Technical Breakdown"> <strong>NormalizeForecastToArray(forecast) As Variant</strong> — <em>canonical forecast normalization & stable sorting</em><br><strong>Purpose:</strong> Convert heterogeneous forecast input shapes (2D arrays, arrays of rows, collections of dicts) into a stable 1-based 2D variant array [1..n,1..2], remove empty rows, coerce amounts, and sort ascending by date deterministically pushing non-dates to end. Preserves deterministic behavior across runs and versions.<br><strong>Signature:</strong> <code>Private Function NormalizeForecastToArray(ByVal forecast As Variant) As Variant</code><br><strong>Behavior:</strong> If no rows returns Empty. Copies inputs into temp array treating various shapes, compacts valid rows where Date present or numeric amount present. Builds <code>out</code> array and performs a stable bubble-sort by date: date-date comparison, non-date pushed after dates. Returns Empty if no valid rows. Uses micro error blocks when probing items.<br><strong>Complexity:</strong> O(n^2) due to bubble-sort — acceptable because forecasts are typically small; intentionally stable deterministic algorithm chosen over faster non-stable sorts for auditability.<br><strong>Side-effects:</strong> None.<br><strong>Invariants:</strong> Output is 1-based 2D array with dates (or Empty) and numeric amounts; rows sorted with all dates first ascending then non-dates. <br><strong>Failure modes:</strong> If forecast extremely large performance may degrade; recommended to pre-validate sizes before calling. <br><strong>Tests:</strong> Provide differently ordered inputs including non-dates, confirm deterministic ordering and removal of empty rows. </td></tr><tr><td data-label="Technical Breakdown"> <strong>SwapForecastRows(ByRef arr As Variant, i As Long, j As Long)</strong> — <em>swap utility</em><br><strong>Purpose:</strong> Swap two rows in forecast 2D array used by bubble-sort.<br><strong>Signature:</strong> <code>Private Sub SwapForecastRows(ByRef arr As Variant, ByVal i As Long, ByVal j As Long)</code><br><strong>Behavior:</strong> Swaps date and amount pairs; trivial utility. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> small array swap correctness. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetForecastDateAt(forecast, idx) As Variant</strong> — <em>safe accessor for forecast date</em><br><strong>Purpose:</strong> Provide robust read from different forecast shapes using LBound awareness and object/array probing; returns Empty on failure.<br><strong>Signature:</strong> <code>Private Function GetForecastDateAt(ByVal forecast As Variant, ByVal idx As Long) As Variant</code><br><strong>Behavior:</strong> For arrays computes base + idx - 1 indexing; for objects attempts forecast(idx)(1) with error suppression. Errors return Empty. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Different forecast shapes produce expected values. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetForecastAmountAt(forecast, idx) As Variant</strong> — <em>safe accessor for forecast amount</em><br><strong>Purpose:</strong> As above but returns numeric amount or 0 on failure.<br><strong>Signature:</strong> <code>Private Function GetForecastAmountAt(ByVal forecast As Variant, ByVal idx As Long) As Variant</code><br><strong>Behavior:</strong> Defensive indexing; returns 0 on errors. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>YearFractionEx(d0, d1, convention) As Double</strong> — <em>daycount implementation</em><br><strong>Purpose:</strong> Compute year fraction between two dates using supported conventions: "ACT/365" (default), "ACT/360", "30/360". Non-dates produce 0; negative days produce 0 (no negative yf).<br><strong>Signature:</strong> <code>Private Function YearFractionEx(ByVal d0 As Variant, ByVal d1 As Variant, ByVal convention As String) As Double</code><br><strong>Behavior:</strong> Validates dates, computes days difference as <code>CDbl(dt1) - CDbl(dt0)</code>, applies convention formulas. "30/360" uses simple 30/360 arithmetic. Unknown convention falls back to ACT/365.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> None.<br><strong>Failure modes:</strong> Input non-dates -> 0. <br><strong>Tests:</strong> Known date pairs for each convention; negative dt1 < dt0 returns 0. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetRowCount(arr) As Long</strong> — <em>generic row/collection counter</em><br><strong>Purpose:</strong> Provide robust count for arrays (handles arbitrary LBound/UBound) and collection-like objects; returns 0 for missing/empty inputs.<br><strong>Signature:</strong> <code>Private Function GetRowCount(ByVal arr As Variant) As Long</code><br><strong>Behavior:</strong> If IsArray uses LBound/UBound to compute count; if IsObject attempts <code>arr.count</code> with error suppression; else 0. Errors handled. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Arrays with different bounds; collections; Nothing inputs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetDictValue(dictLike, key) As Variant</strong> — <em>safe dict get</em><br><strong>Purpose:</strong> Return value if object and key exists; else Empty. Thin defensive wrapper used across module.<br><strong>Signature:</strong> <code>Private Function GetDictValue(ByVal dictLike As Variant, ByVal key As String) As Variant</code><br><strong>Behavior:</strong> Uses <code>IsObject</code> -> <code>Exists</code> check with <code>On Error Resume Next</code>. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>GetDictValueIndexed(dictArray, idx, key) As Variant</strong> — <em>safe indexed dict get</em><br><strong>Purpose:</strong> For arrays or collections of dict-like items provide safe extraction of a key from the element at index <code>idx</code> with support for arrays with non-1 LBound.<br><strong>Signature:</strong> <code>Private Function GetDictValueIndexed(ByVal dictArray As Variant, ByVal idx As Long, ByVal key As String) As Variant</code><br><strong>Behavior:</strong> Handles array and object forms; returns Empty when not present or on error. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Array-of-dicts and collection-of-dicts scenarios with missing keys. </td></tr><tr><td data-label="Technical Breakdown"> <strong>NZDouble(v, Optional def = 0#) As Double</strong> — <em>null-safe numeric coercion</em><br><strong>Purpose:</strong> Convert value to Double if numeric else return default. Swallows errors.<br><strong>Signature:</strong> <code>Private Function NZDouble(ByVal v As Variant, Optional ByVal def As Double = 0#) As Double</code><br><strong>Behavior:</strong> <code>IsNumeric</code> then <code>CDbl</code> else def. <br><strong>Complexity:</strong> O(1).<br><strong>Tests:</strong> Numeric strings, Null, Empty, objects. </td></tr><tr><td data-label="Technical Breakdown"> <strong>NZDoubleObjKey(o, key, Optional def = 0#) As Double</strong> — <em>object-key numeric fetch</em><br><strong>Purpose:</strong> If object exists and contains key, coerce numeric value via NZDouble else default.<br><strong>Signature:</strong> <code>Private Function NZDoubleObjKey(ByVal o As Object, ByVal key As String, Optional ByVal def As Double = 0#) As Double</code><br><strong>Behavior:</strong> Defensive checks for Nothing and key existence. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>NZStringObj(o, key, Optional def = "") As String</strong> — <em>object-key string fetch</em><br><strong>Purpose:</strong> Defensive extraction of string from object key; returns default otherwise.<br><strong>Signature:</strong> <code>Private Function NZStringObj(ByVal o As Object, ByVal key As String, Optional ByVal def As String = &quot;&quot;) As String</code><br><strong>Behavior:</strong> Similar to NZDoubleObjKey but returns CStr. <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>NZString(v, Optional def = "") As String</strong> — <em>null/empty to string helper</em><br><strong>Purpose:</strong> Coerce variant to string or default for Null/Empty.<br><strong>Signature:</strong> <code>Private Function NZString(ByVal v As Variant, Optional ByVal def As String = &quot;&quot;) As String</code><br><strong>Behavior:</strong> Returns def for Null/Empty else CStr(v). <br><strong>Complexity:</strong> O(1). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Round2(v As Double) As Double</strong> — <em>centralized rounding policy</em><br><strong>Purpose:</strong> Central rounding to 2 decimal places using <code>VBA.Round</code>. Single point of change for rounding policy (bankers vs away-from-zero note in header).<br><strong>Signature:</strong> <code>Private Function Round2(ByVal v As Double) As Double</code><br><strong>Behavior:</strong> Calls <code>VBA.Round(v,2)</code> with error suppression. <br><strong>Complexity:</strong> O(1).<br><strong>Notes:</strong> If rounding policy needs change, modify here; maintainers should add unit tests for edge .005 cases for target policy. </td></tr><tr><td data-label="Technical Breakdown"> <strong>AllocateImpairment(assets, impairment, mode, weights) As Object</strong> — <em>deterministic allocation algorithm (core)</em><br><strong>Purpose:</strong> Deterministically allocate total impairment across assets according to mode: "PRORATA" (default), "EQUAL", "WEIGHTED". Returns Dictionary AssetID -> allocation (rounded 2dp). Guarantees sum-to-impairment after residual deterministic adjustment and invariant verification/fallback.<br><strong>Signature:</strong> <code>Private Function AllocateImpairment(ByVal assets As Variant, ByVal impairment As Double, ByVal mode As String, ByVal weights As Variant) As Object</code><br><strong>Behavior (detailed):</strong><br>- Defensive early exit for no assets -> empty dict.<br>- Extract arrays <code>carries()</code> and <code>ids()</code> (deterministic ordering by input iteration).<br>- Compute <code>rawAlloc()</code> based on mode: PRORATA uses carrying weights; EQUAL divides equally; WEIGHTED uses provided weights (array or dictionary) with fallback to pro-rata when weights invalid.<br>- Round each line via <code>Round2</code> and accumulate <code>sumRounded</code>.<br>- Compute <code>residual = Round2(impairment - sumRounded)</code> and if residual significant (abs>=0.005) pick deterministic index to adjust: for PRORATA choose largest carrying (tie-break lex AssetID case-insensitive); for EQUAL/WEIGHTED choose largest rawAlloc (tie-break lex smallest id). Apply residual to chosen asset and re-round.<br>- Verify final sum equals impairment (rounded). If mismatch log <code>AllocationInvariant</code> and deterministically add remaining diff to lexicographically smallest AssetID.<br>- Return Dictionary. On error calls <code>HandleInternalError</code> and returns best-effort allocations.<br><strong>Complexity:</strong> O(rc) where rc = asset count. <br><strong>Side-effects:</strong> Creates and returns Dictionary; uses <code>SafeLog</code> on invariant mismatch.<br><strong>Invariants:</strong> Sum of allocations (rounded) equals <code>impairment</code> (rounded). Tie-break deterministic to ensure reproducibility.<br><strong>Failure modes:</strong> Non-numeric carrying amounts treated as 0; weights malformed -> fallback to pro-rata. For extremely large asset counts numeric rounding may produce frequent residuals; algorithm handles by deterministic redistribution.<br><strong>Recommended tests:</strong> Multiple modes, weight dictionary vs array, tie scenarios where residual distribution deterministic, round-trip sum equality. </td></tr><tr><td data-label="Technical Breakdown"> <strong>IAS36_AllocateImpairment(assets, impairment, Optional mode="PRORATA", Optional weights) As Object</strong> — <em>public thin wrapper to allocation</em><br><strong>Purpose:</strong> Expose allocation algorithm preserving backward compatibility; ensures impairment is rounded to module policy before allocation and logs verification with generated correlation ID.<br><strong>Signature:</strong> <code>Public Function IAS36_AllocateImpairment(ByVal assets As Variant, ByVal impairment As Double, Optional ByVal mode As String = &quot;PRORATA&quot;, Optional ByVal weights As Variant) As Object</code><br><strong>Behavior:</strong> Round <code>impRounded = Round2(NZDouble(impairment))</code>, call <code>AllocateImpairment</code>, call <code>VerifyAllocationInvariant</code> with generated correlation and "ALLOC_PUBLIC" marker, return allocation. On error returns Nothing after <code>HandleInternalError</code>.<br><strong>Complexity:</strong> O(rc).<br><strong>Side-effects:</strong> Logs verification. <br><strong>Tests:</strong> Public wrapper returns same as private when impairment rounded; verification logs created. </td></tr><tr><td data-label="Technical Breakdown"> <strong>VerifyAllocationInvariant(allocations, expectedTotal, cguid, correlationID)</strong> — <em>invariant checker & auditor</em><br><strong>Purpose:</strong> Compute sum of allocation dictionary and log either OK or mismatch; non-throwing (resilient).<br><strong>Signature:</strong> <code>Private Sub VerifyAllocationInvariant(ByVal allocations As Object, ByVal expectedTotal As Double, ByVal cguid As String, ByVal correlationID As String)</code><br><strong>Behavior:</strong> Sums allocations via <code>NZDouble</code>, compares rounded sums; on mismatch logs <code>VerifyAllocationInvariant</code> with details; on OK logs <code>VerifyAllocationInvariant.OK</code>. Errors suppressed; uses <code>SafeLog</code> for audit.<br><strong>Complexity:</strong> O(k) where k = number of allocated entries. <br><strong>Side-effects:</strong> Audit logs. <br><strong>Notes:</strong> Useful for telemetry and forensic traceability in batch runs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>SafeLog(moduleName, proc, details)</strong> — <em>structured logging wrapper</em><br><strong>Purpose:</strong> Centralized audit logging that attempts to call host <code>LogAudit</code> (by <code>Application.Run &quot;LogAudit&quot;, ...</code>) and falls back to <code>Debug.Print</code> if not available. Non-throwing to not disturb main flows.<br><strong>Signature:</strong> <code>Private Sub SafeLog(moduleName As String, proc As String, details As String)</code><br><strong>Behavior:</strong> <code>On Error Resume Next</code> + <code>Application.Run &quot;LogAudit&quot;, moduleName &amp; &quot;.&quot; &amp; proc, details</code>. If that errors, prints fallback to Immediate window. Clears Err.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> Calls host macro if present. <br><strong>Failure modes:</strong> Host <code>LogAudit</code> absent triggers fallback. <br><strong>Tests:</strong> With and without host LogAudit hook — confirm fallback behavior. </td></tr><tr><td data-label="Technical Breakdown"> <strong>HandleInternalError(procName, errObj)</strong> — <em>error routing / host integration</em><br><strong>Purpose:</strong> Route internal errors to host <code>HandleError(procName, errNumber, errDescription)</code> if present; otherwise raise minimal VBA error to surface to host while avoiding uncontrolled crashes. Accepts ErrObject or numeric/string descriptors as <code>errObj</code> and extracts Number/Description accordingly.<br><strong>Signature:</strong> <code>Private Sub HandleInternalError(procName As String, ByVal errObj As Variant)</code><br><strong>Behavior:</strong> Defensive extraction of <code>errObj</code> fields (supports ErrObject, object-like, numeric, string). Attempts <code>Application.Run &quot;HandleError&quot;, procName, n, d</code>. If that succeeds returns. If host call not available, raises <code>Err.Raise vbObjectError + 513</code> with a minimal message to surface error. All internal error handling uses <code>On Error Resume Next</code> to avoid masking host behavior and ensures Err cleared where appropriate.<br><strong>Complexity:</strong> O(1).<br><strong>Side-effects:</strong> May raise an error if host handler not present; otherwise delegates to host. <br><strong>Failure modes:</strong> Host <code>HandleError</code> absent -> small raised error; ensure callers expect possible raised errors. <br><strong>Tests:</strong> Simulate host missing -> Err.Raise observed; with host stub -> host receives call. </td></tr><tr><td data-label="Technical Breakdown"> <strong>GenerateCorrelationID() As String</strong> — <em>traceability id generator with GUID fallback</em><br><strong>Purpose:</strong> Attempt to produce GUID via <code>Scriptlet.TypeLib</code>.guid; if not available, generate timestamp-based fallback string <code>&quot;CID_yyyymmddhhNNss_random&quot;</code>. Ensures traceability across logs and batch runs.<br><strong>Signature:</strong> <code>Private Function GenerateCorrelationID() As String</code><br><strong>Behavior:</strong> Try <code>CreateObject(&quot;Scriptlet.TypeLib&quot;).guid</code>, strip braces; on error returns timestamp + pseudo-random component using <code>Rnd</code>. Uses <code>On Error GoTo Fallback</code> pattern. <br><strong>Complexity:</strong> O(1).<br><strong>Failure modes:</strong> Worst-case fallback uses timestamp & Rnd — acceptable for correlation but less globally unique. <br><strong>Tests:</strong> On typical Windows hosts GUID produced; on restricted hosts fallback format used. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Notes on cross-cutting behaviors & maintainability</strong><br><strong>Determinism:</strong> The module consciously chooses deterministic, stable algorithms (bubble-sort stable ordering, tie-break rules in allocations) to ensure auditability; changing tokenization/sorting/allocation rules must be accompanied by migration tests and explicit versioning. <br><strong>Error handling philosophy:</strong> Prefer targeted micro <code>On Error Resume Next</code> blocks when probing host-provided objects or optional fields; global <code>ErrHandler</code> sections route to <code>HandleInternalError</code> and return safe default (Empty, 0, Nothing) to avoid crashing host automation. <br><strong>Rounding policy:</strong> Centralized in <code>Round2</code> to allow policy switch. Add tests for .005 rounding edge cases if policy changes. <br><strong>Security & data sensitivity:</strong> Module handles financial numbers only; avoid writing PII into logs. <code>SafeLog</code> uses host <code>LogAudit</code> — ensure host implements appropriate retention and redaction for sensitive fields. <br><strong>Performance:</strong> Forecast normalization uses O(n^2) stable bubble-sort — acceptable for typical short forecasts. If high row counts expected (>1000) consider replacing with stable merge sort. <br><strong>Testing recommendations:</strong> Unit tests for token deterministic allocations, allocation residual distribution in tie cases, daycount conventions (ACT/365, ACT/360, 30/360), NPV equivalence to reference spreadsheets, per-CGU batch resilience (simulate throwing CGU), SelfTest regression gating in CI. <br><strong>Host integration checklist:</strong> Ensure host provides <code>LogAudit</code> and <code>HandleError</code> or accept fallback behaviours. Prefer host to capture <code>SafeLog</code> outputs for audit trails. <br><strong>Compatibility:</strong> Public API surface preserved: <code>IAS36_RecoverableAmount</code>, <code>IAS36_RunImpairmentTest</code>, <code>IAS36_RunBatchImpairmentTests</code>, <code>IAS36_GenerateImpairmentJournals</code>, <code>IAS36_AllocateImpairment</code> and <code>IAS36_GenerateDisclosureSummary</code> should remain stable for consumers. </td></tr></tbody></table></div><div class="row-count">Rows: 36</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>