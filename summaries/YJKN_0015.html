<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771658211">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="YJKN_0015_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **PPh Pasal 21 withholding and year-end reconciliation**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>PPh Pasal 21 withholding and year-end reconciliation</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Purpose & Scope — canonical operational blueprint (expanded & prescriptive)</strong><br>This single-column artifact functions as the canonical operational and technical blueprint for PPh Pasal 21 withholding and year-end reconciliation procedures that specifically address employees who move between employers inside the same fiscal year. The artifact is intentionally prescriptive: it must be pasted unchanged into policy repositories, payroll SOPs, HCM implementation guides, auditor packages, and training modules. Only numeric or jurisdiction-specific configuration values (for example PTKP tables, progressive band thresholds, biaya jabatan plafon, TER defaults and effective dates) may be modified and only via the single authoritative configuration file <code>config:regulatory_sources</code> which must itself be versioned and carry a verifier id and verification date. For every release include: a machine-readable <code>config/*.json</code>, human readable release_notes.md, regression test artifacts, UAT signoffs, and approver signatures. Where formulas or automation steps are provided they are deliberately paste-ready: spreadsheet cell formulas use explicit named ranges; Power Query applied step names are canonical and reproducible in an Advanced Editor; DAX measures are written for star schema models; solver patterns include algorithmic update rules, iteration guards, and audit logging fields. This artifact also requires that all ingestion, transformation and distribution components implement idempotent processing (checksum first), persistent immutable audit trails per employee per fiscal year, and documented exception handling. The intended audience includes Payroll Controllers, Tax Leads, HR Onboarding teams, Finance approvers, IT integration engineers and external auditors; adapt only numeric values via <code>config</code> and never change governance text without recorded Board or CFO approval. This section must be treated as the single authoritative baseline and any deviation must be captured as a formal policy change in <code>releases/</code> with an approver signature, change rationale, and a regression test demonstrating no unintended delta in calculation outputs. For operational clarity, include a short summary table of the change (field, old_value, new_value, effective_date, verifier_id) with each release. Add a mandatory "regulatory check" step to your release checklist that requires a copy of the applicable statutory text (scanned PDF) and recorded verifier comments referencing exact article numbers. This ensures the blueprint remains both machine-executable and audit-grade for external review. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Governance & auditability (expanded ruleset and controls)</strong><br>Governance must treat monthly withholdings as provisional estimates to be reconciled at year end or upon termination; legal finality is declared only by an issued reconciled statement and associated SSP or audited recon_pdf. All prior employer withholding credits must be applied only when accompanied by an authenticated bukti potong (Form 1721-A1/A2) file; each bukti potong must be stored with a <code>checksum_sha256</code>, <code>uploaded_by</code>, <code>upload_timestamp</code>, and <code>source_contact</code>. Changes to applied credits, TER fallbacks or manual overrides must create an immutable <code>override_record</code> that records actor id, approver id, timestamp, business rationale, numeric deltas, and links to evidence. Maintain an immutable <code>audit_trail</code> package per employee and fiscal year holding each input file, calculation workbook (with cell references and named ranges), SSP/proof of transfer, emails and signed memos; each package must be exported with a manifest file containing checksums and stored under DMS path <code>DMS:/audit_packages/{fiscal_year}/{employee_id}/manifest_{employee_id}_{year}.json</code>. All templates and scripts must use semantic file versioning <code>file_v{major}.{minor}_{YYYYMMDD}</code> and include diffs and approver signatures in the release folder. In addition, require a minimal set of governance metadata for each run: <code>config_version</code>, <code>run_user</code>, <code>run_timestamp</code>, <code>run_id</code>, <code>env</code> (staging/prod) and <code>rerun_of</code> (if any) so auditors can reconstruct any prior result. For any post-production correction, append a remediation note to the audit package and link to the CI issue and approval artifacts documenting why the correction was necessary, who authorized it, and confirmation that the change was included in the next release bundle. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Key definitions (operational clarity & unambiguous reference)</strong><br>Define operational terms precisely to avoid inconsistent interpretations in automation or audits: PKP — Penghasilan Kena Pajak: annual taxable income after allowable deductions (explicitly excluding pre-tax salary sacrifice items mapped to <code>pre_tax</code> codes). PTKP — Penghasilan Tidak Kena Pajak: non-taxable allowance keyed by tax_status_code / filing status and effective date. Biaya Jabatan — statutory cost-of-work deduction equal to 5% of eligible earnings subject to an annual plafon; compute prorata per employer period by inclusive months. TER — Tarif Efektif Rata-rata used as a planning parameter for monthly withholding when prior credit documentation is missing; store TER source and effective date. Prev_employer_entry — canonical DB record containing prior employer gross, withheld tax, evidence path(s), checksum, parse metadata and verification status. Manifest — machine-readable audit package enumerating files, checksums, statuses, and approver signatures. Recon_pdf — final human-readable reconciliation and resolution package that references the manifest. Each definition must be implemented as a typed field in the canonical <code>config</code> and data model to ensure consistent usage across PQ, DAX, VBA and API integrations. Additionally, publish a short glossary table in the policy repo mapping field names, internal column names, and example values so that engineers and auditors can reconcile naming differences across tools and modules. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Core data model (relational canonical schema with implementation notes)</strong><br>Design the schema for use by PQ transforms and downstream BI as a normalized star schema: <code>dim_employee (employee_id PK, legal_name, preferred_name, npwp_normalized, npwp_status, tax_status_code, residency_status, ptkp_code, employee_grade, hire_date, termination_date, contact_email)</code>; <code>fact_payroll (trx_id, employee_id FK, employer_id, payroll_batch_id, pay_period_start, pay_period_end, pay_date, gross_amount, basic_salary, allowances_json, bonus_amount, pension_employee, pension_employer, taxable_benefit_breakdown_json, tax_withheld, payment_type, source_file_id, currency_code, fx_rate_info_json)</code>; <code>prev_employer_entry (entry_id, employee_id, prev_employer_name, prev_employer_npwp, period_start, period_end, months_in_period, credit_prev_gross, credit_prev_tax, file_path, checksum_sha256, upload_date, uploaded_by, parsed_by, parse_confidence, verification_status, verified_by, verified_date, verification_notes, override_reason)</code>; <code>config</code> as single source for regulatory parameters and business policy tables; <code>audit_trail</code> for every file/action with manifest joins. Implementation notes: enforce typed columns, JSON columns for allowances only where unavoidable, index <code>employee_id</code> and <code>checksum_sha256</code>, and maintain <code>parser_version</code> and <code>transform_version</code> columns for reproducibility. Provide migration scripts for adding new fields with zero-impact default logic and clearly documented backwards compatibility rules for older audit packages; these scripts must include a dry-run mode and produce a delta report for review prior to execution in production. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Field-level validation logic (implementable checks, error states, and remediation)</strong><br>Implement validation rules early in data ingestion and persist validation results to <code>validation_log</code> for traceability. Examples: NPWP normalization rule — <code>npwp_normalized = REGEX_REPLACE(npwp_raw, &quot;[^0-9]&quot;, &quot;&quot;)</code>; require <code>LEN(npwp_normalized) == 15</code> for <code>npwp_required</code> employees; violation status = <code>npwp_invalid</code>; action = block final posting and create exception ticket assigned to HR with SLA 3 business days. Inclusive months calculation formula — <code>months_in_period = (YEAR(end)-YEAR(start))*12 + (MONTH(end)-MONTH(start)) + 1</code>. Enforce <code>SUM(months_in_period across prev entries + current_year) &lt;= 12</code>; if greater, create <code>overlap_exception</code> requiring manager approval recorded in <code>audit_trail</code>. Credit sanity check — <code>credit_prev_tax &lt;= credit_prev_gross</code>; if not, set <code>verification_status = manual_review_required</code>, require bukti potong file and verifier note with reason code. Monetary bounds — require all monetary fields <code>&gt;= 0</code>; negative adjustments must include <code>adjustment_reason</code>, <code>adjustment_author</code>, <code>adjustment_approver</code>. FX lines must carry <code>fx_rate</code>, <code>fx_source</code>, <code>fx_rate_date</code>, <code>converted_amount</code>; compute <code>fx_variance = converted_amount - (original_amount * fx_rate)</code>; if <code>ABS(fx_variance) &gt; fx_variance_threshold</code> flag <code>tax_counsel_review</code>. File ingestion: compute SHA256 and if checksum exists update metadata instead of creating duplicate records. Record <code>parser_version</code>, <code>parse_time_ms</code>, <code>parse_confidence</code> for each automatic parse operation. Store exception counters and median time to resolve as KPIs reported weekly to Payroll leadership. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>End-to-end operational checklist (detailed steps, owner tasks & SLAs)</strong><br>Define concrete runbook steps with owners and SLAs for each operational milestone: Onboarding (HR) Day 0–3 — HR must request prior bukti potong and NPWP, provision secure upload link, verify receipt and create <code>prev_employer_entry</code> record; if 1721 absent set <code>fallback_TER_flag</code> and notify employee; SLA: acknowledge request within ≤3 business days. Exit payroll (prior employer) Day 0–7 — prior employer calculates final pay including prorata PTKP and pesangon, issues 1721-A1/A2, and stores file plus checksum and transfer proof; SLA: 1721 issuance within ≤7 business days. New employer onboarding Day 0–3 — new employer requests bukti potong, verifies NPWP and PTKP status, uploads prev entry and marks verification outcome; SLA: verification within ≤3 business days. Monthly payroll — snapshot <code>config_version</code> in payroll metadata, compute monthly withholdings using TER or layered algorithm, record <code>withholding_reason</code> per line, execute exceptions export. December job / Exit reconciliation — aggregate incomes across prev entries and current employer, compute annual PKP and annual PPh, reconcile prior withholdings generating <code>recon_pdf</code> and <code>manifest</code>, and instruct finance for refund or additional withholding; SLA: adjustments applied within the next payroll cycle after reconciliation. Ensure runbooks contain command snippets, file paths, and contact lists, with a triage matrix indicating which exceptions can be auto-resolved and which require manager approval. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Detailed numeric worked example (spreadsheet ready with explicit named ranges and formulas)</strong><br>This worked example is intentionally formula-driven and uses named ranges so it can be copied directly into configuration workbooks. Assumptions: tax status TK/0; <code>PTKP = 54,000,000</code>; <code>biaya_jabatan_plafon = 6,000,000</code>. Company X Jan–Jun: <code>monthly_gross = 15,000,000</code>; <code>pension_monthly = 100,000</code> → <code>total_gross_X = 15,000,000 * 6 = 90,000,000</code>. Company Y Jul–Dec: <code>monthly_gross = 17,000,000</code>; <code>pension_monthly = 150,000</code>; <code>bonus_Nov = 10,000,000</code> → <code>total_gross_Y = (17,000,000 * 6) + 10,000,000 = 112,000,000</code>. Combined: <code>rng_TotalGross = total_gross_X + total_gross_Y = 202,000,000</code>. <code>rng_TotalPension = (100,000 * 6) + (150,000 * 6) = 1,500,000</code>. <code>rng_BiayaRaw = 0.05 * rng_TotalGross = 10,100,000</code>; <code>rng_Biaya = MIN(rng_BiayaRaw, rng_BiayaPlafon)</code> → <code>MIN(10,100,000, 6,000,000) = 6,000,000</code>. Allocation per employer uses proportional formula: <code>biaya_X = rng_Biaya * (total_gross_X / rng_TotalGross)</code> etc. Net taxable income formula <code>rng_NetTaxable = rng_TotalGross - rng_TotalPension - rng_Biaya</code>. PKP <code>rng_PKP = MAX(0, rng_NetTaxable - rng_PTKP)</code>. Implement progressive tax using a bands table and SUMX formula rows in spreadsheet: <code>tax_for_band_i = MAX(0, MIN(rng_PKP, upper_i) - lower_i) * rate_i</code>. This example yields annual_tax = 15,075,000 and shows withheld totals to demonstrate a shortage and the reconciliation balance; include cell references to <code>tbl_ProgressiveBands</code> and named ranges for portability. Provide an explicit "paste area" in the workbook with named ranges <code>rng_TotalGross</code>, <code>rng_BiayaPlafon</code>, <code>rng_PTKP</code>, and keep a verification sheet that recomputes each intermediate step with checksums to ensure formula integrity when copied between systems. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Per-month sample table (detailed, paste-ready with named range references and formula patterns)</strong><br>Provide a month-by-month ledger that operators can paste into <code>monthly_withholding</code> sheet: columns <code>Month | Employer | Gross | Withheld | Cumulative_Withheld | Source_File | Payslip_Link</code>. Example rows: <code>Jan | X | =rng_X_MonthlyGross | =Gross * VLOOKUP(Employer, tbl_TER, 2, FALSE)</code>; <code>Feb | X | =...</code> continuing through Dec. For bonus rows indicate <code>Payment_Type = Bonus</code> and withhold using specific bonus tax rate or applicable TER override. Cumulative formula uses <code>=SUM($D$2:Dn)</code> so that monthly accruals are transparent. Ensure each row contains <code>Source_File</code> and <code>Payslip_Link</code> mapping to <code>fact_payroll.source_file_id</code> and DMS location; these links are used by auditors to validate per-month withheld amounts. Include notes that rounding rules should be applied according to <code>config.rounding_rule</code> and that the reconciliation engine must use exact raw numbers (not rounded intermediate) for annual aggregation to avoid small rounding differences at settlement. Provide a reconciliation tolerance cell and a scripted check that raises an exception if <code>ABS(december_balance) &gt; config.tolerance</code>. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Gross-up policy & spreadsheet solver (operational algorithm, logging & approval gates)</strong><br>Gross-up is a controlled benefit and must be implemented with rigorous approval flows and auditable solver logs. Policy: gross-up allowed only when documented business case and Finance Director approval exist, and only when <code>computed_gross_up_amount &gt; config.gross_up_cap</code> the transaction requires an additional CFO signoff. Solver pattern for spreadsheets: create a solver table with columns <code>iteration | Ak (trial gross) | biaya_jabatan_temp | annual_tax_temp | net_received | error</code>. Initialize <code>A0 = target_net * TER / (1 − TER)</code> as a pragmatic guess; iterate using <code>Ak+1 = Ak + lr * error</code> with <code>lr = 0.5</code> default, recomputing <code>biaya_jabatan_temp = MIN(0.05 * Ak, biaya_plafon)</code>, <code>annual_tax_temp</code> via banded calculation, and <code>net_received = Ak - annual_tax_temp - employer_social_contribs</code> depending on local law. Terminate when <code>ABS(error) &lt; 1</code> (IDR 1) or <code>iterations &gt; 25</code>. Persist <code>gross_up_log</code> with <code>iterations</code>, <code>convergence_flag</code>, <code>runtime_ms</code>, <code>user_id</code>, <code>approver</code>, <code>solver_version</code>. If <code>Ak &gt; config.gross_up_cap</code> automatically flag for additional approver and do not post until signature recorded in <code>audit_trail</code>. Keep solver rows for audit and include a checksum of final solver table in the manifest. Ensure solver implementation is idempotent and provides a replayable seed to reproduce results for auditors. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Pesangon, THR, bonus & special incomes — legal mapping & treatment rules</strong><br>Special types of payments require explicit legal citations and treatment rules: Pesangon — determine statutory exemptions according to the applicable PMK and compute <code>taxable_portion = gross_payment − statutory_exemption</code>; include clear citation string in the manifest and require <code>TaxLead</code> sign-off for non-routine calculations. THR and bonuses — treat as income in the period of payment from the paying employer; include in cumulative PKP calculations for the year. For cases where prior employer cannot issue 1721 (insolvency or dissolution), capture registry evidence (bankruptcy registrar, notary report), mark prev_entry <code>unverifiable = true</code>, advise employee on claiming via SPT, and record the pathway in <code>case_log</code>. For cross-border assignments or double taxation treaty considerations, mark case for <code>TaxLead</code> and capture treaty articles, with explicit currency conversion policy tied to <code>config.fx_policy</code>. For each special income, attach the legal citation and the approver signature within the manifest for auditability, and create a secondary approvals table for cross-checking nonstandard tax treatments. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Power Query (PQ) cookbook — canonical applied steps, error handling & test artifacts</strong><br>Power Query pipelines must be modular, well-commented and reproducible. Canonical query names: <code>raw_payroll</code>, <code>raw_prev_1721</code>, <code>employee_master</code>. Standard applied steps (Advanced Editor ready): <code>01_SourceFolder</code> (enumerate file set by naming pattern), <code>02_UseFirstRowAsHeaders</code>, <code>03_RenameColumns_ToCanonical</code> (use a mapping table in repo), <code>04_ChangeTypes</code> (strict), <code>05_Calc_Months</code> (inclusive month count), <code>06_Prorata_Plafon</code> (prorata formula for biaya_jabatan), <code>07_Calc_CostOfWork</code>, <code>08_ParsePrev1721</code> (extract credit_prev_gross and credit_prev_tax via deterministic parsing), <code>09_Flag_ManualReview</code> (parse_confidence threshold), <code>10_GroupBy_Employee</code>, <code>11_Export_Exceptions</code>. Keep <code>pq_tests/good</code> and <code>pq_tests/corrupt</code> sample files in repo. Nightly refresh must produce metrics: <code>last_refresh_time</code>, <code>records_processed</code>, <code>exceptions_count</code>, <code>parser_version</code>. Tests must be part of CI and fail builds exceeding <code>exceptions_threshold</code>. Persist <code>Applied Step</code> names and comments as part of code review to preserve auditability. Ensure advanced editor includes a top header with <code>parser_version</code> and <code>config_source</code> constants to enable deterministic transforms across environments. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>M expression & Advanced Editor guidance (audit comments & defensive coding)</strong><br>In every PQ Advanced Editor file include a top constant block with <code>parser_version</code>, <code>plafon_constant</code>, and <code>config_source</code> to enable reproducible transforms. Use explicit inline comments such as <code>// Calc_Months: inclusive month count; required for prorata PTKP</code> and <code>// Calc_CostOfWork: compute 5% and cap by prorata_plafon; keep intermediate columns for audit</code>. Use <code>try ... otherwise</code> patterns to isolate corrupted or unexpected rows into a separate exceptions table with a <code>parse_errors</code> column capturing the exception message and stack. Deduplicate prev employer entries by <code>checksum_sha256</code> prior to aggregation. When parsing PDFs or XML, capture <code>parse_confidence</code> (0–1) and threshold at <code>0.85</code> (recommended) to automatically flag manual review. Store <code>parser_version</code> as a hardcoded constant at top and increment for each change; record changes in <code>version_control</code>. For any top-level schema changes, include a compatibility shim step that records legacy column mappings to ensure older audit packages can still be validated. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Macros & safe automation governance (controls to prevent unsigned macros & regression)</strong><br>Macro governance requires macros to be code-signed, stored in a versioned central workbook and released only via VCS with release notes and regression test evidence. Macro design principles: idempotent ingest (checksum checks), macro_log entries (timestamp, user, function, input_checksum, status, error), structured rollback functions for each mutating operation, and approval gating for actions that change posted payroll or gross-up above thresholds. Maintain <code>macro_tests</code> dataset with representative inputs and expected outputs for regression automation. The macro repository must include <code>vba_macros_readme.md</code> listing functions: <code>ImportFiles</code>, <code>ValidateRows</code>, <code>ComputeTaxes</code>, <code>GrossUpSolver</code>, <code>ExportPDFs</code>, <code>NotifyStakeholders</code> along with preconditions, expected runtime and required permissions. Perform signature verification during build and refuse macro execution in production if signature missing. Include code review checklist items for macros: security scan results, unit test coverage, and a smoke-run in staging with sample audit package creation. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Exporting, emailing & delivery rules (robustness & observability requirements)</strong><br>Export rules mandate that every recon_pdf embeds the <code>manifest_checksum</code> in the footer and includes the manifest JSON path and DMS link in the document metadata. The PDF generator must compute the PDF checksum and store it alongside the manifest. Emailing rules: queue personalized messages that include recon_pdf & manifest links; use exponential retry/backoff for transient send failures with a recorded <code>send_attempts</code> count; flag <code>email_failed</code> after <code>N</code> retries and escalate to Payroll Lead. For large batches prefer batched sending with per-employee merge tokens to prevent rate limits; log delivery, open and bounce metadata persisted to <code>communication_log</code>. All communications templates must be stored and versioned in <code>email_templates</code> so that legal reviews can reference the exact wording used for notifications. Maintain a retention policy for sent communications consistent with the audit package retention. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>DAX modeling patterns (star schema measures, debug measures and performance notes)</strong><br>Implement DAX in a star schema with <code>dim_progressive_bands</code> as a static table containing <code>lower</code>, <code>upper</code>, <code>rate</code> and a band index. Copy-ready measures: <code>TotalGross = SUM(fact_payroll[GrossAmount])</code>; <code>AnnualGross</code> filtered by employee and fiscal year; <code>BiayaJabatan = MIN(0.05 * [AnnualGross], SELECTEDVALUE(dim_config[BiayaPlafon]))</code>; <code>PKP = MAX(0, [AnnualGross] - [BiayaJabatan] - SELECTEDVALUE(dim_config[PTKP]))</code>; <code>AnnualTax = SUMX(dim_progressive_bands, MAX(0, MIN([PKP], dim_progressive_bands[upper]) - dim_progressive_bands[lower]) * dim_progressive_bands[rate])</code>; <code>TotalWithheld = SUM(fact_payroll[TaxWithheld])</code>; <code>Balance = [AnnualTax] - [TotalWithheld]</code>. Publish debug measures like <code>Debug_Biaya</code> and <code>Debug_PKP</code> for QA. Performance notes: avoid row-by-row iterative computations in DAX; precompute heavy logic in PQ or backend; keep band table small and stable. Provide sample pbix measure definitions in <code>dax_measures_documentation.md</code> and recommend refresh schedules aligned with reconciliation windows. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>UAT & test plan (exhaustive template, pass criteria & artifacts)</strong><br>UAT must use a templated test case format: <code>Test_ID | Title | Precondition | Steps | Expected | Actual | Status | Owner | Notes</code>. Include seed scenarios covering typical, edge and negative cases. Representative TCs include: TC001 mid-year move without bonus; TC002 mid-year move with final settlement and later bonus; TC003 pesangon partial exemption; TC004 missing 1721 fallback and TER application; TC005 prorata biaya_jabatan boundary behavior; TC006 invalid NPWP blocking; TC007 FX conversion and variance handling; TC008 multiple moves (>2 employers) and dedup logic; TC009 gross-up convergence and logging; TC010 parser failure injection and exception routing. Acceptance criteria: numeric results within rounding tolerance defined in <code>config.rounding_rule</code>, recon_pdf and manifest complete and linkable, audit files present, and automated regression tests passing. Store UAT artifacts in <code>uat_results/{run_id}</code> and require sign-off from Payroll Manager and QA with recorded digital signatures. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Regression testing & CI integration (automation & thresholds)</strong><br>Maintain a representative seed dataset (~30 records) covering all edge cases used by CI; store golden datasets and expected outputs. CI pipeline steps: on PQ, script or config changes, run PQ transforms in a CI environment to produce a candidate workbook; execute comparison scripts against golden dataset, produce PASS/FAIL and diffs in CSV format; block merges if diffs exceed tolerance thresholds. Publish <code>ci_reports/{build_tag}</code> including <code>exceptions_count</code>, <code>parse_failures</code>, <code>regression_diffs</code> and <code>coverage</code>. Integrate CI with Slack/email alerts for failing builds with owners and remediation steps. Periodically rotate seed records and update golden datasets to reflect regulatory or policy changes; require a CCB approval for any golden dataset update. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Exception handling & escalation playbooks (timelines, owners & automation)</strong><br>Define deterministic escalation playbooks for frequent exception types with explicit timelines and owners. Missing prior bukti potong: Day0 auto email with secure upload link; Day2 automated reminder; Day3 escalate to prior employer HRBP and set <code>case_status=&#x27;followup&#x27;</code>; Day7 escalate to Payroll Manager cc Finance; Day14 advise employee to claim via SPT and apply <code>TER</code> fallback; Day30 close or escalate to legal if unresolved. Parser failure: immediate insertion into <code>manual_review_queue</code> with SLA 3 business days; if unresolved after SLA escalate to Parser Owner with a root cause request. For every action log actor, timestamp, message content and attachments in <code>case_log</code>. Implement automated notifications and ownership reassignment when SLAs are breached; maintain a dashboard of open exceptions and average resolution time by category. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Audit package manifest schema (machine-readable JSON, checksum rules & storage)</strong><br>Manifest is the single source of truth for audit artifacts and must be machine-readable JSON with strict fields: <code>manifest_id</code>, <code>employee_id</code>, <code>fiscal_year</code>, <code>files</code> (array of objects: <code>file_name</code>, <code>file_type</code>, <code>checksum</code>, <code>uploaded_by</code>, <code>upload_date</code>, <code>verification_status</code>), <code>calculation_workbook_path</code>, <code>recon_pdf_path</code>, <code>prepared_by</code>, <code>prepared_date</code>, <code>approval_signature</code>, <code>manifest_checksum</code>, <code>notes</code>. The file name convention: <code>manifest_{employee_id}_{year}.json</code> and store alongside files under <code>DMS:/audit_packages/{fiscal_year}/{employee_id}/</code>. The manifest generation process must compute <code>manifest_checksum</code> as SHA256 of ordered file list and store that checksum in PDF footer and DMS metadata. Quarterly immutability & restore tests should verify manifest integrity and file accessibility; include automated restore verification scripts as part of the quarterly maintenance runbook. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Retention, legal & dispute workflows (timelines and packet assembly)</strong><br>Retention baseline is 5 years; recommend 10 years for regulated sectors or where disputes are likely. The DMS must support legal holds and immutable retention. Dispute workflow: on dispute initiation assemble a packet within 5 business days including manifest, calculation workbook with cell references, payslips, bukti potong, SSPs and email trails; convene Payroll+Tax+HR meeting within 7 business days; produce dispute memo with proposed remedial action; if unresolved escalate to external counsel and tax authority with CFO signoff within 30 calendar days. Archive dispute artifacts in <code>case_log</code> and tag with <code>legal_hold</code> flag if required. Maintain a dispute SLA dashboard showing time to packet assembly and resolution outcomes, and require monthly review of open disputes by management. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Security & access controls (technical controls & least privilege)</strong><br>Apply defense in depth: encryption at rest for DMS objects, TLS v1.2+ for transit, RBAC with least privilege applied to data stores and PQ service accounts. Segregate duties: Payroll Operator (operational access), Approver (read & sign), Auditor (read-only with special access to manifests), IT Admin (infrastructure). Implement append-only <code>audit_trail</code> tables with cryptographic signer fields for approvals. Secrets must be stored in a managed vault with rotation policy and audit logs; restrict SQL query execution to least-privilege DB accounts and enforce parameterized queries. Integrate monitoring alerts with SIEM and create watch rules for anomalous patterns such as spikes in gross-up approvals, parser_fail_rate surges, or bulk manifest deletions. Regularly perform penetration testing and role review audits and document remediation steps in the risk register. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Operational SLAs & KPI table (copyable with required telemetry)</strong><br>Provide a compact SLA & KPI mapping used by operations dashboards: <code>Activity | SLA | KPI</code>. Examples: <code>1721 issuance by prior employer | ≤ 7 business days | % issued ≤7d</code>; <code>Verification &amp; upload by new employer | ≤ 3 business days | % verified ≤3d</code>; <code>Refund processed by finance | ≤ 14 business days post recon | avg payout days</code>; <code>UAT pass rate | — | ≥95%</code>; <code>Auto-parse rate (1721 parser) | — | ≥90%</code>. Implement instrumentation to compute these KPIs nightly and store historical trend data for RCA. Define alert thresholds (e.g., % issued ≤7d drops below 90% triggers PagerDuty to Payroll Lead). Provide a recommended dashboard layout and sample queries to populate each KPI widget. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Communications templates (copy-ready, templated fields & legal language)</strong><br>Store all communications templates in <code>email_templates</code> and version them. Example 1721 request email template: <code>Subject: Request for Form 1721 – {EmployeeName}</code>; <code>Body: Dear {PriorEmployerContact}, please upload Form 1721 for {EmployeeName} (NPWP: {NPWP_masked}) for period {period}. Secure upload link: {secure_upload_link}. SLA: 7 business days from receipt. Contact: {PayrollLeadEmail}</code>. Reconciliation notice template must include a human-friendly summary of the balance, link to recon_pdf & manifest, a sign_url for acceptance, dispute contact details and timeline (e.g., 14 days to dispute). Keep legal counsel on the template approval loop, store signatures used for notices, and preserve sent copies in <code>communication_log</code> for audit. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Reconciliation PDF required layout (fields, order & mandatory metadata)</strong><br>Recon_pdf must follow a standardized layout to ensure auditors and employees can quickly locate evidence: Header with employer logo, payroll contact and fiscal year; Section A — employee details (mask NPWP as configured); Section B — income by employer rows <code>period_start | period_end | gross | pension | cost_of_work | taxable_income_period</code> with source file links; Section C — consolidation summary showing <code>annual_gross</code>, <code>biaya_jabatan</code>, <code>total_pension</code>, <code>pkp</code>, <code>annual_tax</code> with banded breakdown and cell refs to the calculation workbook; Section D — monthly withholdings with payslip & SSP links; Section E — balance and proposed action with GL mapping referenced; Section F — attachments, approver signatures and signature timestamps. Footer must contain <code>manifest_id</code>, <code>manifest_checksum</code> and optional QR code pointing to DMS manifest; include PDF metadata with <code>manifest_path</code> and <code>prepared_by</code>. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Edge cases handling (concise operational rules & examples)</strong><br>Provide deterministic rules for common edge cases to reduce manual variance: Multiple moves — deduplicate overlapping prev entries by checksum and inclusive date rules, aggregate annual_gross and allocate biaya_jabatan proportionally by employer gross share, persist per-employer allocation for audit. Employer bankruptcy — set <code>prev_entry.unverifiable = true</code>, capture public registry proof, mark employee advised to claim via SPT and record steps in <code>case_log</code>. Late 1721 after refund — prepare amendment reconciliation, compute reclaim or offset and document employee consent in <code>audit_trail</code>. Salary sacrifice — map codes to <code>pre_tax</code> classification and exclude from PKP where law requires; store legal citation and approver signoff. For cross-currency items capture FX policy used and attach conversion rationale to manifest. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Implementation 90-day plan (owners, milestones & deliverables with checklists)</strong><br>Provide a phased delivery plan with owners and deliverables: 0–14 days — governance updates, onboarding checklist changes, design template_reconciliation skeleton, freeze initial config and scope; deliverable: <code>template_reconciliation.xlsx v0.1</code> and <code>governance_signoff</code> record. 15–30 days — implement PQ pipelines, parser v0 to staging, exceptions routing and checksum idempotency; deliverable: <code>pq_pipeline_v0.1</code> and <code>parser_test_results</code>. 31–45 days — build DAX measures, QA environment, unit tests for formulas; deliverable: <code>pbix_v0.1</code> and unit test logs. 46–60 days — stabilize parser, HCM API integration for prev entries, alerts and monitoring; deliverable: API integration specs and monitoring dashboards. 61–75 days — UAT with 50 sample employees including edge cases, tune TER & overrides; deliverable: UAT report and signoffs. 76–90 days — production deploy, training, automated monthly reconciliations and KPI dashboard, post-deploy audit & signoff; deliverable: production artifacts, training recordings and final approvals. Assign owners in a project tracker and attach checklists to each milestone. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Deliverables (repo file list, expected structure & usage guidance)</strong><br>Standard set of repository deliverables required for operational handover: <code>template_reconciliation.xlsx</code> (contains config, employer_input, consolidation, monthly_withholding, reconciliation, audit_trail, tests and version_control sheets — this workbook is the canonical operator artifact); <code>pq_transform_documentation.md</code> (Applied Steps, M snippets, mapping); <code>dax_measures_documentation.md</code> (measure descriptors & debug cards); <code>vba_macros_readme.md</code> (macro names, preconditions, signing & release process); <code>email_templates.docx</code> (1721 requests, reminders, recon notices); <code>uat_test_plan.xlsx</code> with seed data and expected results; <code>audit_manifest_template.csv</code> and sample manifests; <code>security_policy_snippet.md</code> for encryption & vault usage; <code>/templates/payslips/</code> containing HRIS-style templates for simple, detailed and mobile formats. Each deliverable must include a readme with release checklist and approver signatures, and be tagged in <code>releases/{tag}</code> in version control. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Operational playbooks (copy-ready runbooks with command snippets and screenshots)</strong><br>Provide executable step sequences for common operations: Missing 1721 onboarding — auto email generation using 1721 request template → 48-hour reminder trigger → HR phone follow-up → escalate to prior employer HR manager → record <code>case_log</code> action entries and timeline → advise SPT claim after 14 days & apply TER fallback. December reconciliation — freeze config (snapshot <code>config_version</code>) → run PQ refresh → run consolidation and generate <code>exceptions.csv</code> → exceptions triage and manual fixes → QA signoff → apply adjustments and record GL entries using <code>config.gl_map</code> → archive audit packages and publish recon_pdf & manifest links to employees. Include CLI or GUI command snippets, screenshots for PQ refresh, and sample SQL for aggregation with rollback instructions and emergency contacts. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Audit checklist (printer-friendly, ordered verification steps)</strong><br>Provide an auditor checklist to be printed and ticked:<br>1. prior bukti potong present and checksum verified;<br>2. monthly payslips linked and accessible;<br>3. SSP/payment proofs for additional withholdings;<br>4. calculation workbook with explicit cell references and approver signature;<br>5. proof of refund transfer and employee acknowledgment recorded;<br>6. manifest.csv listing file paths and checksums and manifest checksum verified;<br>7. gross-up logs and approvals for any gross-up transaction;<br>8. parser logs and parser_version recorded in manifest;<br>9. retention metadata and legal hold status if applicable. Each checklist line must map to a DMS path and manifest entry to enable cross-verification. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Governance policy snippets (copy-ready legal language and internal rules)</strong><br>Provide short copy-ready governance lines for insertion into employee handbooks or SOPs: <code>&quot;The company will issue Form 1721-A1/A2 for employees terminating employment within 7 business days from termination date. All documents related to withholding and reconciliation shall be retained for a minimum of 5 years.&quot;</code> and <code>&quot;All gross-up requests require Finance Director approval; calculations and justification must be archived in audit_trail before payroll posting.&quot;</code> These snippets must be stored in <code>policy_snippets.md</code> and be subject to legal and tax counsel approval before publication; maintain a change log for policy text and approver signatures. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Monitoring & CI/CD recommendations (metrics, dashboards & alerts)</strong><br>Operational monitoring plan: Nightly PQ refresh metrics — <code>exceptions_count</code>, <code>parser_fail_rate</code>, <code>last_refresh_time</code> and record <code>parser_version</code>; CI pipeline for PQ and config changes that runs regression tests and blocks merges if diffs exceed tolerance; BI dashboard surfaces exceptions trend, average days to 1721 issuance, auto-parse rate, UAT pass rate, and reconciliation variance histogram. Implement alerting: when <code>exceptions_count</code> surpasses threshold send automated incidents to owners; weekly RCA for recurring exceptions with owners and remediation actions logged. Archive historical metrics for trend analysis and capacity planning; maintain metrics retention for at least 12 months for trend analysis. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>One-row employee narrative template (structured export format & example)</strong><br>Provide a single line summary record for exports and controllers: fields <code>EmployeeID | Name | Periods (employer + dates) | AnnualGross | BiayaJabatanAllocated | PensionTotal | PKP | AnnualTax | TotalWithheld | Balance | Action | ReconPDFPath | Notes</code>. Example line must include <code>manifest_id</code>, approver signatures, and a brief notes field describing overrides or unusual items. This one-row export is intended for quick executive review and must link to the full reconciliation folder; include a CSV export template and an explanation of field formats and allowed values to ensure consistent ingestion by downstream accounting or GL posting tools. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Appendix A — formula cheat sheet (spreadsheet ready with named ranges and examples)</strong><br>Provide exact spreadsheet formulas referencing named ranges: <code>total_gross = monthly_gross * months_in_period</code>; <code>total_pension = pension_monthly * months_in_period</code>; <code>prorata_plafon = (plafon_annual / 12) * months_in_period</code>; <code>cost_of_work = MIN(0.05 * total_gross, prorata_plafon)</code>; <code>net_income_period = total_gross - total_pension - cost_of_work</code>; <code>annual_pkp = MAX(0, SUM(net_income_period_range) - ptkp_annual)</code>; <code>tax_for_band_i = MAX(0, MIN(annual_pkp, upper_i) - lower_i) * rate_i</code>; <code>annual_tax = SUM(tax_for_band_i)</code>; <code>monthly_accrual = ROUND(annual_tax / 12, 0)</code>; <code>december_balance = annual_tax - SUM(withheld_jan_to_nov)</code>; <code>gross_up_initial_guess = target_net * TER / (1 - TER)</code>. Recommend named ranges: <code>rng_TotalGross</code>, <code>rng_TotalPension</code>, <code>rng_BiayaPlafon</code>, <code>rng_PTKP</code>, <code>tbl_ProgressiveBands</code>. Provide worked examples and cell references for auditors. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Appendix B — quick operational reminders (concise operator rules)</strong><br>Keep short operator reminders for day-to-day work: PQ — descriptive applied step names and comments; include <code>parser_version</code> metadata; always keep <code>pq_tests</code> sample inputs; Macros — all must be code signed with <code>macro_log</code> entries; DAX — maintain progressive bands in <code>dim_progressive_bands</code> and expose debug measures for QA; Training — store recordings, replay materials and signoffs in <code>version_control/training/</code>. Include a small checklist for daily runs: PQ refresh success, exceptions_count = 0 or triaged, nightly notifications sent, and manifests created for any reconciliations processed. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Appendix C — SQL patterns & security notes (parameterization & examples)</strong><br>Provide safe SQL design patterns and anti-injection rules: use parameterized queries stored under <code>version_control/sql/</code> with names and versioning, avoid dynamic SQL concatenation, limit exposed privileges to least-privilege DB roles, and use read-only accounts for analyst views. Example pattern description: SELECT employee_id, SUM(gross_amount) AS annual_gross FROM fact_payroll WHERE fiscal_year = @fiscal_year GROUP BY employee_id then LEFT JOIN prev_employer_credits ON employee_id. Store query diffs and approvals; use prepared statements and bind variables in application code. Log query access and alert on anomalous large scans; include query explain plans in performance reviews. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Appendix D — reconciliation evidence fields (manifest checklist & required items)</strong><br>Manifest checklist required fields: <code>manifest_id</code>; employee snapshot (name, NPWP masked/full per policy); per-employer file names and checksums; calculation snapshot with cell refs and workbook path; monthly withholding table with payslip & SSP links; bank transfer proof for refunds; approver signatures and timestamps; exceptions list and resolution notes. Store manifest checksum and DMS link in PDF footer. Include example CSV manifest template with column definitions and sample rows as reference. Ensure each item has a DMS URI and a recorded uploader identity for chain of custody; require a final sign-off step by Payroll Manager before publishing. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Risk register (summary, risk owner & mitigations, update cadence)</strong><br>Create a living risk register with owner and mitigation status: Risk — Missing prior bukti potong (owner HR) — Mitigation: enforce upload during onboarding, automated reminders, SLA escalation, TER fallback with exception flag; Risk — Parser failures (owner IT/Parser) — Mitigation: confidence thresholds, manual review queue, maintain parser_version and test corpus; Risk — Gross-up abuse (owner Finance) — Mitigation: gross_up_cap, multi-level approvals, audit gross_up_log; Risk — FX volatility (owner Treasury) — Mitigation: fx variance threshold and counsel review when exceeded. Update the risk register monthly and include in BI dashboard; retain historical mitigation outcomes and residual risk scores for executive review. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>GL mapping recommendations (sample GL codes and journaling rules)</strong><br>Provide recommended GL mapping keys that must be stored in <code>config.gl_map</code>: <code>Employee tax withheld (liability): 2100.01 – PPh21 Payable</code>; <code>Employer gross-up expense: 6100.10 – Employee Benefits Expense (gross-up)</code>; <code>Refund to employee: debit 2100.01 / credit 1010.01 (bank)</code>; <code>Unapplied credits suspense: 2100.99</code>. Include example journal templates: Debit <code>2100.01</code> / Credit <code>1010.01</code> for refund; Debit <code>6100.10</code> / Credit <code>2100.01</code> for gross-up expense with payable reduction. Link GL mapping to reconciliation actions so automated posting scripts can apply mapping deterministically; include sample export files for ERP integration. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Runbook & schedule (example operational windows, rollback & contacts)</strong><br>Define scheduled run windows and rollback procedures: Nightly PQ refresh at <code>01:30 local</code> (produce exceptions CSV and summary to analysts); Weekly staging dry-run Friday <code>09:00</code> for QA; Monthly production run (December job) with window <code>02:00–06:00</code>, produce reconciliation reports by <code>10:00</code> and require Finance approval by <code>17:00</code> same day. Provide rollback instructions for each job (snapshot locations, DB restore points, and <code>revert_command</code> for PQ or posting macros). Attach emergency contact list with phone numbers and escalation order for critical failures. Keep runbook steps concise, tested and versioned with documented drills at least twice per year. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Training plan & change control (week-by-week actions & artifacts)</strong><br>Training schedule across the implementation rollout: Week 0 stakeholder briefing for Payroll, HR, Tax and IT covering governance and scope; Week 1 hands-on PQ training and test cases for analysts with lab exercises; Week 2 DAX dashboard training for controllers and auditors; Week 3 reconciliation dry-run for operators and SOP sign-off; deliver training recordings, slides and signoff forms to <code>version_control/training/</code>. Implement a change control board (CCB) for <code>config</code> changes that requires defined approvers and an audit entry for every change. Maintain a change calendar and require at least one week notice for config changes affecting live payroll. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Change log & versioning rules (release artifacts & gating)</strong><br>Apply semantic versioning for templates and scripts using <code>file_v{major}.{minor}_{YYYYMMDD}</code>. Release gating: each release must include <code>release_notes.md</code> describing changes, a <code>diff</code> of modified files, approver signatures captured as digital artifacts, regression test results demonstrating no unintended deltas beyond tolerance, and UAT signoffs where required. Store releases under <code>releases/{tag}</code> and update the <code>version_control</code> sheet in <code>template_reconciliation.xlsx</code> with links to artifacts, approvers and checksum of the release bundle. Enforce branch protection in VCS and require at least one code and one legal or tax approver for policy affecting releases. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Contacts, escalation & RACI (copy-ready roles, escalation order & contact storage)</strong><br>Define an operational RACI and store contacts in <code>config.team_contacts</code> with role, primary and secondary contact details and escalation order: <code>Payroll Lead</code> (owner for monthly & recon runs), <code>Tax Lead</code> (policy and gross-up approver), <code>IT Owner</code> (maintains PQ, parser and integrations), <code>HR Lead</code> (onboarding & NPWP verification), <code>Auditors</code> (periodic reviews and signoffs). Include phone and email with escalation order and business hours coverage. Use these contacts for automated pager and email templates and include them in runbooks for operator use. Periodically verify contact accuracy and update <code>config.team_contacts</code> on personnel change. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Final verification checklist (pre-production gate requirements & signoff items)</strong><br>Pre-production verification must ensure:<br>1. regulatory numeric parameters are pulled from <code>config:regulatory_sources</code> and verified with recorded verifier and verification date;<br>2. <code>parser_version</code> and test corpus exist in the repo;<br>3. UAT signoffs captured and artifacts stored;<br>4. backup and restore tests for audit packages passed;<br>5. manifest checksum logic validated end-to-end;<br>6. SLA owners assigned and notified;<br>7. gross-up approval gating implemented and tested;<br>8. CI regression tests passing;<br>9. GL mapping documented and sample journal entries validated;<br>10. RACI and training completed and signoffs recorded. Capture final release tag, list of approvers, and store release in <code>releases/</code> with checksums and diffs. </td></tr><tr><td data-label="PPh Pasal 21 withholding and year-end reconciliation"> <strong>Operational closing instruction (compliance directive & usage mandate)</strong><br>Use this single-column artifact as the canonical operational plus technical blueprint for PPh 21 withholding and reconciliation involving employees moving between employers. Before any payroll posting or tax submission validate regulatory numeric parameters against official sources and record verifier and approver in <code>config:regulatory_sources</code>. Tag each release in <code>version_control</code>, maintain immutable audit packages per employee, execute escalation playbooks for exceptions, and retain evidence per retention policy. Any deviation from this blueprint must be recorded as a formal policy change with approver signatures and versioned release notes; emergency operational deviations must be corrected by a documented remediation plan and attached to the audit package for the affected fiscal year. </td></tr></tbody></table></div><div class="row-count">Rows: 44</div></div><div class="table-caption" id="Table2" data-table="YJKN_0015_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by Learning curve: **VBA** vs **PQ** vs **Power Pivot** — Try **PQ** first (Comprehensive)"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Learning curve: <strong>VBA</strong> vs <strong>PQ</strong> vs <strong>Power Pivot</strong> — Try <strong>PQ</strong> first (Comprehensive)</div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Quick summary:</strong><br> <strong>PQ:</strong> Power Query for repeatable ETL and point and click shaping<br> <strong>Power Pivot:</strong> Power Pivot for in memory relational modeling and high performance measures with <strong>DAX:</strong> Data Analysis Expressions<br> <strong>VBA:</strong> VBA for custom automation and UI workflows and tasks outside the data model lifecycle<br> <strong>Purpose:</strong> quick ETL → model → automate pipeline<br> <strong>Primary users:</strong> analysts (PQ/Power Pivot), power users/developers (VBA)<br> <strong>Typical outcome:</strong> refreshable pipelines, compressed models, and scripted automation </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Initial ramp (learning curve):</strong><br> <strong>PQ:</strong> minutes to a few hours to be productive on common tasks<br> <strong>Power Pivot:</strong> hours to several weeks to become effective with modeling concepts and common <strong>DAX</strong> patterns<br> <strong>VBA:</strong> days to weeks to write maintainable robust solutions, longer to master advanced patterns and add ins<br> <strong>What to expect:</strong> fast wins in PQ, steady ramp for DAX, longer investment for robust VBA<br> <strong>Training focus:</strong> hands-on PQ first, followed by structured DAX exercises, then targeted VBA patterns </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Paradigm & mental model:</strong><br> <strong>PQ:</strong> step based functional M transformations recorded in a sequence<br> <strong>Power Pivot:</strong> relational star schema thinking with context aware <strong>DAX</strong> measures<br> <strong>VBA:</strong> imperative procedural code interacting with Excel’s object model<br> Each requires a different mental shift, <strong>PQ</strong> equals transform pipeline, Pivot equals data model and filter context, <strong>VBA</strong> equals program control flow<br> <strong>Mindset shift:</strong> declarative transforms (PQ) → relational/context (Power Pivot) → imperative control (VBA)<br> <strong>Separation of concerns:</strong> keep ETL, modeling and orchestration distinct </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Visual feedback & development experience:</strong><br> <strong>PQ:</strong> previews every step and is interactive<br> <strong>Power Pivot:</strong> exposes tables relationships and measure outputs via PivotTables<br> <strong>DAX:</strong> measure outputs appear in pivot context and require testing with pivot layouts<br> <strong>VBA:</strong> requires editing code, running macros, and using breakpoints and watches for inspection<br> <strong>PQ</strong> provides the fastest feedback loop for ETL<br> <strong>Feedback loop:</strong> immediate preview (PQ) → pivot validation (Power Pivot/DAX) → run/debug cycle (VBA)<br> <strong>Tooling tips:</strong> use Query Diagnostics, DAX Studio and the VBA debugger respectively </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>ETL overview (high level):</strong><br> <strong>PQ:</strong> Extract and Transform natively, and often Load to Power Pivot or tables<br> <strong>Power Pivot:</strong> usually the Load destination where modeling and analytics occur<br> <strong>VBA:</strong> can perform any ETL phase using explicit code<br> <strong>Role definition:</strong> PQ = ETL engine; Power Pivot = analytic store; VBA = orchestration/gap filler<br> <strong>Governance note:</strong> prefer declarative PQ pipelines for maintainability and auditing </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Extract — detailed:</strong><br> <strong>PQ:</strong> acquiring data from files, databases, web, APIs, and cloud services using built in connectors, preview sampling, and incremental load patterns<br> <strong>Power Pivot:</strong> receives loaded tables for modeling, not typically a source connector layer<br> <strong>VBA:</strong> used for custom authentication, special API workflows, legacy systems, or cases where connectors do not exist<br> <strong>Connector guidance:</strong> prefer native PQ connectors; use VBA only when no connector or auth flow exists<br> <strong>Performance tip:</strong> enable folding and sample early to reduce local processing </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Transform — detailed:</strong><br> <strong>PQ:</strong> data cleaning, type conversion, deduplication, joins, pivots, unpivots, and calculated columns using point and click transforms recorded as steps and the M language for advanced transforms<br> <strong>Power Pivot:</strong> supports calculated columns and measures with <strong>DAX</strong> when model side calculation is required<br> <strong>VBA:</strong> provides bespoke row by row logic, complex algorithms, and integration with sheet formulas when needed<br> <strong>Best practice:</strong> perform set-based transforms in PQ, model calculations in DAX, procedural in VBA only if unavoidable<br> <strong>Maintainability:</strong> document complex M/DAX and isolate VBA transforms in modules </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Load — detailed:</strong><br> <strong>PQ:</strong> writes final tables to Excel tables or the data model and supports refresh<br> <strong>Power Pivot:</strong> stores tables in memory for high performance analysis and relationships<br> <strong>VBA:</strong> offers flexible outputs across workbooks, programmatic exports, automated emailing, and custom workbook or UI updates<br> <strong>Load decision:</strong> choose output by scale and consumer: table (small), model (analytics), DB/dataflow (enterprise)<br> <strong>Operational note:</strong> prefer refreshable model loads and governed endpoints for production </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Query folding (why it matters):</strong><br> <strong>PQ:</strong> can delegate transforms back to the source database when supported to preserve performance and lower local compute<br> Design transforms to maximize folding by filtering early and using simple column operations<br> When folding breaks because of custom steps, complex transforms, or connectors, <strong>PQ</strong> must process data locally so plan accordingly<br> <strong>Why it matters:</strong> reduces data movement and leverages source compute<br> <strong>Design rules:</strong> filter early, minimize non-foldable steps, stage complex logic downstream </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>M language (Power Query advanced):</strong><br> <strong>PQ:</strong> M is functional and case sensitive, learn its structure for parameterization, custom functions, and advanced transforms<br> Use the UI for most cases and read or modify M when reuse, dynamic queries, or UI limitations require it<br> <strong>When to use M:</strong> parameterization, reusable functions, performance tuning<br> <strong>Readability:</strong> keep M readable, name steps clearly and expose parameters for maintainability </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Power Pivot fundamentals:</strong><br> <strong>Power Pivot:</strong> columnar in memory xVelocity engine, model design favors star schema with fact and dimension tables, explicit relationships, and centralized measures in <strong>DAX</strong><br> Load cleaned tables from <strong>PQ</strong> into <strong>Power Pivot</strong> to separate ETL from modeling concerns<br> <strong>Modeling rules:</strong> star schema, narrow facts, descriptive dims<br> <strong>Storage tip:</strong> reduce cardinality and use surrogate keys where practical </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>DAX basics (Data Analysis Expressions):</strong><br> <strong>DAX:</strong> declarative expression language for measures and calculated columns<br> Key concepts include filter context versus row context, CALCULATE, context transition, and time intelligence<br> Prefer measures over calculated columns for efficiency and flexibility<br> <strong>Core concepts:</strong> filter vs row context, CALCULATE, variables, time intelligence<br> <strong>Learning focus:</strong> build measures, reason about context, test with pivot scenarios </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Calculated columns vs measures (guidance):</strong><br> <strong>DAX:</strong> calculated columns evaluate per row and increase model size, use them only when a column value is required for relationships or filtering<br> <strong>DAX:</strong> measures compute on aggregation and operate in context, preferred for aggregations, KPIs, and time intelligence<br> <strong>Rule of thumb:</strong> default to measures; use columns only for relationship/slicer needs<br> <strong>Model impact:</strong> columns increase memory; measures are compute-time, context-aware </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Performance & scaling:</strong><br> Combine <strong>PQ</strong> query folding with <strong>Power Pivot</strong> compression for best results<br> For very large datasets prefer server side processing, incremental refresh, and avoid per row <strong>VBA</strong> operations<br> Use <strong>DAX</strong> measures not calculated columns and reduce cardinality where possible<br> <strong>Performance checklist:</strong> preserve folding, reduce columns, surrogate-key high-cardinality texts<br> <strong>Scaling path:</strong> move to Power BI/SSAS or push aggregations to DB when Excel limits reached </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Incremental refresh & large data strategies:</strong><br> <strong>PQ:</strong> implement incremental refresh in supported tooling, partitioning, and filters to limit data loaded during development<br> <strong>Power Pivot:</strong> for Excel only scenarios consider moving heavy workloads to Power BI or SSAS for scale<br> <strong>Strategy:</strong> implement RangeStart/RangeEnd params for incremental loads in supported tools<br> <strong>Migration cue:</strong> once refresh times or memory usage exceed limits, plan migration to server </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Maintainability & governance:</strong><br> <strong>PQ:</strong> step history is self documenting, document purposes of queries, parameters, and transformations<br> <strong>Power Pivot:</strong> document table roles, key fields, and measure intent for <strong>DAX</strong> measures<br> <strong>VBA:</strong> enforce modular structures, comments, and test patterns, use naming conventions and store metadata in a hidden sheet or documentation file<br> <strong>Governance checklist:</strong> owner, refresh schedule, credentials, QA checks, documentation<br> <strong>Naming conventions:</strong> src_/stg_/fact_/dim_ prefixes and query descriptions </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Reuse parameterization & templates:</strong><br> <strong>PQ:</strong> use parameters for connection strings, file paths, date ranges, and to create reusable templates<br> <strong>Power Pivot:</strong> build reusable measure libraries in <strong>DAX</strong><br> <strong>VBA:</strong> create libraries or add ins for common functions<br> <strong>Template guidance:</strong> config sheet for non-technical repointing; parameterize environment values<br> <strong>Reuse goal:</strong> reduce copy-paste and centralize logic for maintainability </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Debugging & error handling:</strong><br> <strong>PQ:</strong> surfaces step errors and allows step inspection, use Query Diagnostics for performance root causes<br> <strong>DAX:</strong> evaluate measures with PivotTables and tools like DAX Studio to diagnose filter context and performance<br> <strong>VBA:</strong> use Option Explicit, structured error handling, and the debugger with breakpoints and watches<br> <strong>Troubleshooting flow:</strong> isolate failing PQ step → validate data types → profile DAX → debug VBA with logs<br> <strong>Logging:</strong> add telemetry for unattended automations </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Security credentials & data governance:</strong><br> <strong>PQ:</strong> stores credential types such as Windows, OAuth, and Basic, never hardcode secrets in queries or <strong>VBA</strong><br> Use organizational gateways for scheduled refreshes and IT managed data sources<br> Limit workbook sharing for sensitive models and prefer server repositories for governed publishing<br> <strong>Security rules:</strong> no hardcoded secrets, use managed gateways and permissioned services<br> <strong>Data policy:</strong> restrict exports and maintain audit trail for sensitive datasets </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Sharing & collaboration:</strong><br> <strong>PQ:</strong> embed queries in a workbook for small teams or single workbook sharing<br> <strong>Power Pivot:</strong> publish models or queries to Power BI, use shared dataflows or SSAS Tabular for governed assets<br> <strong>VBA:</strong> use only where needed for orchestration in shared workflows, store code in centralized add ins where practical<br> Use OneDrive or SharePoint for versioned workbook storage<br> <strong>Collaboration pattern:</strong> embed for ad hoc; publish for enterprise reuse<br> <strong>Automation governance:</strong> central add-ins, not scattered macros </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Version control & deployment:</strong><br> Excel files are binary, use change logs and save separate revision files<br> <strong>PQ:</strong> consider exporting M and <strong>DAX</strong> definitions to text for source control<br> For mature projects use Power BI or SSAS deployment pipelines and CI practices<br> <strong>VC approach:</strong> export textual artifacts (M/DAX) for git; track change logs for binaries<br> <strong>Deployment:</strong> promote through dev → test → prod pipelines where possible </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Integration with Power BI & SSAS:</strong><br> <strong>PQ</strong> and <strong>Power Pivot</strong> concepts translate directly to Power BI Desktop and SSAS Tabular<br> <strong>DAX</strong> measures and model design map well<br> Use Power BI for interactive dashboards, scheduled refresh, and enterprise distribution when Excel limits are reached<br> <strong>Portability:</strong> design PQ/M and DAX with Power BI compatibility in mind<br> <strong>When to move:</strong> need for scheduled enterprise refresh, larger memory or central governance </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>VBA role — when it is still the right tool:</strong><br> <strong>VBA:</strong> automating workbook level tasks like generating reports, UI forms, custom dialogs, integrating with other Office apps or legacy COM APIs, and performing actions that cannot be modeled in <strong>PQ</strong> or <strong>Power Pivot</strong> such as controlling the Excel UI, sending emails, or orchestrating multi workbook workflows<br> <strong>Use cases:</strong> UI customization, Office automation, legacy system integration<br> <strong>Limit:</strong> avoid using VBA to replace ETL/modeling responsibilities </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>VBA best practices (concise):</strong><br> <strong>VBA:</strong> use Option Explicit, modular functions, avoid Select and Activate, use arrays for bulk operations, handle errors gracefully, isolate I O, and document side effects<br> Convert large row loops into batch operations for speed<br> <strong>Coding standards:</strong> strict typing, modular design, centralized I/O<br> <strong>Operational practice:</strong> include logging and retry strategies for unattended runs </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Interop patterns (PQ → Power Pivot → VBA):</strong><br> Typical pipeline is <strong>PQ</strong> extracts and transforms, then load to <strong>Power Pivot</strong>, then build <strong>DAX</strong> measures, then present in Pivot or worksheet, then optional <strong>VBA</strong> automates refresh, exports, or UI tasks<br> Use <strong>VBA</strong> only to orchestrate or fill functional gaps<br> <strong>Pipeline roles:</strong> PQ = ETL, Power Pivot = model, VBA = orchestrator<br> <strong>Separation benefit:</strong> simplifies debugging and reduces accidental coupling </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Testing & validation:</strong><br> <strong>PQ:</strong> implement data quality checks like row counts, null checks, and type assertions<br> <strong>Power Pivot:</strong> validate <strong>DAX</strong> measure results with known test cases and small samples<br> <strong>VBA:</strong> create unit testable modules where feasible and use test workbooks with controlled inputs<br> <strong>QA patterns:</strong> automated row-count checks, sample-based validation, pivot test cases for DAX<br> <strong>Test automation:</strong> integrate simple QA queries into refresh flows </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Common pitfalls & mitigations:</strong><br> Overloading Excel with too much data, mitigate with model compression and moving to Power BI<br> Breaking query folding, refactor transforms earlier to preserve folding<br> Mixing responsibilities, separate ETL (<strong>PQ</strong>) from modeling (<strong>Power Pivot</strong>) and automation (<strong>VBA</strong>)<br> <strong>Pitfall mitigation:</strong> stage data, preserve folding, enforce separation of concerns<br> <strong>Monitoring:</strong> track model size, refresh duration and query plan changes </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Workshop curriculum (practical track full pipeline):</strong><br> 1) Overview and motivations 15 min<br> 2) <strong>PQ</strong> live demo connect, clean, merge, and parameterize 45 to 60 min<br> 3) Load into <strong>Power Pivot</strong> and model design 30 to 45 min<br> 4) <strong>DAX</strong> core measures and time intelligence 45 to 60 min<br> 5) Short <strong>VBA</strong> demo for automation 20 to 30 min<br> 6) Hands on exercises and review 60 to 90 min<br> Adjust time by audience skill<br> <strong>Learning goals:</strong> hands-on PQ, model design, DAX fundamentals, automation overview<br> <strong>Outcome:</strong> a reproducible end-to-end project for participants </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Hands on exercise suggestions:</strong><br> Beginner, import CSV, remove blanks, simple merge, and load to table<br> Intermediate, parameterize <strong>PQ</strong> for dates, load to model, and create a basic <strong>DAX</strong> measure<br> Advanced, design star schema, implement advanced <strong>DAX</strong> like Year over Year and running totals, and automate refresh with <strong>VBA</strong><br> <strong>Progression:</strong> small wins → parameterization → modeling → automation<br> <strong>Verification:</strong> each exercise ends with a pivot/report or automated output </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Teaching tips & sequencing:</strong><br> Start with concrete small wins in <strong>PQ</strong> like cleaning a shopping list, then introduce loading to <strong>Power Pivot</strong> to show scale and performance, then introduce <strong>DAX</strong> with familiar KPIs, and finally show <strong>VBA</strong> only when participants ask for automation beyond refresh and export<br> Emphasize reproducibility and refreshability<br> <strong>Sequence rationale:</strong> rapid PQ wins build buy-in for deeper modeling work<br> <strong>Classroom tip:</strong> use real-world KPIs to teach DAX context </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Quick reference & cheat sheet (short):</strong><br> <strong>PQ</strong> equals ETL with UI first<br> <strong>M:</strong> advanced transforms<br> <strong>Query folding:</strong> pushes work to the source<br> <strong>Power Pivot:</strong> model and <strong>DAX</strong><br> Use <strong>DAX</strong> measures not columns where possible<br> <strong>VBA:</strong> automation and interop, avoid for heavy row processing unless optimized<br> <strong>One-line map:</strong> PQ = ETL, Power Pivot = model, VBA = automation<br> <strong>Remember:</strong> preserve folding and favor measures </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Troubleshooting checklist:</strong><br> If slow, check folding, filter early, reduce columns, and check <strong>DAX</strong> cardinality<br> If errors, inspect <strong>PQ</strong> step where the error appears, check data types, and validate connections and credentials<br> If refresh fails in a shared environment, verify gateway and credentials<br> <strong>Stepwise triage:</strong> validate folding → inspect PQ step → test DAX with sample pivot → verify gateway/credentials<br> <strong>Escalation:</strong> move heavy processing upstream or to server platforms </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Next steps & recommended learning path:</strong><br> 1) Hands on <strong>PQ</strong> exercises with connectors and transforms<br> 2) Load to <strong>Power Pivot</strong> and practice star schema patterns<br> 3) Learn core <strong>DAX</strong> patterns like CALCULATE, FILTER, and time intelligence<br> 4) Learn basic <strong>VBA</strong> patterns for automation after mastering the above<br> Build one end to end project<br> <strong>Study plan:</strong> iterative projects with increasing complexity; document lessons learned<br> <strong>Milestones:</strong> PQ proficiency → functioning model → validated DAX → pragmatic automation </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Example real world scenarios & guidance:</strong><br> Invoice consolidation across files, use <strong>PQ</strong> for extract and transform, then load to <strong>Power Pivot</strong> for relationships and measures<br> Multi sheet report automation with email distribution, use <strong>PQ</strong> and <strong>Power Pivot</strong> for data and <strong>VBA</strong> for export and emailing<br> Large database aggregations, prefer SQL or push transforms to the database and use <strong>PQ</strong> for light shaping<br> <strong>Scenario patterns:</strong> file consolidation → PQ, complex analytics → Power Pivot/DAX, distribution → VBA orchestration<br> <strong>Operational advice:</strong> push heavy joins to DB; keep Excel for summarized consumption </td></tr><tr><td data-label="Learning curve: VBA vs PQ vs Power Pivot — Try PQ first (Comprehensive)"> <strong>Final recommendation (practical):</strong><br> For most participants teach <strong>PQ</strong> first to get immediate repeatable wins in ETL, then <strong>Power Pivot</strong> for robust analysis and scalable measures, and teach <strong>VBA</strong> last and only for scenarios requiring automation or integration that cannot be addressed by <strong>PQ</strong> and <strong>Power Pivot</strong> workflows<br> <strong>Adoption sequence:</strong> PQ → Power Pivot/DAX → VBA (only as needed)<br> <strong>Governance:</strong> apply naming, documentation and QA before promoting to production </td></tr></tbody></table></div><div class="row-count">Rows: 35</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>