<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>Tables Viewer v2.1</title>
<style>:root{--main-header-height:56px;} .table-wrapper{opacity:0;min-height:24px;transition:opacity .12s linear}</style>
<link rel="stylesheet" href="assets/style.css?v=1769960840">
<link rel="stylesheet" href="assets/overrides.css?v=1771304638">
</head><body>
<div id="tables-viewer" role="region" aria-label="Tables viewer">
<div id="stickyMainHeader">
<div id="tv-header">
<div><h1>Tables Viewer v2.1</h1></div>
<div style="display:flex;gap:8px;align-items:center;">
<input id="searchBox" class="tv-search" type="search" placeholder="Search" aria-label="Search tables" />
<button id="modeBtn" type="button" onclick="toggleMode()" aria-label="Toggle theme">Theme</button>
<button id="toggleAllBtn" type="button" aria-label="Toggle all" onclick="toggleAllTables()">Collapse All Tables</button>
<button id="copyAllPlainBtn" class="copy-btn" type="button" onclick="copyAllTablesPlain()" aria-label="Copy all tables as plain text">Copy All Tables (Plain Text)</button>
<button id="copyAllTablesBtn" class="copy-all-btn" type="button" onclick="copyAllTablesMarkdown()" aria-label="Copy All Tables (Markdown)">Copy All Tables (Markdown)</button>
<button id="copyAllMdBtn" style="display:none" aria-hidden="true"></button>
<button id="resetAllBtn" type="button" onclick="resetAllTables()" aria-label="Reset All Tables">Reset All Tables</button>
</div></div>
<script>
(function(){
  function ensureDelegation(){
    try {
      var vis = document.getElementById('copyAllTablesBtn');
      var alias = document.getElementById('copyAllMdBtn');
      if(!vis || !alias) return;
      alias.addEventListener = function(type, listener, options){
        vis.addEventListener(type, listener, options);
      };
      alias.removeEventListener = function(type, listener, options){
        vis.removeEventListener(type, listener, options);
      };
      Object.defineProperty(alias, 'onclick', {
        set: function(fn){ vis.onclick = fn; },
        get: function(){ return vis.onclick; },
        configurable: true
      });
      alias.focus = function(){ vis.focus(); };
      alias.blur = function(){ vis.blur(); };
    } catch(e) {
      try{ console && console.warn && console.warn('alias delegation failed', e); }catch(_){} 
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureDelegation);
  } else {
    ensureDelegation();
  }
})();
</script>
<noscript><div style='color:#b91c1c'>JavaScript is disabled. Tables will be shown statically. For large tables enable JS for virtualization.</div></noscript>
<div id="tocBar" role="navigation" aria-label="Table of contents"><ul><li class="toc-item"><a class="toc-link" href="#Table1">Table 1</a></li>
<li class="toc-item"><a class="toc-link" href="#Table2">Table 2</a></li>
<li class="toc-item"><a class="toc-link" href="#Table3">Table 3</a></li>
<li class="toc-item"><a class="toc-link" href="#Table4">Table 4</a></li>
<li class="toc-item"><a class="toc-link" href="#Table5">Table 5</a></li></ul></div></div>
<div class="table-caption" id="Table1" data-table="Docu_0143_01" style="margin-top:2mm;margin-left:3mm;"><strong>Table 1</strong></div>
<div class="table-wrapper" data-table-id="table-1"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module Name</strong><br>modMain.bas </td></tr><tr><td data-label="Technical Breakdown"> <strong>Module Purpose</strong><br>Orchestrates the end-to-end execution of PPh21 job runs. It coordinates tasks like settings loading, job folder creation, input ingestion, configuration loading, per-row computation (via modCalc), CSV export (via modIO), manifest generation (via modManifest), imports to output sheets, logging, and safe shutdown/cleanup. Keeps orchestration concerns separate from domain logic and I/O primitives. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Design Principles</strong><br>• Orchestration-only: no tax logic inside; delegate to modCalc.<br>• Deterministic control flow: identical inputs + config produce same outputs and side-effects.<br>• Fail-safe: never allow unhandled errors to bubble to the user; always catch, log, and produce a controlled failure state.<br>• Idempotent operations where possible (safe re-runs when JOB_ID reused).<br>• Minimal dependencies at top-level; use modUtils, modIO, modCalc, modManifest for primitives. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Public API (recommended signatures)</strong><br>Public Sub pph21_RunAll()<br>Public Function InitializeJob(Optional ByVal providedJobId As String = "") As Boolean<br>Public Function LoadSettings() As Object ' returns Dictionary<br>Public Function LoadRules() As Boolean<br>Public Function ProcessAllRows(rows As Object) As Object ' returns results container<br>Public Function WriteOutputs(results As Object) As Boolean<br>Public Function GenerateManifest(jobFolder As String, jobId As String) As Boolean<br>Public Function ImportOutputsToSheets(jobFolder As String) As Boolean<br>Public Sub AbortCleanup(errContext As String) </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (pph21_RunAll)</strong><br>1. LoadSettings() → read Settings sheet into a Dictionary.<br>2. Validate OUTPUT_BASE; call modUtils.EnsureFolder(OUTPUT_BASE); abort if invalid.<br>3. InitializeJob() → generate or accept JOB_ID, create job folder ${OUTPUT_BASE}\${JOB_ID}.<br>4. LoadRules() → call modIO.ReadBrackets and modIO.ReadParams (or modIO.ReadTableToDicts) and store in modConfig.<br>5. rows = modIO.ReadTableToDicts("Input","tblInput").<br>6. results = ProcessAllRows(rows) → iterate rows, call modCalc.CalcRow, collect outputs and per-row diagnostics.<br>7. WriteOutputs(results) → produce bukti_potong.csv and per11_payload.csv via modIO.WriteCsvAtomic.<br>8. GenerateManifest(jobFolder, JOB_ID) → call modManifest.WriteManifest.<br>9. ImportOutputsToSheets(jobFolder) → optionally import CSVs back to Excel output sheets via modIO.ImportCsvToSheet.<br>10. Finalize: write success log entry and update Settings sheet with JOB_ID and last-run timestamp. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Initialization & Settings handling (LoadSettings / InitializeJob)</strong><br>• Read Settings sheet first 100 rows via modUtils.ReadSettings.<br>• Required keys: OUTPUT_BASE (absolute path); optional: JOB_ID, RULES_BRACKETS_SHEET, RULES_PARAMS_SHEET, MOD_VERSION, VERBOSE.<br>• Validate OUTPUT_BASE exists and is writable; if not, attempt modUtils.EnsureFolder if allowed by policy.<br>• JOB_ID semantics: if providedJobId not empty → use it (idempotent run) else if Settings JOB_ID present → reuse if allowed; else generate job_YYYYMMDD_HHNNSS.<br>• Persist generated JOB_ID back to Settings sheet (use safe write pattern: update in-memory then write via modIO or direct Range assignment wrapped in error handling).<br>• Create jobFolder = JoinPath(OUTPUT_BASE, JOB_ID) using modUtils.JoinPath and call modUtils.EnsureFolder(jobFolder). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Rule & Configuration Loading (LoadRules)</strong><br>• Load bracket table and params using modIO.ReadBrackets and modIO.ReadParams or ReadTableToDicts depending on implementation.<br>• Validate loaded data (non-empty brackets, ascending uppers, presence of PTKP entries).<br>• Map config flags for BPJS handling into modConfig (e.g., TreatEmployerBPJSAsGross, EmployeeBPJSDeductible).<br>• Place modConfig into module-level read-only container for downstream calls (single-load per job).<br>• If validation fails, log and abort job with clear error message. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Input ingestion (ReadTableToDicts)</strong><br>• Call modIO.ReadTableToDicts("Input","tblInput").<br>• Validate presence of required input headers (e.g., nip, npwp, period, period_type, gross or legacy components).<br>• If headers missing → log detailed error and abort.<br>• For large inputs, support chunked processing: supply ProcessAllRows with a subset and allow repeated runs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Processing loop (ProcessAllRows)</strong><br>• For each row dictionary: 1) call modCalc.CalcRow(row) inside On Error guard; 2) capture returned dictionary (results) and any ComputationNotes; 3) append to results collection for CSV export; 4) log per-row failures as warnings and continue unless a fatal count of errors is reached (configurable threshold).<br>• Maintain counters: processed, succeeded, skipped, failed.<br>• Periodic checkpointing: for very large runs, optionally write incremental CSVs to jobFolder to allow resume. </td></tr><tr><td data-label="Technical Breakdown"> <strong>WriteOutputs (CSV export)</strong><br>• Convert results to CSV rows with canonical header order (match bukti_potong.csv and per11_payload.csv schema).<br>• Ensure CSV escaping per RFC4180: double quotes doubled, fields wrapped in quotes when necessary.<br>• Use streaming writer / modIO.WriteCsvAtomic(jobFolder, fileName, csvGenerator) so .tmp is written then atomically renamed.<br>• On each write success, compute and log checksum (modManifest or modUtils).<br>• If write fails due to locking/permission, attempt configurable retry/backoff (e.g., 3 attempts with small delays) then fail and trigger AbortCleanup. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Manifest generation & atomicity (GenerateManifest)</strong><br>• After final files are in place, call modManifest.WriteManifest(jobFolder, JOB_ID, fileList) where fileList is an ordered collection of final file paths.<br>• Ensure modIO.WriteCsvAtomic consumes the JSON and writes manifest.json atomically.<br>• Verify manifest created and consistent (optionally re-hash listed files and compare). </td></tr><tr><td data-label="Technical Breakdown"> <strong>ImportOutputsToSheets</strong><br>• Optionally call modIO.ImportCsvToSheet into Outputs_BuktiPotong and Outputs_Per11 sheets for immediate inspection.<br>• Preserve textual formatting for npwp/nip via preserveTextColumns=True.<br>• If import fails, log but do not mark job as failed (imports are convenience for users). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Concurrency, locking & retries</strong><br>• Protect jobFolder creation/writes with simple file-based lockfile: create ${jobFolder}\.lock using atomic .tmp pattern; remove on finalize.<br>• If lock present at startup and age < configured threshold → abort with log indicating concurrent run.<br>• For transient file system errors (sharing violations), implement limited retry/backoff with configurable attempts.<br>• Never block the UI thread for long durations; use DoEvents responsibly in long loops. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Error handling & AbortCleanup</strong><br>• Centralized error handler: catch errors, write modUtils.LogMsg("Logs", "<context>: <Err.Number> - <Err.Description>"), mark job status in Settings/Logs, attempt best-effort cleanup (delete tmp files, remove lockfile), and return a boolean failure state to caller.<br>• Preserve evidence: do not delete .tmp files without logging when aborting unless explicitly configured. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Observability & logging</strong><br>• Log start/end timestamps, settings snapshot, rules loaded counts, input row count, success/failure counters, file write events, manifest creation, and final status.<br>• Support Verbose mode controlled by Settings.Verbose to emit per-row trace logs (useful in debugging but off by default).<br>• Ensure modUtils.LogMsg is used for all logs and that Logs sheet receives a summary row at job end. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Crash recovery & idempotence</strong><br>• On startup, detect incomplete previous job (.tmp files present or lockfile leftover).<br>• If .tmp files exist, either clean up (if older than threshold) or abort with instruction to operator.<br>• If JOB_ID reused, WriteOutputs must overwrite final files atomically; manifest will reflect latest contents.<br>• Document recommended recovery steps in user guide. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Versioning & compatibility</strong><br>• Define Const MODMAIN_VERSION = "2025-11-27-1" at module top.<br>• Preserve public routine names (e.g., pph21_RunAll).<br>• If schema changes (new BPJS columns), ensure mapping layer updates CSV header order but preserve backwards-compatible columns where possible. </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><div class="table-caption" id="Table2" data-table="Docu_0143_02" style="margin-top:2mm;margin-left:3mm;"><strong>Table 2</strong></div>
<div class="table-wrapper" data-table-id="table-2"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module Name</strong><br>modCalc.bas </td></tr><tr><td data-label="Technical Breakdown"> <strong>Module Purpose</strong><br>Contains the core tax calculation logic for PPh 21 computations, including row-by-row tax calculations, PTKP (Personal Taxable Income) deductions, tax rates, and rounding rules. This module focuses on the tax logic, leaving orchestration and I/O concerns to other modules like <code>modMain</code> and <code>modIO</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Design Principles</strong><br>• Calculation logic centralized: all tax-related rules and algorithms reside here.<br>• Separation of concerns: orchestration is delegated to <code>modMain</code>, I/O to <code>modIO</code>.<br>• Deterministic behavior: same input and configuration should result in consistent outputs.<br>• Maintainability: code is structured to easily update or add tax rules or bracket modifications.<br>• Performance: optimized for batch processing, handling large sets of rows efficiently. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Public API (recommended signatures)</strong><br>Public Function CalcRow(row As Dictionary) As Dictionary<br>Public Function CalcPTKP(grossIncome As Double) As Double<br>Public Function ApplyTaxRate(taxableIncome As Double, taxCategory As String) As Double<br>Public Function RoundTaxAmount(taxAmount As Double) As Double </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (CalcRow)</strong><br>1. Extract data from input row (e.g., gross income, allowances, bonuses, etc.).<br>2. Apply PTKP deductions using <code>CalcPTKP</code>. Subtract PTKP from gross income to get taxable income.<br>3. Determine tax category based on income band using <code>ApplyTaxRate</code>.<br>4. Apply tax rate to taxable income, producing the preliminary tax amount.<br>5. Round the resulting tax amount using <code>RoundTaxAmount</code> to ensure conformity with local rounding rules.<br>6. Return results as a dictionary containing tax breakdown (e.g., taxable income, tax withheld). </td></tr><tr><td data-label="Technical Breakdown"> <strong>PTKP Calculation (CalcPTKP)</strong><br>• PTKP is calculated based on the gross income of the individual.<br>• PTKP brackets are defined as part of the configuration loaded from <code>modMain</code>. The logic checks for individual, marital status, and number of dependents.<br>• Return the PTKP deduction amount based on these factors. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Tax Rate Application (ApplyTaxRate)</strong><br>• Determines the tax category based on taxable income, which is derived from the gross income after PTKP deduction.<br>• The tax rate is applied based on defined thresholds and categories (e.g., Category A, B, C, etc.).<br>• Tax categories are loaded as part of the configuration from <code>modMain</code>.<br>• The appropriate tax rate is applied according to the category to compute the tax payable. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Rounding Logic (RoundTaxAmount)</strong><br>• Rounds the final tax amount to comply with local regulations, usually rounding to the nearest Rp 1 or Rp 100.<br>• The function ensures that all tax amounts conform to the expected rounding rules.<br>• Applies rounding after all calculations to prevent rounding errors from accumulating. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Error Handling</strong><br>• Errors related to calculation are logged but do not stop execution unless critical.<br>• For invalid input data, return error messages that allow users to correct input without breaking the entire job process.<br>• Catch potential floating-point errors during calculations (e.g., rounding errors) and log them for review. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Logging</strong><br>• Log major tax calculation steps for each row, including PTKP calculation, tax category assignment, and tax computation.<br>• Log the final tax amount for each row, as well as any adjustments made during calculation.<br>• If errors occur during row processing, log a detailed message with the error context (e.g., invalid income value, incorrect category mapping). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Unit Testing</strong><br>• Each function, especially <code>CalcRow</code>, <code>CalcPTKP</code>, <code>ApplyTaxRate</code>, and <code>RoundTaxAmount</code>, should be unit tested.<br>• Test scenarios include varying gross income, different family configurations for PTKP, multiple tax categories, and rounding behavior.<br>• Ensure that edge cases (e.g., income right on the tax bracket thresholds) are handled correctly. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Edge Cases</strong><br>• Ensure that all tax categories are correctly applied to income bands that are near the bracket boundaries.<br>• Handle non-standard income cases (e.g., foreign currency, severance, bonuses) with appropriate adjustments.<br>• Correct handling of tax-exempt income and non-taxable allowances.<br>• Handle missing or malformed input data gracefully (e.g., missing required fields, invalid income values). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Dependencies</strong><br>• <code>modMain</code> for configuration data like PTKP thresholds and tax brackets.<br>• <code>modUtils</code> for utility functions like file path management or logging.<br>• <code>modIO</code> for input/output file handling.<br>• <code>modManifest</code> for post-calculation file checks and export verification. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Performance Considerations</strong><br>• Avoid looping over large datasets unnecessarily; process rows in batches if needed.<br>• Cache commonly accessed values like tax rates, PTKP brackets, and thresholds in memory.<br>• If the dataset is large, avoid excessive logging, or ensure logs are written in a way that doesn't impede performance (e.g., batch writes). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Versioning & Compatibility</strong><br>• Add versioning for tax rate tables and PTKP thresholds to ensure compatibility with future rule changes.<br>• Clearly document changes to the logic when modifying tax rate tables or PTKP rules.<br>• When significant changes occur, increment the module version and document breaking changes in the release notes. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Security & Validation</strong><br>• Ensure that no unvalidated user input can break the calculation logic.<br>• Always validate income and deduction fields before processing them.<br>• Safeguard against malicious data input that could affect tax calculations or processing (e.g., script injections or data manipulation). </td></tr></tbody></table></div><div class="row-count">Rows: 16</div></div><div class="table-caption" id="Table3" data-table="Docu_0143_03" style="margin-top:2mm;margin-left:3mm;"><strong>Table 3</strong></div>
<div class="table-wrapper" data-table-id="table-3"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module Name</strong><br>modIO.bas </td></tr><tr><td data-label="Technical Breakdown"> <strong>Module Purpose</strong><br>Handles the input/output operations, including reading from and writing to Excel worksheets, reading and writing CSV files, and managing file system interactions. Provides a common interface for interacting with data in different formats and exporting the results of tax calculations. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Design Principles</strong><br>• Centralized I/O logic: All reading, writing, and file operations are handled within this module.<br>• Separation of concerns: <code>modIO</code> is responsible for I/O, not business logic or computation.<br>• Streamlined file handling: Ensure atomic file operations, handle file locks and errors gracefully.<br>• High flexibility: Support for reading and writing multiple file formats, such as Excel, CSV, and others if required.<br>• Minimal dependencies: Only relies on core I/O operations and utility functions. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Public API (recommended signatures)</strong><br>Public Function ReadTableToDicts(sheetName As String, tableName As String) As Object<br>Public Function ReadCsv(filePath As String) As Object<br>Public Function WriteCsvAtomic(folderPath As String, fileName As String, data As Object) As Boolean<br>Public Function ImportCsvToSheet(filePath As String, sheetName As String) As Boolean<br>Public Function EnsureFolderExistence(folderPath As String) As Boolean </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (ReadTableToDicts)</strong><br>1. Accept <code>sheetName</code> and <code>tableName</code> as inputs.<br>2. Open the specified worksheet and table.<br>3. Extract all rows and columns as a collection of dictionaries where each key represents a column header.<br>4. Return the collection of dictionaries to the calling function for further processing. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (ReadCsv)</strong><br>1. Accept <code>filePath</code> as an input.<br>2. Open the specified CSV file for reading.<br>3. Read the content and parse it into a structured format (e.g., list of dictionaries or lists).<br>4. Return the parsed data to the calling function for further processing.<br>5. Handle errors such as file not found or invalid format. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (WriteCsvAtomic)</strong><br>1. Accept <code>folderPath</code>, <code>fileName</code>, and <code>data</code> as inputs.<br>2. Generate the path to save the CSV file.<br>3. Open the file in write mode, create a temporary <code>.tmp</code> file.<br>4. Write the data in CSV format with proper escaping and encoding.<br>5. Once the write operation is complete, atomically rename the <code>.tmp</code> file to the target filename to ensure data integrity.<br>6. Return <code>True</code> if the write was successful, otherwise <code>False</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (ImportCsvToSheet)</strong><br>1. Accept <code>filePath</code> and <code>sheetName</code> as inputs.<br>2. Open the specified CSV file and parse its contents.<br>3. Map the CSV data to columns and rows in the specified worksheet.<br>4. Import the data to the Excel sheet, ensuring proper formatting and conversion.<br>5. Return <code>True</code> if import was successful, otherwise <code>False</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (EnsureFolderExistence)</strong><br>1. Accept <code>folderPath</code> as an input.<br>2. Check if the folder exists.<br>3. If the folder does not exist, create it using appropriate file system operations.<br>4. If the folder exists or creation is successful, return <code>True</code>; otherwise, return <code>False</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>File Operations</strong><br>• Ensure atomic file writes to prevent data corruption.<br>• Use <code>.tmp</code> files for intermediate writes, renaming them once the operation completes successfully.<br>• Handle file path concatenations safely, using system-specific separators.<br>• Validate file paths before attempting I/O operations to prevent errors. </td></tr><tr><td data-label="Technical Breakdown"> <strong>CSV Parsing and Formatting</strong><br>• CSV reading and writing adhere to the RFC 4180 standard.<br>• Escape commas, newlines, and quotes within fields as required.<br>• Ensure proper quoting of fields that contain commas or newlines.<br>• Use consistent field separators and handle different character encodings. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Error Handling</strong><br>• Catch errors related to file access, permission issues, or data formatting during reading and writing.<br>• Provide clear error messages when files cannot be read or written, and log the context of errors (e.g., file path, operation type).<br>• Gracefully handle missing or malformed CSV files by logging errors and providing fallback mechanisms. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Logging</strong><br>• Log the start and end of major file operations (e.g., reading, writing, importing).<br>• Log detailed error messages when file operations fail, including the operation type and any relevant context.<br>• Ensure that log entries are clear and actionable, providing sufficient details for troubleshooting. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Unit Testing</strong><br>• Test reading and writing for different file types (e.g., Excel, CSV) and formats.<br>• Ensure that errors such as missing files or access permissions are handled properly.<br>• Test with different datasets, ensuring that data is correctly parsed and exported.<br>• Validate that all file paths are correctly handled and cross-platform compatibility is ensured. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Edge Cases</strong><br>• Handle cases where the input file is empty or malformed.<br>• Ensure correct handling of file paths that include special characters or spaces.<br>• If folder creation fails, ensure proper fallback and logging.<br>• Handle CSV files with unexpected column counts or missing headers. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Dependencies</strong><br>• Relies on <code>modUtils</code> for utility functions like path manipulation and logging.<br>• Interacts with <code>modManifest</code> for post-processing and verification of exported data.<br>• Works closely with <code>modMain</code> to process configuration files and ensure correct file structure. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Performance Considerations</strong><br>• Optimize file reading and writing for large datasets by using efficient methods and buffering.<br>• Minimize memory usage by processing large CSV files in chunks when needed.<br>• Use caching for frequently accessed files to improve performance. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Versioning & Compatibility</strong><br>• Ensure compatibility with different versions of Excel and CSV formats.<br>• Track changes in the file format or structure and ensure backward compatibility.<br>• Ensure that file handling mechanisms are flexible enough to support future updates or new file formats. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Security & Validation</strong><br>• Always validate file paths and user-provided inputs to prevent directory traversal attacks.<br>• Safeguard against malicious CSV file contents, such as script injections or malformed data.<br>• Ensure that the input/output files are handled in a secure environment with proper access controls. </td></tr></tbody></table></div><div class="row-count">Rows: 19</div></div><div class="table-caption" id="Table4" data-table="Docu_0143_04" style="margin-top:2mm;margin-left:3mm;"><strong>Table 4</strong></div>
<div class="table-wrapper" data-table-id="table-4"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module Name</strong><br>modUtils.bas </td></tr><tr><td data-label="Technical Breakdown"> <strong>Module Purpose</strong><br>Provides utility functions for common tasks like logging, path manipulation, file system checks, error handling, and other supporting operations needed across multiple modules. Aims to centralize reusable code and reduce redundancy. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Design Principles</strong><br>• Centralized utility functions: All general-purpose helper functions are located here.<br>• Error handling: Ensure error messages are clear, actionable, and logged consistently.<br>• Reusability: Functions are designed to be used by various modules, ensuring consistency across the codebase.<br>• Minimal external dependencies: Only rely on core system libraries for operations like file handling and logging. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Public API (recommended signatures)</strong><br>Public Function JoinPath(part1 As String, part2 As String) As String<br>Public Function EnsureFolder(folderPath As String) As Boolean<br>Public Function LogMsg(logType As String, message As String) As Boolean<br>Public Function ReadSettings(sheetName As String) As Object<br>Public Function ValidatePath(path As String) As Boolean<br>Public Function SafeWriteFile(filePath As String, data As String) As Boolean </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (JoinPath)</strong><br>1. Accept two path components (<code>part1</code>, <code>part2</code>).<br>2. Join them using the appropriate system separator (<code>\</code> or <code>/</code>).<br>3. Return the combined path as a string.<br>4. Handle edge cases like trailing slashes or missing separators. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (EnsureFolder)</strong><br>1. Accept <code>folderPath</code> as an input.<br>2. Check if the folder already exists.<br>3. If the folder exists, return <code>True</code>.<br>4. If the folder does not exist, attempt to create it using file system APIs.<br>5. Return <code>True</code> if successful, otherwise return <code>False</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (LogMsg)</strong><br>1. Accept <code>logType</code> and <code>message</code> as inputs.<br>2. Validate the log type (e.g., error, info, warning).<br>3. Format the log message with a timestamp and other relevant details.<br>4. Write the formatted message to a log file or output stream.<br>5. Return <code>True</code> if logging was successful, otherwise return <code>False</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (ReadSettings)</strong><br>1. Accept <code>sheetName</code> as an input.<br>2. Open the specified settings sheet.<br>3. Read the settings values and store them in a dictionary or another appropriate structure.<br>4. Return the dictionary to the calling function for further use. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (ValidatePath)</strong><br>1. Accept <code>path</code> as an input.<br>2. Check if the path is valid, ensuring it does not contain illegal characters or point to a restricted location.<br>3. Return <code>True</code> if the path is valid, otherwise return <code>False</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (SafeWriteFile)</strong><br>1. Accept <code>filePath</code> and <code>data</code> as inputs.<br>2. Validate the file path and ensure the folder exists (call <code>EnsureFolder</code>).<br>3. Open the file in write mode.<br>4. Write the provided data to the file.<br>5. Handle errors gracefully and ensure the file is closed properly.<br>6. Return <code>True</code> if the write operation was successful, otherwise return <code>False</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Path Handling</strong><br>• Provide functions for joining and validating file paths (<code>JoinPath</code>, <code>ValidatePath</code>).<br>• Ensure that path separators are correctly handled, especially across different operating systems.<br>• Use <code>EnsureFolder</code> to check for and create necessary folders before file operations. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Error Handling</strong><br>• Always log errors using <code>LogMsg</code> with a clear and informative message.<br>• Ensure that functions that perform file system operations handle potential errors (e.g., access denied, file not found) gracefully.<br>• Use try-catch or equivalent mechanisms to ensure robustness against unexpected errors. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Logging</strong><br>• Log both normal and error messages with a timestamp for traceability.<br>• Ensure that logs contain sufficient context (e.g., function name, parameters) for debugging.<br>• Maintain a consistent log format across the application (e.g., time, log type, message).<br>• Store logs in a dedicated log file to keep track of operations and errors. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Unit Testing</strong><br>• Test file and folder creation, ensuring that <code>EnsureFolder</code> behaves as expected.<br>• Validate that <code>JoinPath</code> correctly handles edge cases like multiple slashes or missing separators.<br>• Test <code>SafeWriteFile</code> to ensure that files are correctly written and that errors are handled properly.<br>• Validate the behavior of <code>LogMsg</code>, checking that logs are formatted correctly and written to the appropriate location. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Edge Cases</strong><br>• Handle cases where paths contain illegal characters or lead to restricted locations (e.g., system directories).<br>• Ensure that <code>EnsureFolder</code> can handle scenarios where permission is denied or there are other system restrictions.<br>• Handle cases where file paths are too long or invalid (e.g., exceeding system limits). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Dependencies</strong><br>• Relies on basic file system APIs for operations like path manipulation and folder creation.<br>• Interacts with other modules like <code>modMain</code>, <code>modIO</code> for file operations and settings management. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Performance Considerations</strong><br>• Ensure that file operations are efficient, especially in large-scale applications.<br>• Avoid excessive file writes or reads to improve performance.<br>• Optimize folder creation and path validation functions to minimize unnecessary file system checks. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Versioning & Compatibility</strong><br>• Ensure backward compatibility when adding new utility functions or modifying existing ones.<br>• Track and update the module versioning to match changes made in utility functions.<br>• Ensure compatibility across different operating systems (e.g., Windows, Linux). </td></tr><tr><td data-label="Technical Breakdown"> <strong>Security & Validation</strong><br>• Ensure that paths are validated to prevent directory traversal attacks.<br>• Validate the data being written to files to prevent data corruption or malicious content.<br>• Implement appropriate file permission checks to avoid unauthorized file writes or reads. </td></tr></tbody></table></div><div class="row-count">Rows: 19</div></div><div class="table-caption" id="Table5" data-table="Docu_0143_05" style="margin-top:2mm;margin-left:3mm;"><strong>Table 5</strong></div>
<div class="table-wrapper" data-table-id="table-5"><div class="table-heading-bar" aria-label="Table heading"></div><div class="table-container"><div class="table-header-wrapper" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;"><div class="copy-buttons"><button type="button" class="copy-plain-btn" data-action="copy-plain" onclick="copyTablePlain(this)">Copy Plain Table</button><button type="button" class="copy-markdown-btn" data-action="copy-markdown" onclick="copyTableMarkdown(this)">Copy Markdown Table</button><button type="button" class="export-csv-btn" data-action="export-csv" onclick="exportTableCSV(this)">Export CSV</button><button type="button" class="export-json-btn" data-action="export-json" onclick="exportTableJSON(this)">Export JSON</button><button type="button" class="export-xlsx-btn" data-action="export-xlsx" onclick="exportTableXLSX(this)">Export XLSX</button><button type="button" class="export-pdf-btn" data-action="export-pdf" onclick="exportTablePDF(this)">Export PDF</button><button type="button" class="export-markdown-btn export-markdown-initial" data-action="export-markdown" onclick="exportTableMarkdown(this)" style="display:none" data-initial-hidden="1">Export Markdown</button></div><div style="display:flex; align-items:center;"><button type="button" class="toggle-table-btn" data-action="toggle-collapse" onclick="toggleTable(this)">Collapse Table</button></div></div><table class="tv-table" role="table"><thead><tr><th class="tv-col-left" role="button" aria-label="Sort by **Technical Breakdown**"><div class="th-with-sort"><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;"><strong>Technical Breakdown</strong></div><button class="sort-btn sort-state-0" title="Toggle sort" aria-label="Toggle sort"><span class="sort-icon" aria-hidden="true"></span></button></div></th></tr></thead><tbody><tr><td data-label="Technical Breakdown"> <strong>Module Name</strong><br>modManifest.bas </td></tr><tr><td data-label="Technical Breakdown"> <strong>Module Purpose</strong><br>Handles the creation and management of manifests, which are essential for tracking file integrity and ensuring correct data processing. It writes out metadata, including file paths, checksums, and other relevant details about the generated output files. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Design Principles</strong><br>• Centralized manifest management: Provides functions for creating and updating manifests across multiple modules.<br>• File integrity: Ensures the generated manifest accurately tracks file details, including checksums, to verify output integrity.<br>• Data consistency: Provides a structured approach to writing and maintaining manifest files. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Public API (recommended signatures)</strong><br>Public Function WriteManifest(jobFolder As String, jobId As String, fileList As Object) As Boolean<br>Public Function CalculateChecksum(filePath As String) As String<br>Public Function ReadManifest(jobFolder As String) As Object </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (WriteManifest)</strong><br>1. Accept <code>jobFolder</code>, <code>jobId</code>, and <code>fileList</code> as inputs.<br>2. Create a manifest file in the <code>jobFolder</code> directory.<br>3. For each file in <code>fileList</code>, calculate its checksum using <code>CalculateChecksum</code>.<br>4. Write the metadata (file path, checksum, etc.) for each file into the manifest.<br>5. Return <code>True</code> if the manifest is successfully written, otherwise return <code>False</code>. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (CalculateChecksum)</strong><br>1. Accept <code>filePath</code> as input.<br>2. Open the file at <code>filePath</code> and calculate its checksum (e.g., SHA-256).<br>3. Return the checksum as a string. </td></tr><tr><td data-label="Technical Breakdown"> <strong>High-level flow (ReadManifest)</strong><br>1. Accept <code>jobFolder</code> as input.<br>2. Open the manifest file in the <code>jobFolder</code>.<br>3. Parse the manifest file and extract the metadata into an object.<br>4. Return the object containing the manifest data for further processing. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Manifest Generation</strong><br>• The <code>WriteManifest</code> function is responsible for creating the manifest and adding the details of each file generated during the job run.<br>• Each file in the <code>fileList</code> will have a corresponding entry in the manifest that includes its path, checksum, and any other relevant metadata.<br>• The manifest is saved in the <code>jobFolder</code>, where the files are stored. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Checksum Calculation</strong><br>• The <code>CalculateChecksum</code> function uses a hashing algorithm (e.g., SHA-256) to generate a unique checksum for a given file.<br>• This checksum is used to ensure file integrity and verify that the file has not been altered or corrupted.<br>• Checksum generation can be slow for large files, so consider performance implications in long-running jobs. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Manifest Parsing</strong><br>• The <code>ReadManifest</code> function is responsible for reading the manifest file back into memory for validation, troubleshooting, or further processing.<br>• The manifest data is typically stored in a structured format (e.g., JSON, XML) and can be parsed into a dictionary or similar data structure.<br>• Parsing errors should be handled gracefully, ensuring the manifest file is valid and readable before use. </td></tr><tr><td data-label="Technical Breakdown"> <strong>File Integrity & Security</strong><br>• The checksum ensures that files have not been tampered with or corrupted during processing or transmission.<br>• The manifest file itself should be protected from unauthorized modification to maintain trust in the integrity of the data.<br>• Implement file access control mechanisms to ensure that only authorized users can modify the manifest file. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Versioning & Compatibility</strong><br>• Track the module version to maintain backward compatibility with older manifest formats or checksum algorithms.<br>• When making changes to the manifest format (e.g., adding new metadata fields), ensure that old versions of the manifest are still readable.<br>• Keep the checksum calculation consistent across versions to ensure that file integrity is still verifiable. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Error Handling</strong><br>• Ensure that errors are logged and handled appropriately, particularly in file-related operations (e.g., file not found, checksum calculation failure).<br>• In case of failure in <code>WriteManifest</code>, <code>CalculateChecksum</code>, or <code>ReadManifest</code>, return a <code>False</code> value and log the error message for troubleshooting.<br>• Ensure the manifest file is not left in an inconsistent state if an error occurs during manifest generation. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Edge Cases</strong><br>• Handle cases where files in the <code>fileList</code> are not accessible or do not exist.<br>• Ensure that <code>CalculateChecksum</code> can handle large files efficiently without excessive memory consumption.<br>• Handle file system errors gracefully, such as read/write permission issues or disk space running out. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Dependencies</strong><br>• Relies on file system APIs for reading and writing files.<br>• Interacts with other modules (e.g., <code>modMain</code>, <code>modIO</code>) to get the list of files to include in the manifest.<br>• Uses cryptographic libraries (e.g., for checksum calculation) to generate unique file hashes. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Performance Considerations</strong><br>• Manifest writing and checksum calculation can be time-consuming for large files. Consider optimizing file I/O operations or introducing caching where possible.<br>• For large datasets, ensure that the checksum generation process is efficient and that the manifest file is written in an optimized manner. </td></tr><tr><td data-label="Technical Breakdown"> <strong>Security & Validation</strong><br>• Validate that the manifest file is properly secured against unauthorized access or tampering.<br>• Ensure that the checksum algorithm used is secure (e.g., SHA-256) and not easily reversible.<br>• When reading or writing the manifest, handle potential file system issues (e.g., permissions, file locks) to avoid corruption or unauthorized access. </td></tr></tbody></table></div><div class="row-count">Rows: 17</div></div><script src="assets/xlsx.full.min.js?v=1758605028" defer></script>
<script src="assets/script.js?v=1759748863" defer></script>
<script src="assets/worker.js?v=1758331710" defer></script>
<script>
(function(){
  const template = "{table}_{date}";
  const userVal = "";
  const hrefPrefix = "assets";
  function formatName(tableName) {
    const date = (new Date()).toISOString().slice(0,10);
    return template.replace('{table}', tableName).replace('{date}', date).replace('{user}', userVal);
  }
  const btn = document.getElementById('exportBtn');
  if(btn) {
    btn.addEventListener('click', async function() {
      try {
        const html = document.documentElement.outerHTML;
        if(html.length > 2000000) { alert('Export refused: html too large'); return; }
        if(window.Worker) {
          const workerUrl = (function(){ try{ return hrefPrefix + '/worker.js'; }catch(e){ return null; } })();
          if(workerUrl) {
            try {
              const worker = new Worker(workerUrl);
              worker.postMessage({html: html, format: 'pdf'});
              worker.onmessage = function(e) { console.log('worker:', e.data); alert('Worker replied: '+(e.data.msg||e.data.status)); };
            } catch(err) { console.warn('Worker create failed', err); alert('Worker not available'); }
          } else { alert('Worker not available'); }
        } else { alert('Export worker not supported in this environment.'); }
      } catch(err) { console.warn('Export failed', err); alert('Export worker not available. See console for details.'); }
    });
  }
})();
window.addEventListener('load', function(){ try{ document.querySelectorAll('.table-wrapper').forEach(function(e){ e.style.opacity='1'; }); }catch(e){} });
</script>
</div>
</body>
</html>